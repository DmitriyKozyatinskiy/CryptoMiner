/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 788);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(132);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(329);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(333);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(330);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(18);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(18);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* unused harmony export getLogger */
/* harmony export (immutable) */ __webpack_exports__["a"] = getFileLogger;
/* unused harmony export getDefaultLogger */


/*eslint no-console: 0*/
var isEdge = typeof console.log.bind == "function";
var _debug = isEdge ? (console.debug || console.log).bind(console) : function () {};
var _info = isEdge ? (console.info || console.log).bind(console) : function () {};
var _warn = isEdge ? (console.warn || console.log).bind(console) : function () {};
var _error = isEdge ? (console.error || console.log).bind(console) : function () {};

var LOG_LEVELS = { ERROR: 1, WARN: 2, INFO: 3, DEBUG: 4, TRACE: 5 };

function startsWith(haystack, needle) {
  return haystack.slice(0, needle.length) === needle;
}

var Logger = function () {
  function Logger(id) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Logger);

    this._id = id;
    this._level = {
      //"base.content.elementLocator": "DEBUG",
      //"base.content.player.ContentPlayer": "DEBUG",
      // "base.content.player.LocatorSearcher": "DEBUG",
      // "embed.common.EmbedStorage": "DEBUG",
      //"embed.content.EmbedBackgroundPort": "DEBUG",
      //"embed.background.EmbedDocumentsPort": "DEBUG",
      //"embed.background.EmbedTabsController": "DEBUG",
      //"base.background.capture.Process.handlers.MOUSE": "DEBUG",
      // "embed.inject": "DEBUG",
      "default": "WARN"
    };
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Logger, [{
    key: "isEnabled",
    value: function isEnabled(level) {
      if (this._level == null) {
        return false;
      }
      var logLevel = this._level[this._id] || this._level['default'];
      return logLevel != null && LOG_LEVELS[level] <= LOG_LEVELS[logLevel];
    }
  }, {
    key: "debug",
    value: function debug(msg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.isEnabled("DEBUG")) _debug.apply(undefined, ["[" + this._id + "] DEBUG", msg].concat(args));
    }
  }, {
    key: "trace",
    value: function trace(msg) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (this.isEnabled("TRACE")) _debug.apply(undefined, ["[" + this._id + "] TRACE", msg].concat(args));
    }
  }, {
    key: "info",
    value: function info(msg) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      if (this.isEnabled("INFO")) _info.apply(undefined, ["[" + this._id + "] INFO", msg].concat(args));
    }
  }, {
    key: "warn",
    value: function warn(msg) {
      for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      if (this.isEnabled("WARN")) _warn.apply(undefined, ["[" + this._id + "] WARNING", msg].concat(args));
    }
  }, {
    key: "error",
    value: function error(msg) {
      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      if (this.isEnabled("ERROR")) _error.apply(undefined, ["[" + this._id + "] ERROR", msg].concat(args));
    }
  }]);

  return Logger;
}();

function getLogger(id) {
  return new Logger(id);
}

// Get a logger in.dotted.form from a filename (from webpack's __filename special var)
function getFileLogger(filename) {
  var id = filename.replace(/^.*\/src\//, '').replace(/[/\\]/g, '.').replace(/.js$/, '');
  return new Logger(id);
}

function getDefaultLogger() {
  return new Logger('default');
}

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 8 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 9 */,
/* 10 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(69)('wks');
var uid = __webpack_require__(45);
var Symbol = __webpack_require__(10).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = namespace;
var prefix =  true ? 'iorad-embed' : 'iorad-extension';

function namespace() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 0) return prefix;
  return args.map(function (str) {
    return prefix + '-' + str;
  }).join(' ');
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(249);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(7);
var ctx = __webpack_require__(40);
var hide = __webpack_require__(25);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(17);
var IE8_DOM_DEFINE = __webpack_require__(113);
var toPrimitive = __webpack_require__(72);
var dP = Object.defineProperty;

exports.f = __webpack_require__(19) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(189);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(188);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(28)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
 * Utility functions
 */

var util = {};

util.isObject = function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

util.isNumber = function isNumber(arg) {
  return typeof arg === 'number';
}

util.isUndefined = function isUndefined(arg) {
  return arg === void 0;
}

util.isFunction = function isFunction(arg){
  return typeof arg === 'function';
}


/**
 * EventEmitter class
 */

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error' && !this._events.error) {
    er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      throw Error('Uncaught, unspecified "error" event.');
    }
    return false;
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;

      if (util.isFunction(console.error)) {
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
      }
      if (util.isFunction(console.trace))
        console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (Array.isArray(listeners)) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};


/***/ }),
/* 21 */,
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(326);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(15);
var createDesc = __webpack_require__(36);
module.exports = __webpack_require__(19) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(135);
var defined = __webpack_require__(66);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(181),
    isLength = __webpack_require__(170);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__settings_config__ = __webpack_require__(309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__env__ = __webpack_require__(308);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__env___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__env__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_cloneDeep__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_cloneDeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash_cloneDeep__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_each__ = __webpack_require__(486);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_each___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_each__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_extend__ = __webpack_require__(487);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_extend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_extend__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_isArray__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_isArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_isArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_replaceAll__ = __webpack_require__(319);









/* harmony default export */ __webpack_exports__["a"] = {
  env: __WEBPACK_IMPORTED_MODULE_2__env___default.a, // current used environment

  envs: __WEBPACK_IMPORTED_MODULE_1__settings_config__["a" /* default */].envs, // possible envs
  values: __WEBPACK_IMPORTED_MODULE_1__settings_config__["a" /* default */].values, // actual config

  get: function get(name, variables) {
    var self = this;
    var pathFragments = name.split('.');
    var start = this.values;
    var env = this.env;
    var envParent;
    var envParentIndex;
    for (var i = 0; i < pathFragments.length; i++) {
      var fragment = pathFragments[i];
      if ('*' in start && envParent === undefined) {
        // keep track of the first wildcard env
        envParent = start;
        envParentIndex = i;
      }
      if (start[env]) {
        // use current env
        envParent = start;
        envParentIndex = i;
        start = start[env];
      }
      start = start[fragment];
      if (start === undefined) {
        if (envParent !== undefined && '*' in envParent && env != '*') {
          // try with * env
          env = '*';
          start = envParent;
          i = envParentIndex - 1; // because of the i++
        } else {
          // not found
          return undefined;
        }
      }
    }

    // don't modify original settings
    start = __WEBPACK_IMPORTED_MODULE_3_lodash_cloneDeep___default()(start);

    // if the getted setting still contains env properties, remove those not related to the current
    // and merge the current env with the wildcard env.
    var removeEnvs = function removeEnvs(target) {
      if (target && (typeof target === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(target)) == 'object') {
        // object or array
        // recursion (depth-first so to avoid collisions with "sub envs")
        __WEBPACK_IMPORTED_MODULE_4_lodash_each___default()(target, function (value, key) {
          target[key] = removeEnvs(target[key]);
        });

        if (!__WEBPACK_IMPORTED_MODULE_6_lodash_isArray___default()(target)) {
          // objects only
          if ('*' in target) {
            // merge * with target
            __WEBPACK_IMPORTED_MODULE_5_lodash_extend___default()(target, target['*']);
            delete target['*'];
          }
          __WEBPACK_IMPORTED_MODULE_4_lodash_each___default()(self.envs, function (possibleEnv) {
            if (possibleEnv in target) {
              if (possibleEnv === self.env) {
                // merge env
                __WEBPACK_IMPORTED_MODULE_5_lodash_extend___default()(target, target[possibleEnv]);
              }
              // (true also for foreign envs)
              delete target[possibleEnv];
            }
          });
        }
      }
      return target;
    };
    start = removeEnvs(start);

    var replaceVars = function replaceVars(target) {
      if ((typeof target === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(target)) == 'object') {
        for (var prop in target) {
          if (target.hasOwnProperty(prop)) {
            target[prop] = replaceVars(target[prop]);
          }
        }
      } else if (typeof target == 'string') {
        // replace variables in string with their specified values
        for (var variable in variables) {
          if (variables.hasOwnProperty(variable)) {
            target = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__utils_replaceAll__["a" /* default */])(target, '%' + variable + '%', variables[variable]);
          }
        }
      }
      return target;
    };
    if (variables) start = replaceVars(start);

    return start;
  }
};

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 32 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 33 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 35 */,
/* 36 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__(406),
    baseMatchesProperty = __webpack_require__(407),
    identity = __webpack_require__(43),
    isArray = __webpack_require__(8),
    property = __webpack_require__(495);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(231),
    baseKeys = __webpack_require__(237),
    isArrayLike = __webpack_require__(29);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(65);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(403),
    getValue = __webpack_require__(440);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(121);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(156),
    baseAssignValue = __webpack_require__(120);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getPrototypeOf = __webpack_require__(332);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = __webpack_require__(331);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(116);
var enumBugKeys = __webpack_require__(67);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 51 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(15).f;
var has = __webpack_require__(24);
var TAG = __webpack_require__(11)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(209)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(114)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(97)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 55 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(95)
  , IE8_DOM_DEFINE = __webpack_require__(218)
  , toPrimitive    = __webpack_require__(147)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(54) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(375)
  , defined = __webpack_require__(371);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46),
    getRawTag = __webpack_require__(439),
    objectToString = __webpack_require__(468);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(364);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(132);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var createFind = __webpack_require__(433),
    findIndex = __webpack_require__(489);

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(34);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(334);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 66 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 67 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(69)('keys');
var uid = __webpack_require__(45);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 70 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(66);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(27);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var core = __webpack_require__(7);
var LIBRARY = __webpack_require__(49);
var wksExt = __webpack_require__(74);
var defineProperty = __webpack_require__(15).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(11);


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(212);
var global = __webpack_require__(10);
var hide = __webpack_require__(25);
var Iterators = __webpack_require__(31);
var TO_STRING_TAG = __webpack_require__(11)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 76 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(146)('wks')
  , uid        = __webpack_require__(76)
  , Symbol     = __webpack_require__(32).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(43),
    overRest = __webpack_require__(259),
    setToString = __webpack_require__(167);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(8),
    isKey = __webpack_require__(164),
    stringToPath = __webpack_require__(480),
    toString = __webpack_require__(271);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 80 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 81 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(417),
    keys = __webpack_require__(38);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
var document = __webpack_require__(10).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(17);
var dPs = __webpack_require__(203);
var enumBugKeys = __webpack_require__(67);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(83)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(134).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var createWrap = __webpack_require__(435);

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

module.exports = curry;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(399),
    isObjectLike = __webpack_require__(34);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(13),
    stubFalse = __webpack_require__(498);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)(module)))

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(231),
    baseKeysIn = __webpack_require__(405),
    isArrayLike = __webpack_require__(29);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 91 */,
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_base_common_utils_waitForInit__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_filter__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_filter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_indexOf__ = __webpack_require__(748);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_indexOf___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_indexOf__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_map__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_sortBy__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_sortBy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_sortBy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_chrome_browser__ = __webpack_require__(187);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return PARENT; });
/* unused harmony export CHILDREN */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ALL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return frameId; });
/* harmony export (immutable) */ __webpack_exports__["a"] = send;
/* harmony export (immutable) */ __webpack_exports__["c"] = onMessage;


// This module implements communication between frames using postMessage.


var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__["a" /* getFileLogger */])(__filename);











var PARENT = "PARENT";
var CHILDREN = "CHILDREN";
var ALL = "ALL";
var TOP = "TOP";

var DUPE_CHECK_KEY = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__["a" /* default */])("frameMessages-loaded");
if (window[DUPE_CHECK_KEY]) {
  // Webpack CommonsChunkPlugin should ensure this, but it'll cause crazy hard
  // to find bugs if it breaks
  throw new Error("IORAD: Should be only one instance of frameMessages per content");
}
window[DUPE_CHECK_KEY] = true;

// MODULE LEVEL STATE! WE SHARE THIS WITH OTHER INSTANCES OF THIS MODULE LOADED
var frameId = "FRAMEID:" + String(+new Date()) + String(Math.random());
var messageListeners = {};
var isBackground = !!(__WEBPACK_IMPORTED_MODULE_11_chrome_browser__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_11_chrome_browser__["a" /* default */].tabs);

if (!isBackground) {
  contentPageListener();
}

// destination can be PARENT, CHILDREN, ALL, TOP, frameId  or a frame/window object
function send(destination, topic) {
  var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (isBackground) throw new Error("Not allowed on background");
  logger.debug("Send Message", destination, topic);
  var frames = void 0;
  if ((typeof destination === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(destination)) === "object") {
    // It's a frame/window object
    frames = [destination];
    destination = "";
  } else if (destination === PARENT) {
    frames = [window.parent];
  } else if (destination === CHILDREN) {
    frames = Array.from(document.documentElement.querySelectorAll("iframe")).map(function (iframe) {
      return iframe.contentWindow;
    });
  } else {
    // For any other type we need to start at the root
    frames = [window.top];
  }

  var message = {
    isFrameMessage: true,
    namespace: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__["a" /* default */])(),
    destination: destination,
    topic: topic,
    payload: payload,
    frameId: frameId
  };

  frames.forEach(function (frame) {
    frame.postMessage(message, "*");
  });
}

// topic is optional, defaults to '*'
function onMessage(topic, callback) {
  if (isBackground) throw new Error("Not allowed on background"); // TODO:

  if (typeof topic === "function") {
    callback = topic;
    topic = "*";
  }

  messageListeners[topic] = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(messageListeners[topic] || []), [callback]);

  return {
    unsubscribe: function unsubscribe() {
      messageListeners[topic] = messageListeners[topic].filter(function (f) {
        return f !== callback;
      });
    }
  };
}

function deliver(message) {
  // This message is directed to this frame
  ["*", message.topic].forEach(function (topic) {
    var listeners = messageListeners[topic];
    if (listeners) {
      listeners.forEach(function (l) {
        return l(message);
      });
    }
  });
}

function isFrameMessage(event) {
  var message = event.data;
  return (typeof message === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(message)) === "object" && message != null && message.isFrameMessage && message.namespace === __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__["a" /* default */])();
}

function messageHandler(event) {
  if (!isFrameMessage(event)) return;
  var message = event.data;
  event.stopImmediatePropagation();

  function broadcastDown() {
    // route to child iframes (continue broadcast)
    // NOTE: we don't use window.frames since is broken in EDGE
    var childFrameWindows = Array.from(document.documentElement.querySelectorAll("iframe")).map(function (iframe) {
      return iframe.contentWindow;
    });
    for (var i = 0; i < childFrameWindows.length; i++) {
      childFrameWindows[i].postMessage(message, "*");
    }
  }

  function accept() {
    deliver(message);
  }

  var destination = message.destination;


  if (destination === PARENT || destination === CHILDREN || destination === TOP || destination === "") {
    accept();
  } else if (destination === ALL) {
    broadcastDown();
    accept();
  } else {
    // Destination is a specific frame id
    if (frameId === destination) {
      accept();
    } else {
      broadcastDown();
    }
  }
}

function contentPageListener() {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_base_common_utils_windowEvents__["a" /* addWindowListener */])("message", messageHandler);
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/common/utils/frameMessages.js"))

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(51);
var createDesc = __webpack_require__(36);
var toIObject = __webpack_require__(26);
var toPrimitive = __webpack_require__(72);
var has = __webpack_require__(24);
var IE8_DOM_DEFINE = __webpack_require__(113);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(19) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(70);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(98);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 96 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(222)
  , enumBugKeys = __webpack_require__(141);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(453),
    listCacheDelete = __webpack_require__(454),
    listCacheGet = __webpack_require__(455),
    listCacheHas = __webpack_require__(456),
    listCacheSet = __webpack_require__(457);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(81);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(235),
    createBaseEach = __webpack_require__(429);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(102),
    isObject = __webpack_require__(16);

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtor;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(451);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(389),
    Map = __webpack_require__(150),
    Promise = __webpack_require__(391),
    Set = __webpack_require__(285),
    WeakMap = __webpack_require__(228),
    baseGetTag = __webpack_require__(58),
    toSource = __webpack_require__(263);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 110 */,
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["b"] = addReattachMessageListener;
/* harmony export (immutable) */ __webpack_exports__["a"] = addWindowListener;
/* harmony export (immutable) */ __webpack_exports__["c"] = removeWindowListener;

// We want to listen from "message" (and other) event on window. However:
//  - When the host page calls document.write it obliterates message listners 
//  - We want to stop any messages we handle from being handled by the host page



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

// Module level state
var events = {};
var reattachListeners = new Set();

function setupWindowEvent(eventName) {
  // State
  var listeners = new Set();
  var attachments = [];
  var totalAttachmentsCount = 0; // Just for debug

  function messageHandler(event) {
    var handled = false;

    // Is this a test message generated by this module itself?
    // NOTE: the event.type check is required in Firefox to prevent the
    // '"Error: Permission denied to access property "data"' error
    if (event.type === 'message' && __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(event.data) === 'object' && event.data !== null && event.data.windowEventsTestMessage === __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__["a" /* default */])()) {
      event.stopImmediatePropagation();
      return;
    }

    if (listeners.length === 0) {
      if (eventName === 'message') {
        logger.warn('No listeners for window', eventName, 'event', event);
      }
      return;
    }
    listeners.forEach(function (handler) {
      return handler(event);
    });
  }

  // So we often aren't sure if we need to reattach, we have no way of telling
  // if an event handler is still attached. However, we don't want to build up more and
  // more attached handlers. We also want to keep the earliest one attached if
  // at all possible because that gives us the ability to cancel events before
  // anything else can see them. So what we do is we add a new one whenever we
  // think we need it then whenever we get a callback through one we remove any
  // others.
  function reattach() {
    var index = attachments.length;
    var attachmentNumber = totalAttachmentsCount++;
    logger.debug('Reattach window', eventName, 'event #', attachmentNumber);
    function handler(event) {
      if (attachments.length > 1) {
        var isNewAttachment = index !== 0; // Is this a new attachment or did the old one still work?

        logger.debug('Remove', attachments.length - 1, 'uneeded window', eventName, 'event attachments. Lowest working index:', index);
        attachments.forEach(function (fn, i) {
          if (i !== index) {
            window.removeEventListener(eventName, fn, true);
          }
        });
        // No we only have this one attachment left
        attachments = [attachments[index]];
        index = 0;

        // Is icky to test for specific eventName, but this mechanism only works for message
        if (isNewAttachment && eventName === "message") {
          reattachListeners.forEach(function (handler) {
            return handler();
          });
        }
      }
      messageHandler(event);
    }
    window.addEventListener(eventName, handler, true);
    attachments.push(handler);

    if (index !== 0 && eventName === "message") {
      // Test the new attachment
      window.postMessage({ windowEventsTestMessage: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__["a" /* default */])() }, '*');
    }
  }

  function setup() {
    reattach();

    // Check if we have MutationObserver so as not to fail the tests
    if (typeof MutationObserver !== 'undefined') {
      // Use an observer to detect when root element chanegs (which seems to mean
      // that document.write has been called, what else would replace the HTML
      // element?)
      var observer = new MutationObserver(function () {
        logger.info('Root element changed, this is probably document.write.');
        reattach();

        // setTimeout(reattach, 1);
      });
      observer.observe(document, { childList: true });
    }
  }
  setup();

  // callback should return true if it processes the message
  return {
    add: function add(callback) {
      listeners.add(callback);
    },
    remove: function remove(callback) {
      listeners.delete(callback);
    }
  };
}

function getEvent(eventName) {
  return events[eventName] = events[eventName] || setupWindowEvent(eventName);
}

// Get a callback when we have reattached "message" event to the window, this is
// a notification that events may have been lost
function addReattachMessageListener(callback) {
  reattachListeners.add(callback);
}

function addWindowListener(eventName, callback) {
  getEvent(eventName).add(callback);
}

function removeWindowListener(eventName, callback) {
  getEvent(eventName).remove(callback);
}

// Pre-load message event
getEvent('message');
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/common/utils/windowEvents.js"))

/***/ }),
/* 112 */,
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(19) && !__webpack_require__(28)(function () {
  return Object.defineProperty(__webpack_require__(83)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(49);
var $export = __webpack_require__(14);
var redefine = __webpack_require__(117);
var hide = __webpack_require__(25);
var has = __webpack_require__(24);
var Iterators = __webpack_require__(31);
var $iterCreate = __webpack_require__(199);
var setToStringTag = __webpack_require__(52);
var getPrototypeOf = __webpack_require__(137);
var ITERATOR = __webpack_require__(11)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(116);
var hiddenKeys = __webpack_require__(67).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(24);
var toIObject = __webpack_require__(26);
var arrayIndexOf = __webpack_require__(194)(false);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(25);


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(100),
    stackClear = __webpack_require__(473),
    stackDelete = __webpack_require__(474),
    stackGet = __webpack_require__(475),
    stackHas = __webpack_require__(476),
    stackSet = __webpack_require__(477);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 119 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(247);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(79),
    toKey = __webpack_require__(61);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(81),
    isArrayLike = __webpack_require__(29),
    isIndex = __webpack_require__(80),
    isObject = __webpack_require__(16);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(404),
    baseUnary = __webpack_require__(122),
    nodeUtil = __webpack_require__(467);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(409),
    flatRest = __webpack_require__(177);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(157),
    baseOrderBy = __webpack_require__(408),
    baseRest = __webpack_require__(78),
    isIterateeCall = __webpack_require__(123);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(499);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });






function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var Component = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(Component, _EventEmitter);

  function Component() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Component);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Component.__proto__ || Object.getPrototypeOf(Component)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Component, [{
    key: 'start',
    value: function start(extension) {
      var _this2 = this;

      this.extension = extension;
      this.flux = this.extension.flux;
      this.ownContext = this.flux[this.flux.ownContextName + 'Context'].bind(this.flux);

      this.flux.on('update', function (type) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var fnName = 'updateFor' + capitalizeFirstLetter(type);
        var fn = _this2[fnName];
        if (fn) {
          fn.apply(_this2, args);
        }
      });
    }
  }]);

  return Component;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);



/***/ }),
/* 131 */,
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(190), __esModule: true };

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(44);
var TAG = __webpack_require__(11)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(10).document;
module.exports = document && document.documentElement;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(44);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(65);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(24);
var toObject = __webpack_require__(71);
var IE_PROTO = __webpack_require__(68)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(133);
var ITERATOR = __webpack_require__(11)('iterator');
var Iterators = __webpack_require__(31);
module.exports = __webpack_require__(7).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 139 */
/***/ (function(module, exports) {



/***/ }),
/* 140 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 141 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(56)
  , createDesc = __webpack_require__(144);
module.exports = __webpack_require__(54) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 143 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(32)
  , hide      = __webpack_require__(142)
  , has       = __webpack_require__(55)
  , SRC       = __webpack_require__(76)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(96).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(32)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(98);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(102),
    baseLodash = __webpack_require__(159);

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

module.exports = LazyWrapper;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(102),
    baseLodash = __webpack_require__(159);

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

module.exports = LodashWrapper;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(458),
    mapCacheDelete = __webpack_require__(459),
    mapCacheGet = __webpack_require__(460),
    mapCacheHas = __webpack_require__(461),
    mapCacheSet = __webpack_require__(462);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(151),
    setCacheAdd = __webpack_require__(471),
    setCacheHas = __webpack_require__(472);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(288);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(120),
    eq = __webpack_require__(81);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(155),
    isFlattenable = __webpack_require__(450);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(400),
    isObjectLike = __webpack_require__(34);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

module.exports = baseLodash;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(227);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var metaMap = __webpack_require__(257),
    noop = __webpack_require__(39);

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(229),
    stubArray = __webpack_require__(269);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(8),
    isSymbol = __webpack_require__(63);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(411),
    shortOut = __webpack_require__(262);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var createFlow = __webpack_require__(294);

/**
 * This method is like `_.flow` except that it creates a function that
 * invokes the given functions from right to left.
 *
 * @static
 * @since 3.0.0
 * @memberOf _
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flow
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flowRight([square, _.add]);
 * addSquare(1, 2);
 * // => 9
 */
var flowRight = createFlow(true);

module.exports = flowRight;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(29),
    isObjectLike = __webpack_require__(34);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isMobileBrowsers;
/* http://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
 * http://detectmobilebrowsers.com/
 */
function isMobileBrowsers() {
  var check = false;
  (function (a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
}

/***/ }),
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(328);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(327);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(265),
    overRest = __webpack_require__(259),
    setToString = __webpack_require__(167);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(236),
    getSymbolsIn = __webpack_require__(253),
    keysIn = __webpack_require__(89);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(258);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(158);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObject = __webpack_require__(16);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(264),
    isObject = __webpack_require__(16);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 183 */,
/* 184 */,
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = waitFor;
function waitFor(fn, callback) {
  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;

  var result = fn();
  if (!result) {
    // try later
    setTimeout(waitFor.bind(null, fn, callback), time);
    return;
  }
  if (callback) callback(result);
}

/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getWindowScrollOffset__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_every__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_every__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_dom__ = __webpack_require__(277);
/* harmony export (immutable) */ __webpack_exports__["a"] = getElementVisualBounds;
// Get the visual bounds of the element, as close to what would be perceived by
// the user as we can muster. By default gives it in viewport bounds but pass in
// true to the second argument to get page bounds (that's the page loaded inside
// this frame)





function parseNumber(n) {
  var value = parseInt(n, 10);
  if (isNaN(value)) return 0;
  return value;
}

function getElementVisualBounds(el) {
  var pageBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var clientRect = el.getBoundingClientRect ? el.getBoundingClientRect() : { x: 0, y: 0, width: window.width, height: window.height };
  var width = clientRect.width,
      height = clientRect.height,
      top = clientRect.top,
      left = clientRect.left;


  if (el.tagName === "IMG") {
    // Issue #378: If an IMG element has no background or border then ignore its padding
    var style = window.getComputedStyle(el);
    var noBorder = __WEBPACK_IMPORTED_MODULE_1_lodash_every___default()(["Left", "Right", "Top", "Bottom"], function (d) {
      return style["border" + d].match(/(^0px )|transparent/);
    });
    var noBackground = style.backgroundImage === "none" && style.backgroundColor.match(/rgba(.*,\s*0)|rgb(0,0,0)|transparent|/);
    if (noBackground && noBorder) {
      top += parseNumber(style.paddingTop);
      left += parseNumber(style.paddingLeft);
      width -= parseNumber(style.paddingRight) + parseNumber(style.paddingLeft);
      height -= parseNumber(style.paddingBottom) + parseNumber(style.paddingTop);
    }
  } else if (el.tagName === 'INPUT' && el.getAttribute('type') === 'file') {
    // issue #781
    var _style = window.getComputedStyle(el);
    if (_style.opacity === '0') {
      var buttonEl = el.parentNode.querySelector('button, [type="button"]');
      if (buttonEl) {
        var _buttonEl$getBounding = buttonEl.getBoundingClientRect();

        width = _buttonEl$getBounding.width;
        height = _buttonEl$getBounding.height;
        top = _buttonEl$getBounding.top;
        left = _buttonEl$getBounding.left;
      }
    }
  } else {
    // issue #1077: element inside a position:absolute element
    // which is partially hidden via a smaller position:fixed parent
    // => only consider what is actually visible
    var firstContainerFound = false;
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_dom__["a" /* closest */])(el, function (currentEl) {
      if (currentEl.nodeType !== Node.ELEMENT_NODE) return;
      var computedStyles = window.getComputedStyle(currentEl);
      if (['absolute', 'fixed'].includes(computedStyles.position)) {
        if (!firstContainerFound) {
          firstContainerFound = true;
        } else {
          var parentBounds = currentEl.getBoundingClientRect();
          if (computedStyles.overflowX !== 'visible' && parentBounds.left + parentBounds.width - left > 0) {
            width = Math.min(parentBounds.left + parentBounds.width - left, width);
          }
        }
      }
    });
  }

  if (!pageBounds) {
    // getBoundingClientRect is fixed and relative to the document, make it relative to the body
    var _getWindowScrollOffse = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__getWindowScrollOffset__["a" /* default */])(),
        x = _getWindowScrollOffse.x,
        y = _getWindowScrollOffse.y;

    top += y;
    left += x;
  }

  return { width: width, height: height, y: top, x: left };
}

/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// The extension API point (chrome on Chrome and browser on Edge)
// NOTE: actually for the time being we are still using chrome on Edge
// since support is still shaky and we want to leverage the api bridge

// This module can probably just stay like this, but could *POTENTIALLY* grow to
// add cross compatibility stuff in the future. Or it could get warnings for
// APIs not supported on both.

// NOTE: in Firefox content scripts `window !== this`
// thus `window.browser` is undefined
// see https://bugzilla.mozilla.org/show_bug.cgi?id=1344066


/* harmony default export */ __webpack_exports__["a"] =  true ? undefined : BROWSER === "chrome" || BROWSER === 'edge' || BROWSER === 'test' ? window.chrome : browser;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(191), __esModule: true };

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(192), __esModule: true };

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(213);
var $Object = __webpack_require__(7).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(214);
__webpack_require__(139);
__webpack_require__(215);
__webpack_require__(216);
module.exports = __webpack_require__(7).Symbol;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(53);
__webpack_require__(75);
module.exports = __webpack_require__(74).f('iterator');


/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(26);
var toLength = __webpack_require__(94);
var toAbsoluteIndex = __webpack_require__(211);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(50);
var gOPS = __webpack_require__(85);
var pIE = __webpack_require__(51);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(31);
var ITERATOR = __webpack_require__(11)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(44);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(17);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(84);
var descriptor = __webpack_require__(36);
var setToStringTag = __webpack_require__(52);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(25)(IteratorPrototype, __webpack_require__(11)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(11)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 201 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(45)('meta');
var isObject = __webpack_require__(27);
var has = __webpack_require__(24);
var setDesc = __webpack_require__(15).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(28)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(15);
var anObject = __webpack_require__(17);
var getKeys = __webpack_require__(50);

module.exports = __webpack_require__(19) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(26);
var gOPN = __webpack_require__(115).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(14);
var core = __webpack_require__(7);
var fails = __webpack_require__(28);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(17);
var isObject = __webpack_require__(27);
var newPromiseCapability = __webpack_require__(136);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(17);
var aFunction = __webpack_require__(65);
var SPECIES = __webpack_require__(11)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(70);
var defined = __webpack_require__(66);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(40);
var invoke = __webpack_require__(347);
var html = __webpack_require__(134);
var cel = __webpack_require__(83);
var global = __webpack_require__(10);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(44)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(70);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(193);
var step = __webpack_require__(201);
var Iterators = __webpack_require__(31);
var toIObject = __webpack_require__(26);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(114)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(14);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(19), 'Object', { defineProperty: __webpack_require__(15).f });


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(10);
var has = __webpack_require__(24);
var DESCRIPTORS = __webpack_require__(19);
var $export = __webpack_require__(14);
var redefine = __webpack_require__(117);
var META = __webpack_require__(202).KEY;
var $fails = __webpack_require__(28);
var shared = __webpack_require__(69);
var setToStringTag = __webpack_require__(52);
var uid = __webpack_require__(45);
var wks = __webpack_require__(11);
var wksExt = __webpack_require__(74);
var wksDefine = __webpack_require__(73);
var enumKeys = __webpack_require__(195);
var isArray = __webpack_require__(197);
var anObject = __webpack_require__(17);
var toIObject = __webpack_require__(26);
var toPrimitive = __webpack_require__(72);
var createDesc = __webpack_require__(36);
var _create = __webpack_require__(84);
var gOPNExt = __webpack_require__(204);
var $GOPD = __webpack_require__(93);
var $DP = __webpack_require__(15);
var $keys = __webpack_require__(50);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(115).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(51).f = $propertyIsEnumerable;
  __webpack_require__(85).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(49)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(25)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(73)('asyncIterator');


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(73)('observable');


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(98)
  , document = __webpack_require__(32).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(54) && !__webpack_require__(97)(function(){
  return Object.defineProperty(__webpack_require__(217)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(222)
  , hiddenKeys = __webpack_require__(141).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 221 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(55)
  , toIObject    = __webpack_require__(57)
  , arrayIndexOf = __webpack_require__(368)(false)
  , IE_PROTO     = __webpack_require__(223)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(146)('keys')
  , uid    = __webpack_require__(76);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 224 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(77);

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/
(function() {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/*** EXPORTS FROM exports-loader ***/
module.exports = global.fetch;
}.call(global));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)))

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 229 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 230 */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(241),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(8),
    isBuffer = __webpack_require__(88),
    isIndex = __webpack_require__(80),
    isTypedArray = __webpack_require__(125);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 232 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 233 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 234 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(287),
    keys = __webpack_require__(38);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(155),
    isArray = __webpack_require__(8);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(108),
    nativeKeys = __webpack_require__(465);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(121),
    baseSet = __webpack_require__(239),
    castPath = __webpack_require__(79);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(156),
    castPath = __webpack_require__(79),
    isIndex = __webpack_require__(80),
    isObject = __webpack_require__(16),
    toKey = __webpack_require__(61);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(43),
    metaMap = __webpack_require__(257);

/**
 * The base implementation of `setData` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;


/***/ }),
/* 241 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 242 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;


/***/ }),
/* 243 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

module.exports = composeArgsRight;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(78),
    isIterateeCall = __webpack_require__(123);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var composeArgs = __webpack_require__(242),
    composeArgsRight = __webpack_require__(243),
    countHolders = __webpack_require__(428),
    createCtor = __webpack_require__(105),
    createRecurry = __webpack_require__(246),
    getHolder = __webpack_require__(252),
    reorder = __webpack_require__(470),
    replaceHolders = __webpack_require__(166),
    root = __webpack_require__(13);

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_ARY_FLAG = 128,
    WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG,
      isBind = bitmask & WRAP_BIND_FLAG,
      isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
      isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
      isFlip = bitmask & WRAP_FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtor(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybrid;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var isLaziable = __webpack_require__(254),
    setData = __webpack_require__(260),
    setWrapToString = __webpack_require__(261);

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString(result, func, bitmask);
}

module.exports = createRecurry;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arraySome = __webpack_require__(233),
    cacheHas = __webpack_require__(160);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)))

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(236),
    getSymbols = __webpack_require__(163),
    keys = __webpack_require__(38);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var realNames = __webpack_require__(469);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

module.exports = getFuncName;


/***/ }),
/* 252 */
/***/ (function(module, exports) {

/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

module.exports = getHolder;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(155),
    getPrototype = __webpack_require__(179),
    getSymbols = __webpack_require__(163),
    stubArray = __webpack_require__(269);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(148),
    getData = __webpack_require__(162),
    getFuncName = __webpack_require__(251),
    lodash = __webpack_require__(500);

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

module.exports = isLaziable;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 256 */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var WeakMap = __webpack_require__(228);

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;


/***/ }),
/* 258 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(119);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetData = __webpack_require__(240),
    shortOut = __webpack_require__(262);

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = shortOut(baseSetData);

module.exports = setData;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var getWrapDetails = __webpack_require__(441),
    insertWrapDetails = __webpack_require__(449),
    setToString = __webpack_require__(167),
    updateWrapDetails = __webpack_require__(482);

/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
function setWrapToString(wrapper, reference, bitmask) {
  var source = (reference + '');
  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}

module.exports = setWrapToString;


/***/ }),
/* 262 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 263 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16),
    now = __webpack_require__(493),
    toNumber = __webpack_require__(270);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(157);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(153),
    baseEach = __webpack_require__(103),
    castFunction = __webpack_require__(291),
    isArray = __webpack_require__(8);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(398),
    hasPath = __webpack_require__(295);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(151);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 269 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16),
    isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(415);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 272 */,
/* 273 */,
/* 274 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_isEqual__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_isEqual___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_isEqual__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Flux; });










var Flux = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(Flux, _EventEmitter);

  function Flux() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Flux);

    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Flux.__proto__ || Object.getPrototypeOf(Flux)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Flux, [{
    key: 'updater',

    // Call handlers with specified path values
    // if they have changed
    value: function updater(oldState, state, rules) {
      rules.forEach(function (rule) {
        var ruleObj = rule;
        if (Array.isArray(rule)) {
          ruleObj = {
            path: rule[0],
            handler: rule[1],
            compare: rule[2]
          };
        }
        ruleObj.compare = ruleObj.compare || __WEBPACK_IMPORTED_MODULE_7_lodash_isEqual___default.a;

        if (ruleObj.path) {
          // (falsy paths can be used to implement conditional rules)
          var value = __WEBPACK_IMPORTED_MODULE_6_lodash_get___default()(state, ruleObj.path);
          if (!oldState) ruleObj.handler(value);else {
            var oldValue = __WEBPACK_IMPORTED_MODULE_6_lodash_get___default()(oldState, ruleObj.path);
            if (!ruleObj.compare(value, oldValue)) {
              ruleObj.handler(value);
            }
          }
        }
      });
    }
  }, {
    key: 'dispatch',
    value: function dispatch(context, actionName) {
      for (var _len = arguments.length, actionArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        actionArgs[_key - 2] = arguments[_key];
      }

      if (context.name !== this.ownContextName) {
        this.callRemoteAction(context, actionName, actionArgs);
      } else {
        // direct
        this.callLocalAction(actionName, actionArgs);
      }
    }
  }, {
    key: 'callRemoteAction',
    value: function callRemoteAction(context, actionName, actionArgs) {
      this.sendToContext(context, {
        topic: 'dispatchAction',
        data: {
          context: context,
          actionName: actionName,
          actionArgs: actionArgs
        }
      });
    }
  }, {
    key: 'sendToContext',
    value: function sendToContext(context, message) {
      throw new Error('Subclases should implement this method');
    }
  }, {
    key: 'callLocalAction',
    value: function callLocalAction(actionName, actionArgs) {
      var action = this._actions[actionName];
      if (!action) {
        throw new Error('Action not found: ' + actionName);
      }
      action.apply(undefined, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(actionArgs));
    }
  }]);

  return Flux;
}(__WEBPACK_IMPORTED_MODULE_5_node_event_emitter___default.a);



/***/ }),
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(fetch) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return apiFetch; });

var authFetch = function authFetch(url) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return fetch(url, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({ credentials: 'include' }, opts));
};
/* harmony default export */ __webpack_exports__["b"] = authFetch;

var apiFetch =  true ? fetch : authFetch;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(226)))

/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__ = __webpack_require__(622);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_waitForInit__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_mapValues__ = __webpack_require__(303);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_mapValues___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_mapValues__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_pick__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_pick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_pick__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__ = __webpack_require__(6);
/* unused harmony export screen2page */
/* harmony export (immutable) */ __webpack_exports__["a"] = pagebounds2screen;
/* unused harmony export screenbounds2page */
/* unused harmony export screenbounds2tab */
/* unused harmony export applyZoom2bounds */










var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

// Offsets between the origin of the screen coordinate system and the
// content coordinate system. We start of with an educated guess but
// the first time we see a mouse event we'll be given both client and
// screen coordinates and can actually get the real numbers
// INITIAL GUESS VALUES!
var isTop = window === window.top;
var contentScreenOffsetX = window.screenX + (isTop ? (window.outerWidth - window.innerWidth) / 2 : 0);
var contentScreenOffsetY = window.screenY + (isTop ? window.outerHeight - window.innerHeight - contentScreenOffsetX : 0);
var isTrusted = false;

function broadcastDown() {
  var iframes = Array.from(document.documentElement.querySelectorAll("iframe"));
  iframes.forEach(function (iframe) {
    var screenBounds = page2screen(iframe.getBoundingClientRect());
    __WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__["a" /* send */](iframe.contentWindow, 'coordinates:initialValues', {
      contentScreenOffsetX: screenBounds.left,
      contentScreenOffsetY: screenBounds.top,
      isTrusted: isTrusted
    });
  });
}

function updateOffsets(values) {
  var changed = values.contentScreenOffsetX !== contentScreenOffsetX || values.contentScreenOffsetY !== contentScreenOffsetY || values.isTrusted !== isTrusted;

  if (changed) {
    contentScreenOffsetX = values.contentScreenOffsetX;
    contentScreenOffsetY = values.contentScreenOffsetY;
    isTrusted = values.isTrusted;

    broadcastDown();
    //console.log('updateOffsets', contentScreenOffsetY, mouseEvent.screenY, mouseEvent.clientY, ratio);
  }
}

if (!isTop) {
  __WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__["c" /* onMessage */]('coordinates:initialValues', function (_ref) {
    var payload = _ref.payload;

    if (isTrusted && !payload.trusted) return;
    updateOffsets(payload);
  });
  __WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__["f" /* PARENT */], 'coordinates:getInitialValues');
}
__WEBPACK_IMPORTED_MODULE_4_base_common_utils_frameMessages__["c" /* onMessage */]('coordinates:getInitialValues', function () {
  broadcastDown();
});

function handleEvent(mouseEvent) {
  if (!document.body) return; // too early
  if (mouseEvent.type === 'click' && mouseEvent.screenX === 0 && mouseEvent.screenY === 0) return; // ignore fake event (see 946#issuecomment-339658942)
  var ratio =  false ? window.devicePixelRatio : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__["a" /* getZoom */])();
  updateOffsets({
    contentScreenOffsetX: mouseEvent.screenX - mouseEvent.clientX * ratio,
    contentScreenOffsetY: mouseEvent.screenY - mouseEvent.clientY * ratio,
    isTrusted: true
  });
}
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_waitForInit__["a" /* default */])(function () {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_base_common_utils_windowEvents__["a" /* addWindowListener */])('click', handleEvent, true);
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_base_common_utils_windowEvents__["a" /* addWindowListener */])('mousemove', handleEvent, true);
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_base_common_utils_windowEvents__["a" /* addWindowListener */])('mouseover', handleEvent, true); // needed in case of 100% size iframes (#817)
});

function mapBoundsPosition(boundsPosition, horizontalFn, verticalFn) {
  var horizontal = __WEBPACK_IMPORTED_MODULE_5_lodash_mapValues___default()(__WEBPACK_IMPORTED_MODULE_6_lodash_pick___default()(boundsPosition, ['x', 'left', 'right']), function (h) {
    return horizontalFn(h);
  });

  var vertical = __WEBPACK_IMPORTED_MODULE_5_lodash_mapValues___default()(__WEBPACK_IMPORTED_MODULE_6_lodash_pick___default()(boundsPosition, ['y', 'top', 'bottom']), function (v) {
    return verticalFn(v);
  });

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, horizontal, vertical);
}

function page2screen(boundsPosition) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  offset = offset || { x: contentScreenOffsetX, y: contentScreenOffsetY };
  var ratio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__["a" /* getZoom */])();

  return mapBoundsPosition(boundsPosition, function (h) {
    return Math.round(h * ratio + offset.x);
  }, function (v) {
    return Math.round(v * ratio + offset.y);
  });
}

// Used by testPage.js and screenbounds2page (which is only used by testPage.js)
function screen2page(boundsPosition) {
  var ratio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__["a" /* getZoom */])();

  return mapBoundsPosition(boundsPosition, function (h) {
    return (h - contentScreenOffsetX) / ratio;
  }, function (v) {
    return (v - contentScreenOffsetY) / ratio;
  });
}

function screen2tab(boundsPosition) {
  return mapBoundsPosition(boundsPosition, function (h) {
    return h - contentScreenOffsetX;
  }, function (v) {
    return v - contentScreenOffsetY;
  });
}

function pagebounds2screen(bounds) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var ratio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__["a" /* getZoom */])();
  var boundsPosition = __WEBPACK_IMPORTED_MODULE_6_lodash_pick___default()(bounds, ['x', 'y', 'left', 'top', 'right', 'bottom']);

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, page2screen(boundsPosition, offset), {
    width: Math.round(bounds.width * ratio),
    height: Math.round(bounds.height * ratio)
  });
}

// Only used in testPage.js currently
function screenbounds2page(bounds) {
  var ratio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_content_zoom_zoomFrameNode__["a" /* getZoom */])();
  var boundsPosition = __WEBPACK_IMPORTED_MODULE_6_lodash_pick___default()(bounds, ['x', 'y', 'left', 'top', 'right', 'bottom']);

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, screen2page(boundsPosition), {
    width: bounds.width / ratio,
    height: bounds.height / ratio
  });
}

// Note: only works in top frame!
function screenbounds2tab(bounds) {
  var boundsPosition = __WEBPACK_IMPORTED_MODULE_6_lodash_pick___default()(bounds, ['x', 'y', 'left', 'top', 'right', 'bottom']);

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, screen2tab(boundsPosition), {
    width: bounds.width,
    height: bounds.height
  });
}

// Note: screen and tab bounds already include zoom,
// thus this might only be useful for page bounds.
function applyZoom2bounds(_ref2, zoom) {
  var x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height;

  logger.debug('Before zoom', { x: x, y: y, width: width, height: height });

  x = Math.round(x * zoom);
  y = Math.round(y * zoom);
  width = Math.round(width * zoom);
  height = Math.round(height * zoom);

  logger.debug('After zoom', { x: x, y: y, width: width, height: height });
  return { x: x, y: y, width: width, height: height };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/common/utils/coordinates.js"))

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export withDefaultPrevented */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closest; });
var withDefaultPrevented = function withDefaultPrevented(fn) {
  return function (e) {
    e.preventDefault();
    return fn(e);
  };
};

var closest = function closest(el, fn) {
  var currentEl = el;
  while (currentEl) {
    if (fn(currentEl)) return currentEl;
    currentEl = currentEl.parentElement;
  }
};

/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getRedirect;
/* harmony export (immutable) */ __webpack_exports__["a"] = redirectIfNeeded;
/* harmony export (immutable) */ __webpack_exports__["c"] = willBrowserReload;
function normalizedUrlWithoutOrigin(parsedUrl) {
  // Add eventual ending '/' to pathname
  // Note: this is needed for urls such as "A: https://site.com/some", "B: https://site.com/some/"
  var normalizedPathname = parsedUrl.pathname === '' ? '/' : parsedUrl.pathname;

  // ignore out custom "ioradLiveId" query parameter, since it has no effect on the user page.
  // it also does other cleaning on the search.
  var normalizedSearch = parsedUrl.search.match(/[?&]ioradLiveId=\d+/) ? parsedUrl.search.replace(/[?&]ioradLiveId=\d+/, '') : parsedUrl.search;
  normalizedSearch = normalizedSearch.startsWith('&') ? normalizedSearch = '?' + normalizedSearch.slice(1) : normalizedSearch;
  normalizedSearch = normalizedSearch === '?' ? '' : normalizedSearch;

  var normalizedHash = parsedUrl.hash === '#' ? '' : parsedUrl.hash;

  return normalizedPathname + normalizedSearch + normalizedHash;
}

function getRedirect(stepUrlString, currentUrlString, force) {
  if (!stepUrlString) return null;
  var stepUrl = new URL(stepUrlString);
  var currentUrl = new URL(currentUrlString);

  if (force) {
    return stepUrl.href;
  }

  var whitelisted = stepUrl.hostname.endsWith(".zendesk.com") || stepUrl.hostname.endsWith(".iorad.com") || stepUrl.hostname.endsWith(".iorad.dev");
  if (!whitelisted) {
    return null;
  }

  // Don't switch to urls with numeric path segments. This is a very very
  // rough heuristic for a url that changes depending on the user
  if (/\/\d+($|\/)/.exec(stepUrl.pathname)) {
    return null;
  }

  // Special case for zendesk so we can apply urls to the user's current
  // account. See #619
  // QUESTION: Would this make sense in general for sub-domains?
  var isZendeskSubdomain = stepUrl.hostname.endsWith(".zendesk.com") && (currentUrl.hostname.endsWith(".zendesk.com") || window.Zendesk) && currentUrl.hostname !== "www.zendesk.com" && stepUrl.hostname !== "www.zendesk.com";
  if (isZendeskSubdomain) {
    stepUrl.hostname = currentUrl.hostname;
  }

  // If the urls are the same except the parts after the last '/',
  // then we can assume it is safe to redirect.
  // Note: the "/" could also be inside the search or the hash (e.g. "/#/" vs "/#/Quora")
  if (stepUrl.hostname === currentUrl.hostname) {
    var stepUrlParts = normalizedUrlWithoutOrigin(stepUrl).split('/');
    var currentUrlParts = normalizedUrlWithoutOrigin(currentUrl).split('/');
    var sameInitialUrl = stepUrlParts.slice(0, -1).join('/') === currentUrlParts.slice(0, -1).join('/');
    var sameFinalUrl = stepUrlParts.slice(-1).join('/') === currentUrlParts.slice(-1).join('/');
    if (sameInitialUrl && !sameFinalUrl) {
      return stepUrl.href;
    }
  }

  return null;
}

function redirectIfNeeded(stepUrlString, force) {
  var redirectUrl = getRedirect(stepUrlString, window.location.href, force);
  if (redirectUrl && redirectUrl !== window.location.href) {
    window.location.href = redirectUrl;
    return true;
  }
  return false;
}

// Browser won't reload the page if only the hash has changed
function willBrowserReload(oldUrlString, newUrlString) {
  if (oldUrlString === newUrlString) return false;

  var oldUrlParser = document.createElement('a');
  oldUrlParser.href = oldUrlString;

  var newUrlParser = document.createElement('a');
  newUrlParser.href = newUrlString;

  return oldUrlParser.origin + oldUrlParser.pathname + oldUrlParser.search !== newUrlParser.origin + newUrlParser.pathname + newUrlParser.search;
}

/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_css_escape__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_css_escape___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_css_escape__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__elementInfo__ = __webpack_require__(609);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_compact__ = __webpack_require__(547);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_compact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_compact__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_filter__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_filter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_intersection__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_intersection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_intersection__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_last__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_last___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_last__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_map__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_omit__ = __webpack_require__(549);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_omit___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_omit__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_toArray__ = __webpack_require__(753);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_union__ = __webpack_require__(756);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_union___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_union__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_uniq__ = __webpack_require__(757);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_uniq___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_uniq__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_every__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_every__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_flatten__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_flatten___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_lodash_flatten__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_difference__ = __webpack_require__(745);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_difference___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_lodash_difference__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_uniqWith__ = __webpack_require__(758);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_uniqWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_lodash_uniqWith__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash_isEmpty__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash_isEmpty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_lodash_isEmpty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["b"] = getLocator;
/* unused harmony export calculateInfoScore */
/* unused harmony export calculateLocatorScore */
/* unused harmony export areElementsSimilar */
/* unused harmony export findSimilarBottomDescendants */
/* unused harmony export findSimilarElements */
/* unused harmony export reduceBySharedClasses */
/* harmony export (immutable) */ __webpack_exports__["a"] = locateElement;





var _marked = [narrowPart].map(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark);

// on the page. Of course this will always be a heuristic, not
// possible to do it perfectly.



















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

function queryFind(document, query) {
  try {
    if (!query || query.trim().length === 0) return [];
    var els = document.querySelectorAll(query);

    // ignore invisible elements
    // TODO: this could not work with fixed elements, needs improvement
    /*els = [...els].filter(el =>
      el.offsetParent !== null || el === document.documentElement || el === document.body
    );*/

    return els;
  } catch (e) {
    logger.error('Error while looking for selector "' + query + '", got error: ', e, '\n', e.stack);
    return [];
  }
}

function filterByText(els, text) {
  if (text) {
    var simplifyText = function simplifyText(aText) {
      // remove numbers since they often change
      // among different playbacks
      return aText.replace(/\d+/g, '').trim();
    };

    var getText = function getText(e) {
      if (!e.classList) return '';
      var textContent = e && e.textContent;
      if (e.hasAttribute('alt')) {
        textContent = e.getAttribute('alt');
      }
      return textContent || '';
    };

    els = __WEBPACK_IMPORTED_MODULE_7_lodash_filter___default()(els, function (e) {
      return simplifyText(getText(e)) === simplifyText(text);
    });
  }
  return els;
}

function filterByDetectedName(els, name) {
  if (name) {
    var simplifyName = function simplifyName(aName) {
      // remove numbers since they often change
      // among different playbacks
      return aName.replace(/\d+/g, '').trim();
    };

    var getName = function getName(e) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__elementInfo__["a" /* detectName */])(e) || '';
    };

    els = __WEBPACK_IMPORTED_MODULE_7_lodash_filter___default()(els, function (e) {
      return simplifyName(getName(e)) === simplifyName(name);
    });
  }
  return els;
}

function areElementsSiblings(els) {
  if (els.length < 2) return false;
  var firstParent = els[0].parentNode;
  return [].concat(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(els)).filter(function (el) {
    return el.parentNode !== firstParent;
  }).length === 0;
}

function getAttributes(el) {
  if (!el.attributes) return []; // e.g. window

  return (// make an object {attrName: attrValue}
    Array.from(el.attributes).reduce(function (attrs, node) {
      return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, attrs, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, node.nodeName, node.nodeValue));
    }, {})
  );
}

function getNestedinfo(el, contextProp, infoPropName, nestingLevel) {
  var contextNode = el[contextProp];
  if (!contextNode || nestingLevel <= 0) return null;

  var info = elementInfo(contextNode, false);
  info[infoPropName] = getNestedinfo(el, contextProp, infoPropName, nestingLevel - 1);
  return info;
}
function getParents(el) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

  var info = getNestedinfo(el, 'parentNode', 'parent', limit);
  return info;
}
function getPrevSiblings(el) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

  return getNestedinfo(el, 'previousElementSibling', 'prevSibling', limit);
}
function getNextSiblings(el) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

  return getNestedinfo(el, 'nextElementSibling', 'nextSibling', limit);
}
function getContextInfo(el) {
  return {
    parent: getParents(el),
    prevSibling: getPrevSiblings(el),
    nextSibling: getNextSiblings(el)
  };
}

function elementInfo(el) {
  var withContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var tagName = el.tagName,
      classList = el.classList;

  var id = el.classList && el.getAttribute('id') || undefined;
  var name = el.classList && el.getAttribute('name') || undefined;
  var detectedName = ['INPUT', 'TEXTAREA'].indexOf(el.tagName) !== -1 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__elementInfo__["a" /* detectName */])(el) || undefined;
  var placeholder = el.classList && el.getAttribute('placeholder') || undefined;
  var href = el.classList && el.getAttribute('href') || undefined;
  var src = el.classList && el.getAttribute('src') || undefined;
  var childIndex = el.parentNode && el.parentNode.children ? Array.prototype.indexOf.call(el.parentNode.children, el) : undefined;
  var textContent = el.classList ? el.textContent.trim() || el.getAttribute('alt') : undefined;
  var attributes = getAttributes(el);
  var contextInfo = withContext ? getContextInfo(el) : {};
  var ariaLabel = el.classList && el.getAttribute('aria-label') || undefined;

  return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({
    tagName: tagName,
    id: id,
    classes: classList && classList.length > 0 ? __WEBPACK_IMPORTED_MODULE_12_lodash_toArray___default()(classList) : undefined,
    text: textContent && textContent.length < 50 ? textContent : undefined,
    placeholder: placeholder,
    ariaLabel: ariaLabel,
    name: name,
    detectedName: detectedName,
    href: href,
    src: src,
    childIndex: childIndex,
    attributes: attributes
  }, contextInfo);
}

function getLocator(el) {
  var locator = [];

  var MAX_LEVEL = 10;
  var currentEl = el;
  while (currentEl !== null && locator.length < MAX_LEVEL) {
    var info = elementInfo(currentEl);
    locator.unshift(info);

    currentEl = currentEl.parentNode || null;
  }

  return locator;
}

var IMPORTANT_INFO_PROPS = ['tagName', 'id', 'name', 'detectedName', 'href', 'src', 'placeholder', 'ariaLabel'];
var importantAttributes = ['id', 'class', 'name', 'href', 'src', 'placeholder', 'aria-label'];

function makeQuery(info) {
  var query = '';
  if (info.tagName) query += '' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.tagName);
  if (info.id) {
    query += '#' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.id);
  }
  query += __WEBPACK_IMPORTED_MODULE_10_lodash_map___default()(info.classes, function (cls) {
    return '.' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(cls);
  }).join('');
  if (info.name) {
    query += '[name="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.name) + '"]';
  }
  if (info.href) {
    query += '[href="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.href) + '"]';
  }
  if (info.hrefSuffix) {
    query += '[href$="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.hrefSuffix) + '"]';
  }
  if (info.src) {
    query += '[src="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.src) + '"]';
  }
  if (info.childIndex != null) {
    query += ':nth-child(' + (info.childIndex + 1) + ')';
  }
  if (info.placeholder) {
    query += '[placeholder="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.placeholder) + '"]';
  }
  if (info.ariaLabel) {
    query += '[aria-label="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(info.ariaLabel) + '"]';
  }
  if (info.attributes) {
    var attributes = __WEBPACK_IMPORTED_MODULE_11_lodash_omit___default()(info.attributes, importantAttributes);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(attributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var attributeName = _step.value;

        if (attributeName.indexOf(':') !== -1) continue; // I have no idea how to do a CSS selector namespaces attributes
        var attributeValue = attributes[attributeName];
        query += '[' + attributeName + '="' + __WEBPACK_IMPORTED_MODULE_4_css_escape___default()(attributeValue) + '"]';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  return query;
}

function queryLocator(document, locator) {
  if (!Array.isArray(locator)) {
    locator = [locator];
  }

  var queries = locator.map(makeQuery);
  var query = (queries[0] || '').trim();
  for (var i = 1; i < queries.length; i++) {
    var currentQuery = queries[i].trim();
    var querySeparator = !query || !currentQuery ? '' : locator[i].directChild ? ' > ' : ' ';
    query += querySeparator + currentQuery;
  }

  var els = queryFind(document, query);

  if (__WEBPACK_IMPORTED_MODULE_9_lodash_last___default()(locator).text) {
    els = filterByText(els, __WEBPACK_IMPORTED_MODULE_9_lodash_last___default()(locator).text);
  }

  if (__WEBPACK_IMPORTED_MODULE_9_lodash_last___default()(locator).detectedName) {
    els = filterByDetectedName(els, __WEBPACK_IMPORTED_MODULE_9_lodash_last___default()(locator).detectedName);
  }

  return { query: query, els: els };
}

function countLocator(document, locator) {
  return queryLocator(document, locator).els.length;
}

function calculateInfoScore(info) {
  var importantPropsScore = 10;
  var textScore = 10;
  var aClassScore = 4;
  var anAttributeScore = 4;

  return Object.keys(info).reduce(function (currentScore, infoProp) {
    var propScore = 0;
    if (IMPORTANT_INFO_PROPS.indexOf(infoProp) !== -1) {
      propScore = importantPropsScore;
    }if (infoProp === 'text') {
      propScore = textScore;
    } else if (infoProp === 'classes' && info.classes) {
      propScore = info.classes.length * aClassScore;
    } else if (infoProp === 'attributes' && info.attributes) {
      var attributeNames = Object.keys(__WEBPACK_IMPORTED_MODULE_11_lodash_omit___default()(info.attributes, ['class'].concat(IMPORTANT_INFO_PROPS)));
      propScore = attributeNames.length * anAttributeScore;
    }
    return currentScore + propScore;
  }, 0);
}

function calculateLocatorScore(locator) {
  return locator.reduce(function (currentScore, info) {
    return currentScore + calculateInfoScore(info);
  }, 0);
}

// Note: this is best suited for comparing siblings.

// NOTE: This function has been micro-optimised, we call it a *lot*
function areElementsSimilar(elements, minEqualClasses, threshold) {
  if (elements.length === 0) return false;
  if (elements.length === 1) return true;
  // elements = Array.from(elements);

  // TOO HIGH: doesn't catch similar elements
  // TOO LOW: catches elements that aren't similar
  if (typeof minEqualClasses === 'undefined') minEqualClasses = 1;
  // part of not similar elements allowed
  if (typeof threshold === 'undefined') threshold = 0.2; // 20%

  // Must all be the same tag type
  var tagName = elements[0].tagName.toUpperCase();
  for (var i = 1; i < elements.length; i++) {
    if (!elements[i].tagName || elements[i].tagName.toUpperCase() !== tagName) {
      return false;
    }
  }

  // they must all have the same tag name
  // list/table elements are similar regardless of everything else
  var areListTableElements = tagName === 'LI' || tagName === 'TR' || tagName === 'TD';
  if (areListTableElements) {
    return true;
  }
  // or they must all have at least X equal classes (or no class at all)

  var seenClasses = {};
  var sharedClasses = 0,
      totalClasses = 0;
  for (var _i = 0; _i < elements.length; _i++) {
    var cl = elements[_i].classList;
    for (var j = 0; j < cl.length; j++) {
      var c = cl[j];
      var val = (seenClasses[c] || 0) + 1;
      seenClasses[c] = val;
      if (val >= elements.length * (1 - threshold)) {
        sharedClasses++;
        if (sharedClasses >= minEqualClasses) {
          return true;
        }
      }
      totalClasses++;
    }
  }
  var haveNoClasses = totalClasses === 0;
  if (haveNoClasses) {
    return true;
  }

  return false;
}

// Note: uses depth-first search.
function findSimilarBottomDescendants(el, descendants) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof options.originalDescendantsLength === 'undefined') {
    options = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, options, { originalDescendantsLength: descendants.length });
  }

  if (descendants.length === 0) return [el]; // end of recursion

  var result = [];
  var children = Array.from(el.children);

  var similarTopDescendants = children.filter(function (child) {
    return areElementsSimilar([child, descendants[0]],
    // be less restrictive with non-bottom descendants
    descendants.length > 1 ? 1 : options.minEqualClasses);
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = similarTopDescendants[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var similarTopDescendant = _step2.value;

      var similarBottomDescendants = findSimilarBottomDescendants(similarTopDescendant, descendants.slice(1), options);
      result.push.apply(result, __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(similarBottomDescendants));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (children.length !== 0 && similarTopDescendants.length !== children.length && options.originalDescendantsLength > 1 && !options.skippedOne) {
    // retry by skipping one descendant
    // NOTE: this is needed in case the original element has a wrapper that doesn't exist in a similar element (e.g. gmail #658)
    var similarBottomDescendants = findSimilarBottomDescendants(el, descendants.slice(1), __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, options, {
      skippedOne: true
    }));
    result.push.apply(result, __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(similarBottomDescendants));

    // Note: this is needed in case the similar element has a wrapper that doesn't exist in the original element (e.g. gmail #690)
    // (i.e. is the specular case of the previous one)
    if (el.children.length === 1) {
      var moreSimilarBottomDescendants = findSimilarBottomDescendants(el.children[0], descendants, __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, options, {
        skippedOne: true
      }));
      result.push.apply(result, __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(moreSimilarBottomDescendants));
    }
  }

  return result;
}

// Find closest ancestor with simimilar descendants.
// The bottom descendants will be the similar elements.
function findSimilarElements(el) {
  var result = [el];

  var descendants = [];
  var currentEl = el;
  while (currentEl && currentEl.parentNode && currentEl.parentNode.classList) {
    var siblings = currentEl.parentNode.children;
    var MIN_SIBLINGS = 1;
    if (siblings.length >= MIN_SIBLINGS && areElementsSimilar(siblings)) {
      // find similar descendants downwards!
      for (var i = 0; i < siblings.length; i++) {
        var _result;

        (_result = result).push.apply(_result, __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(findSimilarBottomDescendants(siblings[i], descendants)));
      }
    }

    descendants.unshift(currentEl);
    currentEl = currentEl.parentNode;
  }

  result = __WEBPACK_IMPORTED_MODULE_14_lodash_uniq___default()(result);
  var MIN_LENGTH = 2;
  if (result.length > MIN_LENGTH) {
    result = reduceByTagName(el, result);
  }
  if (result.length > MIN_LENGTH) {
    result = reduceBySharedClasses(el, result, MIN_LENGTH);
  }
  return result;
}

function reduceByTagName(el, sels) {
  return sels.filter(function (sel) {
    return sel.tagName === el.tagName;
  });
}

var hasClassesRequired = function hasClassesRequired(length, classList) {
  return function (sel) {
    return __WEBPACK_IMPORTED_MODULE_8_lodash_intersection___default()(sel.classList, classList).length >= length;
  };
};

function reduceBySharedClasses(el, sels, minLength) {
  var reducedList = [];
  var cl = el.classList;

  for (var lengthRequired = cl.length; reducedList.length < minLength && lengthRequired > 0; lengthRequired--) {
    reducedList = sels.filter(hasClassesRequired(lengthRequired, cl));
  }
  return reducedList.length < minLength ? sels : reducedList;
}

// Narrow a selector part (given the full original version)
function narrowPart(info, originalInfo) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var _options$onlyImportan, onlyImportant, _options$includeText, includeText, _options$includeDirec, includeDirectChild, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, prop, text, classes, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, aClass, attributes, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, attributeName, attributeValue, childIndex;

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function narrowPart$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _options$onlyImportan = options.onlyImportant, onlyImportant = _options$onlyImportan === undefined ? false : _options$onlyImportan, _options$includeText = options.includeText, includeText = _options$includeText === undefined ? false : _options$includeText, _options$includeDirec = options.includeDirectChild, includeDirectChild = _options$includeDirec === undefined ? false : _options$includeDirec;
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 4;
          _iterator3 = IMPORTANT_INFO_PROPS[Symbol.iterator]();

        case 6:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 14;
            break;
          }

          prop = _step3.value;

          if (!(!(prop in info) && originalInfo[prop])) {
            _context.next = 11;
            break;
          }

          _context.next = 11;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, prop, originalInfo[prop]));

        case 11:
          _iteratorNormalCompletion3 = true;
          _context.next = 6;
          break;

        case 14:
          _context.next = 20;
          break;

        case 16:
          _context.prev = 16;
          _context.t0 = _context['catch'](4);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t0;

        case 20:
          _context.prev = 20;
          _context.prev = 21;

          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }

        case 23:
          _context.prev = 23;

          if (!_didIteratorError3) {
            _context.next = 26;
            break;
          }

          throw _iteratorError3;

        case 26:
          return _context.finish(23);

        case 27:
          return _context.finish(20);

        case 28:
          if (!includeText) {
            _context.next = 34;
            break;
          }

          if (!originalInfo.text) {
            _context.next = 34;
            break;
          }

          text = originalInfo.text;

          if (!(typeof info.text === 'undefined')) {
            _context.next = 34;
            break;
          }

          _context.next = 34;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, {
            text: text
          });

        case 34:
          if (!originalInfo.classes) {
            _context.next = 63;
            break;
          }

          classes = originalInfo.classes;
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context.prev = 39;
          _iterator4 = classes[Symbol.iterator]();

        case 41:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context.next = 49;
            break;
          }

          aClass = _step4.value;

          if (!(!info.classes || info.classes.indexOf(aClass) === -1)) {
            _context.next = 46;
            break;
          }

          _context.next = 46;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, {
            classes: [].concat(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(info.classes || []), [aClass])
          });

        case 46:
          _iteratorNormalCompletion4 = true;
          _context.next = 41;
          break;

        case 49:
          _context.next = 55;
          break;

        case 51:
          _context.prev = 51;
          _context.t1 = _context['catch'](39);
          _didIteratorError4 = true;
          _iteratorError4 = _context.t1;

        case 55:
          _context.prev = 55;
          _context.prev = 56;

          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }

        case 58:
          _context.prev = 58;

          if (!_didIteratorError4) {
            _context.next = 61;
            break;
          }

          throw _iteratorError4;

        case 61:
          return _context.finish(58);

        case 62:
          return _context.finish(55);

        case 63:
          if (!originalInfo.attributes) {
            _context.next = 93;
            break;
          }

          attributes = __WEBPACK_IMPORTED_MODULE_11_lodash_omit___default()(originalInfo.attributes, importantAttributes);
          _iteratorNormalCompletion5 = true;
          _didIteratorError5 = false;
          _iteratorError5 = undefined;
          _context.prev = 68;
          _iterator5 = Object.keys(attributes)[Symbol.iterator]();

        case 70:
          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
            _context.next = 79;
            break;
          }

          attributeName = _step5.value;
          attributeValue = attributes[attributeName];

          if (!(!info.attributes || typeof info.attributes[attributeName] === 'undefined')) {
            _context.next = 76;
            break;
          }

          _context.next = 76;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, {
            attributes: __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info.attributes, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, attributeName, attributeValue))
          });

        case 76:
          _iteratorNormalCompletion5 = true;
          _context.next = 70;
          break;

        case 79:
          _context.next = 85;
          break;

        case 81:
          _context.prev = 81;
          _context.t2 = _context['catch'](68);
          _didIteratorError5 = true;
          _iteratorError5 = _context.t2;

        case 85:
          _context.prev = 85;
          _context.prev = 86;

          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }

        case 88:
          _context.prev = 88;

          if (!_didIteratorError5) {
            _context.next = 91;
            break;
          }

          throw _iteratorError5;

        case 91:
          return _context.finish(88);

        case 92:
          return _context.finish(85);

        case 93:
          if (onlyImportant) {
            _context.next = 99;
            break;
          }

          if (!(originalInfo.childIndex != null)) {
            _context.next = 99;
            break;
          }

          childIndex = originalInfo.childIndex;

          if (!(typeof info.childIndex === 'undefined')) {
            _context.next = 99;
            break;
          }

          _context.next = 99;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, {
            childIndex: childIndex
          });

        case 99:
          if (!includeDirectChild) {
            _context.next = 103;
            break;
          }

          if (info.directChild) {
            _context.next = 103;
            break;
          }

          _context.next = 103;
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, info, {
            directChild: true
          });

        case 103:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked[0], this, [[4, 16, 20, 28], [21,, 23, 27], [39, 51, 55, 63], [56,, 58, 62], [68, 81, 85, 93], [86,, 88, 92]]);
}

function replaceIndex(array, index, value) {
  return [].concat(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(array.slice(0, index)), [value], __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_toConsumableArray___default()(array.slice(index + 1)));
}

function maximizeNarrowingIndex(document, locator, fullLocator, i) {
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = narrowPart(locator[i], fullLocator[i], {
      onlyImportant: false,
      includeText: i === locator.length - 1,
      includeDirectChild: i > 0 && !__WEBPACK_IMPORTED_MODULE_19_lodash_isEmpty___default()(locator[i - 1])
    })[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var narrowedPart = _step6.value;

      var narrowedLocator = replaceIndex(locator, i, narrowedPart);
      var narrowedCount = countLocator(document, narrowedLocator);
      if (narrowedCount !== 0) {
        // the narrowed locator can only be better in term of count (since is a restriction)
        return maximizeNarrowingIndex(document, narrowedLocator, fullLocator, i);
      }
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6.return) {
        _iterator6.return();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return locator;
}

// Narrows the locator as much as possible, so to maximize its score
// (a MUST in multi-frame scenarios)
function maximizeNarrowing(document, locator, fullLocator) {
  for (var i = locator.length - 1; i >= 0; i--) {
    locator = maximizeNarrowingIndex(document, locator, fullLocator, i);
  }

  return locator;
}

// The absolute minimal version of a locator we demand matches (this function
// just produces the minimal version, it DOES NOT test it)
function minimalLocator(fullLocator) {
  var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // QUESTION: is this minimal enough? Should we accept chains in which the tag
  // names don't all match? Maybe we should just insist on certain tags (TD and
  // TH would be good candidates for this)?
  return fullLocator.map(function (l, i) {
    if (loose && i !== fullLocator.length - 1 && l.tagName === 'DIV') return {}; // too generic, even a single wrapper DIV would break the locator (see #918)

    var segment = {
      tagName: l.tagName
    };
    // Demand that if a tag is INPUT it should be the right *type* of input
    if (l.tagName === 'INPUT' && l.attributes && l.attributes.type) {
      segment.attributes = { type: l.attributes.type };
    }
    return segment;
  });
}

// restriction: shouldn't match by just using tagName and/or position
// (with the exception of locators composed of just HTML and BODY elements)
function isInvalidLocator(locator) {
  var nonTrivialLocator = locator.filter(function (l) {
    return ['HTML', 'BODY', undefined].indexOf(l.tagName) === -1;
  });
  return nonTrivialLocator.length !== 0 && __WEBPACK_IMPORTED_MODULE_15_lodash_every___default()(nonTrivialLocator, function (l) {
    return __WEBPACK_IMPORTED_MODULE_15_lodash_every___default()(Object.keys(l), function (key) {
      return ['tagName', 'childIndex', 'directChild'].indexOf(key) >= 0;
    });
  });
}

function matchLocator(document, fullLocator) {
  var allowMultiple = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // Whatever happens we always expect to find the correct sequence of tag names

  var minLocator = minimalLocator(fullLocator);
  var minCount = countLocator(document, minLocator);
  if (minCount === 0) {
    // try being less strict
    minLocator = minimalLocator(fullLocator, true);
    minCount = countLocator(document, minLocator);
    if (minCount === 0) {
      logger.debug("Even the loose minimal locator didn't match, no point going further", fullLocator);
      return null;
    }
  }

  var narrowedLocator = maximizeNarrowing(document, minLocator, fullLocator);
  var narrowedCount = countLocator(document, narrowedLocator);
  logger.debug('Found so far', narrowedLocator, narrowedCount);

  if (narrowedCount === 1 || allowMultiple) {
    if (isInvalidLocator(narrowedLocator)) return null;
    return narrowedLocator;
  }

  return null;
}

function locateElement(locator) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!locator) return { el: null, query: null, score: 0 };
  if (!Array.isArray(locator)) {
    throw new Error("Expected locator to be an array: " + JSON.stringify(locator));
  }
  var document = options.document || window.document;

  logger.debug('Locating', locator);

  var matchingLocator = matchLocator(document, locator, options.multipleMatches);

  if (matchingLocator) {
    var _queryLocator = queryLocator(document, matchingLocator),
        query = _queryLocator.query,
        els = _queryLocator.els;

    if (options.multipleMatches) {
      var originalEls = els;
      // find all the similar elements

      // We used to findSimilarElements from all of the current elements like this...
      // els = [].concat(...originalEls.map(el => findSimilarElements(el)));
      // ...but that was very slow in some situations so now we just look at the first like this...
      if (els.length) {
        els = els.concat(findSimilarElements(els[0]));
      }

      // there might be duplicate results we need to remove
      // moreover, there might be elements that are ancestors of other elements
      // (we want to keep the descendants)
      els = __WEBPACK_IMPORTED_MODULE_18_lodash_uniqWith___default()(els, function (elA, elB) {
        return elA === elB || elA.contains(elB);
      });
      return { query: query, el: els, score: calculateLocatorScore(matchingLocator) };
    } else {
      return { query: query, el: els[0], score: calculateLocatorScore(matchingLocator) };
    }
  }

  return { el: null, query: "", score: 0 };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/elementLocator.js"))

/***/ }),
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_cloneDeep__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_cloneDeep___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_cloneDeep__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_defaults__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_defaults___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_defaults__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_forEach__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_forEach___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_forEach__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_isEmpty__ = __webpack_require__(301);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_isEmpty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_isEmpty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_isEqual__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_isEqual___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash_isEqual__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_omit__ = __webpack_require__(549);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_omit___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_omit__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_pick__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_pick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash_pick__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_set__ = __webpack_require__(496);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__sharedEmitter__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ObjectStore; });


















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

// We use an external emitter so that the background storage instance
// can listen to the events of the content storage instance, and viceversa
// (since they run in the same context).
var emitter = new __WEBPACK_IMPORTED_MODULE_14_node_event_emitter___default.a();

var ObjectStore = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(ObjectStore, _EventEmitter);

  function ObjectStore(key, permission) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ObjectStore);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ObjectStore.__proto__ || Object.getPrototypeOf(ObjectStore)).call(this));

    _this.key = key;
    _this.permission = permission;

    _this._listenForChanges();
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ObjectStore, [{
    key: '_listenForChanges',
    value: function _listenForChanges() {
      var _this2 = this;

      // Note: the window 'storage' event is not fired on the same page (frame?) that is making the changes
      window.addEventListener('storage', function (e) {
        if (e.key === _this2.key) {
          var changeInfo = {
            oldValue: e.oldValue && JSON.parse(e.oldValue),
            newValue: e.newValue && JSON.parse(e.newValue),
            changeTime: Date.now()
          };
          _this2.emit('change', changeInfo);
        }
      });

      emitter.on('change', function (key) {
        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        if (key === _this2.key) {
          _this2.emit.apply(_this2, ['change'].concat(rest));
        }
      });
    }

    // from https://developer.chrome.com/extensions/storage#type-StorageArea
    // @param keys string or array of string or object
    // A single key to get, list of keys to get, or a dictionary specifying default values (see description of the object).
    // An empty list or object will return an empty result object. Pass in null to get the entire contents of storage.

  }, {
    key: 'get',
    value: function get(keys) {
      var _this3 = this;

      //logger.debug('get', keys);
      return Promise.resolve().then(function () {
        var mainObject = localStorage.getItem(_this3.key);

        if (!mainObject) mainObject = {};else mainObject = JSON.parse(mainObject);

        if (keys === null || typeof keys === 'undefined') return mainObject;
        if (Array.isArray(keys)) return __WEBPACK_IMPORTED_MODULE_12_lodash_pick___default()(mainObject, keys);
        if ((typeof keys === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(keys)) === 'object') {
          var result = __WEBPACK_IMPORTED_MODULE_12_lodash_pick___default()(mainObject, Object.keys(keys));
          return __WEBPACK_IMPORTED_MODULE_6_lodash_defaults___default()(result, keys);
        }
        return mainObject[keys];
      });
    }

    // Note: fn should return the value immediately, promises aren't allowed
    // (the change must be atomic to prevent concurrency issues)!

  }, {
    key: 'setByFunction',
    value: function setByFunction(fn) {
      var _this4 = this;

      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      return Promise.resolve().then(function () {
        var mainObject = localStorage.getItem(_this4.key);

        var oldValue = void 0;
        if (!mainObject) {
          mainObject = {};
          oldValue = null;
        } else {
          mainObject = JSON.parse(mainObject);
          oldValue = __WEBPACK_IMPORTED_MODULE_5_lodash_cloneDeep___default()(mainObject); // deep cloned since mainObject could be mutated during fn call
        }

        mainObject = fn(mainObject);

        if (!__WEBPACK_IMPORTED_MODULE_10_lodash_isEqual___default()(mainObject, oldValue)) {
          // prevent un-needed change
          localStorage.setItem(_this4.key, JSON.stringify(mainObject));

          // make sure the event is also emitted on the same frame
          var changeInfo = { oldValue: oldValue, newValue: mainObject, changeTime: Date.now() };
          emitter.emit('change', _this4.key, changeInfo);
          // also route the change to the sharedEmitter,
          // since it won't be able to get it from the window 'storage' event
          __WEBPACK_IMPORTED_MODULE_15__sharedEmitter__["a" /* default */].emit('change', _this4.key, changeInfo);
        }
      });
    }

    // // from https://developer.chrome.com/extensions/storage#type-StorageArea
    // @param items
    // An object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected.
    // Primitive values such as numbers will serialize as expected. Values with a typeof "object" and "function"
    // will typically serialize to {}, with the exception of Array (serializes as expected),
    // Date, and Regex (serialize using their String representation).

  }, {
    key: 'set',
    value: function set(items) {
      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      logger.debug('set', items);
      return this.setByFunction(function (mainObject) {
        return Object.assign({}, mainObject, items);
      });
    }
  }, {
    key: 'setByPath',
    value: function setByPath(items) {
      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      if (!items || __WEBPACK_IMPORTED_MODULE_9_lodash_isEmpty___default()(items)) return Promise.resolve();
      logger.debug('setByPath', items);
      return this.setByFunction(function (mainObject) {
        __WEBPACK_IMPORTED_MODULE_7_lodash_forEach___default()(items, function (value, path) {
          var calculatedValue = void 0;
          if (typeof value === 'function') {
            calculatedValue = value(__WEBPACK_IMPORTED_MODULE_8_lodash_get___default()(mainObject, path));
          } else {
            calculatedValue = value;
          }

          mainObject = __WEBPACK_IMPORTED_MODULE_13_lodash_set___default()(mainObject, path, calculatedValue);
        });
        return mainObject;
      });
    }
  }, {
    key: 'extendByPath',
    value: function extendByPath(path, value) {
      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      logger.debug('extendByPath', path, value);
      return this.setByFunction(function (mainObject) {
        var calculatedValue = void 0;
        if (typeof value === 'function') {
          calculatedValue = value(__WEBPACK_IMPORTED_MODULE_8_lodash_get___default()(mainObject, path));
        } else {
          calculatedValue = value;
        }

        // don't create empty path if no value is returned
        if (typeof calculatedValue === 'undefined') return mainObject;

        return __WEBPACK_IMPORTED_MODULE_13_lodash_set___default()(mainObject, path, Object.assign({}, __WEBPACK_IMPORTED_MODULE_8_lodash_get___default()(mainObject, path, {}), calculatedValue));
      });
    }
  }, {
    key: 'clear',
    value: function clear() {
      var _this5 = this;

      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      logger.debug('clear');
      return Promise.resolve().then(function () {
        var mainObject = localStorage.getItem(_this5.key);
        if (!mainObject) mainObject = {};else mainObject = JSON.parse(mainObject);

        localStorage.removeItem(_this5.key);

        // make sure the event is also emitted on the same frame
        var changeInfo = { oldValue: mainObject, newValue: null, changeTime: Date.now() };
        emitter.emit('change', _this5.key, changeInfo);
        // also route the change to the sharedEmitter,
        // since it won't be able to get it from the window 'storage' event
        __WEBPACK_IMPORTED_MODULE_15__sharedEmitter__["a" /* default */].emit('change', _this5.key, changeInfo);
      });
    }
  }, {
    key: 'getByPath',
    value: function getByPath(path) {
      var _this6 = this;

      //logger.debug('getByPath', path);
      return Promise.resolve().then(function () {
        var mainObject = localStorage.getItem(_this6.key);

        if (!mainObject) mainObject = {};else mainObject = JSON.parse(mainObject);

        return __WEBPACK_IMPORTED_MODULE_8_lodash_get___default()(mainObject, path);
      });
    }
  }, {
    key: 'removeByPath',
    value: function removeByPath(path) {
      if (this.permission !== 'readwrite') {
        throw 'Access denied: no readwrite permission';
      }

      if (!path) return Promise.resolve();
      if (!Array.isArray(path)) path = [path];
      if (path.length === 0) return Promise.resolve();
      logger.debug('removeByPath', path);
      return this.setByFunction(function (mainObject) {
        return __WEBPACK_IMPORTED_MODULE_11_lodash_omit___default()(mainObject, path);
      });
    }
  }]);

  return ObjectStore;
}(__WEBPACK_IMPORTED_MODULE_14_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/common/sharedMemory/ObjectStore.js"))

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(118),
    arrayEach = __webpack_require__(153),
    assignValue = __webpack_require__(156),
    baseAssign = __webpack_require__(395),
    baseAssignIn = __webpack_require__(396),
    cloneBuffer = __webpack_require__(292),
    copyArray = __webpack_require__(104),
    copySymbols = __webpack_require__(425),
    copySymbolsIn = __webpack_require__(426),
    getAllKeys = __webpack_require__(250),
    getAllKeysIn = __webpack_require__(178),
    getTag = __webpack_require__(107),
    initCloneArray = __webpack_require__(447),
    initCloneByTag = __webpack_require__(448),
    initCloneObject = __webpack_require__(297),
    isArray = __webpack_require__(8),
    isBuffer = __webpack_require__(88),
    isObject = __webpack_require__(16),
    keys = __webpack_require__(38);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(430);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(234),
    baseIsNaN = __webpack_require__(402),
    strictIndexOf = __webpack_require__(478);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(103),
    isArrayLike = __webpack_require__(29);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),
/* 290 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(43);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(13);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)(module)))

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(161);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var LodashWrapper = __webpack_require__(149),
    flatRest = __webpack_require__(177),
    getData = __webpack_require__(162),
    getFuncName = __webpack_require__(251),
    isArray = __webpack_require__(8),
    isLaziable = __webpack_require__(254);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return flatRest(function(funcs) {
    var length = funcs.length,
        index = length,
        prereq = LodashWrapper.prototype.thru;

    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = getFuncName(func),
          data = funcName == 'wrapper' ? getData(func) : undefined;

      if (data && isLaziable(data[0]) &&
            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && isLaziable(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 && isArray(value)) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this, result);
      }
      return result;
    };
  });
}

module.exports = createFlow;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(79),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(8),
    isIndex = __webpack_require__(80),
    isLength = __webpack_require__(170),
    toKey = __webpack_require__(61);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 296 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(102),
    getPrototype = __webpack_require__(179),
    isPrototype = __webpack_require__(108);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    createAssigner = __webpack_require__(244),
    keysIn = __webpack_require__(89);

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

module.exports = assignIn;


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(286);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEvery = __webpack_require__(721),
    baseEvery = __webpack_require__(722),
    baseIteratee = __webpack_require__(37),
    isArray = __webpack_require__(8),
    isIterateeCall = __webpack_require__(123);

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = every;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(237),
    getTag = __webpack_require__(107),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(8),
    isArrayLike = __webpack_require__(29),
    isBuffer = __webpack_require__(88),
    isPrototype = __webpack_require__(108),
    isTypedArray = __webpack_require__(125);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33),
    baseIteratee = __webpack_require__(37),
    baseMap = __webpack_require__(289),
    isArray = __webpack_require__(8);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(120),
    baseForOwn = __webpack_require__(235),
    baseIteratee = __webpack_require__(37);

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),
/* 304 */,
/* 305 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return sendToExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return listenToPracticeMessage; });




var sendToExtension = function sendToExtension(topic, data) {
  var message = {
    topic: topic, data: data, from: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__namespace__["a" /* default */])('practice'), to: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__namespace__["a" /* default */])('content')
  };
  window.top.postMessage(message, '*');
};

var listenToPracticeMessage = function listenToPracticeMessage(handler) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_windowEvents__["a" /* addWindowListener */])('message', function (event) {
    var message = event.data;
    if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;
    if (message.from !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__namespace__["a" /* default */])('practice') || message.to !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__namespace__["a" /* default */])('content')) return;

    var isTopFrame = window.parent === window;
    if (!isTopFrame) return;

    handler(message);
  });
};

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(388);
__webpack_require__(387);
module.exports = __webpack_require__(96).Symbol;

/***/ }),
/* 307 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Port; });




// Abstract class



var Port = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(Port, _EventEmitter);

  function Port() {
    var _port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var extension = arguments[2];

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Port);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Port.__proto__ || Object.getPrototypeOf(Port)).call(this));

    _this.extension = extension;
    _this._port = _port;
    _this.name = name;
    _this._bindHandlers();
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Port, [{
    key: 'connect',
    value: function connect() {
      this._bindHandlers();
    }
  }, {
    key: '_bindHandlers',
    value: function _bindHandlers() {
      // no-op
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      // no-op
    }
  }, {
    key: '_unbindHandlers',
    value: function _unbindHandlers() {
      // no-op
    }
  }, {
    key: 'send',
    value: function send(message, responseHandler) {
      // no-op

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    }
  }, {
    key: '_onConnected',
    value: function _onConnected() {
      this.emit('connected');
    }
  }, {
    key: '_onDisconnected',
    value: function _onDisconnected(error) {
      this._port = null;
      this.emit('disconnected', error);
    }
  }, {
    key: '_waitExtensionReady',
    value: function _waitExtensionReady() {
      var _this2 = this;

      if (this._waitExtensionReadyPromise) return this._waitExtensionReadyPromise;
      return this._waitExtensionReadyPromise = new Promise(function (resolve) {
        if (_this2.extension.isReady) resolve();else _this2.extension.once('ready', resolve);
      });
    }
  }, {
    key: '_onMessageReceived',
    value: function _onMessageReceived(message, respond) {
      var _this3 = this;

      // don't emit the event before the extension
      // is fully created and initialized
      // (so that the message can be handled)
      this._waitExtensionReady().then(function () {
        _this3.emit('message', message, respond);
      });
    }
  }], [{
    key: 'listen',
    value: function listen(callback) {
      // no-op
    }
  }]);

  return Port;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);



/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "test.iorad.com";

/***/ }),
/* 309 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);

// const development = 'http://localhost:3100';
var development = 'https://test.iorad.com';
var testIoradCom = 'https://test.iorad.com';
var production = 'https://www.iorad.com';

var nodeApi = 'http://dev.iorad.dev/api';
// const nodeApi = 'https://local.iorad.com:8443/api';
var nodeAppPrefix = 'http://dev.iorad.dev';

var relativePath = function relativePath(path) {
  var propName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'url';
  return {
    development: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, development + '/api' + path),
    vagrant: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, nodeApi + path),
    'test.iorad.com': __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, testIoradCom + '/api' + path),
    production: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, production + '/api' + path)
  };
};
var relativePage = function relativePage(path) {
  var propName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'url';
  return {
    development: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, development + path),
    vagrant: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, nodeAppPrefix + path),
    'test.iorad.com': __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, testIoradCom + path),
    production: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, propName, production + path)
  };
};

/* harmony default export */ __webpack_exports__["a"] = {
  // keep sure to specify below all the possible envs!
  envs: ['development', 'vagrant', 'test.iorad.com', 'production'],

  values: {

    'debug': {
      development: {
        isDisabled: false
      },
      vagrant: {
        isDisabled: false
      },
      'test.iorad.com': {
        isDisabled: false
      },
      production: {
        isDisabled: true
      }
    },

    'defaultColors': {
      '*': {
        main: '#1d1f23',
        navBar: '#1d1f23',
        actionButton: '#0090e2',
        highlight: '#0090e2'
      }
    },

    'extension': {
      'chrome': {
        'ids': {
          'kjfmedbganalpkohkeghhpppicoigdal': {
            'build': 'standard'
          },
          'fheghmognccmbkljflobhkcfkiajllip': {
            build: 'ci'
          }
        }
      },
      // WARNING: basePath setting is ignored if it can get the base url from the script tag
      'embed': {
        'development': {
          basePath: 'chrome-extension://neacfafhadfodpoaggeahjgghjofmelp'
        },
        'vagrant': {
          'basePath': '/dist/embed'
        },
        'test.iorad.com': {
          'basePath': 'https://test.iorad.com/server/assets/embed'
        },
        'production': {
          'basePath': 'https://www.iorad.com/server/assets/embed'
        }
      }
    },

    pages: {
      createNewBrowserTutorialUrl: {
        development: {
          url: 'http://local.iorad.com:9000/editor.html?module=DEV&uid=DEV#capture/launch/browser'
        },
        vagrant: {
          url: nodeAppPrefix + '/createNewBrowserTutorial/?referrer=extension'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/createNewBrowserTutorial/?referrer=extension'
        },
        production: {
          url: 'https://www.iorad.com/createNewBrowserTutorial/?referrer=extension'
        }
      },

      createNewDesktopTutorialUrl: {
        development: {
          url: 'http://local.iorad.com:9000/editor.html?module=DEV&uid=DEV#capture/launch/app'
        },
        vagrant: {
          url: nodeAppPrefix + '/createNewDesktopTutorial/?referrer=extension'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/createNewDesktopTutorial/?referrer=extension'
        },
        production: {
          url: 'https://www.iorad.com/createNewDesktopTutorial/?referrer=extension'
        }
      },

      'mytutorials': {
        'production': {
          'url': 'http://www.iorad.com/tutorials'
        },
        vagrant: {
          'url': nodeAppPrefix + '/tutorials'
        },
        '*': {
          'url': 'https://test.iorad.com/tutorials'
        }
      },

      'myaccount': {
        'production': {
          'url': 'http://www.iorad.com/account'
        },
        vagrant: {
          'url': nodeAppPrefix + '/account'
        },
        '*': {
          'url': 'https://test.iorad.com/account'
        }
      },
      tutorialPlayer: {
        development: {
          url: 'http://local.iorad.com:9000/%authorID%/%tutorialID%/%title%'
        },
        vagrant: {
          url: nodeAppPrefix + '/player/%tutorialID%/%title%'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/player/%tutorialID%/%title%'
        },
        production: {
          url: 'https://www.iorad.com/player/%tutorialID%/%title%'
        }
      },
      help: {
        '*': {
          url: 'http://help.iorad.com/'
        }
      },
      terms: {
        development: {
          url: 'http://local.iorad.com:9000/terms'
        },
        vagrant: {
          url: nodeAppPrefix + '/terms'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/terms'
        },
        production: {
          url: 'https://www.iorad.com/terms'
        }
      },
      pricing: relativePage('/pricing'),

      extensionInstalled: {
        '*': {
          url: 'https://start.iorad.com/installed'
        }
      }
    },

    'capture': {
      'desktop': {
        'production': {
          'location': {
            'vanilla': {
              'windows': 'https://www.iorad.com/server/webstart/iorad-capture.exe',
              'mac': 'https://www.iorad.com/server/webstart/iorad-capture.pkg'
            },
            'bundled': {
              'windows': 'https://www.iorad.com/server/webstart/iorad-capture-JVM.exe',
              'mac': 'https://www.iorad.com/server/webstart/iorad-capture-JVM.pkg'
            }
          }
        },
        '*': {
          'location': {
            'vanilla': {
              'windows': 'https://test.iorad.com/server/webstart/iorad-capture.exe',
              'mac': 'https://test.iorad.com/server/webstart/iorad-capture.pkg'
            },
            'bundled': {
              'windows': 'https://test.iorad.com/server/webstart/iorad-capture-JVM.exe',
              'mac': 'https://test.iorad.com/server/webstart/iorad-capture-JVM.pkg'
            }
          }
        }
      }
    },

    server: {
      searchTutorials: relativePath('/tutorial/search?urls=%urls%&sk=%text%&st=tag,name,desc&onlyLive=%onlyLive%&liveEmbedForUser=%liveEmbedFor%'),
      tutorialLiveList: relativePath('/tutorial/liveList?urls=%urls%&searchKey=%searchKey%&embed=%embed%&mobileMode=%mobileMode%'),
      getTutorial: relativePath('/tutorial/get?tutorial_id=%tutorial_id%'),
      getNotifications: relativePath('/notification/findAll'),
      tutorialSaveStatistics: relativePath('/tutorial/saveStatistics'),

      signup: relativePath('/signup'),
      googleAuth: relativePath('/googleAuth'),
      login: relativePath('/login'),
      samlLoginURL: relativePath('/settings/samlLoginURL'),
      resetPassword: relativePath('/resetPassword'),
      resendActivation: relativePath('/resendActivation'),
      logout: relativePath('/logout'),
      loadAuth: relativePath('/loadAuth'),
      me: relativePath('/me?accountInfo=%accountInfo%'),

      imageRemotePath: {
        development: {
          url: 'https://test.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%image_id%.png?nocache=%nocache%'
        },
        vagrant: {
          url: nodeAppPrefix + '/capture/tutorials/%user_id%/%tutorial_id%/%image_id%.png?nocache=%nocache%'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%image_id%.png?nocache=%nocache%'
        },
        production: {
          url: 'https://s3.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%image_id%.png?nocache=%nocache%'
        }
      },

      audioRemotePath: {
        development: {
          url: 'https://test.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%audio_id%.%audio_ext%?cache=%cache%'
        },
        vagrant: {
          url: nodeAppPrefix + '/capture/tutorials/%user_id%/%tutorial_id%/%audio_id%.%audio_ext%?cache=%cache%'
        },
        'test.iorad.com': {
          url: 'https://test.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%audio_id%.%audio_ext%?cache=%cache%'
        },
        production: {
          url: 'https://s3.iorad.com/capture/tutorials/%user_id%/%tutorial_id%/%audio_id%.%audio_ext%?cache=%cache%'
        }
      },

      avatar: relativePath('/user/avatar?userid=%user_id%')
    }
  }
};

/***/ }),
/* 310 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharedMemory; });



// This is just a stub, we actually only need SharedMemory in embed
var SharedMemory = function () {
  function SharedMemory() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, SharedMemory);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(SharedMemory, [{
    key: "start",
    value: function start(extension) {
      this.extension = extension;
    }
  }]);

  return SharedMemory;
}();



/***/ }),
/* 311 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getDocumentHeight;
/* unused harmony export getDocumentWidth */
// Use this function instead of solely relying on document.body.scrollHeight,
// since it doesn't work in Firefox
// http://stackoverflow.com/a/15935454/1418049, #440
function getDocumentHeight() {
  var D = document;
  return Math.max(Math.max(D.body ? D.body.scrollHeight : 0, D.documentElement ? D.documentElement.scrollHeight : 0), Math.max(D.body ? D.body.offsetHeight : 0, D.documentElement ? D.documentElement.offsetHeight : 0), Math.max(D.body ? D.body.clientHeight : 0, D.documentElement ? D.documentElement.clientHeight : 0));
}

function getDocumentWidth() {
  var D = document;
  return Math.max(Math.max(D.body ? D.body.scrollWidth : 0, D.documentElement ? D.documentElement.scrollWidth : 0), Math.max(D.body ? D.body.offsetWidth : 0, D.documentElement ? D.documentElement.offsetWidth : 0), Math.max(D.body ? D.body.clientWidth : 0, D.documentElement ? D.documentElement.clientWidth : 0));
}

/***/ }),
/* 312 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// expand marker size without exceeding limits
/* harmony default export */ __webpack_exports__["a"] = function (amount, maxWidth, maxHeight, markerBounds) {
  var x = Math.max(0, markerBounds.x - amount);
  var y = Math.max(0, markerBounds.y - amount);

  var width = Math.min(maxWidth, markerBounds.x - x + markerBounds.width + amount);
  var height = Math.min(maxHeight, markerBounds.y - y + markerBounds.height + amount);
  return { x: x, y: y, width: width, height: height };
};

/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = fuzzyMatchUrl;
// Return true if the two urls are probably roughly the same page. We ignore
// subdomains, numeric segments of the path. See #618
function fuzzyMatchUrl(urla, urlb) {
  var normalize = function normalize(url) {
    var parsed = new URL(url);
    parsed.hostname = parsed.hostname.split('.').slice(-2).join('.');
    parsed.pathname = parsed.pathname.replace(/\/\d+($|\/)/g, '/{NUMBER}$1');
    parsed.search = parsed.search.replace(/=\d+($|&)/g, '={NUMBER}$1');
    return parsed.href;
  };

  return normalize(urla) === normalize(urlb);
}

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_pick__);


/* harmony default export */ __webpack_exports__["a"] = function (el) {
  return __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default()(el.getBoundingClientRect(), ['top', 'left', 'right', 'bottom', 'width', 'height']); // make it enumerable
};

/***/ }),
/* 315 */,
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getParentPopup;
function getParentPopup(el) {
  var parentEl = el.parentNode;
  while (parentEl && parentEl.classList && parentEl !== document.body) {
    var styles = window.getComputedStyle(parentEl);
    var bounds = parentEl.getBoundingClientRect();

    var isDropdown = styles.position === 'absolute' && bounds.width <= 400 && bounds.height <= 400 && bounds.width >= 100 && bounds.height >= 100;
    if (isDropdown) {
      return parentEl;
    }

    parentEl = parentEl.parentNode;
  }
  return null;
}

/***/ }),
/* 317 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isStepLoggedIn;
/* unused harmony export getStepLoggedInType */
// Note: returns undefined if the step doesn't have this info
function isStepLoggedIn(step) {
  if (step.window && typeof step.window.loggedIn !== 'undefined') {
    return step.window.loggedIn;
  }
  // legacy tutorials
  return step.event && step.event.loggedIn;
}

function getStepLoggedInType(step) {
  return step.window.loggedInType;
}

/***/ }),
/* 318 */,
/* 319 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = replaceAll;
// based on http://stackoverflow.com/a/1145525
// A replace all function without using regex (that have to be escaped)
function replaceAll(target, search) {
  var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  return target.split(search).join(replacement);
}

/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = tutorialMatchUrl;
// return true if currentUrl matches the base domain of at least one step
function tutorialMatchUrl(tutorialData, currentUrl) {
  if (!tutorialData || !tutorialData.steps || !currentUrl) return false;
  var pageBaseDomain = new URL(currentUrl).hostname.split('.').slice(-2).join('.');
  var stepBaseDomains = tutorialData.steps.map(function (s) {
    return new URL(s.window.url).hostname.split('.').slice(-2).join('.');
  });
  return stepBaseDomains.indexOf(pageBaseDomain) !== -1;
}

/***/ }),
/* 321 */,
/* 322 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_waitFor__ = __webpack_require__(185);
/* harmony export (immutable) */ __webpack_exports__["a"] = waitForInit;


function waitForInit(callback, time) {
  if (window !== window.top && document.location.href === 'about:blank') {
    // Note: without waitFor the window/document listeners won't be called in iframes created with document.write
    // (e.g. iorad editor, see #395)
    // TODO: understand why it happens
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_waitFor__["a" /* default */])(function () {
      return !!document.head;
    }, callback, time);
  } else {
    callback();
  }
}

/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getWindowScrollOffset;
// Function to get the offset to adjust positions to go from portal-relative to
// page-content relative in the current page/frame

function parseNumber(n) {
  var value = parseInt(n, 10);
  if (isNaN(value)) return 0;
  return value;
}

function sumCSSProperties(properties, computedStyle) {
  return properties.reduce(function (count, prop) {
    return count + parseNumber(computedStyle[prop]);
  }, 0);
}

function getWindowScrollOffset() {
  var top = window.pageYOffset;
  var left = window.pageXOffset;
  var bodyComputedStyle = window.getComputedStyle(document.body);
  if (bodyComputedStyle.position === 'relative') {
    top -= sumCSSProperties(['top', 'marginTop', 'borderTopWidth'], bodyComputedStyle);
    left -= sumCSSProperties(['left', 'marginLeft', 'borderLeftWidth'], bodyComputedStyle);
  }
  return { x: left, y: top };
}

/***/ }),
/* 324 */,
/* 325 */,
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(335), __esModule: true };

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(336), __esModule: true };

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(337), __esModule: true };

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(338), __esModule: true };

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(339), __esModule: true };

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(340), __esModule: true };

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(341), __esModule: true };

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(342), __esModule: true };

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(343), __esModule: true };

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(53);
__webpack_require__(355);
module.exports = __webpack_require__(7).Array.from;


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(75);
__webpack_require__(53);
module.exports = __webpack_require__(353);


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(75);
__webpack_require__(53);
module.exports = __webpack_require__(354);


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(356);
module.exports = __webpack_require__(7).Object.assign;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(357);
var $Object = __webpack_require__(7).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(358);
var $Object = __webpack_require__(7).Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(359);
module.exports = __webpack_require__(7).Object.getPrototypeOf;


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(360);
module.exports = __webpack_require__(7).Object.setPrototypeOf;


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(139);
__webpack_require__(53);
__webpack_require__(75);
__webpack_require__(361);
__webpack_require__(362);
__webpack_require__(363);
module.exports = __webpack_require__(7).Promise;


/***/ }),
/* 344 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(15);
var createDesc = __webpack_require__(36);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(40);
var call = __webpack_require__(198);
var isArrayIter = __webpack_require__(196);
var anObject = __webpack_require__(17);
var toLength = __webpack_require__(94);
var getIterFn = __webpack_require__(138);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 347 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(10);
var macrotask = __webpack_require__(210).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(44)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(50);
var gOPS = __webpack_require__(85);
var pIE = __webpack_require__(51);
var toObject = __webpack_require__(71);
var IObject = __webpack_require__(135);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(28)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(25);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(27);
var anObject = __webpack_require__(17);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(40)(Function.call, __webpack_require__(93).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(10);
var core = __webpack_require__(7);
var dP = __webpack_require__(15);
var DESCRIPTORS = __webpack_require__(19);
var SPECIES = __webpack_require__(11)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(17);
var get = __webpack_require__(138);
module.exports = __webpack_require__(7).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(133);
var ITERATOR = __webpack_require__(11)('iterator');
var Iterators = __webpack_require__(31);
module.exports = __webpack_require__(7).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(40);
var $export = __webpack_require__(14);
var toObject = __webpack_require__(71);
var call = __webpack_require__(198);
var isArrayIter = __webpack_require__(196);
var toLength = __webpack_require__(94);
var createProperty = __webpack_require__(345);
var getIterFn = __webpack_require__(138);

$export($export.S + $export.F * !__webpack_require__(200)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(14);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(349) });


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(14);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(84) });


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(26);
var $getOwnPropertyDescriptor = __webpack_require__(93).f;

__webpack_require__(205)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(71);
var $getPrototypeOf = __webpack_require__(137);

__webpack_require__(205)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(14);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(351).set });


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(49);
var global = __webpack_require__(10);
var ctx = __webpack_require__(40);
var classof = __webpack_require__(133);
var $export = __webpack_require__(14);
var isObject = __webpack_require__(27);
var aFunction = __webpack_require__(65);
var anInstance = __webpack_require__(344);
var forOf = __webpack_require__(346);
var speciesConstructor = __webpack_require__(208);
var task = __webpack_require__(210).set;
var microtask = __webpack_require__(348)();
var newPromiseCapabilityModule = __webpack_require__(136);
var perform = __webpack_require__(206);
var promiseResolve = __webpack_require__(207);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(11)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(350)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(52)($Promise, PROMISE);
__webpack_require__(352)(PROMISE);
Wrapper = __webpack_require__(7)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(200)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(14);
var core = __webpack_require__(7);
var global = __webpack_require__(10);
var speciesConstructor = __webpack_require__(208);
var promiseResolve = __webpack_require__(207);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(14);
var newPromiseCapability = __webpack_require__(136);
var perform = __webpack_require__(206);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(365);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),
/* 365 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),
/* 366 */,
/* 367 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(57)
  , toLength  = __webpack_require__(385)
  , toIndex   = __webpack_require__(384);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(140)
  , TAG = __webpack_require__(77)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(367);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 371 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(99)
  , gOPS    = __webpack_require__(221)
  , pIE     = __webpack_require__(143);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(32)
  , core      = __webpack_require__(96)
  , hide      = __webpack_require__(142)
  , redefine  = __webpack_require__(145)
  , ctx       = __webpack_require__(370)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(32).document && document.documentElement;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(140);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(140);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(99)
  , toIObject = __webpack_require__(57);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(76)('meta')
  , isObject = __webpack_require__(98)
  , has      = __webpack_require__(55)
  , setDesc  = __webpack_require__(56).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(97)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(95)
  , dPs         = __webpack_require__(380)
  , enumBugKeys = __webpack_require__(141)
  , IE_PROTO    = __webpack_require__(223)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(217)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(374).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(56)
  , anObject = __webpack_require__(95)
  , getKeys  = __webpack_require__(99);

module.exports = __webpack_require__(54) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(143)
  , createDesc     = __webpack_require__(144)
  , toIObject      = __webpack_require__(57)
  , toPrimitive    = __webpack_require__(147)
  , has            = __webpack_require__(55)
  , IE8_DOM_DEFINE = __webpack_require__(218)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(54) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(57)
  , gOPN      = __webpack_require__(220).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(56).f
  , has = __webpack_require__(55)
  , TAG = __webpack_require__(77)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(224)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(224)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(32)
  , core           = __webpack_require__(96)
  , LIBRARY        = __webpack_require__(219)
  , wksExt         = __webpack_require__(225)
  , defineProperty = __webpack_require__(56).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(369)
  , test    = {};
test[__webpack_require__(77)('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  __webpack_require__(145)(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(32)
  , has            = __webpack_require__(55)
  , DESCRIPTORS    = __webpack_require__(54)
  , $export        = __webpack_require__(373)
  , redefine       = __webpack_require__(145)
  , META           = __webpack_require__(378).KEY
  , $fails         = __webpack_require__(97)
  , shared         = __webpack_require__(146)
  , setToStringTag = __webpack_require__(383)
  , uid            = __webpack_require__(76)
  , wks            = __webpack_require__(77)
  , wksExt         = __webpack_require__(225)
  , wksDefine      = __webpack_require__(386)
  , keyOf          = __webpack_require__(377)
  , enumKeys       = __webpack_require__(372)
  , isArray        = __webpack_require__(376)
  , anObject       = __webpack_require__(95)
  , toIObject      = __webpack_require__(57)
  , toPrimitive    = __webpack_require__(147)
  , createDesc     = __webpack_require__(144)
  , _create        = __webpack_require__(379)
  , gOPNExt        = __webpack_require__(382)
  , $GOPD          = __webpack_require__(381)
  , $DP            = __webpack_require__(56)
  , $keys          = __webpack_require__(99)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(220).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(143).f  = $propertyIsEnumerable;
  __webpack_require__(221).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(219)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(142)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(442),
    hashDelete = __webpack_require__(443),
    hashGet = __webpack_require__(444),
    hashHas = __webpack_require__(445),
    hashSet = __webpack_require__(446);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(41),
    root = __webpack_require__(13);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 392 */
/***/ (function(module, exports) {

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;


/***/ }),
/* 393 */
/***/ (function(module, exports) {

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;


/***/ }),
/* 394 */
/***/ (function(module, exports) {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    keys = __webpack_require__(38);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    keysIn = __webpack_require__(89);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arrayIncludes = __webpack_require__(154),
    arrayIncludesWith = __webpack_require__(230),
    arrayMap = __webpack_require__(33),
    baseUnary = __webpack_require__(122),
    cacheHas = __webpack_require__(160);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;


/***/ }),
/* 398 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(34);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(118),
    equalArrays = __webpack_require__(248),
    equalByTag = __webpack_require__(436),
    equalObjects = __webpack_require__(437),
    getTag = __webpack_require__(107),
    isArray = __webpack_require__(8),
    isBuffer = __webpack_require__(88),
    isTypedArray = __webpack_require__(125);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(118),
    baseIsEqual = __webpack_require__(158);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 402 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(181),
    isMasked = __webpack_require__(452),
    isObject = __webpack_require__(16),
    toSource = __webpack_require__(263);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isLength = __webpack_require__(170),
    isObjectLike = __webpack_require__(34);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(16),
    isPrototype = __webpack_require__(108),
    nativeKeysIn = __webpack_require__(466);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(401),
    getMatchData = __webpack_require__(438),
    matchesStrictComparable = __webpack_require__(256);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(158),
    get = __webpack_require__(42),
    hasIn = __webpack_require__(267),
    isKey = __webpack_require__(164),
    isStrictComparable = __webpack_require__(255),
    matchesStrictComparable = __webpack_require__(256),
    toKey = __webpack_require__(61);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33),
    baseIteratee = __webpack_require__(37),
    baseMap = __webpack_require__(289),
    baseSortBy = __webpack_require__(414),
    baseUnary = __webpack_require__(122),
    compareMultiple = __webpack_require__(424),
    identity = __webpack_require__(43);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(238),
    hasIn = __webpack_require__(267);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(121);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(484),
    defineProperty = __webpack_require__(247),
    identity = __webpack_require__(43);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 412 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(103);

/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  baseEach(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;


/***/ }),
/* 414 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46),
    arrayMap = __webpack_require__(33),
    isArray = __webpack_require__(8),
    isSymbol = __webpack_require__(63);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arrayIncludes = __webpack_require__(154),
    arrayIncludesWith = __webpack_require__(230),
    cacheHas = __webpack_require__(160),
    createSet = __webpack_require__(737),
    setToArray = __webpack_require__(124);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(161);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

var addMapEntry = __webpack_require__(392),
    arrayReduce = __webpack_require__(232),
    mapToArray = __webpack_require__(165);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;


/***/ }),
/* 420 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

var addSetEntry = __webpack_require__(393),
    arrayReduce = __webpack_require__(232),
    setToArray = __webpack_require__(124);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(63);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

var compareAscending = __webpack_require__(423);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    getSymbols = __webpack_require__(163);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    getSymbolsIn = __webpack_require__(253);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 428 */
/***/ (function(module, exports) {

/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}

module.exports = countHolders;


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(29);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),
/* 430 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

var createCtor = __webpack_require__(105),
    root = __webpack_require__(13);

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

module.exports = createBind;


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(119),
    createCtor = __webpack_require__(105),
    createHybrid = __webpack_require__(245),
    createRecurry = __webpack_require__(246),
    getHolder = __webpack_require__(252),
    replaceHolders = __webpack_require__(166),
    root = __webpack_require__(13);

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

module.exports = createCurry;


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__(37),
    isArrayLike = __webpack_require__(29),
    keys = __webpack_require__(38);

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(119),
    createCtor = __webpack_require__(105),
    root = __webpack_require__(13);

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = createCtor(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartial;


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetData = __webpack_require__(240),
    createBind = __webpack_require__(431),
    createCurry = __webpack_require__(432),
    createHybrid = __webpack_require__(245),
    createPartial = __webpack_require__(434),
    getData = __webpack_require__(162),
    mergeData = __webpack_require__(464),
    setData = __webpack_require__(260),
    setWrapToString = __webpack_require__(261),
    toInteger = __webpack_require__(128);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}

module.exports = createWrap;


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46),
    Uint8Array = __webpack_require__(227),
    eq = __webpack_require__(81),
    equalArrays = __webpack_require__(248),
    mapToArray = __webpack_require__(165),
    setToArray = __webpack_require__(124);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(250);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(255),
    keys = __webpack_require__(38);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 440 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 441 */
/***/ (function(module, exports) {

/** Used to match wrap detail comments. */
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

module.exports = getWrapDetails;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(109);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 443 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(109);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(109);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(109);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 447 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(161),
    cloneDataView = __webpack_require__(418),
    cloneMap = __webpack_require__(419),
    cloneRegExp = __webpack_require__(420),
    cloneSet = __webpack_require__(421),
    cloneSymbol = __webpack_require__(422),
    cloneTypedArray = __webpack_require__(293);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 449 */
/***/ (function(module, exports) {

/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

module.exports = insertWrapDetails;


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(8);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 451 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(427);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 453 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(101);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(101);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(101);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(101);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(390),
    ListCache = __webpack_require__(100),
    Map = __webpack_require__(150);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(106);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(106);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(106);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(106);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(268);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

var composeArgs = __webpack_require__(242),
    composeArgsRight = __webpack_require__(243),
    replaceHolders = __webpack_require__(166);

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

  var isCombo =
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & WRAP_BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;


/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(258);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 466 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(249);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)(module)))

/***/ }),
/* 468 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 469 */
/***/ (function(module, exports) {

/** Used to lookup unminified function names. */
var realNames = {};

module.exports = realNames;


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

var copyArray = __webpack_require__(104),
    isIndex = __webpack_require__(80);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;


/***/ }),
/* 471 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 472 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(100);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 474 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 475 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 476 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(100),
    Map = __webpack_require__(150),
    MapCache = __webpack_require__(151);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 478 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

var asciiToArray = __webpack_require__(394),
    hasUnicode = __webpack_require__(296),
    unicodeToArray = __webpack_require__(481);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(463);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 481 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(153),
    arrayIncludes = __webpack_require__(154);

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256,
    WRAP_FLIP_FLAG = 512;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', WRAP_ARY_FLAG],
  ['bind', WRAP_BIND_FLAG],
  ['bindKey', WRAP_BIND_KEY_FLAG],
  ['curry', WRAP_CURRY_FLAG],
  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
  ['flip', WRAP_FLIP_FLAG],
  ['partial', WRAP_PARTIAL_FLAG],
  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
  ['rearg', WRAP_REARG_FLAG]
];

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  arrayEach(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

module.exports = updateWrapDetails;


/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(148),
    LodashWrapper = __webpack_require__(149),
    copyArray = __webpack_require__(104);

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

module.exports = wrapperClone;


/***/ }),
/* 484 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(119),
    assignInWith = __webpack_require__(744),
    baseRest = __webpack_require__(78),
    customDefaultsAssignIn = __webpack_require__(739);

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(args) {
  args.push(undefined, customDefaultsAssignIn);
  return apply(assignInWith, undefined, args);
});

module.exports = defaults;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(266);


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(298);


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(229),
    baseFilter = __webpack_require__(724),
    baseIteratee = __webpack_require__(37),
    isArray = __webpack_require__(8);

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(234),
    baseIteratee = __webpack_require__(37),
    toInteger = __webpack_require__(128);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(726),
    hasPath = __webpack_require__(295);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33),
    baseIntersection = __webpack_require__(727),
    baseRest = __webpack_require__(78),
    castArrayLikeObject = __webpack_require__(734);

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;


/***/ }),
/* 492 */
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(13);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33),
    baseIteratee = __webpack_require__(37),
    basePickBy = __webpack_require__(238),
    getAllKeysIn = __webpack_require__(178);

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(290),
    basePropertyDeep = __webpack_require__(410),
    isKey = __webpack_require__(164),
    toKey = __webpack_require__(61);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

var baseSet = __webpack_require__(239);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

var arraySome = __webpack_require__(233),
    baseIteratee = __webpack_require__(37),
    baseSome = __webpack_require__(413),
    isArray = __webpack_require__(8),
    isIterateeCall = __webpack_require__(123);

/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = isArray(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = some;


/***/ }),
/* 498 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(270);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

var LazyWrapper = __webpack_require__(148),
    LodashWrapper = __webpack_require__(149),
    baseLodash = __webpack_require__(159),
    isArray = __webpack_require__(8),
    isObjectLike = __webpack_require__(34),
    wrapperClone = __webpack_require__(483);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

module.exports = lodash;


/***/ }),
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */
/***/ (function(module, exports) {

var COMPLETE = 'complete',
    CANCELED = 'canceled';

function raf(task){
    if('requestAnimationFrame' in window){
        return window.requestAnimationFrame(task);
    }

    setTimeout(task, 16);
}

function setElementScroll(element, x, y){
    if(element.self === element){
        element.scrollTo(x, y);
    }else{
        element.scrollLeft = x;
        element.scrollTop = y;
    }
}

function getTargetScrollLocation(target, parent, align){
    var targetPosition = target.getBoundingClientRect(),
        parentPosition,
        x,
        y,
        differenceX,
        differenceY,
        targetWidth,
        targetHeight,
        leftAlign = align && align.left != null ? align.left : 0.5,
        topAlign = align && align.top != null ? align.top : 0.5,
        leftOffset = align && align.leftOffset != null ? align.leftOffset : 0,
        topOffset = align && align.topOffset != null ? align.topOffset : 0,
        leftScalar = leftAlign,
        topScalar = topAlign;

    if(parent.self === parent){
        targetWidth = Math.min(targetPosition.width, parent.innerWidth);
        targetHeight = Math.min(targetPosition.height, parent.innerHeight);
        x = targetPosition.left + parent.pageXOffset - parent.innerWidth * leftScalar + targetWidth * leftScalar;
        y = targetPosition.top + parent.pageYOffset - parent.innerHeight * topScalar + targetHeight * topScalar;
        x -= leftOffset;
        y -= topOffset;
        differenceX = x - parent.pageXOffset;
        differenceY = y - parent.pageYOffset;
    }else{
        targetWidth = targetPosition.width;
        targetHeight = targetPosition.height;
        parentPosition = parent.getBoundingClientRect();
        var offsetLeft = targetPosition.left - (parentPosition.left - parent.scrollLeft);
        var offsetTop = targetPosition.top - (parentPosition.top - parent.scrollTop);
        x = offsetLeft + (targetWidth * leftScalar) - parent.clientWidth * leftScalar;
        y = offsetTop + (targetHeight * topScalar) - parent.clientHeight * topScalar;
        x = Math.max(Math.min(x, parent.scrollWidth - parent.clientWidth), 0);
        y = Math.max(Math.min(y, parent.scrollHeight - parent.clientHeight), 0);
        x -= leftOffset;
        y -= topOffset;
        differenceX = x - parent.scrollLeft;
        differenceY = y - parent.scrollTop;
    }

    return {
        x: x,
        y: y,
        differenceX: differenceX,
        differenceY: differenceY
    };
}

function animate(parent){
    raf(function(){
        var scrollSettings = parent._scrollSettings;
        if(!scrollSettings){
            return;
        }

        var location = getTargetScrollLocation(scrollSettings.target, parent, scrollSettings.align),
            time = Date.now() - scrollSettings.startTime,
            timeValue = Math.min(1 / scrollSettings.time * time, 1);

        if(
            time > scrollSettings.time + 20
        ){
            setElementScroll(parent, location.x, location.y);
            parent._scrollSettings = null;
            return scrollSettings.end(COMPLETE);
        }

        var easeValue = 1 - scrollSettings.ease(timeValue);

        setElementScroll(parent,
            location.x - location.differenceX * easeValue,
            location.y - location.differenceY * easeValue
        );

        animate(parent);
    });
}
function transitionScrollTo(target, parent, settings, callback){
    var idle = !parent._scrollSettings,
        lastSettings = parent._scrollSettings,
        now = Date.now(),
        endHandler;

    if(lastSettings){
        lastSettings.end(CANCELED);
    }

    function end(endType){
        parent._scrollSettings = null;
        if(parent.parentElement && parent.parentElement._scrollSettings){
            parent.parentElement._scrollSettings.end(endType);
        }
        callback(endType);
        parent.removeEventListener('touchstart', endHandler);
    }

    parent._scrollSettings = {
        startTime: lastSettings ? lastSettings.startTime : Date.now(),
        target: target,
        time: settings.time + (lastSettings ? now - lastSettings.startTime : 0),
        ease: settings.ease,
        align: settings.align,
        end: end
    };

    endHandler = end.bind(null, CANCELED);
    parent.addEventListener('touchstart', endHandler);

    if(idle){
        animate(parent);
    }
}

function defaultIsScrollable(element){
    return (
        'pageXOffset' in element ||
        (
            element.scrollHeight !== element.clientHeight ||
            element.scrollWidth !== element.clientWidth
        ) &&
        getComputedStyle(element).overflow !== 'hidden'
    );
}

function defaultValidTarget(){
    return true;
}

module.exports = function(target, settings, callback){
    if(!target){
        return;
    }

    if(typeof settings === 'function'){
        callback = settings;
        settings = null;
    }

    if(!settings){
        settings = {};
    }

    settings.time = isNaN(settings.time) ? 1000 : settings.time;
    settings.ease = settings.ease || function(v){return 1 - Math.pow(1 - v, v / 2);};

    var parent = target.parentElement,
        parents = 0;

    function done(endType){
        parents--;
        if(!parents){
            callback && callback(endType);
        }
    }

    var validTarget = settings.validTarget || defaultValidTarget;
    var isScrollable = settings.isScrollable;

    while(parent){
        if(validTarget(parent, parents) && (isScrollable ? isScrollable(parent, defaultIsScrollable) : defaultIsScrollable(parent))){
            parents++;
            transitionScrollTo(target, parent, settings, done);
        }

        parent = parent.parentElement;

        if(!parent){
            return;
        }

        if(parent.tagName === 'BODY'){
            parent = parent.ownerDocument;
            parent = parent.defaultView || parent.ownerWindow;
        }
    }
};


/***/ }),
/* 508 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_Flux__ = __webpack_require__(274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_StateManager__ = __webpack_require__(510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__actions__ = __webpack_require__(571);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Flux; });









var Flux = function (_CommonFlux) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(Flux, _CommonFlux);

  function Flux() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Flux);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = Flux.__proto__ || Object.getPrototypeOf(Flux)).call.apply(_ref, [this].concat(args)));

    _this.ownContextName = 'background';

    _this.oldBackgroundState = null;
    _this.backgroundState = {};

    // TODO: cleanup on tab close (including embed cache)
    _this.panelStates = {}; // <tab id, state>
    _this.oldPanelStates = {}; // <tab id, state>
    _this.contentStates = {}; // <tab id, state>
    _this.oldContentStates = {}; // <tab id, state>
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Flux, [{
    key: 'start',
    value: function start(extension) {
      var _this2 = this;

      this.extension = extension;
      this.documentsPort = this.extension.portManager.documentsPort;

      this.localStateManager = new __WEBPACK_IMPORTED_MODULE_6_base_common_StateManager__["a" /* default */](this.extension.getInitialState());
      this._actions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__actions__["a" /* default */])({
        setState: this.localStateManager.setState.bind(this.localStateManager),
        getState: this.localStateManager.getState.bind(this.localStateManager)
      });

      return this.fetch().then(function () {
        _this2.localStateManager.on('stateChanged', function (state, excludedTabs) {
          _this2.handleBackgroundState(state, excludedTabs);
        });
        _this2.extension.once('ready', function () {
          return _this2.handleBackgroundState(_this2.localStateManager.state);
        });

        _this2.documentsPort.on('message', function (message) {
          if (message.topic === 'contentStateChanged') {
            _this2.handleContentState(message.data, message.tab.id);
          }
          if (message.topic === 'panelStateChanged') {
            _this2.handlePanelState(message.data, message.tab.id);
          }

          if (message.topic === 'dispatchAction') {
            _this2.dispatch.apply(_this2, [message.data.context, message.data.actionName].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(message.data.actionArgs)));
          }

          if (message.topic === 'requestBackgroundState') {
            _this2.documentsPort.sendToOne(message.tab.id, {
              topic: 'backgroundStateChanged',
              data: _this2.backgroundState
            });
          }
        });

        _this2.extension.tabsController.on('tabRemoved', function (_ref2) {
          var tabId = _ref2.tabId;

          // cleanup to avoid memory leaks
          // (delay in case there are pending messages)
          setTimeout(function () {
            delete _this2.panelStates[tabId];
            delete _this2.oldPanelStates[tabId];
            delete _this2.contentStates[tabId];
            delete _this2.oldContentStates[tabId];
          }, 5000);
        });
      });
    }
  }, {
    key: 'fetch',
    value: function fetch() {
      // default implementation
      return Promise.resolve();
    }
  }, {
    key: 'handleBackgroundState',
    value: function handleBackgroundState(state) {
      var excludedTabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (!state) return;
      this.oldBackgroundState = this.backgroundState;
      this.backgroundState = state;

      this.emit('update', 'background', this.oldBackgroundState, this.backgroundState);

      this.documentsPort.send({
        topic: 'backgroundStateChanged',
        data: state,
        excludedTabs: excludedTabs
      });
    }
  }, {
    key: 'handleContentState',
    value: function handleContentState(state, tabId) {
      if (!state) return;
      this.oldContentStates[tabId] = this.contentStates[tabId] || null;
      this.contentStates[tabId] = state.content;

      this.emit('update', 'content', this.oldContentState, this.contentState, tabId);
    }
  }, {
    key: 'handlePanelState',
    value: function handlePanelState(state, tabId) {
      if (!state) return;
      this.oldPanelStates[tabId] = this.panelStates[tabId] || null;
      this.panelStates[tabId] = state.panel;

      this.emit('update', 'panel', this.oldPanelState, this.panelState, tabId);
    }
  }, {
    key: 'backgroundContext',
    value: function backgroundContext() {
      return {
        state: this.backgroundState,
        dispatch: this.dispatch.bind(this, { name: 'background' })
      };
    }
  }, {
    key: 'contentContext',
    value: function contentContext(tabId) {
      return {
        state: this.contentStates[tabId] || {},
        dispatch: this.dispatch.bind(this, { name: 'content', tabId: tabId })
      };
    }
  }, {
    key: 'panelContext',
    value: function panelContext(tabId) {
      return {
        state: this.panelStates[tabId] || {},
        dispatch: this.dispatch.bind(this, { name: 'panel', tabId: tabId })
      };
    }
  }, {
    key: 'sendToContext',
    value: function sendToContext(context, message) {
      this.documentsPort.sendToOne(context.tabId, message);
    }
  }]);

  return Flux;
}(__WEBPACK_IMPORTED_MODULE_5_base_common_Flux__["a" /* default */]);



/***/ }),
/* 509 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_chrome_browser__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_Component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_tutorialMatchUrl__ = __webpack_require__(320);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PanelController; });













var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var PanelController = function (_Component) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(PanelController, _Component);

  function PanelController() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, PanelController);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PanelController.__proto__ || Object.getPrototypeOf(PanelController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(PanelController, [{
    key: 'start',
    value: function start() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default()(PanelController.prototype.__proto__ || Object.getPrototypeOf(PanelController.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      this.setupDocuments();
      this.setupBrowserAction();
      this.setupTabs();
      this.setupAuth();
      this.updateTabsCount();
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'setupBrowserAction',
    value: function setupBrowserAction() {
      this.browserAction = this.extension.browserActionManager;
      this.browserAction.on('message', this._onBrowserActionMessage.bind(this));
    }
  }, {
    key: 'setupTabs',
    value: function setupTabs() {
      var _this2 = this;

      this.tabsController = this.extension.tabsController;
      this.monitorPanelSupported();

      this.tabsController.on('tabRemoved', function (_ref) {
        var tabId = _ref.tabId;

        // cleanup to avoid memory leaks
        // (delay in case there are pending messages)
        setTimeout(function () {
          _this2.ownContext().dispatch('clearPanelOpen', tabId);
        }, 5000);
        _this2.updateTabsCount();
      });
    }
  }, {
    key: 'setupAuth',
    value: function setupAuth() {
      var _this3 = this;

      this.extension.auth.on('userChanged', function (_ref2) {
        var user = _ref2.user;

        _this3.documentsPort.send({ topic: 'userChanged', data: { user: user } });
      });
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      var _this4 = this;

      if (message.topic === 'showPanel') {
        // on all tabs if message.data.tabId is undefined!
        this.showPanel(message.data.explicit, message.data.tabId);
      }
      if (message.topic === 'hidePanel') {
        this.hidePanel(message.data.explicit, message.data.tabId);
      }

      if (message.topic === 'reloadAllTabs') {
        this.reloadAllTabs();
      }

      if (message.topic === 'viewLive') {
        this.viewLive(message.data, message.tab.id);
      }

      if (message.topic === 'registerPanelController') {
        this.tabsController.getActiveTabId().then(function (activeTabId) {
          var tabInfo = _this4.tabsController.getTabInfo(message.tab.id);
          respond({
            tab: { id: message.tab.id },
            enabled: message.tab.id === activeTabId,
            tabInfo: tabInfo
          });
          _this4.documentsPort.sendToOne(message.tab.id, {
            topic: 'backgroundStateChanged',
            data: _this4.ownContext().state,
            excludedTabs: []
          });
          var willOpen = false;
          if (_this4.shouldPanelOpenOnNewTab(message.tab)) {
            // force panel opening in new tab
            _this4.setPanelOpen(message.tab.id, true);
            willOpen = true; // HACK: setPanelOpen is async, but we want to send the showPanel right now
          }
          if (_this4.isPanelOpen(message.tab.id) || willOpen) {
            _this4.showPanel(false, message.tab.id);
          }
          _this4.documentsPort.sendToOne(message.tab.id, {
            topic: _this4.extension.browserCapture.capturing ? 'disableWidget' : 'enableWidget'
          });
        });
      }

      if (message.topic === 'persistPanelState') {
        // ignore persist from inactive tabs, since they could be in an outdated state (#524)
        // Note: the persist is not ignored if the active tab is "new", so to handle messages sent on "open in a new tab" links (#570)
        var activeTabTime = Date.now() - this.tabsController.activeTabStartTime;
        if (this.tabsController.activeTabId === message.tab.id || activeTabTime <= 500 || message.tab.includeInvalidTabs) {
          this.ownContext().dispatch('setPanel', message.data, [message.tab.id]);
        }
      }
      if (message.topic === 'extendPersistedPanelState') {
        // ignore persist from inactive tabs, since they could be in an outdated state (#524)
        // Note: the persist is not ignored if the active tab is "new", so to handle messages sent on "open in a new tab" links (#570)
        var _activeTabTime = Date.now() - this.tabsController.activeTabStartTime;
        if (this.tabsController.activeTabId === message.tab.id || _activeTabTime <= 500 || message.tab.includeInvalidTabs) {
          this.extendPanelState(message.data);
        }
      }
    }
  }, {
    key: 'updateForBackground',
    value: function updateForBackground(oldState, state) {
      // TODO
    }
  }, {
    key: 'updateForContent',
    value: function updateForContent(oldState, state, tabId) {
      // TODO
    }
  }, {
    key: 'updateForPanel',
    value: function updateForPanel(oldState, state, tabId) {
      // TODO
    }
  }, {
    key: '_onBrowserActionMessage',
    value: function _onBrowserActionMessage(message) {
      // console.info('BROWSER ACTION MESSAGE', message);
      if (message.topic === 'showPanel') {
        this.showPanel(message.data.explicit, message.tabId, message.data.capturing);
      } else if (message.topic === 'hidePanel') {
        this.hidePanel(message.data.explicit, message.tabId);
      } else if (message.topic === 'reloadAllTabs') {
        this.reloadAllTabs();
      }
    }

    // TODO: move to ChromePanelController

  }, {
    key: 'reloadAllTabs',
    value: function reloadAllTabs() {
      var _this5 = this;

      __WEBPACK_IMPORTED_MODULE_5_chrome_browser__["a" /* default */].tabs.query({}, function (tabs) {
        var _loop = function _loop(tab) {
          // Note: do not reload chrome://extension page since seems to cause infinite reloading
          if (!tab.url || tab.url.indexOf('chrome://extensions') === -1 && tab.url.indexOf('https://start.iorad.com') === -1) {
            if (false) {
              // reload isn't yet supported in edge
              browser.tabs.update(tab.id, { url: 'about:blank' }, function () {
                browser.tabs.update(tab.id, { url: tab.url });
              });
            } else {
              __WEBPACK_IMPORTED_MODULE_5_chrome_browser__["a" /* default */].tabs.reload(tab.id);
            }
          }
        };

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tab = _step.value;

            _loop(tab);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        _this5.ownContext().dispatch('toggleIsExtensionJustInstalled', false);
      });
    }
  }, {
    key: 'viewLive',
    value: function viewLive(_ref3, tabId) {
      var liveURL = _ref3.liveURL,
          domain = _ref3.domain;

      __WEBPACK_IMPORTED_MODULE_5_chrome_browser__["a" /* default */].cookies.getAll({ domain: domain }, function (results) {
        var validCookies = results.filter(function (cookie) {
          return !cookie.domain.startsWith('.') && cookie.path === '/' && cookie.domain !== domain && cookie.domain !== 'www.' + domain;
        });
        // try first with the longest non-session cookie
        var subDomainCookie = validCookies.filter(function (cookie) {
          return cookie.expirationDate;
        }).sort(function (a, b) {
          return b.expirationDate - a.expirationDate;
        } // longest expiration
        )[0];
        if (!subDomainCookie) {
          // as last resort, just pick the first one
          subDomainCookie = validCookies[0];
        }

        if (subDomainCookie) {
          // replace liveURL with subDomainCookie.domain
          var parsedLiveURL = new URL(liveURL);
          parsedLiveURL.hostname = subDomainCookie.domain;
          liveURL = parsedLiveURL.href;
          __WEBPACK_IMPORTED_MODULE_5_chrome_browser__["a" /* default */].tabs.update(tabId, { url: liveURL });
        } else {
          // ask the subdomain to the user
          __WEBPACK_IMPORTED_MODULE_5_chrome_browser__["a" /* default */].tabs.update(tabId, {
            url: 'https://start.iorad.com/viewlive?default=true' + ('&liveURL=' + encodeURIComponent(liveURL)) + ('&domain=' + encodeURIComponent(domain))
          });
        }
      });
    }
  }, {
    key: 'monitorPanelSupported',
    value: function monitorPanelSupported() {
      var _this6 = this;

      var checkTab = function checkTab(tabId) {
        if (tabId === null) return;
        _this6.tabsController.getTab(tabId).then(function (tab) {
          if (!tab) return;
          _this6.ownContext().dispatch('toggleIsPanelSupported', _this6.isPanelSupportedOnTab(tab));
        });
      };

      this.tabsController.on('activeTabChanged', function (_ref4) {
        var tabId = _ref4.tabId;
        return checkTab(tabId);
      });
      this.tabsController.on('tabUpdated', function (_ref5) {
        var tabId = _ref5.tabId;

        if (tabId === _this6.tabsController.activeTabId) {
          // check active tab on url change
          checkTab(tabId);
        }
      });
      checkTab(this.tabsController.activeTabId);
    }
  }, {
    key: 'isPanelSupportedOnTab',
    value: function isPanelSupportedOnTab(tab) {
      // default implementation
      return true;
    }
  }, {
    key: 'showPanel',
    value: function showPanel() {
      var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var _this7 = this;

      var tabId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var capturing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      logger.debug("showPanel", explicit, tabId, capturing);
      var message = {
        topic: 'showPanel',
        data: { explicit: explicit, capturing: capturing }
      };

      if (tabId !== null) {
        this.setPanelOpen(tabId, true);
        this.documentsPort.sendToOne(tabId, message);
      } else {
        // all open
        this.tabsController.getAllTabs().then(function (currentTabs) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = currentTabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentTab = _step2.value;

              _this7.setPanelOpen(currentTab.id, true);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          _this7.documentsPort.send(message);
        });
      }
    }
  }, {
    key: 'hidePanel',
    value: function hidePanel() {
      var _this8 = this;

      var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var tabId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var message = { topic: 'hidePanel', data: { explicit: explicit } };

      if (tabId !== null) {
        this.setPanelOpen(tabId, false);
        this.documentsPort.sendToOne(tabId, message);
      } else {
        // all closed
        this.tabsController.getAllTabs().then(function (currentTabs) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = currentTabs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var currentTab = _step3.value;

              _this8.setPanelOpen(currentTab.id, false);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          _this8.documentsPort.send(message);
        });
      }
    }
  }, {
    key: 'extendCaptureState',
    value: function extendCaptureState(captureState) {
      var excludedTabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      this.ownContext().dispatch('extendCaptureState', captureState, excludedTabs);
    }
  }, {
    key: 'extendPanelState',
    value: function extendPanelState(panelState) {
      var excludedTabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      this.ownContext().dispatch('extendPanelState', panelState, excludedTabs);
    }
  }, {
    key: 'setPanelOpen',
    value: function setPanelOpen(tabId, isOpen) {
      logger.debug("Set panel open", tabId, isOpen);
      this.ownContext().dispatch('setPanelOpen', tabId, isOpen);
    }
  }, {
    key: 'isPanelOpen',
    value: function isPanelOpen(tabId) {
      return Boolean(this.ownContext().state.isPanelOpen[tabId]);
    }
  }, {
    key: 'shouldPanelOpenOnNewTab',
    value: function shouldPanelOpenOnNewTab(tab) {
      var currentTutorial = __WEBPACK_IMPORTED_MODULE_9_lodash_get___default()(this.ownContext().state, 'panel.learn.currentTutorial');
      return currentTutorial && currentTutorial.started && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_tutorialMatchUrl__["a" /* default */])(currentTutorial.tutorialData, tab.url);
    }
  }, {
    key: 'updateTabsCount',
    value: function updateTabsCount() {
      var _this9 = this;

      if (!this.tabsController.getTabsCount) return;
      this.tabsController.getTabsCount().then(function (tabsCount) {
        _this9.ownContext().dispatch('setTabsCount', tabsCount);
      });
    }
  }]);

  return PanelController;
}(__WEBPACK_IMPORTED_MODULE_6_base_common_Component__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/PanelController.js"))

/***/ }),
/* 510 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StateManager; });






var StateManager = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(StateManager, _EventEmitter);

  function StateManager(initialState) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, StateManager);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StateManager.__proto__ || Object.getPrototypeOf(StateManager)).call(this));

    _this.state = initialState;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(StateManager, [{
    key: 'setState',
    value: function setState(newState) {
      var _this2 = this;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      setTimeout(function () {
        if (typeof newState === 'function') {
          _this2.state = Object.assign({}, newState(_this2.state));
        } else {
          _this2.state = Object.assign({}, _this2.state, newState);
        }

        _this2.emit.apply(_this2, ['stateChanged', _this2.state].concat(args));
      }, 0);
    }
  }, {
    key: 'getState',
    value: function getState() {
      return this.state;
    }
  }]);

  return StateManager;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);



/***/ }),
/* 511 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function () {
  return "\n<svg\n  width='46px' height='46px' xmlns=\"http://www.w3.org/2000/svg\"\n  viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid\" class=\"spinner-white\"\n>\n  <rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" fill=\"none\" class=\"bk\"></rect>\n  <circle\n    cx=\"50\" cy=\"50\" r=\"45\"\n    stroke-dasharray=\"183.7831702350029 98.96016858807849\"\n    stroke=\"#ffffff\" fill=\"none\" stroke-width=\"10\"\n  ></circle>\n</svg>\n";
};

/***/ }),
/* 512 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function () {
  return "\n<svg class=\"widget-icon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"19.485\" height=\"28.83\" viewBox=\"0 0 19.485 28.83\"><path fill=\"#FFF\" d=\"M.025 0L0 28.83l8.27-7.574 11.215.016z\"/></svg>\n";
};

/***/ }),
/* 513 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export findActiveAnchor */
/* harmony export (immutable) */ __webpack_exports__["a"] = findNavActiveAnchor;
/* unused harmony export findParentNavEl */
// NOTE: ordering matters in this array, place first the most representatives properties
var ACTIVE_LINK_PROP_NAMES = ['backgroundColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'color'];

function findActiveAnchor(parentEl) {
  var anchorEls = Array.from(parentEl.querySelectorAll('a'));
  if (anchorEls.length <= 2) {
    //console.log('too few elements', anchorEls);
    return null;
  }

  var groups = {};

  // track which style props are used
  anchorEls.forEach(function (el) {
    var elStyles = window.getComputedStyle(el);
    ACTIVE_LINK_PROP_NAMES.forEach(function (propName) {
      var elProp = elStyles[propName];

      groups[propName] = groups[propName] || {};
      groups[propName][elProp] = groups[propName][elProp] || [];
      groups[propName][elProp].push(el);
    });
  });

  // find a prop only used by one item (while others are all used by more than one),
  // that item will be active one
  var activeEl = null;
  ACTIVE_LINK_PROP_NAMES.find(function (propName) {
    if (!groups[propName]) return true; // stop
    var elProps = Object.keys(groups[propName]);
    elProps.find(function (elProp) {
      if (groups[propName][elProp].length === 1 && // only used by one item
      !elProps.find(function (otherProp) {
        return otherProp !== elProp && groups[propName][otherProp].length < 2;
      }) // while others are all used by more than one
      ) {
          // active el found
          activeEl = groups[propName][elProp][0];
          return true; // stop
        }
    });
    if (activeEl) return true; // stop
  });
  return activeEl;
}

function findNavEls() {
  return Array.from(document.querySelectorAll('[role="navigation"], nav, #nav, .nav'));
}

function findNavActiveAnchor() {
  var navEls = findNavEls();
  var result = null;
  navEls.find(function (navEl) {
    var activeEl = findActiveAnchor(navEl);
    if (activeEl) {
      result = activeEl;
      return true;
    }
  });
  return result;
}

// used on playback
function findParentNavEl(el) {
  var navEls = findNavEls();

  var currentEl = el.parentNode;
  while (currentEl) {
    if (navEls.indexOf(currentEl) !== -1) {
      return currentEl;
    }
    currentEl = currentEl.parentNode;
  }
  return null;
}

/***/ }),
/* 514 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = appendOnBodyLater;
// Useful in case the append must be done as soon as possible on page load
// and document.body might still be undefined
function appendOnBodyLater(el, callback) {
  if (!document.body) {
    // try later
    setTimeout(appendOnBodyLater.bind(null, el, callback), 50);
    return;
  }
  document.body.appendChild(el);
  if (callback) callback(el);
}

/***/ }),
/* 515 */,
/* 516 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getIntercomMessenger */
/* harmony export (immutable) */ __webpack_exports__["a"] = getIntercomLauncher;
/* harmony export (immutable) */ __webpack_exports__["b"] = getIntercomPendingMessages;
// Note: in new versions, the messenger is lazy created only after the launch button is clicked
function getIntercomMessenger() {
  var messengerIframe = document.querySelector('.intercom-messenger-frame iframe');
  var messengerDocument = messengerIframe ? messengerIframe.contentDocument : document;
  return messengerDocument.querySelector('.intercom-messenger, #intercom-messenger');
}

function getIntercomLauncher() {
  var launcherIframe = document.querySelector('.intercom-launcher-frame');
  var launcherDocument = launcherIframe ? launcherIframe.contentDocument : document;
  return launcherDocument.querySelector('.intercom-launcher, #intercom-launcher');
}

function getIntercomPendingMessages() {
  var launcherBadgeIframe = document.querySelector('.intercom-launcher-badge-frame');
  var launcherBadgeDocument = launcherBadgeIframe ? launcherBadgeIframe.contentDocument : document;
  var badgeEl = launcherBadgeDocument.querySelector('.intercom-launcher-badge');
  return badgeEl ? parseInt(badgeEl.innerText, 10) : 0;
}

/***/ }),
/* 517 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (immutable) */ __webpack_exports__["a"] = isPageLoggedIn;
/* harmony export (immutable) */ __webpack_exports__["b"] = getPageLoggedInType;


function isPageLoggedIn() {
  var zendeskLoggedIn = document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__["a" /* default */])('zendesk-loggedIn'));
  if (zendeskLoggedIn) return true;

  // check logout case instead of login, since is more likely for login links/buttons to be
  // immediatelly visible in the page, while in case of login the logout button
  // might be inside dropdowns whose content is loaded lazily on click (e.g. linkedin)
  var isPageLoggedOut = Boolean(Array.from(document.body.querySelectorAll('a, button')).find(function (el) {
    return (el.innerText && el.innerText.match(/sign in|signin|log in|login|sign up|signup/i) !== null || el.className && el.className.match(/signin|login|signup/i) !== null) && (el.tagName !== 'A' || el.href && el.href.match(/signin|login/i) !== null || el.href && el.href.match(/signup/i) !== null) && (!el.innerText || el.innerText.match(/sign out|signout|log out|logout/i) === null) && (!el.href || el.href.match(/signout|logout/i) === null) && (!el.className || el.className.match(/signout|logout/i) === null) &&
    // is visible (NOTE: visibility:hidden elements are still treated as visible), see https://stackoverflow.com/a/33456469
    !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
  }));
  return !isPageLoggedOut;
}

function getPageLoggedInType() {
  var isZendesk = document.location.href.indexOf('.zendesk.com') !== -1;
  if (isZendesk) {
    return document.querySelector('.track-id-new-org') || Array.from(document.querySelectorAll('zd-hc-navbar a')).find(function (el) {
      return (/Guide admin/.test(el.innerText)
      );
    }) || /\/knowledge\/|\/admin\//.test(document.location.href) ? 'admin' : 'agent';
  }

  return undefined;
}

/***/ }),
/* 518 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_sample__ = __webpack_require__(752);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_sample___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_sample__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_times__ = __webpack_require__(550);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_times___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash_times__);
/* harmony export (immutable) */ __webpack_exports__["a"] = randomString;



function randomString() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;

  var chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  return __WEBPACK_IMPORTED_MODULE_1_lodash_times___default()(length, function () {
    return __WEBPACK_IMPORTED_MODULE_0_lodash_sample___default()(chars);
  }).join('');
}

/***/ }),
/* 519 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_scroll_into_view__ = __webpack_require__(507);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_scroll_into_view___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_scroll_into_view__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__documentSize__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_curry__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash_curry___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_curry__);




var getElementScroll = function getElementScroll(element) {
  if (element === window) {
    return {
      x: element.pageXOffset,
      y: element.pageYOffset
    };
  } else {
    return {
      x: element.scrollLeft,
      y: element.scrollTop
    };
  }
};

var getElementPosition = function getElementPosition(el) {
  return el !== window ? el.getBoundingClientRect() : {
    width: el.innerWidth,
    height: el.innerHeight,
    top: 0,
    bottom: el.innerHeight,
    left: 0,
    right: el.innerWidth
  };
};

// margins beetween target and parent sides
var getRelativeMargins = function getRelativeMargins(target, parent) {
  var targetPosition = getElementPosition(target);
  var parentPosition = getElementPosition(parent);
  return {
    top: targetPosition.top - parentPosition.top,
    left: targetPosition.left - parentPosition.left,
    bottom: parentPosition.bottom - targetPosition.bottom,
    right: parentPosition.right - targetPosition.right
  };
};

var scrollAvailable = function scrollAvailable(el) {
  if (el === window) {
    return {
      x: el.innerWidth + el.pageXOffset < el.document.body.scrollWidth,
      y: el.innerHeight + el.pageYOffset < __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__documentSize__["a" /* getDocumentHeight */])()
    };
  } else {
    return {
      x: el.clientWidth < el.scrollWidth,
      y: el.clientHeight < el.scrollHeight
    };
  }
};

// margin is an object of margins between target and viewport
// we say it's in viewport if all margins are bigger than minimum
// or we couldn't scroll in a given axis
var targetInViewport = function targetInViewport(minMargin, target, parent) {
  var margin = getRelativeMargins(target, parent);
  var scrollableAxises = scrollAvailable(parent);
  return ['top', 'bottom', 'left', 'right'].filter(function (side, i) {
    return margin[side] < minMargin && scrollableAxises[i - 2 < 0 ? 'y' : 'x'];
  }).length === 0;
};

var nearestAlign = __WEBPACK_IMPORTED_MODULE_2_lodash_curry___default()(function (target, parent) {
  var margin = getRelativeMargins(target, parent);

  var top = margin.top < margin.bottom ? 0 : 1;
  var left = margin.left < margin.right ? 0 : 1;
  return { top: top, left: left };
});

/* harmony default export */ __webpack_exports__["a"] = function (el) {
  var minMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var autoAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var animationTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;

  var align = autoAlign ? nearestAlign(el) : null;
  var params = {
    time: animationTime,
    align: align,
    validTarget: function validTarget(parent) {
      return !targetInViewport(minMargin, el, parent);
    },
    isScrollable: function isScrollable(target, defaultIsScrollable) {
      // By default scroll-into-view will only attempt to scroll elements that have overflow not set to `"hidden"` and who's scroll width/height is larger than their client height.
      // You can override this check by passing an `isScrollable` function to settings:
      return defaultIsScrollable(target) || target.className && target.className.indexOf('scrollable') !== -1;
    }
  };

  return new Promise(function (resolve) {
    if (!el) {
      resolve(false);
    } else {
      var scrolledParents = __WEBPACK_IMPORTED_MODULE_0_scroll_into_view___default()(el, params, function () {
        return resolve(true);
      });
      if (scrolledParents <= 0) resolve(false);
    }
  });
};

/***/ }),
/* 520 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = safeSetInterval;
// http://www.thecodeship.com/web-development/alternative-to-javascript-evil-setinterval/
function safeSetInterval(func, wait, times) {
    var interv = function (w, t) {
        return function () {
            if (typeof t === "undefined" || t-- > 0) {
                setTimeout(interv, w);
                try {
                    func.call(null);
                } catch (e) {
                    t = 0;
                    throw e.toString();
                }
            }
        };
    }(wait, times);

    setTimeout(interv, wait);
};

/***/ }),
/* 521 */,
/* 522 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_Component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__common_utils_appendOnBodyLater__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__common_utils_reactRender__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__common_utils_reactRender___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__common_utils_reactRender__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_CaptureStartDialog__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_CaptureStartDialog___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__components_CaptureStartDialog__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__common_utils_practicePlayer__ = __webpack_require__(305);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_flowRight__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_flowRight___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_flowRight__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_throttle__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_throttle___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_throttle__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_assignIn__ = __webpack_require__(298);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_assignIn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_assignIn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_base_common_utils_addNewStyle__ = __webpack_require__(588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_base_common_svgInline_spinner_white__ = __webpack_require__(511);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_base_common_svgInline_widget_icon__ = __webpack_require__(512);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_base_common_svgInline_zendesk_widget_icon__ = __webpack_require__(586);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_base_common_svgInline_zendesk_widget_close_icon__ = __webpack_require__(585);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_base_common_utils_fetchEmbedTutorials__ = __webpack_require__(593);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_base_common_utils_getQueryLiveId__ = __webpack_require__(595);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_lodash_after__ = __webpack_require__(545);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_lodash_after___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25_lodash_after__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_base_common_utils_intercom__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__common_utils_coordinates__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_base_common_utils_isPageLoggedIn__ = __webpack_require__(517);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_base_common_utils_player__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__elementLocator__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33_base_common_utils_activeNav__ = __webpack_require__(513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PanelController; });




































var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_34_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var ZENDESK_WIDGET_CONTAINER = 'header';

function isPopup() {
  return window.opener !== window && window.menubar && !window.menubar.visible;
}

function domainMatchUrl(urla, urlb) {
  var normalize = function normalize(url) {
    var parsed = new URL(url);
    return parsed.hostname.split('.').slice(-2).join('.');
  };

  return normalize(urla) === normalize(urlb);
}

var PanelController = function (_Component) {
  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default()(PanelController, _Component);

  function PanelController() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, PanelController);

    var _this = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PanelController.__proto__ || Object.getPrototypeOf(PanelController)).call(this));

    _this.panelEl = null;
    _this.panelHeight = '';
    _this.panelElStarted = false;
    _this.panelDisabled = false;
    _this.panelDragged = false;

    _this.hrefHasTutorials = false;
    _this.customColors = null;
    _this.user = null;

    _this.intercomInstalled = false;

    _this.overlayDismissed = true;

    _this.cacheHeight = __WEBPACK_IMPORTED_MODULE_14_lodash_throttle___default()(_this.cacheHeight, 1000);
    _this.updatePanelMaxHeight = __WEBPACK_IMPORTED_MODULE_14_lodash_throttle___default()(_this.updatePanelMaxHeight, 50);

    _this.draggableInstance = null;
    _this.panelDragHandler = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(PanelController, [{
    key: 'start',
    value: function start() {
      var _get2,
          _this2 = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get___default()(PanelController.prototype.__proto__ || Object.getPrototypeOf(PanelController.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      var embed = "embed" === 'embed';
      if (!this.extension.isTopFrame) return; // TODO: remove (this component is executed only in the main frame anyway)
      if (!embed && isPopup()) {
        // only hide panel/widget (panel JS is needed for player to work)
        /*addNewStyle(`
          .${namespace('panel')}, .${namespace('widget')} {
            visibility: hidden !important;
          }
        `);*/
      }

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__["a" /* addWindowListener */])('beforeunload', function () {
        return _this2.cacheHeight();
      });

      this.retrieveHeight().then(function () {
        _this2.setupBackground();
        _this2.setupPanel();
        _this2.setupPracticePlayer();
        _this2.setupPage();
        _this2.monitorIntercom();
        _this2.monitorZendesk();
        _this2.registerToBackground();
        _this2.listenOverlay();
        _this2.checkLegacyPageStatus();
        _this2.checkPopupPageStatus();
      });
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__["a" /* addWindowListener */])('resize', function () {
        _this2.updatePanelMaxHeight();
        _this2.setCloseElementCoordinates();
      });
      //addWindowListener('resize', () => this.calculatePanelRealBounds());
      //addWindowListener('scroll', () => this.calculatePanelRealBounds());
    }
  }, {
    key: 'setupBackground',
    value: function setupBackground() {
      this.backgroundPort = this.extension.portManager.backgroundPort;
      this.backgroundPort.on('message', this.handleBackgroundMessage.bind(this));
    }
  }, {
    key: 'setupPanel',
    value: function setupPanel() {
      var _this3 = this;

      this.panelPort = this.extension.portManager.panelPort;
      this.panelPort.on('message', this.handlePanelMessage.bind(this));

      var currentHref = document.location.href;
      setInterval(function () {
        var href = document.location.href;

        if (href !== currentHref) {
          currentHref = href;
          _this3.ownContext().dispatch('setLocationHref', href, Date.now());
        }
      }, 500);

      if (document.location.hostname.endsWith('.zendesk.com')) {
        var currentPageLoggedInType = void 0;
        var check = function check() {
          var pageLoggedInType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_30_base_common_utils_isPageLoggedIn__["b" /* getPageLoggedInType */])();
          if (pageLoggedInType !== currentPageLoggedInType) {
            currentPageLoggedInType = pageLoggedInType;
            _this3.ownContext().dispatch('setPageLoggedInType', pageLoggedInType);
          }
        };
        setInterval(check, 3000);
        check();
      }
    }
  }, {
    key: 'setupPracticePlayer',
    value: function setupPracticePlayer() {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12__common_utils_practicePlayer__["a" /* listenToPracticeMessage */])(this.handlePracticeMessage.bind(this));
    }
  }, {
    key: 'setupPage',
    value: function setupPage() {
      var _this4 = this;

      window.addEventListener('message', function (event) {
        var message = event.data;
        if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;
        if (message.from !== 'page' || message.to !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])()) return;
        _this4.handlePageMessage(message);
      });
    }
  }, {
    key: 'handlePageMessage',
    value: function handlePageMessage(message) {
      var BACKGROUND_TOPICS = ['reloadAllTabs', 'viewLive'];

      if (BACKGROUND_TOPICS.indexOf(message.topic) >= 0) {
        this.backgroundPort.send(message);
      }
    }
  }, {
    key: 'setupGoogleTranslate',
    value: function setupGoogleTranslate() {
      this.ownContext().dispatch('toggleGoogleTranslateInstalled', this.isGoogleTranslate());
    }
  }, {
    key: 'isCombineIntercom',
    value: function isCombineIntercom() {
      // default implementation
      return true;
    }
  }, {
    key: 'isGoogleTranslate',
    value: function isGoogleTranslate() {
      return false;
    }
  }, {
    key: 'monitorIntercom',
    value: function monitorIntercom() {
      var _this5 = this;

      if (false) return;

      var check = function check() {
        var intercomLauncherEl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_28_base_common_utils_intercom__["a" /* getIntercomLauncher */])();
        var intercomInstalled = intercomLauncherEl !== null;
        if (intercomInstalled !== _this5.intercomInstalled) {
          _this5.intercomInstalled = intercomInstalled;

          if (_this5.isCombineIntercom()) {
            document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('combine-intercom'));

            _this5.ownContext().dispatch('toggleIntercomInstalled', intercomInstalled);

            // TODO: do this only once!
            if (window.Intercom) {
              window.Intercom('onShow', function () {
                setTimeout(function () {
                  document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('intercom-visible'));
                }, 300); // wait icon change of intercom button to prevent weird visual effect
                _this5.toggleChatButtonWidgetLabel(true);
              });
              window.Intercom('onHide', function () {
                document.documentElement.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('intercom-visible'));
                _this5.hideChatButtonWidget();
                setTimeout(_this5.toggleChatButtonWidgetLabel.bind(_this5), 1000);
              });
            }
            intercomLauncherEl.addEventListener('click', function (e) {
              if (e.clientX === 0 && e.clientY === 0) return; // ignore programmatic clicks
              if (document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('intercom-visible'))) {
                // close
                // also close iorad panel
                if (_this5.panelEl) _this5.panelEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide')); // prevent weird effect where panel is visible for few hundred milliseconds before being closed
                _this5.backgroundPort.send({
                  topic: 'hidePanel',
                  data: { explicit: true, undefined: undefined }
                });
              }
            }, true);

            // TODO: do this only once!
            // remove fade-in animation (https://github.com/iorad/IORAD-extension/issues/407#issuecomment-268307986)
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_base_common_utils_addNewStyle__["a" /* default */])('@media (min-width: 768px) {\n            #intercom-container .intercom-launcher-frame {\n              animation: none !important;\n            }\n            html body #intercom-container .intercom-app .intercom-messenger-frame {\n              transition: none !important;\n            }\n          }');
          } else {
            // TODO: do this only once!
            // just move intercom button to the left
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_base_common_utils_addNewStyle__["a" /* default */])('@media (min-width: 768px) {\n            #intercom-container .intercom-launcher-frame {\n              right: 90px !important;\n            }\n          }');
          }
        }
      };

      setInterval(check, 50);
      check();
    }
  }, {
    key: 'isZendesk',
    value: function isZendesk() {
      return !!document.querySelector('script[src*="zendesk"]') || window.location.hostname.endsWith(".zendesk.com");
    }
  }, {
    key: 'monitorZendesk',
    value: function monitorZendesk() {
      var _this6 = this;

      if (!this.isZendesk()) return;
      document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('zendesk-visible'));

      // admin section uses random classes, we can't just use a selector,
      // thus we find the first element having an actual background
      function findZendeskActionButtonColor(navbarEl) {
        var anchorBackgroundColors = Array.from(navbarEl.querySelectorAll('li a')).map(function (anchorEl) {
          return window.getComputedStyle(anchorEl).backgroundColor;
        });
        var zendeskActionButtonColor = anchorBackgroundColors.find(function (color) {
          return color.startsWith('rgb(');
        }); // Note: ignore rgba(0,0,0,0) colors
        return zendeskActionButtonColor;
      }

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
        return document.querySelector('#main_navigation, div[role="navigation"]');
      }, function (navbarEl) {
        document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('zendesk-loggedIn'));

        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
          return window.getComputedStyle(navbarEl).backgroundColor;
        }, function (zendeskMainColor) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
            return findZendeskActionButtonColor(navbarEl);
          }, function (zendeskActionButtonColor) {
            _this6.handleColors(Object.assign(_this6.customColors || {}, {
              main: zendeskMainColor,
              actionButton: zendeskActionButtonColor,
              highlight: zendeskActionButtonColor
            }));
          });
        });
      });

      // don't show the widget button above the fullscreen player
      // Note: this only works in Chrome (other browsers use other prefixes)
      var handleFullscreenChange = function handleFullscreenChange() {
        var isFullscreen = Boolean(document.webkitFullscreenElement);
        if (_this6.widgetEl) _this6.widgetEl.classList[isFullscreen ? 'add' : 'remove'](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('fullscreen'));
      };
      document.addEventListener("webkitfullscreenchange", handleFullscreenChange, false);
    }
  }, {
    key: 'registerToBackground',
    value: function registerToBackground() {
      var _this7 = this;

      this.backgroundPort.send({ topic: 'registerPanelController' }, function (_ref) {
        var tab = _ref.tab,
            enabled = _ref.enabled,
            tabInfo = _ref.tabInfo;

        _this7.notifyOverlayDismissed(Boolean(tabInfo.overlayDismissed), false);

        _this7.getOrMakeWidget(tab.id).then(function () {
          if (!_this7.panelEl || _this7.panelEl.classList.contains('hide') || _this7.closeEl && _this7.closeEl.classList.contains('loading-widget')) {
            _this7.toggleWidget('show');
          }
        });

        var queryLiveId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_23_base_common_utils_getQueryLiveId__["a" /* default */])(location.search);
        if (queryLiveId) {
          _this7.autoOpenLiveId = queryLiveId;
          _this7.getOrMakePanel(tab.id, false);
          _this7.togglePanel('show', tab.id, false, false);
        } else if (true) {
          // preload the panel
          // OPTIMIZATION: we don't do this in extension for reducing resources usage,
          // plus there wouldn't be almost any gain, since we use local files there.
          _this7.getOrMakePanel(tab.id, false).then(function (panelEl) {
            _this7.loadCoordinates();
            _this7.setDraggable();
          });
        }

        if (!enabled) _this7.disablePanel();
      });
    }
  }, {
    key: 'toggleOverlayFade',
    value: function toggleOverlayFade(mode, force) {
      this.extension.overlayController.toggleBlankVisibility && this.extension.overlayController.toggleBlankVisibility(mode, force);
    }
  }, {
    key: 'shouldSuppressOverlay',
    value: function shouldSuppressOverlay() {
      var panel = this.flux.backgroundContext().state.panel;
      var tutorialStarted = this.flux.panelContext().state.started;

      return this.overlayDismissed || !this.flux.backgroundStateReceived || panel && panel.learn && panel.learn.currentTutorial.started || // avoid blink (#669)
      tutorialStarted || this.extension.overlayController.countdown || this.extension.documentCapture && this.extension.documentCapture.isActive || this.capturePaused || !this.panelEl || this.panelEl.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
    }
  }, {
    key: 'checkOverlay',
    value: function checkOverlay(force) {
      this.toggleOverlayFade(this.shouldSuppressOverlay() ? 'hide' : 'show', force);
    }
  }, {
    key: 'listenOverlay',
    value: function listenOverlay() {
      var _this8 = this;

      this.checkOverlay();
      this.extension.documentCapture.on('change:isActive', function () {
        return _this8.checkOverlay();
      });
      this.on('change:capturePaused', function () {
        return _this8.checkOverlay();
      });
      this.on('change:panelHidden', function () {
        return _this8.checkOverlay();
      });
      this.on('change:overlayDismissed', function () {
        return _this8.checkOverlay();
      });
    }
  }, {
    key: 'disablePanel',
    value: function disablePanel() {
      if (!this.panelPort) return; // too early
      if (this.disablePanelTimer) this.disablePanelTimer.remove();
      this.panelDisabled = true;
      this.panelPort.disable();
      this.emit('disablePanel');
    }
  }, {
    key: 'disablePanelLater',
    value: function disablePanelLater() {
      var _this9 = this;

      var timer = setTimeout(function () {
        return _this9.disablePanel();
      }, 500);
      this.disablePanelTimer = {
        remove: function remove() {
          clearTimeout(timer);
          _this9.disablePanelTimer = undefined;
        }
      };
      return this.disablePanelLater;
    }
  }, {
    key: 'enablePanel',
    value: function enablePanel() {
      if (!this.panelPort) return; // too early
      if (this.disablePanelTimer) this.disablePanelTimer.remove();
      this.panelDisabled = false;
      this.panelPort.enable();
      this.panelPort.send('backgroundStateChanged', this.flux.backgroundState); // HACK
      this.panelPort.send('contentStateChanged', this.flux.contentState); // HACK
      this.emit('enablePanel');
    }
  }, {
    key: 'checkLegacyPageStatus',
    value: function checkLegacyPageStatus() {
      var _this10 = this;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
        return document.body;
      }, function () {
        if (_this10.panelDisabled || document.hidden) return; // too late
        var status = document.body.tagName === 'FRAMESET';
        _this10.flux.backgroundContext().dispatch('toggleIsCurrentPageLegacy', status);
      });
    }
  }, {
    key: 'checkPopupPageStatus',
    value: function checkPopupPageStatus() {
      var _this11 = this;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
        return document.body;
      }, function () {
        if (_this11.panelDisabled || document.hidden) return; // too late
        var status = isPopup();
        _this11.flux.backgroundContext().dispatch('toggleIsCurrentPagePopup', status);
      });
    }
  }, {
    key: 'retrieveHeight',
    value: function retrieveHeight() {
      var _this12 = this;

      return this.extension.storage.get({ 'panelHeight': '' }).then(function (_ref2) {
        var panelHeight = _ref2.panelHeight;

        _this12.panelHeight = panelHeight;
        return panelHeight;
      });
    }
  }, {
    key: 'handleBackgroundMessage',
    value: function handleBackgroundMessage(message) {
      var _this13 = this;

      //logger.debug('PanelController: got message from background' + JSON.stringify(message));

      message.data = message.data || {};

      if (message.topic === 'showPanel' && this.extension.isTopFrame) {
        this.togglePanel('show', message.tab.id, message.data && message.data.explicit, message.data && message.data.capturing);
      }

      if (['hidePanel', 'startCounter', 'stopCounter', 'showStartCapture'].indexOf(message.topic) > -1 && this.extension.isTopFrame) {
        this.togglePanel('hide', message.tab.id, message.data && message.data.explicit);
      }

      if (message.topic === 'startCounter' && this.extension.isTopFrame) {
        this.checkOverlay();
      }
      if (message.topic === 'hidePaused' && this.extension.isTopFrame) {
        this.capturePaused = false;
        this.checkOverlay(true);
      }

      if (message.topic === 'stepFoundInActiveTab' && this.extension.isTopFrame) {
        var isActiveTab = message.tab.id === message.data.activeTabId;
        var show = isActiveTab || !message.data.found;

        this.togglePanel(show ? 'show' : 'hide', message.tab.id, false);
      }

      if (message.topic === 'userChanged' && this.extension.isTopFrame) {
        this.user = message.data.user;

        // TODO: refactor this by moving user into the background or content state
        var send = function send() {
          _this13.flux.panelContext().dispatch('userChanged', _this13.user);
        };
        if (this.panelDisabled) this.once('enablePanel', send);else send();
      }

      if (message.topic === 'startBrowserCapture') {
        this.flux.panelContext().dispatch('startBrowserCapture');
      }
    }
  }, {
    key: 'handlePanelMessage',
    value: function handlePanelMessage(message) {
      var _this14 = this;

      //logger.debug('PanelController: got message from panel' + JSON.stringify(message));

      if (message.topic === 'register') {
        this.registerPanel();
        this.setupGoogleTranslate();
      }

      var backgroundRedirectTopics = ['persistPanelState', 'extendPersistedPanelState', 'resumeCapture', 'pauseCapture', 'cancelCapture', 'completeCapture', 'saveCapturedTutorial', 'playAudio', 'stopAudio', 'updateAudioMuted', 'hidePanel'];

      if (backgroundRedirectTopics.indexOf(message.topic) !== -1 && this.extension.isTopFrame) {
        this.backgroundPort.send(message);
      }

      if (message.topic === 'startCapture') {
        this.backgroundPort.send({ topic: 'showStartCapture' });
        /*this.confirmCaptureStart().then((success) => {
          if (success) this.backgroundPort.send({ topic: 'startCapture' });
        });*/
      }
      if (message.topic === 'restartCapture') {
        this.isCaptureStartConfirmationNeeded().then(function (confirmNeeded) {
          if (confirmNeeded) {
            _this14.backgroundPort.send({ topic: 'pauseCapture' });
            _this14.confirmCaptureStart().then(function (success) {
              if (success) _this14.backgroundPort.send(message);else _this14.backgroundPort.send({ topic: 'resumeCapture' });
            });
          } else {
            _this14.backgroundPort.send({ topic: 'resumeCapture' });
          }
        });
      }

      if (message.topic === 'showPracticeTutorial') {
        this.extension.overlayController.togglePracticeTutorial('show', message.data.playerURL);
      }

      if (message.topic === 'hidePracticeTutorial') {
        this.extension.overlayController.togglePracticeTutorial('hide');
      }

      if (message.topic === 'cancelCapture') {
        this.showCloseWidget();
        this.toggleDragHandler('show');
      }

      if (message.topic === 'updateUserData') {
        this.setUserData(message.data);
      }

      if (message.topic === 'openIntercom') {
        this.toggleIntercom();
      }

      if (message.topic === 'started') {
        this.panelElStarted = true;
      }

      if (message.topic === 'panelHeightChanged') {
        var containerHeight = message.data + 'px';
        this.updateContainer({ containerHeight: containerHeight });
      }

      if (message.topic === 'click') {
        this.notifyOverlayDismissed(false);
      }

      if (message.topic === 'startTutorial') {
        // This is executed only when the user presses the "Guide me" button
        var _flux$panelContext$st = this.flux.panelContext().state,
            currentStep = _flux$panelContext$st.currentStep,
            loadURL = _flux$panelContext$st.loadURL;

        if (currentStep) {
          var isRedirecting = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_31_base_common_utils_player__["a" /* redirectIfNeeded */])(currentStep.window.url, loadURL);
          if (!isRedirecting) {
            this.redirectIfNeededByNav(currentStep);
          }
        }
      }

      if (message.topic === "changeLocationHref") {
        window.location.href = message.data.locationHref;
      }
    }

    // NOTE: this won't work if the nav is inside an iframe

  }, {
    key: 'redirectIfNeededByNav',
    value: function redirectIfNeededByNav(currentStep) {
      // alternative redirect method: check active nav item
      var navActiveAnchorInfo = currentStep.window.navActiveAnchorInfo;

      var domainMatches = domainMatchUrl(currentStep.window.url, window.location.href);
      var isZendesk = new URL(currentStep.window.url).hostname.endsWith('.zendesk.com'); // the general redirect rule is enough for it
      if (navActiveAnchorInfo && domainMatches && !isZendesk) {
        var stepNavActiveAnchor = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_32__elementLocator__["a" /* locateElement */])(navActiveAnchorInfo.locator).el; // anchor that was active during capture of this step
        if (stepNavActiveAnchor && stepNavActiveAnchor.href) {
          var navActiveAnchor = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_33_base_common_utils_activeNav__["a" /* findNavActiveAnchor */])(); // anchor that is active right now
          if (navActiveAnchor && navActiveAnchor !== stepNavActiveAnchor) {
            // this dispatch is needed since the panel
            // doesn't know we are going to redirect
            // (unlike with the regular redirectIfNeeded)
            this.flux.panelContext().dispatch('setLiveLoadingStepPage', true);

            window.location.href = stepNavActiveAnchor.href;
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: 'notifyOverlayDismissed',
    value: function notifyOverlayDismissed(value) {
      var notifyBackground = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.overlayDismissed = value;
      this.emit('change:overlayDismissed', this.overlayDismissed);
      if (notifyBackground) {
        this.backgroundPort.send({
          topic: 'overlayDismissedChanged',
          data: { overlayDismissed: value }
        });
      }
    }
  }, {
    key: 'handlePracticeMessage',
    value: function handlePracticeMessage(message) {
      var _this15 = this;

      var handlers = [
      // topic          handler (topic, data) => {}
      ['practiceReady', function (t) {
        return _this15.panelPort.send(t);
      }]];

      handlers.forEach(function (h) {
        if (message.topic === h[0]) h[1](message.topic, message.data);
      });
    }
  }, {
    key: 'togglePanel',
    value: function togglePanel(mode, tabId) {
      var _this16 = this;

      var explicit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var capturing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var toggle = function toggle() {
        if (mode === 'hide') {
          _this16.closePanel();
          _this16.hideCloseWidget();
          _this16.toggleDragHandler('hide');
        } else {
          if (!_this16.panelElStarted) {
            _this16.startPanel();
          }
          _this16.openPanel();
          if (!capturing) {
            _this16.showCloseWidget();
            _this16.toggleDragHandler('show');
          } else {
            _this16.resetCoordinates();
            _this16.toggleDragHandler('hide');
          }
        }
        _this16.emit('change:panelHidden');
      };

      // wait for iframe load for a smooth animation
      this.getOrMakePanel(tabId, explicit).then(function (panel) {
        _this16.setDraggable().then(function () {
          toggle();
          window.setTimeout(function () {
            return _this16.panelEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel-loaded'));
          }, 2000);
        });
        _this16.loadCoordinates();
      });
    }
  }, {
    key: 'closePanel',
    value: function closePanel() {
      document.documentElement.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel-open'));
      this.panelEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      this.flux.panelContext().dispatch('closePanel');
      this.toggleWidget('show');
      return this.panelEl;
    }
  }, {
    key: 'openPanel',
    value: function openPanel() {
      document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel-open'));
      this.panelEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      this.toggleWidget('hide');
      return this.panelEl;
    }
  }, {
    key: 'startPanel',
    value: function startPanel() {
      var _this17 = this;

      // Starts tutorials fetching in the panel, etc.
      var iframe = this.panelEl.querySelector('iframe');
      this._waitIframeLoad(iframe).then(function () {
        iframe.contentWindow.postMessage({
          topic: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('startApp'),
          src: _this17.panelSrc,
          upwardState: {
            background: _this17.flux.backgroundContext().state,
            content: _this17.flux.contentContext().state
          },
          options: _this17.getPanelOptions()
        }, '*');
      });
    }
  }, {
    key: 'getPanelOptions',
    value: function getPanelOptions() {
      var implicitDomains = this.getImplicitDomains().map(function (d) {
        return escape(d);
      }).join(',');
      return {
        href: location.href,
        domain: location.host,
        intercomInstalled: this.intercomInstalled,
        colors: this.customColors,
        implicitDomains: implicitDomains
      };
    }
  }, {
    key: 'getOrMakePanel',
    value: function getOrMakePanel(tabId) {
      var _this18 = this;

      var waitForLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      return !this.panelEl ? new Promise(function (resolve) {
        var panel = _this18.createPanel(tabId);

        // In embed mode we preload the user and tutorial data as the panel
        // loads
        if (true) {
          _this18.sendEmbedTutorials(panel);
        }

        var isEmbed = "embed" === 'embed';
        var close = void 0;
        if (!isEmbed) {
          close = _this18.isZendesk() ? _this18.createZendeskClosePanel(tabId) : _this18.createClosePanel(tabId);
          _this18.closeEl = close;
        }

        var afterPanelAppend = function afterPanelAppend() {
          if (!isEmbed) {
            if (_this18.isZendesk()) {
              __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
                return document.querySelector(ZENDESK_WIDGET_CONTAINER);
              }, function () {
                document.body.appendChild(close);
                if (!waitForLoad) resolve(panel);
              });
            } else {
              document.body.appendChild(close);
              if (!waitForLoad) resolve(panel);
            }
          } else {
            if (!waitForLoad) resolve(panel);
          }
        };
        if (document.body && document.body.contains(panel)) afterPanelAppend();else __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_utils_appendOnBodyLater__["a" /* default */])(panel, afterPanelAppend);

        if (waitForLoad) {
          _this18._waitIframeLoad().then(function () {
            return resolve(panel);
          });
        }
      }) : Promise.resolve(this.panelEl);
    }
  }, {
    key: 'sendEmbedTutorials',
    value: function sendEmbedTutorials(panel) {
      // fetch embed tutorials from api
      var embedTutorials = void 0;
      var iframe = panel.querySelector('iframe');
      // We want to post after we've both loaded the data and the panel iframe has loaded
      var post = __WEBPACK_IMPORTED_MODULE_25_lodash_after___default()(2, function post() {
        iframe.contentWindow.postMessage({ topic: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('embedTutorials'), embedTutorials: embedTutorials }, '*');
      });

      this._waitIframeLoad(iframe).then(post);

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_22_base_common_utils_fetchEmbedTutorials__["a" /* default */])(this.extension.embedOptions.userId, [window.location.href].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(this.getImplicitDomains()))).then(function (_embedTutorials) {
        embedTutorials = _embedTutorials;
        post();
      });
    }
  }, {
    key: 'createPanel',
    value: function createPanel(tabId) {
      if (true) {
        this.showCloseWidget();
        if (this.closeEl) this.closeEl.classList.add('loading-widget');
      }

      var prefetchedPanel = document.querySelector('.' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panelPrefetch'));
      var prefetchedIframe = prefetchedPanel ? prefetchedPanel.querySelector('iframe') : null;

      var panelEl = this.panelEl = prefetchedPanel || document.createElement('div');

      // Remove stretching effect for initial load
      panelEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel-loaded'));

      panelEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel', 'hide') + ' widget-panel';
      panelEl.style.height = this.panelHeight + '!important';
      panelEl.style.display = ''; // needed in case of prefetchedPanel to remove 'hide'

      var iframe = prefetchedIframe || document.createElement('iframe');
      iframe.width = '100%';
      iframe.height = '100%';
      iframe.style.height = "100%";
      iframe.style.width = "100%";
      iframe.allowTransparency = 'true';

      var src = this.extension.getURL('/panel/index.html');
      this.panelSrc = src;
      if (!prefetchedIframe) iframe.src = src;
      this._waitIframeLoad(iframe);
      if (!prefetchedIframe) panelEl.appendChild(iframe);
      this.updatePanelMaxHeight();

      return panelEl;
    }
  }, {
    key: 'setCloseElementCoordinates',
    value: function setCloseElementCoordinates() {
      var closeEl = this.closeEl;

      var panelCoordinates = this.getPanelCoordinates();

      // Keep initial close element coordinates if panel drag has't happened yet
      if (!closeEl || this.isZendesk() || !panelCoordinates || !panelCoordinates.top || !panelCoordinates.left) {
        return;
      }

      var _getCloseElementCoord = this.getCloseElementCoordinates(panelCoordinates),
          top = _getCloseElementCoord.top,
          left = _getCloseElementCoord.left;

      closeEl.style.top = top + 'px';
      closeEl.style.left = left + 'px';
    }
  }, {
    key: 'getCloseElementCoordinates',
    value: function getCloseElementCoordinates(_ref3) {
      var top = _ref3.top,
          left = _ref3.left;

      var panelHeight = this.panelEl.offsetHeight || Number(this.panelHeight.replace('px', ''));
      var topOffset = panelHeight - 30;
      var leftOffset = 335;

      return {
        top: top + topOffset,
        left: left + leftOffset
      };
    }
  }, {
    key: 'getPanelCoordinates',
    value: function getPanelCoordinates() {
      if (!this.panelEl) return null;
      var top = Number(this.panelEl.style.top.replace('px', ''));
      var left = Number(this.panelEl.style.left.replace('px', ''));
      return {
        top: top,
        left: left
      };
    }
  }, {
    key: 'storeCoordinates',
    value: function storeCoordinates() {
      var panelCoordinates = this.getPanelCoordinates();
      if (!panelCoordinates) return;

      var _getCloseElementCoord2 = this.getCloseElementCoordinates(panelCoordinates),
          top = _getCloseElementCoord2.top,
          left = _getCloseElementCoord2.left;

      panelCoordinates.closeElTop = top;
      panelCoordinates.closeElLeft = left;

      this.extension.storage.set({ panelCoordinates: panelCoordinates });
    }
  }, {
    key: 'resetCoordinates',
    value: function resetCoordinates() {
      this.panelDragged = false;
      this.extension.storage.set({ panelCoordinates: {} });
      var panelEl = this.panelEl,
          closeEl = this.closeEl;

      panelEl.style.top = '';
      panelEl.style.left = '';

      if (!closeEl || this.isZendesk()) {
        return;
      }

      closeEl.style.top = '';
      closeEl.style.left = '';
    }
  }, {
    key: 'loadCoordinates',
    value: function loadCoordinates() {
      var _this19 = this;

      var storage = this.extension.storage,
          panelEl = this.panelEl,
          closeEl = this.closeEl;

      storage.get({ panelCoordinates: {} }).then(function (_ref4) {
        var panelCoordinates = _ref4.panelCoordinates;
        var left = panelCoordinates.left,
            top = panelCoordinates.top,
            closeElTop = panelCoordinates.closeElTop,
            closeElLeft = panelCoordinates.closeElLeft;

        if (!left || !top) {
          return;
        }

        _this19.panelDragged = true;
        panelEl.style.top = top + 'px';
        panelEl.style.left = left + 'px';

        if (!closeEl || _this19.isZendesk()) {
          return;
        }

        // If panel is hidden - use coordinates from storage,
        // otherwise - calculate it using panel's coordinates
        var isPanelHidden = _this19.panelEl.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
        if (isPanelHidden) {
          closeEl.style.top = closeElTop + 'px';
          closeEl.style.left = closeElLeft + 'px';
        } else {
          window.setTimeout(function () {
            _this19.setCloseElementCoordinates();
          }, 100);
        }
      });
    }
  }, {
    key: 'createDragHandler',
    value: function createDragHandler() {
      var _this20 = this;

      var dragHandler = document.createElement('div');
      dragHandler.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('icon-draggable'));
      dragHandler.addEventListener('dblclick', function () {
        return _this20.resetCoordinates();
      });

      return dragHandler;
    }
  }, {
    key: 'toggleDragHandler',
    value: function toggleDragHandler(mode) {
      var panelDragHandler = this.panelDragHandler;

      var hideClass = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide');

      return panelDragHandler && (mode === 'show' ? panelDragHandler.classList.remove(hideClass) : panelDragHandler.classList.add(hideClass));
    }
  }, {
    key: 'setDraggable',
    value: function setDraggable() {
      var _this21 = this;

      return new Promise(function (res) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
          return document.body;
        }, function () {
          // Draggable library should be loaded here, because it has some body-related initialization,
          // which breaks the extension if there is no body yet
          var Draggable = __webpack_require__(711);
          var panelEl = _this21.panelEl,
              closeEl = _this21.closeEl;


          if (!panelEl) {
            res();
            return;
          }

          if (!_this21.panelDragHandler) {
            _this21.panelDragHandler = _this21.createDragHandler();
            panelEl.prepend(_this21.panelDragHandler);
          }

          var _window = window,
              innerWidth = _window.innerWidth,
              innerHeight = _window.innerHeight;
          var offsetWidth = panelEl.offsetWidth,
              offsetHeight = panelEl.offsetHeight;

          var closeElTransitionStyle = '';

          if (_this21.draggableInstance) {
            _this21.draggableInstance.destroy();
          }

          _this21.draggableInstance = new Draggable(panelEl, {
            useGPU: false,
            handle: _this21.panelDragHandler,
            setPosition: false,
            limit: {
              x: [1, innerWidth - offsetWidth],
              y: [1, innerHeight - offsetHeight]
            },
            onDragStart: function onDragStart() {
              if (closeEl) {
                // Clear widget transition to prevent delayed drag
                closeElTransitionStyle = closeEl.style.transition;
                closeEl.style.transition = 'initial';
              }
            },
            onDrag: function onDrag(element) {
              panelEl.style['z-index'] = '';
              _this21.setCloseElementCoordinates();
            },
            onDragEnd: function onDragEnd(element) {
              _this21.storeCoordinates();
              _this21.panelDragged = true;
              // Draggable sets some z-index on dragging, which should be removed
              // (make this async to make sure it runs after Draggable code)
              window.setTimeout(function () {
                return panelEl.style['z-index'] = '';
              }, 0);

              if (closeEl) {
                closeEl.style.transition = closeElTransitionStyle;
              }
            }
          });
          _this21.setCloseElementCoordinates();
          res();
        });
      });
    }
  }, {
    key: 'createClosePanel',
    value: function createClosePanel(tabId) {
      var _this22 = this;

      var closeEl = document.createElement('div');
      closeEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('widget', 'hide') + ' close-panel';
      closeEl.innerHTML = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18_base_common_svgInline_spinner_white__["a" /* default */])();
      closeEl.addEventListener('click', function () {
        return _this22.onCloseWidgetClick(tabId);
      });

      return closeEl;
    }
  }, {
    key: 'createZendeskClosePanel',
    value: function createZendeskClosePanel(tabId) {
      var _this23 = this;

      var closeEl = document.createElement('div');
      closeEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('zendesk-widget', 'zendesk-widget-close', 'hide') + ' ember-view dropdown pull-right user_option';
      closeEl.innerHTML = '\n      <div class="lotus-profile-menu">\n          <button class="js-lotus-profile-menu__toggle">\n              <div class="ember-view round-avatar">\n                  <figure class="thumbnail-container thumbnail-container--sm">\n                      ' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_21_base_common_svgInline_zendesk_widget_close_icon__["a" /* default */])() + '\n                  </figure>\n              </div>\n              <i class=""></i>\n          </button>\n      </div>\n    ';
      closeEl.addEventListener('click', function () {
        return _this23.onCloseWidgetClick(tabId);
      });

      return closeEl;
    }
  }, {
    key: 'getImplicitDomains',
    value: function getImplicitDomains() {
      // show zendesk tutorials on zendesk pages with custom domain
      // (not zendesk.com subdomains)
      var isDevEmbed = "embed" === 'embed' && "test.iorad.com" === 'development';
      var implicitDomains = [this.isZendesk() ? 'www.zendesk.com' : '', isDevEmbed ? 'test.iorad.com' : ''].filter(function (d) {
        return !!d;
      });
      return implicitDomains;
    }
  }, {
    key: 'toggleWidget',
    value: function toggleWidget(mode) {
      if (!this.widgetEl) return;

      if (mode === 'hide') {
        this.hideWidget();
        this.showCloseWidget();
      } else {
        this.showWidget();
        this.hideCloseWidget();
      }
    }
  }, {
    key: 'hideWidget',
    value: function hideWidget() {
      document.documentElement.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('widget-visible'));
      this.widgetEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      return this.widgetEl;
    }
  }, {
    key: 'showWidget',
    value: function showWidget() {
      document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('widget-visible'));
      this.widgetEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      return this.widgetEl;
    }

    // "Widget" here refers to the little button that can launch the panel.

  }, {
    key: 'getOrMakeWidget',
    value: function getOrMakeWidget(tabId) {
      var _this24 = this;

      // Always show in embed mode, only show for zendesk in extension mode (TODO: implement a full whitelist, see #717)
      var shouldShowButton = true || window.location.hostname.endsWith(".zendesk.com");
      if (!shouldShowButton) return Promise.resolve(); // Temporary hack to fix #388. But the widget should be moved to the embed specific files

      return !this.widgetEl ? new Promise(function (resolve) {
        var widget = _this24.isZendesk() ? _this24.createZendeskWidget(tabId) : _this24.createWidget(tabId);
        _this24.widgetEl = widget;

        if (_this24.isZendesk()) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_24_base_common_utils_waitFor__["a" /* default */])(function () {
            return document.querySelector(ZENDESK_WIDGET_CONTAINER);
          }, function () {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_utils_appendOnBodyLater__["a" /* default */])(widget, function () {
              resolve(widget);
            });
          });
        } else {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_utils_appendOnBodyLater__["a" /* default */])(widget, function () {
            resolve(widget);
          });
        }
      }) : Promise.resolve(this.widgetEl);
    }
  }, {
    key: 'createWidget',
    value: function createWidget(tabId) {
      var _this25 = this;

      var iconEl = document.createElement('div');
      iconEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('widget', 'hide');
      iconEl.innerHTML = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19_base_common_svgInline_widget_icon__["a" /* default */])();

      iconEl.addEventListener('click', function () {
        return _this25.onWidgetClick(tabId);
      });

      return iconEl;
    }
  }, {
    key: 'createZendeskWidget',
    value: function createZendeskWidget(tabId) {
      var _this26 = this;

      var iconEl = document.createElement('div');
      iconEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('zendesk-widget', 'hide') + ' ember-view dropdown pull-right user_option';
      iconEl.innerHTML = '\n      <div class="lotus-profile-menu">\n          <button class="js-lotus-profile-menu__toggle">\n              <div class="ember-view round-avatar">\n                  <figure class="thumbnail-container thumbnail-container--sm">\n                      ' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20_base_common_svgInline_zendesk_widget_icon__["a" /* default */])() + '\n                  </figure>\n              </div>\n              <i class=""></i>\n          </button>\n      </div>\n    ';
      iconEl.addEventListener('click', function () {
        return _this26.onWidgetClick(tabId);
      });

      return iconEl;
    }
  }, {
    key: 'updateWidget',
    value: function updateWidget() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$loadingStepPage = _ref5.loadingStepPage,
          loadingStepPage = _ref5$loadingStepPage === undefined ? false : _ref5$loadingStepPage,
          capturingActive = _ref5.capturingActive;

      if (this.closeEl) {
        var c = this.closeEl.classList;
        loadingStepPage ? c.add('loading-widget') : c.remove('loading-widget');
        capturingActive ? c.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('capturing')) : c.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('capturing'));
      }

      if (this.customColors && this.customColors.main) {
        if (this.widgetEl && !this.isZendesk()) this.widgetEl.style.backgroundColor = this.customColors.main;
        if (this.closeEl) {
          if (this.isZendesk()) {
            this.closeEl.querySelector('circle').style.fill = this.customColors.actionButton;
          } else {
            this.closeEl.style.backgroundColor = this.customColors.main;
          }
        }
      }
    }
  }, {
    key: 'onWidgetClick',
    value: function onWidgetClick(tabId) {
      this.backgroundPort.send({
        topic: 'showPanel',
        data: { explicit: true, tabId: tabId }
      });

      if (false) {
        // mimic chrome extension button click
        this.backgroundPort.send({ topic: 'handleActionButtonClick' });
      }
    }
  }, {
    key: 'monitorBodyForPanel',
    value: function monitorBodyForPanel() {
      var _this27 = this;

      setInterval(function () {
        if (!document.body.contains(_this27.panelEl)) {
          logger.debug('Panel was removed! Re-adding...');
          document.body.appendChild(_this27.panelEl);

          // re-set src in case it was removed
          _this27.panelEl.querySelector('iframe').src = _this27.panelSrc;
        }
      }, 100);
    }
  }, {
    key: 'cacheHeight',
    value: function cacheHeight(height) {
      if (this.panelEl) {
        var finalHeight = height;
        if (!finalHeight) {
          finalHeight = this.panelEl.offsetHeight + 'px';
        }
        if (parseInt(finalHeight, 10) === 0) finalHeight = '';

        this.panelHeight = finalHeight;
        this.extension.storage.set({ panelHeight: finalHeight });
      }
    }
  }, {
    key: 'calculatePanelRealBounds',
    value: function calculatePanelRealBounds() {
      return; // DISABLED FOR NOW

      if (!this.panelEl) return;
      var height = this.panelInnerHeight;
      var capturingActive = this.panelEl.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('capturing'));
      var panelBounds = this.panelEl.getBoundingClientRect();
      var panelRealHeight = height && (!isNaN(height) || height.indexOf('px') !== -1) ? parseInt(height, 10) : panelBounds.height;

      // (assignIn since panelBounds props aren't owned)
      this.panelRealBounds = __WEBPACK_IMPORTED_MODULE_15_lodash_assignIn___default()({}, panelBounds, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({
        height: panelRealHeight

      }, capturingActive ? { bottom: panelBounds.top + panelRealHeight } : { top: panelBounds.bottom - panelRealHeight }));
    }
  }, {
    key: 'updatePanelMaxHeight',
    value: function updatePanelMaxHeight() {
      var maxHeight = Math.max(Math.min(window.innerHeight - 60, 630), 250);
      if (this.panelEl) this.panelEl.style.maxHeight = maxHeight + 'px';
    }
  }, {
    key: 'updateContainer',
    value: function updateContainer(_ref6) {
      var _this28 = this;

      var containerHeight = _ref6.containerHeight,
          capturingActive = _ref6.capturingActive;

      if (!this.panelEl) return;

      var mutate = function mutate() {
        _this28.panelEl.style.height = containerHeight;

        // Wait for height stretching to finish
        window.setTimeout(function () {
          return _this28.setCloseElementCoordinates();
        }, 1000);
        _this28.cacheHeight();

        //this.panelInnerHeight = containerHeight;
        //this.calculatePanelRealBounds();
      };

      this.panelEl.classList[containerHeight.match('%') ? 'remove' : 'add'](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('adaptive'));

      if (capturingActive) {
        this.panelEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('capturing'));
        this.resetCoordinates();
        this.toggleDragHandler('hide');
      } else {
        this.panelEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('capturing'));
      }

      mutate();
    }
  }, {
    key: 'isCaptureStartConfirmationNeeded',
    value: function isCaptureStartConfirmationNeeded() {
      var _this29 = this;

      return Promise.resolve(false); // DISABLED

      return new Promise(function (resolve) {
        _this29.backgroundPort.send({ topic: 'getConfirmCaptureStart' }, function (_ref7) {
          var confirmCaptureStart = _ref7.confirmCaptureStart;
          return resolve(confirmCaptureStart);
        });
      });
    }
  }, {
    key: 'confirmCaptureStart',
    value: function confirmCaptureStart() {
      var _this30 = this;

      return new Promise(function (resolve) {
        var saveDontShow = function saveDontShow(dontShow) {
          _this30.backgroundPort.send({
            topic: 'setConfirmCaptureStart',
            data: { confirmCaptureStart: !dontShow }
          });
        };
        _this30.isCaptureStartConfirmationNeeded().then(function (confirmNeeded) {
          if (!confirmNeeded) resolve(true);else {
            _this30.backgroundPort.send({
              topic: 'hidePanel',
              data: { explicit: true }
            });

            var dialog = document.createElement('div');
            var closeDialog = function closeDialog() {
              return dialog.parentNode.removeChild(dialog);
            };
            var render = function render() {
              return __WEBPACK_IMPORTED_MODULE_10__common_utils_reactRender___default()(__WEBPACK_IMPORTED_MODULE_11__components_CaptureStartDialog___default.a, {
                onStart: __WEBPACK_IMPORTED_MODULE_13_lodash_flowRight___default()(function () {
                  return resolve(true);
                }, closeDialog, saveDontShow),
                onClose: __WEBPACK_IMPORTED_MODULE_13_lodash_flowRight___default()(function () {
                  return resolve(false);
                }, closeDialog)
              }, dialog);
            };
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_utils_appendOnBodyLater__["a" /* default */])(dialog, render);
          }
        });
      });
    }
  }, {
    key: 'updateForBackground',
    value: function updateForBackground(oldState, state, tabId) {
      var _this31 = this;

      if (!this.extension.isTopFrame) return;

      this.checkOverlay();

      var capturePaused = Boolean(state.capture && state.capture.browserState === 'paused');
      if (this.capturePaused !== capturePaused) {
        this.capturePaused = capturePaused;
        this.emit('change:capturePaused');
      }

      this.flux.updater(oldState, state, [['activeTabId', function (activeTabId) {
        if (activeTabId !== tabId && !state.isCurrentPagePopup) {
          // delayed because of #802
          _this31.disablePanelLater();
        } else {
          _this31.enablePanel();
        }
      }], ['isCurrentPagePopup', function (isCurrentPagePopup) {
        if (isCurrentPagePopup) {
          // we still want to update the panel in the parent window
          _this31.enablePanel();
        }
      }]]);
    }
  }, {
    key: 'updateForPanel',
    value: function updateForPanel(oldState, state) {
      var _this32 = this;

      this.updateContainer(state);
      this.updateWidget(state);
      this.checkOverlay();

      this.flux.updater(oldState, state, [['containerHeight', this.cacheHeight.bind(this)], ['tutorialsCount', function (tutorialsCount) {
        if (_this32.backgroundPort) {
          _this32.backgroundPort.send({
            topic: 'tutorialsCountChanged',
            data: { tutorialsCount: tutorialsCount }
          });
        }
      }]]);
    }
  }, {
    key: 'updateForContent',
    value: function updateForContent(oldState, state) {
      this.flux.updater(oldState, state, [[true && 'intercomInstalled', this.toggleIntercomExistence.bind(this)]]);
    }

    // NOTE: this is used by inject.js

  }, {
    key: 'handleColors',
    value: function handleColors(colors) {
      this.customColors = colors;

      // also update panel
      this.flux.panelContext().dispatch('colorsChanged', colors);

      this.updateWidget();
    }
  }, {
    key: 'registerPanel',
    value: function registerPanel() {
      var _this33 = this;

      this.panelPort.send('handleUpwardState', {
        background: this.flux.backgroundContext().state,
        panel: this.flux.panelContext().state
      });

      this.getUserData().then(function (data) {
        _this33.flux.panelContext().dispatch('restoreSavedState', data);
      });
      if (this.autoOpenLiveId) {
        var open = function open() {
          _this33.flux.panelContext().dispatch('selectTutorial', _this33.autoOpenLiveId);
        };
        this.backgroundPort.send({ topic: 'hideTutorialSelect' });
        if (this.panelPort.isDisabled()) {
          this.once('enablePanel', open);
          this.backgroundPort.send({ topic: 'requireTabFocus' });
        } else {
          open();
        }
      }
    }
  }, {
    key: 'getUserData',
    value: function getUserData() {
      var _this34 = this;

      return new Promise(function (resolve) {
        _this34.backgroundPort.send({ topic: 'getUserData' }, resolve);
      });
    }
  }, {
    key: 'setUserData',
    value: function setUserData(userData) {
      var _this35 = this;

      return new Promise(function (resolve) {
        _this35.backgroundPort.send({ topic: 'setUserData', data: { userData: userData } }, resolve);
      });
    }
  }, {
    key: 'toggleIntercomExistence',
    value: function toggleIntercomExistence(toggle) {
      if (toggle) {
        var isPanelOpen = document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('panel-open'));
        if (isPanelOpen) this.showChatButtonWidget();
      } else {
        this.hideChatButtonWidget();
      }
    }
  }, {
    key: 'toggleIntercom',
    value: function toggleIntercom() {
      var el = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_28_base_common_utils_intercom__["a" /* getIntercomLauncher */])();
      if (el) el.click();
    }
  }, {
    key: 'openTutorials',
    value: function openTutorials() {
      this.toggleIntercom(); // close Intercom
      this.toggleChatButtonWidgetLabel();
      this.showChatButtonWidget();
    }
  }, {
    key: 'onCloseWidgetClick',
    value: function onCloseWidgetClick(tabId) {
      var _this36 = this;

      this.backgroundPort.send({
        topic: 'hidePanel',
        data: { explicit: true }
      });

      // Wait a bit to let panel disappear
      window.setTimeout(function () {
        return _this36.resetCoordinates();
      }, 500);
    }
  }, {
    key: 'hideCloseWidget',
    value: function hideCloseWidget() {
      if (this.closeEl) this.closeEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      return this.closeEl;
    }
  }, {
    key: 'showCloseWidget',
    value: function showCloseWidget() {
      if (this.closeEl) this.closeEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_namespace__["a" /* default */])('hide'));
      return this.closeEl;
    }

    // iframe is optional (must be passed only if it isn't appended into this.panelEl yet)

  }, {
    key: '_waitIframeLoad',
    value: function _waitIframeLoad(iframe) {
      var _this37 = this;

      if (this._waitIframeLoadPromise) return this._waitIframeLoadPromise;
      this._waitIframeLoadPromise = new Promise(function (resolve, reject) {
        iframe = iframe || _this37.panelEl.querySelector('iframe');
        var handleLoad = function handleLoad() {
          var timer = void 0;

          // Workaround for https://github.com/iorad/iorad-extension/issues/867#issuecomment-329178564
          // Chrome replaces the panel iframe window with another iframe in the page,
          // the actual panel -> page communication still works, but the other way around doesn't,
          // thus we detect this case by checking if the panel is receiving the page messages,
          // if that doesn't happen after a certain amount of time, then we know the bug happened
          // and we fix it by reloading the iframe.

          iframe.contentWindow.postMessage({ topic: 'panelChallenge:request' }, '*');

          var listener = ['message', function (event) {
            var message = event.data;
            if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;
            if (message.topic === 'panelChallenge:response') {
              __WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__["c" /* removeWindowListener */].apply(undefined, listener);
              clearTimeout(timer);

              resolve();
            }
          }];
          __WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__["a" /* addWindowListener */].apply(undefined, listener);

          timer = setTimeout(function () {
            __WEBPACK_IMPORTED_MODULE_27_base_common_utils_windowEvents__["c" /* removeWindowListener */].apply(undefined, listener);
            // reload and try again
            var iframeSrc = iframe.src;
            iframe.src = '';
            iframe.onload = function () {
              iframe.src = iframeSrc;
              _this37._waitIframeLoad(iframe).then(resolve, reject);
            };
          }, 1000);
        };
        if (window.ioradPanelIframeLoaded) handleLoad(); // (for prefetched iframe, in embed)
        else iframe.onload = handleLoad;
      });
      return this._waitIframeLoadPromise;
    }
  }]);

  return PanelController;
}(__WEBPACK_IMPORTED_MODULE_8_base_common_Component__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/PanelController.js"))

/***/ }),
/* 523 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_last__ = __webpack_require__(492);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_last___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash_last__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_throttle__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_throttle___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_throttle__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__getElementVisualBounds__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__getWindowScrollOffset__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__elementLocator__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_base_common_utils_timers__ = __webpack_require__(520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_base_common_utils_documentSize__ = __webpack_require__(311);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_base_common_utils_logger__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__elementOnTop__ = __webpack_require__(525);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_base_common_utils_dom__ = __webpack_require__(277);





















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19_base_common_utils_logger__["a" /* getFileLogger */])(__filename);



// Some utitilies that I wanted to avoid loading from lodash because this goes
// into the per-frame bundle
function maxBy(ary, mapper) {
  return ary.reduce(function (a, b) {
    return mapper(b) > mapper(a) ? b : a;
  });
}

function every(ary, mapper) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = ary[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var x = _step.value;

      if (!mapper(x)) return false;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}

function some(ary, mapper) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = ary[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var x = _step2.value;

      if (mapper(x)) return true;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return false;
}

function without(ary, item) {
  return ary.filter(function (x) {
    return x !== item;
  });
}

function uniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

  return prefix + uniqueId.counter++;
}
uniqueId.counter = 0;

// Just handles simple objects
function deepEqual(a, b) {
  if (a === b) return true;
  if ((typeof a === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_typeof___default()(a)) !== "object" || (typeof b === "undefined" ? "undefined" : __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_typeof___default()(b)) !== "object") return false;
  var keysA = Object.keys(a),
      keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  keysA.sort();
  keysB.sort();
  for (var i = 0; i < keysA.length; i++) {
    if (keysA[i] !== keysB[i]) return false;
  }
  for (var _i = 0; _i < keysA.length; _i++) {
    var key = keysA[_i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

function elementInViewport(document, el) {
  var rect = el.getBoundingClientRect();

  return rect.top >= 0 && rect.left >= 0 && Math.floor(rect.bottom) <= (window.innerHeight || document.documentElement.clientHeight) && Math.floor(rect.right) <= (window.innerWidth || document.documentElement.clientWidth) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20__elementOnTop__["a" /* default */])(el, rect);
}

var RPCTimeout = function (_Error) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(RPCTimeout, _Error);

  function RPCTimeout(m) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, RPCTimeout);

    var _this = __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RPCTimeout.__proto__ || Object.getPrototypeOf(RPCTimeout)).call(this, m || "Timeout"));

    _this.rpctimeout = true;
    return _this;
  }

  return RPCTimeout;
}(Error);

var FrameRPC = function () {
  function FrameRPC(namespace) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, FrameRPC);

    this._pending = {};
    this._methods = {};
    this._namespace = namespace;
    __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["c" /* onMessage */](namespace + ":rpc:call", this._receiveCall.bind(this));
    __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["c" /* onMessage */](namespace + ":rpc:response", this._receiveResponse.bind(this));
    __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["c" /* onMessage */](namespace + ":rpc:heartbeat", this._receivedHeartbeat.bind(this));
    this._timeout = timeout;
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FrameRPC, [{
    key: "_receiveCall",
    value: function _receiveCall(message) {
      var _this2 = this;

      var _message$payload = message.payload,
          id = _message$payload.id,
          method = _message$payload.method,
          arg = _message$payload.arg;

      var sent = false;
      var send = function send(error, result) {
        __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["a" /* send */](message.frameId, _this2._namespace + ":rpc:response", {
          error: error,
          result: result,
          id: id
        });
        sent = true;
      };

      var heartbeat = function heartbeat() {
        if (sent) return;
        __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["a" /* send */](message.frameId, _this2._namespace + ":rpc:heartbeat", {
          id: id
        });
      };

      if (method in this._methods) {
        var result = this._methods[method](arg, __WEBPACK_IMPORTED_MODULE_11_lodash_throttle___default()(heartbeat, Math.min(500, this._timeout / 10), { leading: false })).then(function (result) {
          send(null, result);
        }, function (error) {
          send(error.toString(), null);
        });
      } else {
        send("RPC method not found", null);
      }
    }
  }, {
    key: "_receiveResponse",
    value: function _receiveResponse(message) {
      var _message$payload2 = message.payload,
          id = _message$payload2.id,
          result = _message$payload2.result,
          error = _message$payload2.error;

      if (id in this._pending) {
        logger.debug("Received response for pending id", id);
        var _pending$id = this._pending[id],
            resolve = _pending$id.resolve,
            reject = _pending$id.reject,
            timeoutId = _pending$id.timeoutId;

        delete this._pending[id];
        clearTimeout(timeoutId);
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      } else {
        logger.error("Got a response for a call we don't having pending");
      }
    }
  }, {
    key: "_receivedHeartbeat",
    value: function _receivedHeartbeat(message) {
      var id = message.payload.id;

      this._resetTimeout(id);
      if (id in this._pending) {
        var options = this._pending[id].options;

        if (options.heartbeat) {
          options.heartbeat();
        }
      }
    }
  }, {
    key: "_resetTimeout",
    value: function _resetTimeout(id) {
      if (!(id in this._pending)) return;
      var _pending$id2 = this._pending[id],
          options = _pending$id2.options,
          timeoutFn = _pending$id2.timeoutFn,
          timeoutId = _pending$id2.timeoutId,
          method = _pending$id2.method;

      if (timeoutId) {
        logger.info("Reset timeout in FrameRPC, id", id);
        clearTimeout(timeoutId);
      }
      var newTimeoutId = setTimeout(timeoutFn, options.timeout == null ? this._timeout : options.timeout);
      this._pending[id].timeoutId = newTimeoutId;
    }
  }, {
    key: "register",
    value: function register(method, fn) {
      this._methods[method] = fn;
    }

    // Only use this with destinations that indicate a single frame

  }, {
    key: "call",
    value: function call(destination, method, arg) {
      var _this3 = this;

      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      return new Promise(function (resolve, reject) {
        var id = uniqueId();
        logger.debug("Call", method, "with id", id);
        var timeoutFn = function timeoutFn() {
          if (id in _this3._pending) {
            delete _this3._pending[id];
            reject(new RPCTimeout("Timeout: " + method));
          }
        };
        _this3._pending[id] = {
          resolve: resolve,
          reject: reject,
          timeoutId: null,
          timeoutFn: timeoutFn,
          options: options
        };
        _this3._resetTimeout(id);
        __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["a" /* send */](destination, _this3._namespace + ":rpc:call", {
          arg: arg,
          method: method,
          id: id
        });
      });
    }
  }]);

  return FrameRPC;
}();

// Runs in all frames (including top)


var LocatorSearcherNode = function () {
  function LocatorSearcherNode() {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, LocatorSearcherNode);

    this._rpc = new FrameRPC("LocatorSearcherNode");
    this._rpc.register("search", this.search.bind(this, window.document));
    this._rpc.register("ping", this._pingReceived.bind(this));

    this._isDomContentLoaded = false;
    this.locatedEls = [];

    this._setupEventListeners();

    this._frameResponds = new WeakMap();
    this._domVersion = Date.now();
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(LocatorSearcherNode, [{
    key: "_pingReceived",
    value: function () {
      var _ref = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee() {
        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", "pong");

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _pingReceived() {
        return _ref.apply(this, arguments);
      }

      return _pingReceived;
    }()
  }, {
    key: "_doesFrameRespond",
    value: function () {
      var _ref2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee2(iframe) {
        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._frameResponds.has(iframe)) {
                  _context2.next = 14;
                  break;
                }

                _context2.prev = 1;
                _context2.next = 4;
                return this._rpc.call(iframe.contentWindow, "ping", null, {
                  timeout: 1000
                });

              case 4:
                this._frameResponds.set(iframe, { responds: true });
                _context2.next = 14;
                break;

              case 7:
                _context2.prev = 7;
                _context2.t0 = _context2["catch"](1);

                if (!_context2.t0.rpctimeout) {
                  _context2.next = 13;
                  break;
                }

                this._frameResponds.set(iframe, { responds: false });
                _context2.next = 14;
                break;

              case 13:
                throw _context2.t0;

              case 14:
                return _context2.abrupt("return", this._frameResponds.get(iframe).responds);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 7]]);
      }));

      function _doesFrameRespond(_x4) {
        return _ref2.apply(this, arguments);
      }

      return _doesFrameRespond;
    }()
  }, {
    key: "_setupEventListeners",
    value: function _setupEventListeners() {
      var _this4 = this;

      document.addEventListener("DOMContentLoaded", function () {
        _this4._isDomContentLoaded = true;
        _this4._notifyFrameChange();
      });
      if (document.readyState === "complete" || document.readyState === "interactive") {
        this._isDomContentLoaded = true;
      }

      // Wait for changes in the href (possible in more places than just
      // the hash because of history api)
      var currentHref = null;
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_timers__["a" /* safeSetInterval */])(function () {
        var href = document.location.href;

        if (href !== currentHref) {
          currentHref = href;
          _this4._notifyFrameChange();
        }
      }, 500);

      document.addEventListener("scroll", function () {
        _this4._notifyFrameChange();
      }, true);

      ["resize"].forEach(function (eventName) {
        window.addEventListener(eventName, __WEBPACK_IMPORTED_MODULE_11_lodash_throttle___default()(function () {
          _this4._notifyFrameChange();
        }, 200), true);
      });

      var observer = new MutationObserver(function (mutations) {
        if (!document.body || !_this4.locatedEls) return;
        if (_this4.locatedEls.length && _this4.locatedEls[0].els.find(function (el) {
          return !document.body.contains(el);
        })) {
          // a located element was removed from the DOM
          // NOTE: use reset option in case the "same" element is added later (see #923)
          _this4._domVersion = Date.now();
          _this4._notifyFrameChange();
        }
      });
      observer.observe(document.documentElement, {
        subtree: true,
        childList: true
      });

      document.addEventListener("mousedown", function () {
        __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["e" /* TOP */], "ContentPlayer:mousedown");
      }, true);
    }
  }, {
    key: "_notifyFrameChange",
    value: function _notifyFrameChange(options) {
      __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["e" /* TOP */], "LocatorSearcherNode:frameChange", options);
    }
  }, {
    key: "isGoodElement",
    value: function isGoodElement(el) {
      var _this5 = this;

      if (!el) return false;
      if (Array.isArray(el)) return some(el, function (el) {
        return _this5.isGoodElement(el);
      });
      if (el === window) return true;
      // I've removed the document.contains check because we sometimes look inside
      // same origin iframes -tom
      // if (!document.contains(el)) return false;

      // Note: we use this 'every' approach since
      // bounds property are not enumerables (are virtuals)
      /*const bounds = el.getBoundingClientRect();
      if (every(["x", "y", "width", "height"], b => bounds[b] === 0))
        return false;*/

      return true;
    }
  }, {
    key: "elementVisible",
    value: function elementVisible(document, el) {
      if (!this.isGoodElement(el)) return false;
      if (!elementInViewport(document, el)) return false;

      return true;
    }
  }, {
    key: "search",
    value: function () {
      var _ref3 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee4(document, options) {
        var _this6 = this;

        var sendHeartbeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
        var iframes, offset, frameId, candidates, bestCandidate, locatorData, els, locatorId;
        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                logger.debug("search: search in document", document);

                if (this._isDomContentLoaded) {
                  _context4.next = 4;
                  break;
                }

                logger.debug("search: dom content not loaded");
                return _context4.abrupt("return", null);

              case 4:
                if (!(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_base_common_utils_documentSize__["a" /* getDocumentHeight */])() <= 8)) {
                  _context4.next = 7;
                  break;
                }

                logger.debug("search: no height frame");
                return _context4.abrupt("return", null);

              case 7:
                iframes = Array.prototype.slice.call(document.querySelectorAll("iframe"));
                offset = options.offset, frameId = options.frameId;


                sendHeartbeat();

                _context4.next = 12;
                return Promise.all(iframes.map(function () {
                  var _ref4 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee3(iframe) {
                    var isExtensionBaseUrl, bounds, frameOptions, frameDocument, results;
                    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            // If the frame belongs to the extension then ignore it
                            isExtensionBaseUrl = iframe.src.startsWith("chrome-extension://") || iframe.src.startsWith("ms-browser-extension://") || iframe.src.startsWith("moz-extension://");

                            if (!isExtensionBaseUrl) {
                              _context3.next = 3;
                              break;
                            }

                            return _context3.abrupt("return", null);

                          case 3:
                            bounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13__getElementVisualBounds__["a" /* default */])(iframe);
                            frameOptions = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, options, {
                              depth: options.depth + 1,
                              offset: { x: bounds.x + offset.x, y: bounds.y + offset.y },
                              frameId: frameId === __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["d" /* frameId */] ? undefined : frameId // reset frameId so that we can also search on its sub frames
                            });
                            _context3.prev = 5;
                            _context3.next = 8;
                            return _this6._doesFrameRespond(iframe);

                          case 8:
                            if (!_context3.sent) {
                              _context3.next = 15;
                              break;
                            }

                            logger.debug("search: iframe responds to messages, calling via rpc", iframe);
                            _context3.next = 12;
                            return _this6._rpc.call(iframe.contentWindow, "search", frameOptions, {
                              heartbeat: sendHeartbeat // Forward heartbeat signals up the chain
                            });

                          case 12:
                            return _context3.abrupt("return", _context3.sent);

                          case 15:
                            // Not responding. But maybe we can access directly into the frame?
                            // (will work if the frame is same origin. This is often useful in
                            // Widget mode, can't think when it'd ever be used in extension mode
                            // but it doesn't hurt)
                            frameDocument = void 0;
                            _context3.prev = 16;

                            frameDocument = iframe.contentDocument;
                            logger.debug("search: calling via direct access for frame", iframe);
                            _context3.next = 25;
                            break;

                          case 21:
                            _context3.prev = 21;
                            _context3.t0 = _context3["catch"](16);

                            // We weren't allowed to access the document (cross origin), so ignore this frame
                            logger.debug("search: can't access frame, ignoring", iframe);
                            return _context3.abrupt("return", null);

                          case 25:
                            _context3.next = 27;
                            return _this6.search(frameDocument, frameOptions, sendHeartbeat);

                          case 27:
                            results = _context3.sent;
                            return _context3.abrupt("return", results);

                          case 29:
                            _context3.next = 35;
                            break;

                          case 31:
                            _context3.prev = 31;
                            _context3.t1 = _context3["catch"](5);

                            logger.error("Got error from child search call: " + _context3.t1);
                            return _context3.abrupt("return", null);

                          case 35:
                            _context3.prev = 35;

                            sendHeartbeat();
                            return _context3.finish(35);

                          case 38:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, _this6, [[5, 31, 35, 38], [16, 21]]);
                  }));

                  return function (_x8) {
                    return _ref4.apply(this, arguments);
                  };
                }()));

              case 12:
                _context4.t0 = function (x) {
                  return x != null;
                };

                candidates = _context4.sent.filter(_context4.t0);
                bestCandidate = candidates.length > 0 ? maxBy(candidates, function (c) {
                  return c.score;
                }) : null;


                if (bestCandidate) {
                  logger.debug("search: got candidate", bestCandidate);
                }

                // See if we can find (better) candidates on this frame itself
                locatorData = void 0;

                if (typeof frameId !== "undefined" && frameId !== __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["d" /* frameId */] && this.locatorData) {
                  // This frame didn't change, just reuse the old result
                  locatorData = this.locatorData;
                } else {
                  locatorData = this.locatorData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__elementLocator__["a" /* locateElement */])(options.locator, {
                    document: document,
                    multipleMatches: options.multipleMatches
                  });
                }

                if ((bestCandidate == null || locatorData.score > bestCandidate.score) && locatorData.el && this.isGoodElement(locatorData.el)) {
                  els = Array.isArray(locatorData.el) ? locatorData.el : [locatorData.el];
                  locatorId = uniqueId(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["d" /* frameId */]);

                  // make them visible before calculating bounds
                  // (or they will be 0)

                  this.makeAncestorsVisible(els);

                  this.locatedEls = [{ els: els, locatorId: locatorId }].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(this.locatedEls)).slice(0, 3); // Keep the last 3 around

                  bestCandidate = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({
                    locatorId: locatorId
                  }, locatorData, {
                    el: !!locatorData.el,
                    frameId: __WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["d" /* frameId */],
                    domVersion: this._domVersion,
                    elementBounds: els.map(function (el) {
                      var _getElementVisualBoun = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13__getElementVisualBounds__["a" /* default */])(el, true),
                          x = _getElementVisualBoun.x,
                          y = _getElementVisualBoun.y,
                          width = _getElementVisualBoun.width,
                          height = _getElementVisualBoun.height;

                      var visible = _this6.elementVisible(document, el);
                      // Adjust bounds to the reference frame of the root frame
                      return {
                        x: x + offset.x,
                        y: y + offset.y,
                        width: width,
                        height: height,
                        visible: visible
                      };
                    })
                  });

                  logger.debug("search: found better candidate", bestCandidate);
                }
                return _context4.abrupt("return", bestCandidate);

              case 20:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function search(_x5, _x6) {
        return _ref3.apply(this, arguments);
      }

      return search;
    }()

    // Experimental, see #960

  }, {
    key: "makeAncestorsVisible",
    value: function makeAncestorsVisible(elements) {
      var rules = {
        display: ['none', 'inline-block'],
        opacity: ['0', '1'],
        visibility: ['hidden', 'visible'],
        height: ['0px', 'auto']
      };

      elements.forEach(function (el) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_21_base_common_utils_dom__["a" /* closest */])(el.parentElement, function (parentEl) {
          var computedStyles = window.getComputedStyle(parentEl);
          Object.keys(rules).forEach(function (propName) {
            //console.log(parentEl, propName, computedStyles[propName]);
            var _rules$propName = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(rules[propName], 2),
                hiddenValue = _rules$propName[0],
                visibleValue = _rules$propName[1];

            if (computedStyles[propName] === hiddenValue) {
              parentEl.style[propName] = visibleValue;
            }
          });
          return false; // HACK: use closest() as a forEach for ancestors
        });
      });
    }
  }]);

  return LocatorSearcherNode;
}();

// Only runs in the top frame


var LocatorSearcherController = function () {
  function LocatorSearcherController(node) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, LocatorSearcherController);

    this.node = node;
    this.pendingSearches = [];
  }

  // Takes a locator and returns a promise for information about it


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(LocatorSearcherController, [{
    key: "search",
    value: function () {
      var _ref5 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee5(options) {
        var _this7 = this;

        var pending, lastPending, lastPendingPromise, promise, pendingItem;
        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                pending = this.pendingSearches.find(function (_ref6) {
                  var _ref7 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref6, 2),
                      o = _ref7[0],
                      p = _ref7[1];

                  return deepEqual(o, options);
                });

                if (!pending) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", pending[1]);

              case 3:

                // We want to only be doing one search at a time (it's too intensive
                // otherwise)
                lastPending = __WEBPACK_IMPORTED_MODULE_10_lodash_last___default()(pending);
                lastPendingPromise = lastPending ? lastPending[1] : Promise.resolve();
                promise = lastPendingPromise.then(function () {
                  return _this7.node.search(window.document, __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, options, {
                    offset: { x: 0, y: 0 },
                    depth: 0
                  })).then(function (locatorData) {
                    if (locatorData && locatorData.elementBounds) {
                      var _getWindowScrollOffse = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14__getWindowScrollOffset__["a" /* default */])(),
                          x = _getWindowScrollOffse.x,
                          y = _getWindowScrollOffse.y;

                      var elementBounds = locatorData.elementBounds;
                      return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, locatorData, {
                        elementBounds: elementBounds.map(function (b) {
                          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, b, {
                            x: b.x + x,
                            y: b.y + y
                          });
                        })
                      });
                    }
                    return locatorData;
                  });
                });
                pendingItem = [options, promise];

                this.pendingSearches.push(pendingItem);
                _context5.prev = 8;
                _context5.next = 11;
                return promise;

              case 11:
                return _context5.abrupt("return", _context5.sent);

              case 12:
                _context5.prev = 12;

                // Will always be the first one so we could just use a slice here assuming
                // we're still only allowing one search to happen at once, but let's be a
                // bit more robust to future code changes :)
                this.pendingSearches = without(this.pendingSearches, pendingItem);
                return _context5.finish(12);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[8,, 12, 15]]);
      }));

      function search(_x9) {
        return _ref5.apply(this, arguments);
      }

      return search;
    }()
  }]);

  return LocatorSearcherController;
}();

var LocatorSearcherInterface = function () {
  function LocatorSearcherInterface() {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, LocatorSearcherInterface);

    var isTopFrame = window.parent === window;
    this._rpc = new FrameRPC("LocatorSearcherInterface");

    this._node = new LocatorSearcherNode();

    if (isTopFrame) {
      this._controller = new LocatorSearcherController(this._node);
      this._rpc.register("search", this._controller.search.bind(this._controller));
    }
  }

  // Lookup the actual elements for a given locatorId (only works if the locator
  // was in this frame AND if was 3 searches ago or less)


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(LocatorSearcherInterface, [{
    key: "getEls",
    value: function getEls(locatorId) {
      var found = this._node.locatedEls.find(function (x) {
        return x.locatorId === locatorId;
      });
      if (found) {
        return found.els;
      } else {
        return [];
      }
    }
  }, {
    key: "search",
    value: function () {
      var _ref8 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee6(locator) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!this._controller) {
                  _context6.next = 4;
                  break;
                }

                return _context6.abrupt("return", this._controller.search(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({ locator: locator }, options)));

              case 4:
                return _context6.abrupt("return", this._rpc.call(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_frameMessages__["e" /* TOP */], "search", __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({
                  locator: locator
                }, options)));

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function search(_x10) {
        return _ref8.apply(this, arguments);
      }

      return search;
    }()
  }]);

  return LocatorSearcherInterface;
}();

var DUPE_CHECK_KEY = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18_base_common_utils_namespace__["a" /* default */])("LocatorSearcher-loaded");
if (window[DUPE_CHECK_KEY]) {
  // Webpack CommonsChunkPlugin should ensure this, but it'll cause crazy hard
  // to find bugs if it breaks
  throw new Error("IORAD: Should be only one instance of locatorsearcher per content");
}
window[DUPE_CHECK_KEY] = true;

/* harmony default export */ __webpack_exports__["a"] = new LocatorSearcherInterface();
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/player/LocatorSearcher.js"))

/***/ }),
/* 524 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__elementLocator__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_utils_expandMarker__ = __webpack_require__(312);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__common_utils_rgbToArray__ = __webpack_require__(599);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__common_utils_rgbaToArray__ = __webpack_require__(600);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_every__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_every__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_flowRight__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_flowRight___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash_flowRight__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_mapValues__ = __webpack_require__(303);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_mapValues___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_mapValues__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_times__ = __webpack_require__(550);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_times___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_times__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_toPairs__ = __webpack_require__(754);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_toPairs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_toPairs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_head__ = __webpack_require__(747);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_head___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_lodash_head__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__getElementVisualBounds__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_base_common_svgInline_tools__ = __webpack_require__(583);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_parse_color__ = __webpack_require__(763);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_parse_color___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_parse_color__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SELECTOR_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return drawMarker; });
/* unused harmony export hideMarker */








var _drawMarker = function () {
  var _ref5 = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(markerBounds, type) {
    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var enabledMarkerIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

    var _this = this;

    var isMobile = arguments[5];
    var opts = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};

    var time, currentEls, newEls, panel, _loop, i, _ret;

    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            time = newTime;

            markerBounds = Array.isArray(markerBounds) ? markerBounds : [markerBounds]; // might also be [null] !

            currentEls = Array.from(document.querySelectorAll('.' + SELECTOR_ID));
            newEls = [];
            panel = document.querySelector('.' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20_base_common_utils_namespace__["a" /* default */])('panel'));
            _loop = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _loop(i) {
              var bounds, markerEl, replaceInfo, infoKey, givenId, uid, markerInfoEl, infoPosition, borderColorStr, borderColor;
              return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      bounds = markerBounds[i];
                      markerEl = currentEls[i]; // might be undefined

                      if (!(bounds === null || __WEBPACK_IMPORTED_MODULE_11_lodash_every___default()(__WEBPACK_IMPORTED_MODULE_16_lodash_values___default()(bounds), function (b) {
                        return b === 0;
                      }))) {
                        _context.next = 6;
                        break;
                      }

                      if (markerEl) {
                        markerEl.style.visibility = 'hidden';
                      }
                      newEls.push(null);
                      return _context.abrupt('return', 'continue');

                    case 6:

                      // border expands inside rather than outside to prevent window overflow
                      // and we expand marker size respectively but limited with window size
                      bounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__common_utils_expandMarker__["a" /* default */])(borderWidth, window.innerWidth, window.innerHeight, bounds);

                      replaceInfo = true;
                      infoKey = type + '-' + color + '-' + isMobile + '-' + i;

                      if (!markerEl) {
                        markerEl = document.createElement('DIV');
                      } else {
                        replaceInfo = markerEl.getAttribute('data-info-key') !== infoKey;
                      }

                      givenId = markerEl.getAttribute('data-id');
                      uid = id + '-' + i;


                      if (replaceInfo) {
                        markerEl.setAttribute('data-info-key', infoKey);
                        markerEl.innerHTML = '';
                        markerEl.appendChild(makeMarkerInfo(type, color, isMobile, opts));
                        // we always set the style because it might change from PREVIEW to non PREVIEW type
                        markerEl.setAttribute('style', styleObjToImportantString(selectorStyle(type, i)));
                      }

                      // We always append because we want to make sure we're always the
                      // *last* element of body and even if we've appended before other
                      // things might have been added after us since.
                      // panel should be after marker so it doesn't overlap
                      // FIXME: maybe we should move panel to the end as well
                      if (panel) {
                        document.body.insertBefore(markerEl, panel);
                      } else {
                        document.body.appendChild(markerEl);
                      }

                      markerInfoEl = markerEl.firstChild;

                      directions.map(function (s) {
                        return markerInfoEl.classList.remove(className(s));
                      });
                      infoPosition = markerInfoPosition(bounds, window.innerWidth, window.innerHeight, markerBounds.length > 1);

                      markerInfoEl.classList.add(className(infoPosition));
                      markerInfoEl.style.borderColor = color || '';
                      // show the marker info only on the first marker
                      if (i === 0) {
                        markerInfoEl.style.visibility = '';
                      } else {
                        markerInfoEl.style.visibility = 'hidden';
                      }

                      if (givenId !== uid) {
                        //if (i == enabledMarkerIndex) animateMarkerInfo(markerInfoEl, infoPosition);
                        markerEl.setAttribute('data-id', uid);
                      }

                      markerEl.className = SELECTOR_ID + ' ' + className(type) + (isMobile ? ' ' + className('mobile') : '');
                      markerEl.style.left = bounds.x + 'px';
                      markerEl.style.top = bounds.y + 'px';
                      markerEl.style.width = bounds.width + 'px';
                      markerEl.style.height = bounds.height + 'px';
                      markerEl.style.visibility = 'visible';

                      borderColorStr = color || (type === 'PREVIEW' ? 'rgba(200, 200, 200, 0.4)' : '');

                      markerEl.style.borderColor = borderColorStr;
                      borderColor = __WEBPACK_IMPORTED_MODULE_22_parse_color___default()(borderColorStr).rgb;

                      if (!isMobile) {
                        markerEl.style.backgroundColor = 'rgba(' + [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(borderColorStr), [BG_OPACITY]) + ')';
                      }
                      if (i == enabledMarkerIndex) {
                        markerEl.style.borderColor = 'rgba(' + [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(borderColorStr), [ENABLED_OPACITY]) + ')';
                      } else {
                        markerEl.style.borderColor = 'rgba(' + [].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(borderColorStr), [DISABLED_OPACITY]) + ')';
                      }

                      newEls.push(markerEl);

                      if (!((i + 1) % 50 === 0)) {
                        _context.next = 36;
                        break;
                      }

                      _context.next = 36;
                      return delay(0);

                    case 36:
                      if (!(time !== newTime)) {
                        _context.next = 38;
                        break;
                      }

                      return _context.abrupt('return', {
                        v: void 0
                      });

                    case 38:
                    case 'end':
                      return _context.stop();
                  }
                }
              }, _loop, _this);
            });
            i = 0;

          case 7:
            if (!(i < markerBounds.length)) {
              _context2.next = 19;
              break;
            }

            return _context2.delegateYield(_loop(i), 't0', 9);

          case 9:
            _ret = _context2.t0;
            _context2.t1 = _ret;
            _context2.next = _context2.t1 === 'continue' ? 13 : 14;
            break;

          case 13:
            return _context2.abrupt('continue', 16);

          case 14:
            if (!((typeof _ret === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default()(_ret)) === "object")) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt('return', _ret.v);

          case 16:
            i++;
            _context2.next = 7;
            break;

          case 19:
            // hide exceeding markers (if any)
            for (i = markerBounds.length; i < currentEls.length; i++) {
              currentEls[i].style.visibility = 'hidden';
            }

          case 20:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee, this);
  }));

  return function _drawMarker(_x2, _x3) {
    return _ref5.apply(this, arguments);
  };
}();


















var delay = function delay(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
};

var SELECTOR_ID = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20_base_common_utils_namespace__["a" /* default */])('in-page-selector-');
var directions = ['top', 'left', 'bottom', 'right'];
var className = function className(s) {
  return SELECTOR_ID + s;
}; // avoid conflicts

var DISABLED_OPACITY = '1';
var ENABLED_OPACITY = '1';
var BG_OPACITY = '0.2';

function addColorOpacity(borderColor, opacity) {
  var rgbaArray = void 0;

  if (borderColor.startsWith('rgb(')) {
    rgbaArray = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_utils_rgbToArray__["a" /* default */])(borderColor).concat([opacity]);
  } else if (borderColor.startsWith('rgba(')) {
    rgbaArray = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__common_utils_rgbaToArray__["a" /* default */])(borderColor);
    rgbaArray[rgbaArray.length - 1] = opacity;
  }

  return 'rgba(' + rgbaArray.join(', ') + ')';
}

function sumCSSProperties(properties, computedStyle) {
  return properties.reduce(function (count, prop) {
    var value = parseInt(computedStyle[prop], 10);
    if (isNaN(value)) return count;
    return count + value;
  }, 0);
}

var selectorStyle = function selectorStyle(type, index) {
  var _ref;

  return _ref = {
    'pointer-events': 'none',
    'border-width': type === 'PREVIEW' ? '3px' : '6px',
    'border-style': 'solid',
    'position': 'absolute',
    'box-sizing': 'border-box',
    'transition': 'all 0.5s ease-in-out'
  }, __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty___default()(_ref, 'transition', 'visibility 0s'), __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty___default()(_ref, 'z-index', String(2147582996 - index)), __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_defineProperty___default()(_ref, 'white-space', 'nowrap'), _ref;
};
var infoStyle = function infoStyle(type) {
  return {
    'display': type === 'PREVIEW' ? 'none' : '',
    'height': '40px',
    'padding': '5px',
    'padding-right': '10px',
    'box-sizing': 'border-box',
    'box-shadow': '0px 10px 35px 5px rgba(0,0,0,0.13)',
    'transition-property': 'max-height, max-width, padding, bottom, top, left, right',
    'transition-duration': '.3s'
  };
};
var iconStyle = function iconStyle() {
  return {
    'display': 'inline-block',
    'background-position': 'center center',
    'background-size': '100%',
    'box-sizing': 'border-box',
    'vertical-align': 'bottom'
  };
};

var typeToText = function typeToText(type, isMobile, _ref2) {
  var _ref2$dblClick = _ref2.dblClick,
      dblClick = _ref2$dblClick === undefined ? false : _ref2$dblClick;
  return {
    READ: 'Read',
    LEFT_CLICK: isMobile ? 'Tap' : dblClick ? 'Doubleclick' : 'Click',
    RIGHT_CLICK: isMobile ? 'Tap' : 'Right click',
    SCROLL: 'Scroll',
    TYPING: 'Type',
    DRAG: 'Drag',
    DROP: 'Drop',
    HOVER: 'Hover'
  }[type];
};

var appendImportant = function appendImportant(s) {
  return s + ' !important';
};
var makeStyleImportant = function makeStyleImportant(style) {
  return __WEBPACK_IMPORTED_MODULE_13_lodash_mapValues___default()(style, appendImportant);
};
var styleObjToString = function styleObjToString(o) {
  return __WEBPACK_IMPORTED_MODULE_15_lodash_toPairs___default()(o).map(function (_ref3) {
    var _ref4 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
        k = _ref4[0],
        v = _ref4[1];

    return k + ': ' + v + ';';
  }).join('');
};
var styleObjToImportantString = __WEBPACK_IMPORTED_MODULE_12_lodash_flowRight___default()(styleObjToString, makeStyleImportant);

function makeMarkerInfo(type) {
  var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var isMobile = arguments[2];
  var opts = arguments[3];

  var _times = __WEBPACK_IMPORTED_MODULE_14_lodash_times___default()(3, function () {
    return document.createElement('div');
  }),
      _times2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_times, 3),
      infoEl = _times2[0],
      icon = _times2[1],
      text = _times2[2];

  infoEl.className = className('marker-info');
  infoEl.setAttribute('style', styleObjToImportantString(infoStyle(type)));
  if (color) {
    infoEl.style.backgroundColor = color;
    infoEl.style.borderColor = color; // the arrow inherits this
  }
  icon.className = className('icon');
  icon.setAttribute('style', styleObjToImportantString(iconStyle()));
  var svgBgStyle = color ? 'fill: ' + color + ' !important;' : '';
  var svgStyle = 'g.iorad-tool-icon *{' + svgBgStyle + '}g.iorad-tool-icon .fill{fill: #fff !important}';
  var iconSvg = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_21_base_common_svgInline_tools__["a" /* toolTypeToSvg */])(type);
  icon.innerHTML = iconSvg ? iconSvg({ styles: svgStyle }) : '';
  text.className = className('text');
  text.innerHTML = typeToText(type, isMobile, opts) || type.replace('_', ' ');
  [icon, text].map(function (el) {
    return infoEl.appendChild(el);
  });

  return infoEl;
}

function animateMarkerInfo(info, position) {
  if (!position || position === 'hide') return;
  var verticalStart = {
    maxHeight: '0',
    paddingTop: '0',
    paddingBottom: '0'
  };
  var verticalAfterStart = {
    maxHeight: '40px',
    paddingTop: '5px',
    paddingBottom: '5px'
  };
  var horizontal = {
    start: {
      maxWidth: '0',
      paddingLeft: '0',
      paddingRight: '0'
    },
    afterStart: {
      maxWidth: '115px',
      paddingLeft: '5px',
      paddingRight: '10px'
    }
  };
  var styles = {
    top: {
      start: __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends___default()({}, verticalStart, {
        top: '0'
      }),
      afterStart: __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends___default()({}, verticalAfterStart, {
        top: info.style.top
      })
    },
    bottom: {
      start: __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends___default()({}, verticalStart, {
        bottom: '0'
      }),
      afterStart: __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_extends___default()({}, verticalAfterStart, {
        bottom: info.style.bottom
      })
    },
    left: horizontal,
    right: horizontal
  };
  Object.assign(info.style, styles[position].start);
  setTimeout(function () {
    Object.assign(info.style, styles[position].afterStart);
  });
}

function markerInfoPosition(markerBounds, containerWidth, containerHeight, multipleMatches) {
  // how many px of the marker-info we can afford to cut
  // in case there isn't enough space, in order to still display it.
  var tolerance = 0;

  var requiredXSize = {
    x: 141 - tolerance,
    y: 40 - tolerance
  };
  var requiredYSize = {
    x: 125 - tolerance,
    y: 56 - tolerance
  };
  var markerHCenter = markerBounds.x + markerBounds.width / 2;
  var markerVCenter = markerBounds.y + markerBounds.height / 2;
  var markerBottom = markerBounds.y + markerBounds.height;
  var markerRight = markerBounds.x + markerBounds.width;

  // info is displayed on center, thus we need half space on left/top
  // and half space on right/bottom
  // check the icon size (i.e. the circle size)
  var minXSpace = requiredXSize.y / 2 - tolerance;
  var minYSpace = requiredYSize.x / 2 - tolerance;
  var isHorizontalSuitable = minYSpace === Math.min(minYSpace, // required space
  markerHCenter, // available space on the right
  containerWidth - markerHCenter // available space on the left
  );
  var isVerticalSuitable = minXSpace === Math.min(minXSpace, // required space
  markerVCenter, // available space on the top
  containerHeight - markerVCenter // available space on the bottom
  );

  // check the whole size (with arrow)
  var isTopSuitable = markerBounds.y >= requiredYSize.y && isHorizontalSuitable;
  var isBottomSuitable = containerHeight - markerBottom >= requiredYSize.y && isHorizontalSuitable;
  var isLeftSuitable = markerBounds.x >= requiredXSize.x && isVerticalSuitable;
  var isRightSuitable = containerWidth - markerRight >= requiredXSize.x && isVerticalSuitable;

  var positionToClass = multipleMatches ? [
  // position    info class    arrow class
  [isTopSuitable, 'top'], [isLeftSuitable, 'left'], [isRightSuitable, 'right'], [isBottomSuitable, 'bottom'], [true, 'hide']] : [
  // position    info class    arrow class
  [isBottomSuitable, 'bottom'], [isTopSuitable, 'top'], [isRightSuitable, 'right'], [isLeftSuitable, 'left'], [true, 'hide']];
  // choose the first true
  return positionToClass.filter(__WEBPACK_IMPORTED_MODULE_17_lodash_head___default.a)[0][1];
}

var borderWidth = 6;
var currentPromise = null;
var newTime = null;

var drawMarker = function () {
  var _ref6 = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee2() {
    var _args3 = arguments;
    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            newTime = Date.now();

            if (!currentPromise) {
              _context3.next = 5;
              break;
            }

            _context3.next = 4;
            return currentPromise;

          case 4:
            return _context3.abrupt('return', drawMarker.apply(undefined, _args3));

          case 5:
            currentPromise = _drawMarker.apply(undefined, _args3).then(function () {
              currentPromise = undefined;
            });

          case 6:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee2, this);
  }));

  return function drawMarker() {
    return _ref6.apply(this, arguments);
  };
}();

function hideMarker() {
  var currentEls = document.querySelectorAll('.' + SELECTOR_ID);
  var visibleMarkers = Array.from(currentEls).filter(function (markerEl) {
    return markerEl.style.visibility !== 'hidden';
  });

  Array.from(currentEls).forEach(function (markerEl) {
    return markerEl.style.visibility = 'hidden';
  });

  // Return a true if we hid any markers and false if there weren't any to hide
  return visibleMarkers.length !== 0;
}

/***/ }),
/* 525 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (immutable) */ __webpack_exports__["a"] = elementOnTop;

// Cache panelEl for performance reasons
var panelEl = void 0;
function getPanelEl() {
  if (!panelEl) {
    panelEl = document.querySelector('.' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__["a" /* default */])('panel'));
  }
  return panelEl;
}

// Ignore case where the iorad panel is above the element, since we'll move the panel accordingly.
function elementOnTop(el) {
  var rect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : el.getBoundingClientRect();

  var MARGIN = 5;
  var elementAtCenter = document.elementFromPoint(rect.left + rect.width * 0.5, rect.top + rect.height * 0.5);
  var elementAtCenterLeft = document.elementFromPoint(rect.left + MARGIN, rect.top + rect.height * 0.5);
  var elementAtCenterRight = document.elementFromPoint(rect.right - MARGIN, rect.top + rect.height * 0.5);

  var panelEl = getPanelEl();
  return panelEl && panelEl.contains(elementAtCenter) || el.contains(elementAtCenter) || el.contains(elementAtCenterLeft) || el.contains(elementAtCenterRight);
}

/***/ }),
/* 526 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__READ__ = __webpack_require__(617);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "READ", function() { return __WEBPACK_IMPORTED_MODULE_0__READ__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LEFT_CLICK__ = __webpack_require__(616);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "LEFT_CLICK", function() { return __WEBPACK_IMPORTED_MODULE_1__LEFT_CLICK__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RIGHT_CLICK__ = __webpack_require__(618);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "RIGHT_CLICK", function() { return __WEBPACK_IMPORTED_MODULE_2__RIGHT_CLICK__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__SCROLL__ = __webpack_require__(619);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "SCROLL", function() { return __WEBPACK_IMPORTED_MODULE_3__SCROLL__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__TYPING__ = __webpack_require__(620);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "TYPING", function() { return __WEBPACK_IMPORTED_MODULE_4__TYPING__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DRAG__ = __webpack_require__(613);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DRAG", function() { return __WEBPACK_IMPORTED_MODULE_5__DRAG__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__DROP__ = __webpack_require__(614);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "DROP", function() { return __WEBPACK_IMPORTED_MODULE_6__DROP__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__HOVER__ = __webpack_require__(615);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "HOVER", function() { return __WEBPACK_IMPORTED_MODULE_7__HOVER__["a"]; });









/***/ }),
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_base_common_Storage__ = __webpack_require__(573);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedStorage; });





var EmbedStorage = function (_Storage) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(EmbedStorage, _Storage);

  function EmbedStorage() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedStorage);

    return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedStorage.__proto__ || Object.getPrototypeOf(EmbedStorage)).apply(this, arguments));
  }

  return EmbedStorage;
}(__WEBPACK_IMPORTED_MODULE_3_base_common_Storage__["a" /* default */]);



/***/ }),
/* 535 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StubComponent; });



// OPTIMIZATION: use stub components instead of full "base extensions" to save KBs.
var StubComponent = function () {
  function StubComponent() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, StubComponent);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(StubComponent, [{
    key: "start",
    value: function start(extension) {
      this.extension = extension;
    }
  }, {
    key: "on",
    value: function on() {}
  }]);

  return StubComponent;
}();



/***/ }),
/* 536 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_base_common_sharedMemory_SharedMemory__ = __webpack_require__(310);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharedMemory; });





var SharedMemory = function (_CommonSharedMemory) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(SharedMemory, _CommonSharedMemory);

  function SharedMemory() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, SharedMemory);

    return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SharedMemory.__proto__ || Object.getPrototypeOf(SharedMemory)).apply(this, arguments));
  }

  return SharedMemory;
}(__WEBPACK_IMPORTED_MODULE_3_base_common_sharedMemory_SharedMemory__["a" /* default */]);



/***/ }),
/* 537 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__sharedEmitter__ = __webpack_require__(538);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsStore; });










var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var tabKeyPrefix = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_namespace__["a" /* default */])('tab-');

var TAB_TIMEOUT = 5000;
// invalid tabs aren't immediatelly deleted, since the background
// needs them to handle messages sent just before page reload (persistPanelState, etc. #532)
var TAB_CLEAN_TIMEOUT = 30000;

// Note: this function has side effects if cleanInvalidTabs is true, since
// it will remove any obsolete tab from local storage.
// Return the valid tabs.
function filterTabs(tabs, cleanInvalidTabs) {
  var validTabs = {};

  var dateNow = Date.now();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(tabs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var tabId = _step.value;

      var tab = tabs[tabId];
      var invalid = !tab || !tab.private || tab.private.invalid || dateNow - tab.private.time > TAB_TIMEOUT;
      if (!invalid) {
        validTabs[tabId] = tab;
      } else if (cleanInvalidTabs && (!tab || !tab.private || dateNow - tab.private.time > TAB_CLEAN_TIMEOUT)) {
        localStorage.removeItem(tabKeyPrefix + tabId);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return validTabs;
}

function getTabIdFromKey(key) {
  return key.slice(tabKeyPrefix.length);
}

function getTabs(skipInvalidTabs, cleanInvalidTabs) {
  var tabs = {};
  for (var i = 0, len = localStorage.length; i < len; i++) {
    var key = localStorage.key(i);

    if (key.startsWith(tabKeyPrefix)) {
      var id = getTabIdFromKey(key);
      tabs[id] = JSON.parse(localStorage.getItem(key));
    }
  }
  if (skipInvalidTabs) {
    tabs = filterTabs(tabs, cleanInvalidTabs);
  }
  return tabs;
}

// can only read

var TabsStore = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(TabsStore, _EventEmitter);

  function TabsStore() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, TabsStore);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TabsStore.__proto__ || Object.getPrototypeOf(TabsStore)).call(this));

    _this.cleanInvalidTabs = options.cleanInvalidTabs || false;

    _this._tabs = getTabs(true, _this.cleanInvalidTabs);

    _this._listenForChanges();
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(TabsStore, [{
    key: '_listenForChanges',
    value: function _listenForChanges() {
      var _this2 = this;

      // Note: the window 'storage' event is not fired on the same page (frame?) that is making the changes
      __WEBPACK_IMPORTED_MODULE_7__sharedEmitter__["a" /* default */].on('change', function (key, _ref) {
        var newValue = _ref.newValue;

        if (key.startsWith(tabKeyPrefix)) {
          var changedTabId = getTabIdFromKey(key);
          var changedTab = newValue;

          var oldTabs = _this2._tabs;
          var newTabs = _this2._tabs = filterTabs(Object.assign({}, oldTabs, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, changedTabId, changedTab)), _this2.cleanInvalidTabs);

          _this2.emit('change', {
            oldValue: oldTabs,
            newValue: newTabs,
            changeTime: Date.now()
          });
        }
      });
    }

    // return tabs object: <id, tab>

  }, {
    key: 'getAll',
    value: function getAll() {
      return Promise.resolve(this._tabs);
    }
  }, {
    key: 'getAllIncludingInvalid',
    value: function getAllIncludingInvalid() {
      return Promise.resolve(getTabs(false), this.cleanInvalidTabs);
    }
  }]);

  return TabsStore;
}(__WEBPACK_IMPORTED_MODULE_6_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/common/sharedMemory/TabsStore.js"))

/***/ }),
/* 538 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__ = __webpack_require__(12);



// can be used to listen to any change event emitted by any ObjectStore,
// both from same frame, different frame and different tab.
var sharedEmitter = new __WEBPACK_IMPORTED_MODULE_0_node_event_emitter___default.a();

// Note: the window 'storage' event is not fired on the same page (frame?) that is making the changes
window.addEventListener('storage', function (e) {
  if (!e.key.startsWith(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__["a" /* default */])() + '-')) return; // not one of our keys

  var changeInfo = {
    oldValue: e.oldValue && JSON.parse(e.oldValue),
    newValue: e.newValue && JSON.parse(e.newValue),
    changeTime: Date.now()
  };
  sharedEmitter.emit('change', e.key, changeInfo);
});

/* harmony default export */ __webpack_exports__["a"] = sharedEmitter;

/***/ }),
/* 539 */,
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else if (typeof define == 'function' && define.amd) {
		// For AMD. Register as an anonymous module.
		define([], factory.bind(root, root));
	} else {
		// For browser globals (not exposing the function separately).
		factory(root);
	}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(90)))

/***/ }),
/* 541 */,
/* 542 */,
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

var baseRandom = __webpack_require__(730);

/**
 * A specialized version of `_.sample` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 */
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom(0, length - 1)] : undefined;
}

module.exports = arraySample;


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(120),
    eq = __webpack_require__(81);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(128);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * The opposite of `_.before`; this method creates a function that invokes
 * `func` once it's called `n` or more times.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {number} n The number of calls before `func` is invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var saves = ['profile', 'settings'];
 *
 * var done = _.after(saves.length, function() {
 *   console.log('done saving!');
 * });
 *
 * _.forEach(saves, function(type) {
 *   asyncSave({ 'type': type, 'complete': done });
 * });
 * // => Logs 'done saving!' after the two async saves have completed.
 */
function after(n, func) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}

module.exports = after;


/***/ }),
/* 546 */,
/* 547 */
/***/ (function(module, exports) {

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = compact;


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    getPrototype = __webpack_require__(179),
    isObjectLike = __webpack_require__(34);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33),
    baseClone = __webpack_require__(286),
    baseUnset = __webpack_require__(733),
    castPath = __webpack_require__(79),
    copyObject = __webpack_require__(47),
    customOmitClone = __webpack_require__(740),
    flatRest = __webpack_require__(177),
    getAllKeysIn = __webpack_require__(178);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;


/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(241),
    castFunction = __webpack_require__(291),
    toInteger = __webpack_require__(128);

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH,
      length = nativeMin(n, MAX_ARRAY_LENGTH);

  iteratee = castFunction(iteratee);
  n -= MAX_ARRAY_LENGTH;

  var result = baseTimes(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

module.exports = times;


/***/ }),
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_content_EditorFrameNode__ = __webpack_require__(602);


var editorNode = new __WEBPACK_IMPORTED_MODULE_0_base_content_EditorFrameNode__["a" /* default */]("embed", "1.8.0", 'embed');
editorNode.start();

/***/ }),
/* 561 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_content_player_ContentPlayerFrameNode__ = __webpack_require__(610);


var contentPlayerNode = new __WEBPACK_IMPORTED_MODULE_0_base_content_player_ContentPlayerFrameNode__["a" /* default */]();
contentPlayerNode.start();

/***/ }),
/* 562 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__content_styles_style_scss__ = __webpack_require__(712);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__content_styles_style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__content_styles_style_scss__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__content_EmbedExtension__ = __webpack_require__(703);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__background_EmbedExtension__ = __webpack_require__(694);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_sortBy__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_sortBy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_sortBy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__ = __webpack_require__(6);



__webpack_require__(306);








var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

window.addEventListener('unhandledRejection', function (error) {
  console.error('Unhandled promise rejection:', error instanceof Error ? error.stack : error);
  throw error;
});

(function checkBody() {
  var _this = this;

  if (!document.body) {
    // try later
    setTimeout(checkBody, 50);
    return;
  }

  var contentExtension = new __WEBPACK_IMPORTED_MODULE_4__content_EmbedExtension__["a" /* default */]();

  // inject CSS
  var link = document.createElement('link');
  link.href = contentExtension.getURL('inject.css');
  link.rel = 'stylesheet';
  document.head.appendChild(link);

  var init = function init() {
    if (!contentExtension.isTopFrame) return Promise.resolve();

    var intervals = {};
    function addInterval(name, cb, timeout) {
      intervals[name] = setTimeout(function () {
        cb().then(function () {
          if (intervals[name]) {
            // (prevent call if already cleared)
            addInterval(name, cb, timeout);
          }
        });
      }, timeout);
    }
    function clearIntervals() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(intervals)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;

          clearTimeout(intervals[name]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      intervals = {};
    }

    var extendCurrentTab = function extendCurrentTab() {
      var publicObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var privateObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return contentExtension.sharedMemory.tab.setByFunction(function (tab) {
        if (!tab) {
          console.log('extendCurrentTab: tab not found', contentExtension.frameId);
          return tab;
        }

        tab.public = Object.assign({}, tab.public || {}, publicObj);
        tab.private = Object.assign({}, tab.private || {}, __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, privateObj, {
          time: Date.now()
        }));
        return tab;
      });
    };

    var onActiveChange = function onActiveChange(isActive) {
      return extendCurrentTab({ active: isActive });
    };

    var checkTabs = function checkTabs() {
      return contentExtension.sharedMemory.tabs.getAll().then(function () {
        var _ref = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {
          var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var backgroundTab, newBackgroundTab, backgroundExtension;
          return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // is there a background tab?
                  backgroundTab = __WEBPACK_IMPORTED_MODULE_6_lodash_find___default()(tabs, function (tab) {
                    return tab.private.background;
                  });

                  if (backgroundTab) {
                    _context.next = 12;
                    break;
                  }

                  // find tab with lowest id
                  newBackgroundTab = __WEBPACK_IMPORTED_MODULE_7_lodash_sortBy___default()(tabs, function (tab) {
                    return tab.public.id;
                  })[0];

                  if (!newBackgroundTab) {
                    _context.next = 12;
                    break;
                  }

                  logger.debug('inject: newBackgroundTab', newBackgroundTab);

                  if (!(newBackgroundTab.public.id === contentExtension.frameId)) {
                    _context.next = 10;
                    break;
                  }

                  _context.next = 8;
                  return contentExtension.sharedMemory.tab.setByPath({ 'private.background': true });

                case 8:
                  backgroundExtension = new __WEBPACK_IMPORTED_MODULE_5__background_EmbedExtension__["a" /* default */]();

                  backgroundExtension.start();

                case 10:
                  _context.next = 12;
                  break;

                case 12:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this);
        }));

        return function () {
          return _ref.apply(this, arguments);
        };
      }()
      // no-op: the only tab is being refreshed
      );
    };

    var check = function check() {
      return Promise.resolve().then(function () {
        return checkTabs();
      });
    };

    // register the tab
    return contentExtension.sharedMemory.tab.set({
      public: {
        id: contentExtension.frameId,
        url: window.location.href,
        active: false
      },
      private: {
        background: false,
        time: Date.now()
      }
    }).then(function () {
      // monitor active state
      document.addEventListener('visibilitychange', function () {
        return onActiveChange(!document.hidden);
      });
      document.addEventListener('readystatechange', function () {
        // document.hidden is true during the page pre-render,
        // even if the tab is active
        // (see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API)
        onActiveChange(!document.hidden);
      });
      onActiveChange(!document.hidden);

      // keep registration updated
      addInterval('extendCurrentTab', function () {
        return extendCurrentTab();
      }, 1000);

      window.addEventListener('beforeunload', function () {
        clearIntervals();
        contentExtension.sharedMemory.tab.setByPath({ 'private.invalid': true });
      });

      addInterval('check', function () {
        return check();
      }, 1000);
      return check();
    });
  };

  init().then(function () {
    contentExtension.start();
  });

  // Public API
  window.ioradWidget = {
    togglePanel: function togglePanel(showOrHide) {
      contentExtension.portManager.backgroundPort.send({
        topic: showOrHide ? 'showPanel' : 'hidePanel',
        data: { explicit: true }
      });
    },

    updateColors: function updateColors(colors) {
      contentExtension.panelController.handleColors(colors);
    },

    updateIntercom: function updateIntercom(value) {
      contentExtension.flux.contentContext().dispatch('toggleIntercomInstalled', value);
    },

    updateGoogleTranslate: function updateGoogleTranslate(value) {
      contentExtension.flux.contentContext().dispatch('toggleGoogleTranslateInstalled', value);
    },

    resetColors: function resetColors() {
      contentExtension.panelController.handleColors(contentExtension.embedOptions.colors);
    },

    contentExtension: contentExtension
  };
})();
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/inject_topFrame.js"))

/***/ }),
/* 563 */,
/* 564 */,
/* 565 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_Component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_AudioPlayer__ = __webpack_require__(572);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AudioController; });









var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var AudioController = function (_Component) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(AudioController, _Component);

  function AudioController() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, AudioController);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AudioController.__proto__ || Object.getPrototypeOf(AudioController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(AudioController, [{
    key: 'start',
    value: function start() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default()(AudioController.prototype.__proto__ || Object.getPrototypeOf(AudioController.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      this.setupAudioPlayer();
      this.setupDocuments();
    }
  }, {
    key: 'setupAudioPlayer',
    value: function setupAudioPlayer() {
      var _this2 = this;

      var audio = new __WEBPACK_IMPORTED_MODULE_6_base_common_AudioPlayer__["a" /* default */]();
      var handlers = [
      // event          message to documents
      ['play', function () {
        _this2.ownContext().dispatch('setAudioPlaying', true);
      }], ['end', function () {
        _this2.ownContext().dispatch('setAudioPlaying', false);
      }], ['volumeChanged', function (val) {
        _this2.ownContext().dispatch('setAudioMuted', val === 0);
      }]];
      handlers.forEach(function (a) {
        audio.on(a[0], function () {
          return a[1].apply(a, arguments);
        });
      });
      this.audio = audio;
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      var _this3 = this;

      // do not handle audio requests from inactive tabs (#524)
      // Note: the request is not ignored if the active tab is "new", so to handle messages sent on "open in a new tab" links (#570)
      var activeTabTime = Date.now() - this.extension.tabsController.activeTabStartTime;
      if (this.extension.tabsController.activeTabId !== message.tab.id && activeTabTime > 5000) return;

      var audioHandlers = [
      // topic    handler
      ['playAudio', function () {
        // (don't play the same audio multiple times
        // https://github.com/iorad/IORAD-extension/issues/278#issuecomment-217652861)
        if (_this3.audio.getUrl() !== message.data.url) {
          _this3.audio.setUrl(message.data.url);
          _this3.audio.play();
        }
      }], ['stopAudio', function () {
        _this3.audio.stop();
        _this3.audio.setUrl('');
      }], ['updateAudioMuted', function () {
        _this3.audio.stop();
        _this3.audio.setUrl('');
        _this3.audio.setVolume(message.data.muted ? 0 : 1);
      }]];
      audioHandlers.forEach(function (a) {
        if (message.topic === a[0]) a[1]();
      });
    }
  }]);

  return AudioController;
}(__WEBPACK_IMPORTED_MODULE_5_base_common_Component__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/AudioController.js"))

/***/ }),
/* 566 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_utils_randomString__ = __webpack_require__(518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Flux__ = __webpack_require__(508);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_sharedMemory_SharedMemory__ = __webpack_require__(310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__AudioController__ = __webpack_require__(565);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ShortcutsController__ = __webpack_require__(568);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__UserData__ = __webpack_require__(570);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__PanelController__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Extension; });




// README: keep this file as small as possible, move any logic to specific modules
// and initialize/start them here if needed.










// Needs to be imported so it can run its echo server



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var Extension = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(Extension, _EventEmitter);

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Extension, [{
    key: 'getInitialState',
    value: function getInitialState() {
      return {
        panel: {},
        capture: {
          browserState: 'initial',
          desktopState: 'initial',

          // the mode should be also set if the capture was started directly from app
          mode: 'browser', // native

          captures: 0,
          captureServiceInstalled: null,
          capturedSteps: []
        },

        // In EMBED make this data just a boolean instead that a map depending on the tab id
        // (we don't have great control over tabs, thus we either show or hide the panel in all tabs/pages)
        isPanelOpen:  true ? false : {},

        isPanelSupported: true, // for the current tab
        isCurrentPageLegacy: false,
        isCurrentPagePopup: false,
        isExtensionJustInstalled: false,
        audioPlaying: false,
        audioMuted: false,
        activeTabId: null,
        isStartCaptureOverlayVisible: false
      };
    }
  }, {
    key: 'getPortManagerClass',
    value: function getPortManagerClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'getFluxClass',
    value: function getFluxClass() {
      return __WEBPACK_IMPORTED_MODULE_6__Flux__["a" /* default */];
    }
  }, {
    key: 'getSharedMemoryClass',
    value: function getSharedMemoryClass() {
      return __WEBPACK_IMPORTED_MODULE_7__common_sharedMemory_SharedMemory__["a" /* default */];
    }
  }, {
    key: 'getStorageClass',
    value: function getStorageClass() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getTabsControllerClass',
    value: function getTabsControllerClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'getPanelControllerClass',
    value: function getPanelControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_11__PanelController__["a" /* default */];
    }
  }, {
    key: 'getBrowserCaptureClass',
    value: function getBrowserCaptureClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'getBrowserActionManagerClass',
    value: function getBrowserActionManagerClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'getBridgeClass',
    value: function getBridgeClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'getAudioControllerClass',
    value: function getAudioControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_8__AudioController__["a" /* default */];
    }
  }, {
    key: 'getShortcutsControllerClass',
    value: function getShortcutsControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_9__ShortcutsController__["a" /* default */];
    }
  }, {
    key: 'getUserDataClass',
    value: function getUserDataClass() {
      return __WEBPACK_IMPORTED_MODULE_10__UserData__["a" /* default */];
    }
  }, {
    key: 'getAuthClass',
    value: function getAuthClass() {
      // abstract
      throw new Error('Not implemented');
    }

    // instantiate modules

  }]);

  function Extension(name, version, id) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Extension);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Extension.__proto__ || Object.getPrototypeOf(Extension)).call(this));

    _this.name = name;
    _this.version = version;
    _this.id = id;

    _this.isReady = false;

    _this.backgroundId = 'iorad_' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_utils_randomString__["a" /* default */])();

    var PortManagerClass = _this.getPortManagerClass();
    _this.portManager = new PortManagerClass();

    var FluxClass = _this.getFluxClass();
    _this.flux = new FluxClass();

    var SharedMemoryClass = _this.getSharedMemoryClass();
    _this.sharedMemory = new SharedMemoryClass();

    var StorageClass = _this.getStorageClass();
    _this.storage = new StorageClass();

    var PanelControllerClass = _this.getPanelControllerClass();
    _this.panelController = new PanelControllerClass();

    var BrowserCaptureClass = _this.getBrowserCaptureClass();
    _this.browserCapture = new BrowserCaptureClass();

    var BrowserActionManagerClass = _this.getBrowserActionManagerClass();
    _this.browserActionManager = new BrowserActionManagerClass();

    var AudioControllerClass = _this.getAudioControllerClass();
    _this.audioController = new AudioControllerClass();

    var ShortcutsControllerClass = _this.getShortcutsControllerClass();
    _this.shortcutsController = new ShortcutsControllerClass();

    var UserDataClass = _this.getUserDataClass();
    _this.userData = new UserDataClass();

    var TabsControllerClass = _this.getTabsControllerClass();
    _this.tabsController = new TabsControllerClass();

    var AuthClass = _this.getAuthClass();
    _this.auth = new AuthClass();
    return _this;
  }

  // start modules
  // (having a separate method for this reduces circular dependency problems)


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Extension, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      var ChromeBridgeClass = this.getBridgeClass();

      return Promise.resolve().then(function () {
        return _this2.setupIoradExtensionExistence();
      }).then(function () {
        return _this2.portManager.start(_this2);
      }).then(function () {
        return _this2.flux.start(_this2);
      }).then(function () {
        return _this2.sharedMemory.start(_this2);
      }).then(function () {
        return _this2.storage.start(_this2);
      }).then(function () {
        return _this2.tabsController.start(_this2);
      }).then(function () {
        return _this2.panelController.start(_this2);
      }).then(function () {
        return _this2.browserCapture.start(_this2);
      }).then(function () {
        return _this2.browserActionManager.start(_this2);
      }).then(function () {
        return _this2.audioController.start(_this2);
      }).then(function () {
        return _this2.shortcutsController.start(_this2);
      }).then(function () {
        return _this2.userData.start(_this2);
      }).then(function () {
        return _this2.auth.start(_this2);
      }).then(function () {
        return ChromeBridgeClass.listen(_this2);
      }).then(function () {
        _this2.isReady = true;
        _this2.emit('ready');
      }).catch(function (e) {
        return logger.error('Failed to start background', e);
      });
    }
  }, {
    key: 'setupIoradExtensionExistence',
    value: function setupIoradExtensionExistence() {
      // default implementation: no-op
    }
  }]);

  return Extension;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/Extension.js"))

/***/ }),
/* 567 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PortManager; });



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var PortManager = function () {
  function PortManager() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, PortManager);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(PortManager, [{
    key: 'getDocumentsPortClass',
    value: function getDocumentsPortClass() {
      // abstract
      throw new Error('Not implemented');
    }
  }, {
    key: 'start',
    value: function start(extension) {
      this.extension = extension;

      this.setupDocumentsPort();
    }
  }, {
    key: 'setupDocumentsPort',
    value: function setupDocumentsPort() {
      // this connects immediately
      var DocumentsPortClass = this.getDocumentsPortClass();
      this.documentsPort = new DocumentsPortClass(null, '', this.extension);
      this.documentsPort.connect();
    }
  }]);

  return PortManager;
}();


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/PortManager.js"))

/***/ }),
/* 568 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShortcutsController; });







var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var ShortcutsController = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ShortcutsController, _EventEmitter);

  function ShortcutsController() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ShortcutsController);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ShortcutsController.__proto__ || Object.getPrototypeOf(ShortcutsController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(ShortcutsController, [{
    key: 'start',
    value: function start(extension) {
      this.extension = extension;

      this.setupDocuments();
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      var _this2 = this;

      if (message.hotKey) {
        var hotKey = message.hotKey;
        // logger.debug("coming from hot key",hotKey);

        // compare with user shortcuts
        this.extension.userData.getUserData().then(function (_ref) {
          var shortcuts = _ref.shortcuts;

          // TODO : use settings
          var keyDone = shortcuts.done || 'Alt + D';
          var keyCapture = shortcuts.toggleCapture || 'Alt + P';

          if (hotKey.toLowerCase() === keyCapture.toLowerCase()) {
            _this2.emit('key:capture');
          } else if (hotKey.toLowerCase() === keyDone.toLowerCase()) {
            _this2.emit('key:done');
          }
        });
      }
    }
  }]);

  return ShortcutsController;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/ShortcutsController.js"))

/***/ }),
/* 569 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_Component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsController; });









var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var TabsController = function (_Component) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(TabsController, _Component);

  function TabsController() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, TabsController);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TabsController.__proto__ || Object.getPrototypeOf(TabsController)).call(this));

    _this.activeTabId = null;
    _this.tabInfoMap = new Map();
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(TabsController, [{
    key: 'start',
    value: function start() {
      var _get2,
          _this2 = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(TabsController.prototype.__proto__ || Object.getPrototypeOf(TabsController.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      this.setupDocuments();
      this.monitorActiveTabId();

      this.listenTabOnUpdated(function (tabId, _, tab) {
        return _this2.onTabUpdated({ tabId: tabId, tab: tab });
      });
      this.listenTabOnRemoved(function (tabId) {
        return _this2.onTabRemoved({ tabId: tabId });
      });
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'monitorActiveTabId',
    value: function monitorActiveTabId() {
      var _this3 = this;

      this.getActiveTabId().then(function (tabId) {
        _this3.onActiveTabChanged({ tabId: tabId });
        _this3.listenTabOnActivated(function (info) {
          return _this3.onActiveTabChanged(info);
        });
      });
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      // default implementation: no-op
    }
  }, {
    key: 'listenTabOnUpdated',
    value: function listenTabOnUpdated(callback) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'listenTabOnActivated',
    value: function listenTabOnActivated(callback) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'listenTabOnRemoved',
    value: function listenTabOnRemoved(callback) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getTab',
    value: function getTab(tabId) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getActiveTabId',
    value: function getActiveTabId() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getAllTabs',
    value: function getAllTabs() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'setTabInfo',
    value: function setTabInfo(id, info) {
      var updatedInfo = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, this.getTabInfo(id), info);
      this.tabInfoMap.set(id, updatedInfo);
      return updatedInfo;
    }
  }, {
    key: 'getTabInfo',
    value: function getTabInfo(id) {
      return this.tabInfoMap.get(id) || {};
    }
  }, {
    key: 'clearTabInfo',
    value: function clearTabInfo(id) {
      this.tabInfoMap.delete(id);
    }
  }, {
    key: 'onActiveTabChanged',
    value: function onActiveTabChanged(info) {
      this.activeTabId = info.tabId;
      this.activeTabStartTime = Date.now();

      this.ownContext().dispatch('setActiveTabId', info.tabId);
      this.emit('activeTabChanged', info);
    }
  }, {
    key: 'onTabUpdated',
    value: function onTabUpdated(info) {
      this.emit('tabUpdated', info);
    }
  }, {
    key: 'onTabRemoved',
    value: function onTabRemoved(info) {
      this.emit('tabRemoved', info);
    }
  }]);

  return TabsController;
}(__WEBPACK_IMPORTED_MODULE_6_base_common_Component__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/TabsController.js"))

/***/ }),
/* 570 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_objectWithoutProperties__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_objectWithoutProperties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_objectWithoutProperties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_pickBy__ = __webpack_require__(494);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash_pickBy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash_pickBy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UserData; });








var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var UserData = function () {
  function UserData() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, UserData);

    this.userData = {};
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(UserData, [{
    key: 'start',
    value: function start(extension) {
      this.extension = extension;

      this.setupDocuments();
      this.refreshUserData();
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      var _this = this;

      var handlers = {
        getUserData: function getUserData() {
          return respond(_this.userData);
        },
        setUserData: function setUserData() {
          return _this.setUserData(message.data.userData);
        }
      };

      var matchedHandlers = __WEBPACK_IMPORTED_MODULE_4_lodash_pickBy___default()(handlers, function (v, k) {
        return k === message.topic;
      });
      __WEBPACK_IMPORTED_MODULE_5_lodash_values___default()(matchedHandlers).forEach(function (f) {
        return f();
      }); // running handlers
    }
  }, {
    key: 'refreshUserData',
    value: function refreshUserData() {
      var _this2 = this;

      return this.getUserData().then(function (userData) {
        return _this2.userData = userData;
      });
    }
  }, {
    key: 'getUserData',
    value: function getUserData() {
      return this.extension.storage.get({
        viewedTutorials: [],
        prefs: {
          'key_capture': 'Alt + P',
          'key_done': 'Alt + D'
        },
        shownMessages: []
      }).then(function (_ref) {
        var prefs = _ref.prefs,
            viewedTutorials = _ref.viewedTutorials,
            shownMessages = _ref.shownMessages;
        return {
          shortcuts: {
            toggleCapture: prefs.key_capture,
            done: prefs.key_done
          },
          viewedTutorials: viewedTutorials,
          shownMessages: shownMessages
        };
      });
    }
  }, {
    key: 'setUserData',
    value: function setUserData(userData) {
      this.userData = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, this.userData, userData);

      var _userData = this.userData,
          shortcuts = _userData.shortcuts,
          data = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_objectWithoutProperties___default()(_userData, ['shortcuts']);

      return this.extension.storage.set(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({
        prefs: {
          'key_capture': shortcuts.toggleCapture,
          'key_done': shortcuts.done
        }
      }, data));
    }
  }]);

  return UserData;
}();


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/UserData.js"))

/***/ }),
/* 571 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = actionsFactory;



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

function actionsFactory(_ref) {
  var setState = _ref.setState,
      getState = _ref.getState;

  return {
    setPanelOpen: function setPanelOpen(tabId, isOpen) {
      logger.debug("Received setPanelOpen", tabId, isOpen, true);
      if (true) {
        if (isOpen === getState().isPanelOpen) return;
        setState({
          isPanelOpen: isOpen
        });
      } else {
        setState(function (state) {
          return _extends({}, state, {
            isPanelOpen: _extends({}, state.isPanelOpen, _defineProperty({}, tabId, isOpen))
          });
        });
      }
    },
    clearPanelOpen: function clearPanelOpen(tabId) {
      if (true) return;
      setState(function (state) {
        var isPanelOpen = Object.assign({}, state.isPanelOpen);
        delete isPanelOpen[tabId];
        return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, state, {
          isPanelOpen: isPanelOpen
        });
      });
    },
    setPanel: function setPanel(panel, excludedTabs) {
      setState({ panel: panel }, excludedTabs);
    },
    extendPanelState: function extendPanelState(panelState) {
      var excludedTabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      setState(function (state) {
        return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, state, {
          panel: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, state.panel, panelState)
        });
      }, excludedTabs);
    },
    extendCaptureState: function extendCaptureState(captureState) {
      var excludedTabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      setState(function (state) {
        return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, state, {
          capture: __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_extends___default()({}, state.capture, captureState)
        });
      }, excludedTabs);
    },
    toggleIsCurrentPageLegacy: function toggleIsCurrentPageLegacy(value) {
      setState({ isCurrentPageLegacy: value });
    },
    toggleIsCurrentPagePopup: function toggleIsCurrentPagePopup(value) {
      setState({ isCurrentPagePopup: value });
    },
    toggleIsExtensionJustInstalled: function toggleIsExtensionJustInstalled(value) {
      setState({ isExtensionJustInstalled: value });
    },
    toggleIsPanelSupported: function toggleIsPanelSupported(value) {
      setState({ isPanelSupported: value });
    },
    setAudioPlaying: function setAudioPlaying(value) {
      setState({ audioPlaying: value });
    },
    setAudioMuted: function setAudioMuted(value) {
      setState({ audioMuted: value });
    },
    setActiveTabId: function setActiveTabId(value) {
      setState({ activeTabId: value });
    },
    setTabsCount: function setTabsCount(value) {
      setState({ tabsCount: value });
    },
    toggleIsStartCaptureOverlayVisible: function toggleIsStartCaptureOverlayVisible(value) {
      setState({ isStartCaptureOverlayVisible: value });
    }
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/background/actions.js"))

/***/ }),
/* 572 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);






var AudioPlayer = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(AudioPlayer, _EventEmitter);

  function AudioPlayer(url) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, AudioPlayer);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AudioPlayer.__proto__ || Object.getPrototypeOf(AudioPlayer)).call(this));

    _this.url = url || '';
    _this.sound = new Audio(url);
    _this.sound.addEventListener('play', function () {
      return _this.emit('play');
    });
    _this.sound.addEventListener('ended', function () {
      return _this.emit('end');
    });
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(AudioPlayer, [{
    key: 'play',
    value: function play() {
      if (this.sound.paused || this.sound.currentTime === 0) this.sound.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.sound.pause();
      if (this.sound.currentTime !== 0) {
        // (FF fix: http://stackoverflow.com/q/20390550/1418049, #440)
        this.sound.currentTime = 0;
      }
    }
  }, {
    key: 'setVolume',
    value: function setVolume(val) {
      this.sound.volume = val;
      this.emit('volumeChanged', val);
    }
  }, {
    key: 'setUrl',
    value: function setUrl(url) {
      if (this.sound.src !== url) this.sound.src = url;
    }
  }, {
    key: 'getUrl',
    value: function getUrl() {
      return this.sound.src;
    }
  }]);

  return AudioPlayer;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);

/* harmony default export */ __webpack_exports__["a"] = AudioPlayer;

/***/ }),
/* 573 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Storage; });




// Abstract class



var Storage = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(Storage, _EventEmitter);

  function Storage() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Storage);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Storage.__proto__ || Object.getPrototypeOf(Storage)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Storage, [{
    key: 'start',
    value: function start(extension) {
      this.extension = extension;
    }
  }, {
    key: 'get',
    value: function get(keys) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'set',
    value: function set(items) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'remove',
    value: function remove(keys) {
      throw new Error('Not implemented');
    }
  }, {
    key: 'clear',
    value: function clear() {
      throw new Error('Not implemented');
    }
  }]);

  return Storage;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);



/***/ }),
/* 574 */,
/* 575 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 23 23\">\n  <defs>\n    <style>" + styles + ".cls-1{fill:#0090e2;}}</style>\n  </defs>\n  <title>drag-n-drop</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <polygon class=\"cls-1 fill\" points=\"15 18 11.5 23 8 18 15 18\"/>\n      <polygon class=\"cls-1 fill\" points=\"8 5 11.5 0 15 5 8 5\"/>\n      <rect class=\"cls-1 fill\" x=\"11\" y=\"5\" width=\"1\" height=\"13\"/>\n      <rect class=\"cls-1 fill\" x=\"11\" y=\"5\" width=\"1\" height=\"13\" transform=\"translate(23 0) rotate(90)\"/>\n      <polygon class=\"cls-1 fill\" points=\"5 15 0 11.5 5 8 5 15\"/>\n      <polygon class=\"cls-1 fill\" points=\"18 8 23 11.5 18 15 18 8\"/>\n      <circle class=\"cls-1 fill\" cx=\"11.5\" cy=\"11.5\" r=\"2.5\"/>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 576 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 18 27\">\n  <defs><style>" + styles + ".cls-1{fill:#fff;}</style></defs>\n  <title>hover</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"\u0421\u043B\u043E\u0439_1-2\" data-name=\"\u0421\u043B\u043E\u0439 1\">\n      <g id=\"\u0421\u043B\u043E\u0439_2-2\" data-name=\"\u0421\u043B\u043E\u0439 2\">\n        <g id=\"Content\">\n          <path class=\"cls-1 fill\" d=\"M9,2a7,7,0,0,1,7,7v9A7,7,0,0,1,2,18V9A7,7,0,0,1,9,2M9,0A9,9,0,0,0,0,9v9a9,9,0,0,0,18,0V9A9,9,0,0,0,9,0Z\"/>\n          <path class=\"cls-1 fill\" d=\"M9,14a1,1,0,0,1-1-1V1a1,1,0,0,1,2,0V13A1,1,0,0,1,9,14Z\"/>\n        </g>\n      </g>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 577 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 18 27\">\n  <defs><style>" + styles + ".cls-1{fill:#fff;}.cls-2{fill:#0090e2;}</style></defs>\n  <title>left-click</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <path class=\"cls-1\" d=\"M9,26a8,8,0,0,1-8-8V9A8,8,0,1,1,17,9v9A8,8,0,0,1,9,26Z\"/>\n      <path class=\"cls-2 fill\" d=\"M9,2a7,7,0,0,1,7,7v9A7,7,0,0,1,2,18V9A7,7,0,0,1,9,2M9,0A9,9,0,0,0,0,9v9a9,9,0,0,0,18,0V9A9,9,0,0,0,9,0Z\"/>\n      <path class=\"cls-2 fill\" d=\"M0,9v5H9V0A9,9,0,0,0,0,9Z\"/>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 578 */,
/* 579 */,
/* 580 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.78 15\">\n  <defs>\n    <style>" + styles + ".cls-1{fill:#fff;stroke:#0090e2;stroke-miterlimit:10;stroke-width:2px;}.cls-2{fill:#0090e2;}</style>\n  </defs>\n  <title>read</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <path class=\"cls-1\" d=\"M1.46,6.26a1.9,1.9,0,0,0,0,2.47A14.43,14.43,0,0,0,12.39,14,14.43,14.43,0,0,0,23.33,8.74a1.9,1.9,0,0,0,0-2.47A14.43,14.43,0,0,0,12.39,1,14.43,14.43,0,0,0,1.46,6.26Z\"/>\n      <circle class=\"cls-2 fill\" cx=\"12.39\" cy=\"7.5\" r=\"3.5\"/>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 581 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 18 27\">\n  <defs>\n    <style>" + styles + ".cls-1{fill:#fff;}.cls-2{fill:#0090e2;}</style>\n  </defs>\n  <title>right-click</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <path class=\"cls-1\" d=\"M9,26a8,8,0,0,1-8-8V9A8,8,0,1,1,17,9v9A8,8,0,0,1,9,26Z\"/>\n      <path class=\"cls-2 fill\" d=\"M9,2a7,7,0,0,1,7,7v9A7,7,0,0,1,2,18V9A7,7,0,0,1,9,2M9,0A9,9,0,0,0,0,9v9a9,9,0,0,0,18,0V9A9,9,0,0,0,9,0Z\"/>\n      <path class=\"cls-2 fill\" d=\"M18,9v5H9V0A9,9,0,0,1,18,9Z\"/>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 582 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 18 27\">\n  <defs>\n    <style>" + styles + ".cls-1{fill:#fff;}.cls-2{fill:#0090e2;}</style>\n  </defs>\n  <title>scroll</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <path class=\"cls-1\" d=\"M9,26a8,8,0,0,1-8-8V9A8,8,0,1,1,17,9v9A8,8,0,0,1,9,26Z\"/>\n      <path class=\"cls-2 fill\" d=\"M9,2a7,7,0,0,1,7,7v9A7,7,0,0,1,2,18V9A7,7,0,0,1,9,2M9,0A9,9,0,0,0,0,9v9a9,9,0,0,0,18,0V9A9,9,0,0,0,9,0Z\"/>\n      <rect class=\"cls-2 fill\" x=\"7\" y=\"4\" width=\"4\" height=\"9\" rx=\"2\" ry=\"2\"/>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__drag_n_drop__ = __webpack_require__(575);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__left_click__ = __webpack_require__(577);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__right_click__ = __webpack_require__(581);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__read__ = __webpack_require__(580);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__scroll__ = __webpack_require__(582);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__type__ = __webpack_require__(584);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__hover__ = __webpack_require__(576);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toolTypeToSvg; });








/* unused harmony default export */ var _unused_webpack_default_export = {
  leftClick: __WEBPACK_IMPORTED_MODULE_1__left_click__["a" /* default */], rightClick: __WEBPACK_IMPORTED_MODULE_2__right_click__["a" /* default */], read: __WEBPACK_IMPORTED_MODULE_3__read__["a" /* default */], scroll: __WEBPACK_IMPORTED_MODULE_4__scroll__["a" /* default */], type: __WEBPACK_IMPORTED_MODULE_5__type__["a" /* default */], dragAndDrop: __WEBPACK_IMPORTED_MODULE_0__drag_n_drop__["a" /* default */], hover: __WEBPACK_IMPORTED_MODULE_6__hover__["a" /* default */]
};

var toolTypeToSvg = function toolTypeToSvg(toolType) {
  return {
    READ: __WEBPACK_IMPORTED_MODULE_3__read__["a" /* default */],
    LEFT_CLICK: __WEBPACK_IMPORTED_MODULE_1__left_click__["a" /* default */],
    RIGHT_CLICK: __WEBPACK_IMPORTED_MODULE_2__right_click__["a" /* default */],
    SCROLL: __WEBPACK_IMPORTED_MODULE_4__scroll__["a" /* default */],
    TYPING: __WEBPACK_IMPORTED_MODULE_5__type__["a" /* default */],
    DRAG: __WEBPACK_IMPORTED_MODULE_0__drag_n_drop__["a" /* default */],
    DROP: __WEBPACK_IMPORTED_MODULE_0__drag_n_drop__["a" /* default */],
    HOVER: __WEBPACK_IMPORTED_MODULE_6__hover__["a" /* default */]
  }[toolType];
};

/***/ }),
/* 584 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function (_ref) {
  var styles = _ref.styles;
  return "\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n  <defs>\n    <style>" + styles + ".cls-1{fill:#fff;}.cls-2,.cls-3{fill:#0090e2;}.cls-3{font-size:16px;font-family:TimesNewRomanPS-BoldMT, Times New Roman;font-weight:700;letter-spacing:-0.02em;}</style>\n  </defs>\n  <title>type</title>\n  <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\" class=\"iorad-tool-icon\">\n    <g id=\"Content\">\n      <rect class=\"cls-1\" x=\"1\" y=\"1\" width=\"22\" height=\"22\" rx=\"3\" ry=\"3\"/>\n      <path class=\"cls-2 fill\" d=\"M20,2a2,2,0,0,1,2,2V20a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V4A2,2,0,0,1,4,2H20m0-2H4A4,4,0,0,0,0,4V20a4,4,0,0,0,4,4H20a4,4,0,0,0,4-4V4a4,4,0,0,0-4-4Z\"/>\n      <text class=\"cls-3 fill\" transform=\"translate(6.81 17)\">T</text>\n    </g>\n  </g>\n</svg>\n";
};

/***/ }),
/* 585 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function () {
    return "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n      <defs>\n          <style>\n              .cls-zendesk-widget-close-icon-2 {\n                  fill: none;\n                  stroke: #fff;\n                  stroke-miterlimit: 10;\n                  stroke-width: 2px;\n              }\n          </style>\n      </defs>\n      <title>\u0420\u0435\u0441\u0443\u0440\u0441 18</title>\n      <g id=\"\u0421\u043B\u043E\u0439_2\" data-name=\"\u0421\u043B\u043E\u0439 2\">\n          <g id=\"Content\">\n              <circle fill=\"#30aabc\" cx=\"12\" cy=\"12\" r=\"12\" transform=\"translate(-2.02 21.56) rotate(-79.29)\" />\n              <line class=\"cls-zendesk-widget-close-icon-2\" x1=\"8.47\" y1=\"8.47\" x2=\"15.54\" y2=\"15.54\" />\n              <line class=\"cls-zendesk-widget-close-icon-2\" x1=\"15.54\" y1=\"8.47\" x2=\"8.47\" y2=\"15.54\" />\n          </g>\n      </g>\n  </svg>\n";
};

/***/ }),
/* 586 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function () {
  return "\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n    <g>\n      <g>\n        <circle fill=\"#dedede\" cx=\"12\" cy=\"12\" r=\"12\" />\n        <polygon fill=\"#fff\" points=\"9 5.9 8.99 18.24 12.53 15 17.33 15.01 9 5.9\" />\n      </g>\n    </g>\n  </svg>\n";
};

/***/ }),
/* 587 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_documentSize__ = __webpack_require__(311);
/* harmony export (immutable) */ __webpack_exports__["a"] = scrollWindowIntoView;


// function is serializable to string,
// so it should keep all things it needs in itself
function scrollWindowIntoView(bounds) {
  var animationTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;

  var findHorizontalScroll = function findHorizontalScroll(bounds) {
    var pos = window.pageXOffset + bounds.left;
    return Math.max(0, Math.min(pos, pos - (window.innerWidth - bounds.width) / 2, document.body.scrollWidth - window.innerWidth));
  };
  var findVerticalScroll = function findVerticalScroll(bounds) {
    var pos = window.pageYOffset + bounds.top;
    return Math.max(0, Math.min(pos, pos - (window.innerHeight - bounds.height) / 2, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_documentSize__["a" /* getDocumentHeight */])() - window.innerHeight));
  };
  var findTargetScroll = function findTargetScroll(bounds) {
    var x = bounds.left < 0 || bounds.right > window.innerWidth ? findHorizontalScroll(bounds) : window.pageXOffset;
    var y = bounds.top < 0 || bounds.bottom > window.innerHeight ? findVerticalScroll(bounds) : window.pageYOffset;
    return { x: x, y: y };
  };
  var raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame).bind(window);
  var animate = function animate(startTime, targetScroll) {
    raf(function () {
      var time = Date.now() - startTime;
      var x = targetScroll.x,
          y = targetScroll.y;
      // animation time progress from 0 to 1

      var timeValue = Math.min(1 / animationTime * time, 1);
      if (timeValue >= 1) {
        window.scroll(x, y);
      } else {
        window.scroll(x - (x - window.pageXOffset) * Math.pow(1 - timeValue, timeValue / 2), y - (y - window.pageYOffset) * Math.pow(1 - timeValue, timeValue / 2));
        animate(startTime, targetScroll);
      }
    });
  };
  var scrollTo = function scrollTo(pos) {
    return animate(Date.now(), pos);
  };

  var targetScroll = findTargetScroll(bounds);
  scrollTo(targetScroll);
}

/***/ }),
/* 588 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__waitFor__ = __webpack_require__(185);
/* harmony export (immutable) */ __webpack_exports__["a"] = addNewStyle;



// http://stackoverflow.com/a/7918012/1418049
// Useful for overriding !important rules
function addNewStyle(newStyle) {
  var styleElement = document.getElementById(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])('styles_js'));
  if (!styleElement) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    styleElement.id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__namespace__["a" /* default */])('styles_js');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__waitFor__["a" /* default */])(function () {
      return document.head;
    }, function () {
      document.head.appendChild(styleElement);
    }, 0);
  }
  styleElement.appendChild(document.createTextNode(newStyle));
}

/***/ }),
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__authFetch__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_isMobileBrowsers__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_utils_logger__ = __webpack_require__(6);







var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_utils_logger__["a" /* getFileLogger */])(__filename);

/* harmony default export */ __webpack_exports__["a"] = (function () {
  var _ref = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(userId, urls) {
    var mobileMode, r, json;
    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            mobileMode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__utils_isMobileBrowsers__["a" /* default */])();
            _context.next = 3;
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__authFetch__["a" /* apiFetch */])(__WEBPACK_IMPORTED_MODULE_3__settings__["a" /* default */].get('server.tutorialLiveList.url', {
              urls: urls && urls.map(escape).join(','),
              searchKey: '',
              embed: true,
              mobileMode: mobileMode
            }));

          case 3:
            r = _context.sent;

            if ([200, 204, 304].indexOf(r.status) === -1) {
              logger.error('Fetch embed tutorials: invalid response');
            }

            if (!([200, 304].indexOf(r.status) !== -1)) {
              _context.next = 12;
              break;
            }

            _context.next = 8;
            return r.json();

          case 8:
            json = _context.sent;
            return _context.abrupt('return', json || []);

          case 12:
            return _context.abrupt('return', []);

          case 13:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/common/utils/fetchEmbedTutorials.js"))

/***/ }),
/* 594 */,
/* 595 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function () {
  var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var liveIdMatch = search.match(/ioradLiveId=(\d+)/);
  var liveIdCorrectBrowser = search.match(/ioradLiveEmbed=true/) === null ? "embed" !== 'embed' : "embed" === 'embed';
  return liveIdMatch && liveIdMatch[1] && liveIdCorrectBrowser ? liveIdMatch[1] : '';
};

/***/ }),
/* 596 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = hideConsoleMessages;
var defaultConsoleMethods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'profile', 'profileEnd', 'time', 'timeEnd', 'timeline', 'timelineEnd', 'timeStamp', 'trace', 'warn'];

function hideConsoleMessages() {
  var consoleMethods = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConsoleMethods;
  var hideExceptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  consoleMethods.forEach(function (method) {
    window.console[method] = function () {};
  });

  if (hideExceptions) {
    window.onerror = function () {
      // return true to suppress exception
      return true;
    };
  }
}

/***/ }),
/* 597 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = isSpriteHolder;
/*
  DOCUMENTATION
  isSpriteHolder()
    returns true or false (is or is not a sprite holder)

    Aimed at the Google Docs/MS Office sprite technique
    In these sites, buttons get their image by a large sprite element contained
    inside the button. iorad needs the button itself, and not the sprite element,
    as a target.

    An element is a sprite holder if the following three conditions are true:
    a) it has empty inner html
    b) it has position: absolute;
    c) it is larger than its parent
    d) it has a (background) image that's repeated elsewhere on the page.
    This script checks for these three conditions and returns true if they're
    all true; false if they're not.
    
    Position: absolute is simple: getComputedStyle for position; if it's 
    'absolute' the condition is satisfied.
    
    Dimensions are also simple: take the offsetWidth/Height of the element
    and its parent and compare them. If the element has a larger offset in
    at least one dimension it's larger than its parent and this condition is
    satisfied.
    Note: slight performance hit; measuring offsetWidth/Height requires a
    re-layout. Since we're only checking two elements, though, and only
    when the user clicks, this should not be a huge problem.
    
    The (background) image is slightly more complex. First we check if the
    element has a background image. If so, we search for other elements with
    the same nodeName (tag name) and className, and check them for background
    images as well.
    If we find at least MIN_BACKGROUND_MATCHES other elements with the same background image,
    this condition is satisfied.
    The two elements do not have to define their background images in the same way;
    i.e. if one uses :before and the other src this is counted as a match
    and the condition is satisfied. This seems unlikely to crop up in the
    wild.
    
    Looking for backgrounds is the job of findBackground(). It returns either
    a background string (as delivered by the browser), or false if no
    background was found.
    
    We look for background images in three ways; in this order:
    - A src attribute on the element itself (MS Office use case).
    - A background declaration on the element itself (currently no use case)
    - A background declaration on element:before (Google Docs use case)
    As soon as the script finds one background image it stops checking.
    In the unlikely case that an element would have two background images it
    finds only the one whose function fires first.  
    
    testFunctions contains the test functions. Note it's an array; the functions
    are run in order.
    
    Adding a check is easy: just add a function to testFunctions.
    
    Changing the order is easy as well: just change the order of the
    functions in testFunctions.
    
    After an image has been found we check if it has an http or https. If it
    does it's a true background image, and any comparisons are valid.
    If it does not it is rejected, and we proceed as if the element has
    no background image.
  
*/

var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var MIN_BACKGROUND_MATCHES = 1;

var TEST_FUNCTIONS = [function (el) {
  return el.src;
}, function (el, computedStyle) {
  return computedStyle.background;
}, function (el) {
  return window.getComputedStyle(el, '::before').content;
}];

function findBackground(element) {
  var computedStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.getComputedStyle(element);

  for (var i = 0; i < TEST_FUNCTIONS.length; i++) {
    var fn = TEST_FUNCTIONS[i];
    var bg = fn(element, computedStyle);
    if (/https?/.test(bg)) {
      return bg;
    }
  }
  logger.debug('No background found');
  return null;
}

function isSpriteHolder(element) {
  if (!element.innerHTML) {
    logger.debug('Has empty inner HTML');

    var computedStyle = window.getComputedStyle(element);
    var hasPositionAbsolute = computedStyle.position === 'absolute';
    if (hasPositionAbsolute) {
      logger.debug('Has position absolute');

      var elementDimensions = [element.offsetWidth, element.offsetHeight];
      var parent = element.parentNode;
      var parentDimensions = [parent.offsetWidth, parent.offsetHeight];
      var isLarger = elementDimensions[0] > parentDimensions[0] || elementDimensions[1] > parentDimensions[1];
      if (isLarger) {
        logger.debug('Element larger than its parent');

        var backgroundImage = findBackground(element, computedStyle);
        if (backgroundImage) {
          logger.debug('Background image found: ' + backgroundImage);

          var queryString = element.className ? element.tagName + '.' + element.classList[0] : element.tagName;
          var otherEls = document.querySelectorAll(queryString);
          var matches = 0;
          for (var i = 0; i < otherEls.length; i++) {
            if (otherEls[i] === element || otherEls[i].innerHTML) continue;
            var bgCompare = findBackground(otherEls[i]);
            if (bgCompare === backgroundImage) {
              matches++;
              if (matches >= MIN_BACKGROUND_MATCHES) {
                logger.debug('Has same background as other elements');
                logger.debug('Accepted');
                return true;
              }
            }
          }
        }
      }
    }
  }
  logger.debug('Rejected');
  return false; // or return element?
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/common/utils/isSpriteHolder.js"))

/***/ }),
/* 598 */,
/* 599 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// rgb string to array
/* harmony default export */ __webpack_exports__["a"] = function (rgbColor) {
  var rgbArray = rgbColor.split(',');
  rgbArray[0] = rgbArray[0].substr(rgbArray[0].indexOf('(') + 1); // from " rgb( XYZ " to " XYZ "
  rgbArray[2] = rgbArray[2].substr(0, rgbArray[2].indexOf(')')); // from " XYZ ) " to "  XYZ "
  rgbArray = rgbArray.map(function (value) {
    return parseFloat(value.trim(), 10);
  });
  return rgbArray;
};

/***/ }),
/* 600 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// rgba string to array
/* harmony default export */ __webpack_exports__["a"] = function (rgbaColor) {
  var rgbaArray = rgbaColor.split(',');
  rgbaArray[0] = rgbaArray[0].substr(rgbaArray[0].indexOf('(') + 1); // from " rgb( XYZ " to " XYZ "
  rgbaArray[3] = rgbaArray[3].substr(0, rgbaArray[3].indexOf(')')); // from " XYZ ) " to "  XYZ "
  rgbaArray = rgbaArray.map(function (value) {
    return parseFloat(value.trim(), 10);
  });
  return rgbaArray;
};

/***/ }),
/* 601 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_chrome_browser__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Bridge; });



// Bridges Editor and Background (needed in Edge where onConnectExternal isn't supported)





var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var Bridge = function () {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Bridge, null, [{
    key: 'listen',
    value: function listen() {
      var _this = this;

      // wait for editor connections
      window.addEventListener('message', function (event) {
        var message = event.data;
        if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;

        //logger.debug('Bridge message', message);
        if (message.from === 'iorad-editor' && message.to === __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_base_common_utils_namespace__["a" /* default */])() && message.connect) {
          var editorConnectPort = event.ports[0];
          var backgroundConnectPort = __WEBPACK_IMPORTED_MODULE_3_chrome_browser__["a" /* default */].runtime.connect(message.connectData);

          var instance = new _this();
          instance.start(editorConnectPort, backgroundConnectPort);
        }
      });
    }
  }]);

  function Bridge() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Bridge);

    this.editorConnectPort = null;
    this.backgroundConnectPort = null;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Bridge, [{
    key: 'start',
    value: function start(editorConnectPort, backgroundConnectPort) {
      this.editorConnectPort = editorConnectPort;
      this.backgroundConnectPort = backgroundConnectPort;

      this.bindEditorEvents();
      this.bindBackgroundEvents();
    }
  }, {
    key: 'bindEditorEvents',
    value: function bindEditorEvents() {
      var _this2 = this;

      this.editorConnectPort.onmessage = function (event) {
        var message = event.data;

        if (message && message.disconnect) {
          //logger.debug('BRIDGE: editor disconnected', message);
          _this2.backgroundConnectPort.disconnect();
        } else {
          //logger.debug('BRIDGE: got message from editor', message);
          _this2.backgroundConnectPort.postMessage(message);
        }
      };
    }
  }, {
    key: 'bindBackgroundEvents',
    value: function bindBackgroundEvents() {
      var _this3 = this;

      this.backgroundConnectPort.onDisconnect.addListener(function () {
        //logger.debug('BRIDGE: background disconnected');
        _this3.editorConnectPort.postMessage({ disconnect: true });
        _this3.editorConnectPort.close();
      });

      this.backgroundConnectPort.onMessage.addListener(function (message) {
        //logger.debug('BRIDGE: got message from background', message);
        _this3.editorConnectPort.postMessage(message);
      });
    }
  }]);

  return Bridge;
}();


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/Bridge.js"))

/***/ }),
/* 602 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_common_utils_waitFor__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Bridge__ = __webpack_require__(601);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditorFrameNode; });







var EditorFrameNode = function () {
  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EditorFrameNode, [{
    key: 'getBridgeClass',
    value: function getBridgeClass() {
      return __WEBPACK_IMPORTED_MODULE_5__Bridge__["a" /* default */];
    }
  }]);

  function EditorFrameNode(name, version, id) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EditorFrameNode);

    this.name = name;
    this.version = version;
    this.id = id;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EditorFrameNode, [{
    key: 'start',
    value: function start() {
      var BridgeClass = this.getBridgeClass();

      this.setupIoradExtensionExistence();
      BridgeClass.listen();
    }
  }, {
    key: 'setupIoradExtensionExistence',
    value: function setupIoradExtensionExistence() {
      var _this = this;

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_base_common_utils_waitFor__["a" /* default */])(function () {
        return document.documentElement;
      }, function () {
        document.documentElement.setAttribute('data-' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_namespace__["a" /* default */])(), _this.name);
        if (document.location.href.match('iorad.com') !== null || document.location.hostname === 'dev.iorad.dev') {
          document.documentElement.setAttribute('data-' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_namespace__["a" /* default */])('version'), _this.version);
          document.documentElement.setAttribute('data-' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_namespace__["a" /* default */])('build'), __WEBPACK_IMPORTED_MODULE_3__common_settings__["a" /* default */].get('extension.' + _this.name + '.ids.' + _this.id + '.build'));
        }
      }, 0);

      // document.addEventListener('DOMContentLoaded', () => {
      //   testMode();
      //   testOutlineDrawing();
      // });
    }
  }]);

  return EditorFrameNode;
}();



/***/ }),
/* 603 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_utils_randomString__ = __webpack_require__(518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_utils_hideConsoleMessages__ = __webpack_require__(596);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_utils_waitFor__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__waitForComponent__ = __webpack_require__(621);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Flux__ = __webpack_require__(604);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__common_sharedMemory_SharedMemory__ = __webpack_require__(310);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__KeyboardShortcuts__ = __webpack_require__(605);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__OverlayController__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__OverlayController___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__OverlayController__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__zoom_zoomTopFrame__ = __webpack_require__(623);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_base_content_player_ContentPlayerTopFrame__ = __webpack_require__(611);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_base_content_capture_DocumentCaptureTopFrame__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_base_content_capture_DocumentCaptureTopFrame___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_base_content_capture_DocumentCaptureTopFrame__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_base_content_PanelController__ = __webpack_require__(522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Extension; });




// README: keep this file as small as possible, move any logic to specific modules
// and initialize/start them here if needed.





//import testMode from './testMode';
//import { testOutlineDrawing } from './testMode';















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_20_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var Extension = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(Extension, _EventEmitter);

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Extension, [{
    key: 'getInitialState',
    value: function getInitialState() {
      return {
        locationHref: null,
        locationHrefChangedAt: null,

        pageLoggedInType: null,

        intercomInstalled: false,
        googleTranslateInstalled: false
      };
    }
  }, {
    key: 'getURL',
    value: function getURL() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getPortManagerClass',
    value: function getPortManagerClass() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getFluxClass',
    value: function getFluxClass() {
      return __WEBPACK_IMPORTED_MODULE_11__Flux__["a" /* default */];
    }
  }, {
    key: 'getSharedMemoryClass',
    value: function getSharedMemoryClass() {
      return __WEBPACK_IMPORTED_MODULE_12__common_sharedMemory_SharedMemory__["a" /* default */];
    }
  }, {
    key: 'getStorageClass',
    value: function getStorageClass() {
      throw new Error('Not implemented');
    }
  }, {
    key: 'getKeyboardShortcutsClass',
    value: function getKeyboardShortcutsClass() {
      return __WEBPACK_IMPORTED_MODULE_13__KeyboardShortcuts__["a" /* default */];
    }
  }, {
    key: 'getOverlayControllerClass',
    value: function getOverlayControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_14__OverlayController___default.a;
    }
  }, {
    key: 'getPanelControllerClass',
    value: function getPanelControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_18_base_content_PanelController__["a" /* default */];
    }
  }, {
    key: 'getContentPlayerClass',
    value: function getContentPlayerClass() {
      return __WEBPACK_IMPORTED_MODULE_16_base_content_player_ContentPlayerTopFrame__["a" /* default */];
    }
  }, {
    key: 'getDocumentCaptureClass',
    value: function getDocumentCaptureClass() {
      return __WEBPACK_IMPORTED_MODULE_17_base_content_capture_DocumentCaptureTopFrame___default.a;
    }

    // instantiate modules

  }]);

  function Extension(name, version, id) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Extension);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Extension.__proto__ || Object.getPrototypeOf(Extension)).call(this));

    _this.name = name;
    _this.version = version;
    _this.id = id;

    _this.isReady = false;

    _this.frameId = 'iorad_' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_utils_randomString__["a" /* default */])();

    _this.isTopFrame = window.parent === window;
    logger.debug('Is top frame?', _this.isTopFrame, document.location.href);

    var PortManagerClass = _this.getPortManagerClass();
    _this.portManager = new PortManagerClass();

    var FluxClass = _this.getFluxClass();
    _this.flux = new FluxClass();

    var SharedMemoryClass = _this.getSharedMemoryClass();
    _this.sharedMemory = new SharedMemoryClass(_this.frameId);

    var StorageClass = _this.getStorageClass();
    _this.storage = new StorageClass();

    var KeyboardShortcutsClass = _this.getKeyboardShortcutsClass();
    _this.keyboardShortcuts = new KeyboardShortcutsClass();

    var OverlayControllerClass = _this.getOverlayControllerClass();
    _this.overlayController = new OverlayControllerClass();

    var PanelControllerClass = _this.getPanelControllerClass();
    _this.panelController = new PanelControllerClass();

    var ContentPlayerClass = _this.getContentPlayerClass();
    _this.contentPlayer = new ContentPlayerClass();

    var DocumentCaptureClass = _this.getDocumentCaptureClass();
    _this.documentCapture = new DocumentCaptureClass();
    return _this;
  }

  // start modules
  // (having a separate method for this reduces circular dependency problems)


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Extension, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      return Promise.resolve().then(function () {
        return _this2.setupLogging();
      }).then(function () {
        return _this2.portManager.start(_this2);
      }).then(function () {
        return _this2.flux.start(_this2);
      }).then(function () {
        return _this2.sharedMemory.start(_this2);
      }).then(function () {
        return _this2.storage.start(_this2);
      }).then(function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15__zoom_zoomTopFrame__["a" /* start */])(_this2);
      }).then(function () {
        return _this2.keyboardShortcuts.start(_this2);
      }).then(function () {
        return _this2.overlayController.start(_this2);
      }).then(function () {
        return _this2.panelController.start(_this2);
      }).then(function () {
        return _this2.contentPlayer.start(_this2);
      }).then(function () {
        return _this2.documentCapture.start(_this2);
      }).then(function () {
        _this2.isReady = true;
        _this2.emit('ready');
      });
    }
  }, {
    key: 'setupLogging',
    value: function setupLogging() {
      if (__WEBPACK_IMPORTED_MODULE_6__common_settings__["a" /* default */].get('debug.isDisabled')) __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_utils_hideConsoleMessages__["a" /* default */])(['log', 'info']);
    }
  }]);

  return Extension;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/Extension.js"))

/***/ }),
/* 604 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_Flux__ = __webpack_require__(274);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_StateManager__ = __webpack_require__(510);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__actions__ = __webpack_require__(608);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_mergeWith__ = __webpack_require__(751);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_mergeWith___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_mergeWith__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Flux; });











var Flux = function (_CommonFlux) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(Flux, _CommonFlux);

  function Flux() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Flux);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = Flux.__proto__ || Object.getPrototypeOf(Flux)).call.apply(_ref, [this].concat(args)));

    _this.ownContextName = 'content';

    _this.contentState = {};
    _this.oldContentState = null;

    _this.panelState = {};
    _this.oldPanelState = null;

    _this.backgroundState = {};
    _this.oldBackgroundState = null;
    _this.backgroundStateReceived = false;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Flux, [{
    key: 'start',
    value: function start(extension) {
      var _this2 = this;

      this.extension = extension;
      this.panelPort = this.extension.portManager.panelPort;
      this.backgroundPort = this.extension.portManager.backgroundPort;

      this.portsByContext = {
        panel: this.panelPort,
        background: this.backgroundPort
      };

      this.localStateManager = new __WEBPACK_IMPORTED_MODULE_6_base_common_StateManager__["a" /* default */](this.extension.getInitialState());
      this._actions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__actions__["a" /* default */])({
        setState: this.localStateManager.setState.bind(this.localStateManager),
        getState: this.localStateManager.getState.bind(this.localStateManager)
      });

      this.localStateManager.on('stateChanged', function (state) {
        return _this2.handleContentState(state);
      });
      this.extension.once('ready', function () {
        return _this2.handleContentState(_this2.localStateManager.state);
      });

      this.panelPort.on('message', function (message) {
        if (message.topic === 'panelStateChanged') {
          _this2.handlePanelState(message.data);
        }

        if (message.topic === 'dispatchAction') {
          _this2.dispatch.apply(_this2, [message.data.context, message.data.actionName].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(message.data.actionArgs)));
        }
      });

      this.backgroundPort.on('message', function (message) {
        if (message.topic === 'backgroundStateChanged') {
          var excluded = message.excludedTabs && message.excludedTabs.indexOf(message.tab.id) !== -1;
          _this2.handleBackgroundState(message.data, excluded, message.tab.id);
        }

        if (message.topic === 'dispatchAction') {
          _this2.dispatch.apply(_this2, [message.data.context, message.data.actionName].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(message.data.actionArgs)));
        }
      });

      // request current state
      this.backgroundPort.send({ topic: 'requestBackgroundState' });
      this.panelPort.send({ topic: 'requestPanelState' });
    }
  }, {
    key: 'handleContentState',
    value: function handleContentState(state) {
      if (!state) return;
      this.oldContentState = this.contentState;
      this.contentState = state;

      this.emit('update', 'content', this.oldContentState, this.contentState);

      this.backgroundPort.send({
        topic: 'contentStateChanged',
        data: state
      });
      this.panelPort.send('contentStateChanged', state);
    }
  }, {
    key: 'handlePanelState',
    value: function handlePanelState(state) {
      if (!state) return;
      this.oldPanelState = this.panelState;
      this.panelState = state;

      this.emit('update', 'panel', this.oldPanelState, this.panelState);

      this.backgroundPort.send({
        topic: 'panelStateChanged',
        data: state
      });
    }
  }, {
    key: 'fixBackgroundState',
    value: function fixBackgroundState(state) {
      return state ? __WEBPACK_IMPORTED_MODULE_8_lodash_mergeWith___default()({}, this.backgroundState || {}, state || {},

      // do not update empty values
      function (old, updated) {
        return typeof updated === 'undefined' || updated === null ? old : updated;
      }) : null;
    }

    // Note: tabId is our own tab id

  }, {
    key: 'handleBackgroundState',
    value: function handleBackgroundState(state) {
      var excluded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var tabId = arguments[2];

      if (!state) return;
      this.oldBackgroundState = this.backgroundState;
      this.backgroundState = state = this.fixBackgroundState(state);
      this.backgroundStateReceived = true;

      if (!this.backgroundState) return;

      if (!excluded) {
        this.emit('update', 'background', this.oldBackgroundState, this.backgroundState, tabId);
      }

      this.panelPort.send('backgroundStateChanged', state, excluded);
    }
  }, {
    key: 'contentContext',
    value: function contentContext() {
      return {
        state: this.contentState,
        dispatch: this.dispatch.bind(this, { name: 'content' })
      };
    }
  }, {
    key: 'backgroundContext',
    value: function backgroundContext() {
      return {
        state: this.backgroundState,
        dispatch: this.dispatch.bind(this, { name: 'background' })
      };
    }
  }, {
    key: 'panelContext',
    value: function panelContext() {
      return {
        state: this.panelState,
        dispatch: this.dispatch.bind(this, { name: 'panel' })
      };
    }
  }, {
    key: 'dispatch',
    value: function dispatch(context, actionName) {
      for (var _len2 = arguments.length, actionArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        actionArgs[_key2 - 2] = arguments[_key2];
      }

      if (context.name !== this.ownContextName) {
        this.callRemoteAction(context, actionName, actionArgs);
      } else {
        // direct
        this.callLocalAction(actionName, actionArgs);
      }
    }
  }, {
    key: 'sendToContext',
    value: function sendToContext(context, message) {
      if (context.name === 'panel') {
        this.portsByContext[context.name].send(message.topic, message.data);
      } else {
        this.portsByContext[context.name].send(message);
      }
    }
  }]);

  return Flux;
}(__WEBPACK_IMPORTED_MODULE_5_base_common_Flux__["a" /* default */]);



/***/ }),
/* 605 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyboardShortcuts; });



var KeyboardShortcuts = function () {
  function KeyboardShortcuts() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, KeyboardShortcuts);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(KeyboardShortcuts, [{
    key: 'start',
    value: function start(extension) {
      var _this = this;

      this.extension = extension;

      this.backgroundPort = this.extension.portManager.backgroundPort;

      // binding keydown for hotKey combination
      document.addEventListener('keydown', function (e) {
        var special = void 0;
        var key = void 0;
        var value = void 0;
        if (e.shiftKey || e.metaKey || e.ctrlKey || e.altKey) {
          special = e.shiftKey ? 'shiftKey' : e.metaKey ? 'metaKey' : e.ctrlKey ? 'ctrlKey' : e.altKey ? 'altKey' : '';
          key = e.which || e.keyCode || e.charCode;
          value = special.replace(/Key/, '') + ' + ' + String.fromCharCode(key);

          _this.backgroundPort.send({ 'hotKey': value });
        }
      });
    }
  }]);

  return KeyboardShortcuts;
}();



/***/ }),
/* 606 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_Port__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PanelPort; });





// Note: assumes that "documents" is the only other entity from where it can send/receive messages.




var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_logger__["a" /* getFileLogger */])(__filename);



var PanelPort = function (_Port) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(PanelPort, _Port);

  function PanelPort() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, PanelPort);

    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PanelPort.__proto__ || Object.getPrototypeOf(PanelPort)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(PanelPort, [{
    key: '_bindHandlers',
    value: function _bindHandlers() {
      var _this2 = this;

      if (this._bound) return;
      this._bound = true;

      // Receive panel messages (direct or from a parent frame) and route them to child frames
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_windowEvents__["a" /* addWindowListener */])('message', function (event) {
        var message = event.data;
        //if (event.source !== window) return;
        if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;
        if (message.from !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('panel') || message.to !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('content')) return;

        event.stopImmediatePropagation();

        //logger.debug('PanelPort: received panel message', message);

        _this2._onMessageReceived(message, function () {});
      });
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      throw new Error("disconnect not supported");
    }
  }, {
    key: 'send',
    value: function send(topic, data) {
      var excluded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (this._disabled) return;
      //logger.debug('PanelPort: send', topic, data);

      var message = { topic: topic, data: data, excluded: excluded, from: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('content'), to: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('panel') };

      var panelIframe = document.querySelector('.' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('panel') + ' iframe');
      if (!panelIframe) return; // TODO: store in queue and send when panel is loaded?

      panelIframe.contentWindow.postMessage(message, '*');
    }
  }, {
    key: 'enable',
    value: function enable() {
      this._disabled = false;
    }
  }, {
    key: 'disable',
    value: function disable() {
      this._disabled = true;
    }
  }, {
    key: 'isDisabled',
    value: function isDisabled() {
      return this._disabled;
    }
  }]);

  return PanelPort;
}(__WEBPACK_IMPORTED_MODULE_5__common_Port__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/PanelPort.js"))

/***/ }),
/* 607 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PanelPort__ = __webpack_require__(606);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PortManager; });




var PortManager = function () {
  function PortManager() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, PortManager);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(PortManager, [{
    key: 'getBackgroundPortClass',
    value: function getBackgroundPortClass() {
      // abstract
      return null;
    }
  }, {
    key: 'getPanelPortClass',
    value: function getPanelPortClass() {
      return __WEBPACK_IMPORTED_MODULE_2__PanelPort__["a" /* default */];
    }
  }, {
    key: 'start',
    value: function start(extension) {
      this.extension = extension;

      this.setupBackgroundPort();
      this.setupPanelPort();
    }
  }, {
    key: 'setupBackgroundPort',
    value: function setupBackgroundPort() {
      var BackgroundPortClass = this.getBackgroundPortClass();
      this.backgroundPort = new BackgroundPortClass(null, '', this.extension);
      this.backgroundPort.connect();
    }
  }, {
    key: 'setupPanelPort',
    value: function setupPanelPort() {
      var PanelPortClass = this.getPanelPortClass();
      this.panelPort = new PanelPortClass(null, '', this.extension);
      this.panelPort.connect();
    }
  }]);

  return PortManager;
}();



/***/ }),
/* 608 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = actionsFactory;
function actionsFactory(_ref) {
  var setState = _ref.setState;

  return {
    setLocationHref: function setLocationHref(value, changedAt) {
      setState({
        locationHref: value,
        locationHrefChangedAt: changedAt
      });
    },
    setPageLoggedInType: function setPageLoggedInType(value) {
      setState({
        pageLoggedInType: value
      });
    },
    toggleIntercomInstalled: function toggleIntercomInstalled(value) {
      setState({
        intercomInstalled: value
      });
    },
    toggleGoogleTranslateInstalled: function toggleGoogleTranslateInstalled(value) {
      setState({
        googleTranslateInstalled: value
      });
    }
  };
}

/***/ }),
/* 609 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elementLocator__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_utils_coordinates__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_utils_getParentPopup__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_css_escape__ = __webpack_require__(540);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_css_escape___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_css_escape__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_isSpriteHolder__ = __webpack_require__(597);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_dom__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_map__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = detectName;
/* unused harmony export findActiveElement */
/* unused harmony export getElementInfo */















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

// string: tag name
// function: tester on the element
var BASIC_TYPE_RULES = {
  'BUTTON': ['button', function (el) {
    return el.classList.contains('btn');
  }, function (el) {
    return el.classList.contains('button');
  }],
  'LINK': ['a'],
  'NATIVE_DROPDOWN': ['select'],
  'IMAGE': ['img', 'svg', 'canvas'],
  'LABEL': ['label', function (el) {
    return el.hasAttribute('for');
  }],
  'AUDIO': ['audio'],
  'VIDEO': ['video'],
  // last resort
  'TEXT_FIELD': ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'b', 'strong', 'i', 'u', 'caption', 'code', 'pre', function (el) {
    // el only contains text
    return el.textContent && el.textContent === el.innerHTML;
  }]
};

var INPUT_TYPE_MAPPING = {
  button: "BUTTON",
  checkbox: "CHECK_BOX",
  radio: "RADIO_BUTTON",
  image: "BUTTON",
  submit: "BUTTON",
  reset: "BUTTON",
  hidden: "UNDEFINED"
};

var ROLE_MAPPING = {
  link: "LINK",
  alertdialog: "DIALOG",
  dialog: "DIALOG",
  button: "BUTTON",
  option: "OPTION",
  checkbox: "CHECK_BOX",
  combobox: "COMBO_BOX",
  radio: "RADIO_BUTTON",
  tab: "TAB",
  presentation: "PRESENTATION"
};

var STYLE_PROPERTIES = ['color', 'background-color', 'font-size', 'font-weight', 'font-family'];

// types tipically conveying lots of information and actions (name, click, etc.)
var HIGH_PRIORITY = ["IFRAME", "LINK", "BUTTON", "CHECK_BOX", "RADIO_BUTTON", "NATIVE_DROPDOWN", "COMBO_BOX", "TEXT_INPUT", "TAB"];

// avoids to use the whole page content as name
var NAME_TEXTCONTENT_MAX_LENGTH = 200;

function getTagName(el) {
  // (document and window have no tagname)
  return el && typeof el.tagName === 'string' ? el.tagName.toLowerCase() : '';
}

function detectTypeFromBasicRules(el) {
  var elTagName = getTagName(el);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(BASIC_TYPE_RULES)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var currentType = _step.value;

      var rules = BASIC_TYPE_RULES[currentType];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var rule = _step2.value;

          if (typeof rule === 'string') {
            // rule is the tagname
            if (elTagName === rule) {
              return currentType;
            }
          } else if (typeof rule === 'function') {
            if (rule(el)) {
              return currentType;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return 'UNDEFINED';
}

function detectType(el) {
  if (!el.classList) {
    // Maybe the document/window and not a proper element
    return 'UNDEFINED';
  }

  var elTagName = getTagName(el);

  // top priority element, an inner content script can probably return a better info
  if (elTagName === 'iframe') {
    return 'IFRAME';
  }

  if (elTagName === 'input' || elTagName === 'textarea' || el.hasAttribute('contenteditable')) {
    return INPUT_TYPE_MAPPING[el.type] || 'TEXT_INPUT';
  }

  // a select element is a NATIVE_DROPDOWN no matter what its role attribute is,
  // since the background only draws native dropdowns for that type
  if (elTagName === 'select') {
    return 'NATIVE_DROPDOWN';
  }

  if (el.hasAttribute('role')) {
    var role = el.getAttribute('role');
    // logger.debug('ROLE', role)
    if (role in ROLE_MAPPING) {
      return ROLE_MAPPING[role];
    }
  }

  return detectTypeFromBasicRules(el);
}

// Exported for tests, not for user
function detectName(el) {
  if (!el.classList) {
    // Maybe the document/window and not a proper element
    return undefined;
  }

  var elTagName = getTagName(el);

  if (elTagName === 'select' && el.selectedOptions.length > 0) {
    return el.selectedOptions[0].label;
  }

  if (el.hasAttribute('aria-label')) {
    return el.getAttribute('aria-label');
  }

  if (el.hasAttribute('aria-labelledby')) {
    var labelEl = document.getElementById(el.getAttribute('aria-labelledby'));
    if (labelEl) {
      return labelEl.textContent;
    }
  }

  if ('value' in el && elTagName !== 'option') {
    if (el.id) {
      // try with label
      var _labelEl = document.querySelector('label[for="' + __WEBPACK_IMPORTED_MODULE_5_css_escape___default()(el.id) + '"]');
      if (_labelEl) {
        var labelElName = detectName(_labelEl);
        if (labelElName) {
          return labelElName;
        }
      }
    }

    if (el.hasAttribute('placeholder')) {
      return el.getAttribute('placeholder');
    }

    var isPrivateInput = ['text', 'password'].indexOf(el.getAttribute('type')) !== -1;

    // (value is ignored for text inputs for privacy reasons)
    if (el.value !== '' && !isPrivateInput) {
      return el.value;
    }

    if (isPrivateInput && el.id) {
      return el.id;
    }
  }

  if (el.textContent && el.textContent.length <= NAME_TEXTCONTENT_MAX_LENGTH) {
    return el.textContent;
  }

  return undefined;
}

function detectStyle(el) {
  var style = {};

  var computedStyles = el.classList ? window.getComputedStyle(el, null) : {};
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = STYLE_PROPERTIES[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var prop = _step3.value;

      var value = computedStyles[prop];
      if (typeof value !== 'undefined') {
        style[prop] = value;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return style;
}

function detectOptions(el) {
  if (!el.classList || !el.options) {
    return null;
  }
  return __WEBPACK_IMPORTED_MODULE_9_lodash_map___default()(el.options, function (o) {
    return { value: o.value, label: o.label };
  });
}

function detectValue(el) {
  if (!el.classList) {
    return undefined;
  }
  return el.value;
}

function detectInfo(el) {
  // TODO: we could need more info, at least attributes
  var name = detectName(el);
  var type = detectType(el);
  var style = detectStyle(el);
  var bounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__["a" /* default */])(el, true);
  var options = detectOptions(el);
  var value = detectValue(el);

  var info = { type: type, bounds: bounds, name: name, options: options, value: value, style: style };

  return info;
}

// traverses the DOM tree bottom-up starting from the given el and
// returns the first encountered high priority info (if any),
// otherwise, returns the info of the given el.
// NOTE: sprite holder elements are excluded, they are only used as last resort
// if there aren't other candidates.
function findActiveElement(target) {
  var isValid = function isValid(el) {
    return !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_isSpriteHolder__["a" /* default */])(el);
  };
  var firstElement = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_dom__["a" /* closest */])(target, isValid) || target;
  var firstElementBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__["a" /* default */])(firstElement);

  function makeCandidate(el, isFirst) {
    var info = detectInfo(el);
    return {
      el: el,
      info: info,
      target: isFirst,
      highPriority: HIGH_PRIORITY.indexOf(info.type) !== -1,
      typeInfo: info.type !== 'UNDEFINED',
      nameInfo: !!info.name
    };
  }

  var candidates = [makeCandidate(firstElement, true)];

  var currentEl = firstElement;
  var containsSoFar = true;
  while (currentEl.parentNode && currentEl.parentNode.classList) {
    currentEl = currentEl.parentNode;
    var currentBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__["a" /* default */])(currentEl, true);
    containsSoFar = containsSoFar && currentBounds.y <= firstElementBounds.y && currentBounds.y + currentBounds.height >= firstElementBounds.y + firstElementBounds.height && currentBounds.x <= firstElementBounds.x && currentBounds.x + currentBounds.width >= firstElementBounds.x + firstElementBounds.width;
    // Only considering elements that fully contain the target
    if (!containsSoFar) break;

    var candidate = makeCandidate(currentEl);
    if (candidate.target || candidate.highPriority || candidate.typeInfo || candidate.nameInfo) {
      candidates.push(candidate);
    }
  }

  var bestGuess = __WEBPACK_IMPORTED_MODULE_8_lodash_find___default()(candidates, { highPriority: true }) || __WEBPACK_IMPORTED_MODULE_8_lodash_find___default()(candidates, { target: true });
  // Limiting arbitrarily to 4
  var alternatives = candidates.filter(function (c) {
    return c !== bestGuess && (c.highPriority || c.nameInfo || c.target);
  }).slice(4);

  // Return both the best guess and some alternatives (the user is allowed to
  // switch to one later)
  return {
    el: bestGuess.el,
    info: bestGuess.info,
    alternatives: alternatives.map(function (c) {
      return { el: c.el, info: c.info };
    })
  };
}

// Get information on the element.
function getElementInfo(el) {
  var screenBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var _findActiveElement = findActiveElement(el),
      info = _findActiveElement.info,
      activeEl = _findActiveElement.el,
      alternatives = _findActiveElement.alternatives;

  function addScreenBounds(info) {
    if (screenBounds) {
      var pageBounds = info.bounds;
      var _screenBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_utils_coordinates__["a" /* pagebounds2screen */])(pageBounds);
      info = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, info, {
        bounds: _screenBounds,
        pageBounds: pageBounds
      });
    }
    return info;
  }

  info = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, addScreenBounds(info), {
    isInPopup: Boolean(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_utils_getParentPopup__["a" /* default */])(el)),
    locator: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__elementLocator__["b" /* getLocator */])(activeEl)
  });
  return {
    info: info,
    el: el,
    activeEl: activeEl,
    alternatives: alternatives.map(function (a) {
      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, addScreenBounds(a.info), { locator: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__elementLocator__["b" /* getLocator */])(a.el) });
    })
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/elementInfo.js"))

/***/ }),
/* 610 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_intersection__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash_intersection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash_intersection__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__handlers_index__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_utils_scrollElementIntoView__ = __webpack_require__(519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_utils_getBounds__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_utils_coordinates__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_base_common_utils_getParentPopup__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__elementOnTop__ = __webpack_require__(525);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_base_common_utils_dom__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_base_common_utils_logger__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__LocatorSearcher__ = __webpack_require__(523);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContentPlayerFrameNode; });














var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_logger__["a" /* getFileLogger */])(__filename);



// Runs on every frame, is responsible for doing things that can ony be done on
// the individual frames (like hooking events to element). Do not do stuff here
// that could be done in the root.

var ContentPlayerFrameNode = function () {
  function ContentPlayerFrameNode() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ContentPlayerFrameNode);

    this.currentlyHooked = null;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(ContentPlayerFrameNode, [{
    key: "start",
    value: function start() {
      var _this = this;

      __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:hookElements", function (message) {
        return _this.hookElements(message.payload.step, message.payload.locatorData);
      });
    }
  }, {
    key: "hookElements",
    value: function hookElements(step, locatorData) {
      var _this2 = this;

      var elements = locatorData && locatorData.frameId === __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["d" /* frameId */] ? __WEBPACK_IMPORTED_MODULE_13__LocatorSearcher__["a" /* default */].getEls(locatorData.locatorId) : [];

      var newHooked = { stepIndex: step.index, elements: elements };
      var alreadyHooked = this.currentlyHooked && this.currentlyHooked.stepIndex === newHooked.stepIndex && this.currentlyHooked.elements.length === newHooked.elements.length && __WEBPACK_IMPORTED_MODULE_3_lodash_intersection___default()(this.currentlyHooked.elements, newHooked.elements).length === newHooked.elements.length;
      if (alreadyHooked) {
        logger.debug("Already hooked elements (for this step), nothing to do");
        return;
      }
      // Clear previously hooked
      this.clearDOMListeners();
      this.clearTimers();
      this._completed = false;

      var _onCompleted = function _onCompleted(el) {
        // ignore the url change check when clicking on a link towards the current page
        // (since there could be no actual URL change in modern HTML5 apps, see 916#issue-264801993)
        var skipUrlCheck = false;
        if (window.top === window) {
          var anchor = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_base_common_utils_dom__["a" /* closest */])(el, function (otherEl) {
            return otherEl.tagName === 'A';
          });
          if (anchor && anchor.href === window.location.href) {
            skipUrlCheck = true;
          }
        }

        _this2._completed = true;
        __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["e" /* TOP */], "ContentPlayer:complete", {
          completedAt: Date.now(), // NOTE: new Date() breaks Edge thus we use a timestamp
          skipUrlCheck: skipUrlCheck
        });
      };
      var _onNotCompleted = function _onNotCompleted() {
        _this2._completed = false;
        __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["e" /* TOP */], "ContentPlayer:notCompleted");
      };

      if (elements.length) {
        var markerBorder = 6;
        this.scrollElementIntoView(elements[0], step, markerBorder).then(function () {});

        this.setupParentPopupListeners(elements);

        var handlerType = step.type;
        var handler = __WEBPACK_IMPORTED_MODULE_4__handlers_index__[handlerType];
        if (handler) {
          elements.forEach(function (el, elIndex) {
            handler.call(_this2, {
              el: el,
              elIndex: elIndex,
              step: step,
              onCompleted: function onCompleted() {
                return _onCompleted(el);
              },
              onNotCompleted: function onNotCompleted() {
                return _onNotCompleted(el);
              }
            });
          });
        }
      }

      this.currentlyHooked = newHooked;
    }

    // Go back when elements are inside a dropdown and it is closed
    // Note: assumes the dropdown is the same for every element

  }, {
    key: "setupParentPopupListeners",
    value: function setupParentPopupListeners(elements) {
      var _this3 = this;

      var parentPopup = void 0;
      var elInPopup = elements.filter(function (el) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__elementOnTop__["a" /* default */])(el);
      }).find(function (el) {
        var currentParentPopup = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_base_common_utils_getParentPopup__["a" /* default */])(el);
        if (currentParentPopup) {
          parentPopup = currentParentPopup;
          return true;
        }
        return false;
      });
      if (!elInPopup) return;

      var timerName = "setupParentPopupListeners";
      var messageSent = false;
      var handle = function handle(event) {
        _this3.clearTimer(timerName);
        _this3.addTimer(timerName, function () {
          var targetPopup = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_base_common_utils_getParentPopup__["a" /* default */])(event.target);
          var interactionOutsidePopup = !targetPopup || targetPopup !== parentPopup;
          if (!messageSent && !_this3._completed && interactionOutsidePopup && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10__elementOnTop__["a" /* default */])(elInPopup)) {
            messageSent = true;
            __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["e" /* TOP */], "ContentPlayer:goBack");
          }
        }, 200);
      };
      this.listenToDOM(window, "click", handle);
      this.listenToDOM(window, "mouseover", handle);
    }
  }, {
    key: "listenToDOM",
    value: function listenToDOM(el, eventName, handler, useCapture) {
      this.domListeners = this.domListeners || [];

      handler = handler.bind(this);

      el.addEventListener(eventName, handler, useCapture);

      var domListener = [el, eventName, handler, useCapture];
      var domListenerIndex = this.domListeners.length;
      this.domListeners.push(domListener);
      return domListenerIndex;
    }
  }, {
    key: "stopDOMListening",
    value: function stopDOMListening(domListenerIndex) {
      this.domListeners = this.domListeners || [];

      var domListener = this.domListeners[domListenerIndex];
      if (!domListener) return;

      var el = domListener[0],
          eventName = domListener[1],
          handler = domListener[2],
          useCapture = domListener[3];

      el.removeEventListener(eventName, handler, useCapture);

      this.domListeners[domListenerIndex] = undefined;
    }
  }, {
    key: "clearDOMListeners",
    value: function clearDOMListeners(el) {
      this.domListeners = this.domListeners || [];

      for (var i = 0, l = this.domListeners.length; i < l; i++) {
        var domListener = this.domListeners[i];
        if (domListener) {
          // array is sparse!
          if (!el || domListener[0] === el) {
            this.stopDOMListening(i);
          }
        }
      }
    }
  }, {
    key: "addTimer",
    value: function addTimer(name, callback, time) {
      var _this4 = this;

      this.timers = this.timers || {};

      this.timers[name] = setTimeout(function () {
        delete _this4.timers[name];
        callback();
      }, time);
    }
  }, {
    key: "getTimer",
    value: function getTimer(name) {
      if (!this.timers) return null;
      return this.timers[name];
    }
  }, {
    key: "clearTimer",
    value: function clearTimer(name) {
      if (!this.timers) return;
      clearTimeout(this.timers[name]);
      delete this.timers[name];
    }

    // name examples: 'foo.bar.*', 'foo.*.sample', '*'

  }, {
    key: "clearTimers",
    value: function clearTimers() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "*";

      if (!this.timers) return;

      function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
      }
      var pattern = "^" + name.split("*").map(escapeRegExp).join(".*") + "$";
      var regex = new RegExp(pattern);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(this.timers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var aName = _step.value;

          if (regex.test(aName)) {
            this.clearTimer(aName);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "scrollElementIntoView",
    value: function scrollElementIntoView(el, step, markerBorder) {
      var _this5 = this;

      if (step.type === "READ") return Promise.resolve();
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_utils_scrollElementIntoView__["a" /* default */])(el, markerBorder).then(function () {
        return _this5.scrollWindowIntoView(el);
      });
    }
  }, {
    key: "scrollWindowIntoView",
    value: function scrollWindowIntoView(el) {
      if (!el) return;
      var serializableBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_utils_getBounds__["a" /* default */])(el);
      __WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_2_base_common_utils_frameMessages__["e" /* TOP */], "ContentPlayer:scrollWindowIntoView", serializableBounds);
    }
  }]);

  return ContentPlayerFrameNode;
}();


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/player/ContentPlayerFrameNode.js"))

/***/ }),
/* 611 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_Component__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__drawMarker__ = __webpack_require__(524);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_compact__ = __webpack_require__(547);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash_compact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash_compact__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_debounce__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_debounce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_debounce__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_every__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_every___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash_every__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_has__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_isEqual__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_isEqual___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_lodash_isEqual__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_map__ = __webpack_require__(302);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_lodash_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_max__ = __webpack_require__(750);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_max___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_lodash_max__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash_some__ = __webpack_require__(497);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_lodash_some___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_lodash_some__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_lodash_throttle__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_lodash_throttle___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20_lodash_throttle__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_lodash_intersection__ = __webpack_require__(491);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_lodash_intersection___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_lodash_intersection__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__handlers_index__ = __webpack_require__(526);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__common_utils_scrollElementIntoView__ = __webpack_require__(519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__common_utils_getBounds__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__common_utils_coordinates__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__createLocatorTest__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__createLocatorTest___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27__createLocatorTest__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__getElementVisualBounds__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__getWindowScrollOffset__ = __webpack_require__(323);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_base_common_utils_isMobileBrowsers__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34_base_common_utils_windowEvents__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35_base_common_utils_timers__ = __webpack_require__(520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36_base_common_utils_player__ = __webpack_require__(278);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37_base_common_utils_isPageLoggedIn__ = __webpack_require__(517);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38_base_common_utils_isStepLoggedIn__ = __webpack_require__(317);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39_base_common_utils_activeNav__ = __webpack_require__(513);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40_base_common_utils_fuzzyMatchUrl__ = __webpack_require__(313);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41_base_common_utils_getParentPopup__ = __webpack_require__(316);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__adjustPanelPosition__ = __webpack_require__(612);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43_base_common_utils_ScrollWindowIntoView__ = __webpack_require__(587);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__LocatorSearcher__ = __webpack_require__(523);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_45_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContentPlayerTopFrame; });








// The part of the player that runs as a content script. The main part
// of the player is within the panel script currently.









































var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_46_base_common_utils_logger__["a" /* getFileLogger */])(__filename);
var defaultColors = __WEBPACK_IMPORTED_MODULE_32__common_settings__["a" /* default */].get("defaultColors");

function isIoradEditorUrl(url) {
  return (/(^|\.)iorad\.(com|dev)\/editor(\?|\/)/.test(url)
  );
}

var ContentPlayerTopFrame = function (_Component) {
  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default()(ContentPlayerTopFrame, _Component);

  function ContentPlayerTopFrame() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, ContentPlayerTopFrame);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = ContentPlayerTopFrame.__proto__ || Object.getPrototypeOf(ContentPlayerTopFrame)).call.apply(_ref, [this].concat(args)));

    _this.currentLocatorData = null;
    _this.beforeunload = false;

    _this.enterStep = __WEBPACK_IMPORTED_MODULE_20_lodash_throttle___default()(_this.enterStep.bind(_this), 1000);

    // the "not found" is delayed to give the extension some extra seconds
    // before switching the panel view
    // the "found" isn't delayed since we want to play audio etc. as soon as possible
    _this._notifyNotFound = __WEBPACK_IMPORTED_MODULE_20_lodash_throttle___default()(_this._notifyNotFound.bind(_this), 2000, {
      leading: false,
      trailing: true
    });

    _this._adjustPanelPosition = __WEBPACK_IMPORTED_MODULE_11_lodash_debounce___default()(__WEBPACK_IMPORTED_MODULE_42__adjustPanelPosition__["a" /* default */], 500, {
      leading: false,
      trailing: true
    });
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(ContentPlayerTopFrame, [{
    key: "start",
    value: function start() {
      var _get2;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_get___default()(ContentPlayerTopFrame.prototype.__proto__ || Object.getPrototypeOf(ContentPlayerTopFrame.prototype), "start", this)).call.apply(_get2, [this].concat(args));

      this.register();
      this.setupEventListeners();
    }
  }, {
    key: "setupEventListeners",
    value: function setupEventListeners() {
      var _this2 = this;

      var currentStep = this.flux.panelContext().state.currentStep;


      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("registerContentPlayer", function (message) {
        _this2.enterStep();
      });

      document.addEventListener("visibilitychange", function () {
        // tab is active again
        _this2.enterStep();
      }, false);

      // Every couple of seconds if we haven't yet found
      // a good component to highlight lets try again
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_35_base_common_utils_timers__["a" /* safeSetInterval */])(function () {
        _this2.enterStep();
      }, 2000);

      // Every couple of seconds we check login state
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_35_base_common_utils_timers__["a" /* safeSetInterval */])(function () {
        return _this2.checkLogin();
      }, 2000);

      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("LocatorSearcherNode:frameChange", function (message) {
        _this2.enterStep({ frameId: message.frameId });
      });

      // TODO: Disable when not in QA mode
      document.addEventListener("keydown", function (event) {
        // Listen for alt-shift-t
        if (currentStep && event.keyCode === 84 && event.altKey && event.shiftKey) {
          __WEBPACK_IMPORTED_MODULE_27__createLocatorTest___default()(currentStep, _this2.extension);
        }
      }, true);

      // If the message listener had to reattach we may have lost message, let's
      // register again
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_34_base_common_utils_windowEvents__["b" /* addReattachMessageListener */])(function () {
        logger.debug("Re-register after window message event reattached");
        _this2.register();
      });

      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:complete", this._completed.bind(this));
      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:notCompleted", this._notCompleted.bind(this));

      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:goBack", this._goBack.bind(this));

      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:scrollWindowIntoView", this._scrollWindowIntoView.bind(this));

      // frameMessages.onMessage("ContentPlayer:setMarkerEnabled", message => {
      //   if (message.payload.enabled) {
      //     this.enableMarker(message.payload.index);
      //   } else {
      //     this.disableMarker(message.payload.index);
      //   }
      // });

      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["c" /* onMessage */]("ContentPlayer:mousedown", function () {
        // See #1028
        _this2.flux.panelContext().dispatch('skipWaitLocationHref');
      });

      window.addEventListener("beforeunload", function () {
        _this2.beforeunload = true;
      });
    }
  }, {
    key: "checkLogin",
    value: function checkLogin() {
      var _flux$panelContext$st = this.flux.panelContext().state,
          tutorialStarted = _flux$panelContext$st.started,
          currentStep = _flux$panelContext$st.currentStep;

      if (tutorialStarted && currentStep) {
        if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_38_base_common_utils_isStepLoggedIn__["a" /* default */])(currentStep)) {
          var needsLogin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_37_base_common_utils_isPageLoggedIn__["a" /* default */])() === false;
          this.toggleNeedsLogin(needsLogin);

          // if (currentStep.index === 0) {
          //   const stepLoggedInType = getStepLoggedInType(currentStep);
          //   if (stepLoggedInType === 'admin') {
          //     const needsAdminAccess = getPageLoggedInType() !== 'admin';
          //     this.toggleNeedsAdminAccess(needsAdminAccess);
          //   }
          // }
        }
      }
    }
  }, {
    key: "toggleNeedsLogin",
    value: function toggleNeedsLogin(value) {
      this.needsLogin = value;
      this.flux.panelContext().dispatch("stepNeedsLogin", this.needsLogin);
    }
  }, {
    key: "toggleNeedsAdminAccess",
    value: function toggleNeedsAdminAccess(value) {
      this.needsAdminAccess = value;
      this.flux.panelContext().dispatch("stepNeedsAdminAccess", this.needsAdminAccess);
    }

    // If currentStep is null it'll just remove any current marker

  }, {
    key: "updateForPanel",
    value: function updateForPanel(oldState, state) {
      var previousStep = oldState.currentStep;
      var currentStep = state.currentStep;
      if (previousStep && currentStep && __WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(previousStep, "window.id") && __WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(currentStep, "window.id") && __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(previousStep, "window.id") !== __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(currentStep, "window.id")) {
        // auto redirect on tab switch
        // Note: this shouldn't be executed multiple times
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_36_base_common_utils_player__["a" /* redirectIfNeeded */])(currentStep.window.url, false);
      }

      if (currentStep && previousStep && currentStep.number !== previousStep.number) {
        this._notifyNotFound.cancel();
        this.waitingNextStep = false;
      }

      this.flux.updater(oldState, state, [["started", this.switchTutorialStarted.bind(this)]]);

      this.enterStep();
    }
  }, {
    key: "switchTutorialStarted",
    value: function switchTutorialStarted(tutorialStarted) {
      if (!tutorialStarted) {
        this.reset();
      } else {
        this.checkLogin();
      }

      return true;
    }
  }, {
    key: "reset",
    value: function reset() {
      this._hideMarkers();
      this.toggleNeedsLogin(false);
      this.toggleNeedsAdminAccess(false);
      this.currentLocatorData = null;
      this.waitingNextStep = false;
    }
  }, {
    key: "enterStep",
    value: function enterStep() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _flux$panelContext$st2 = this.flux.panelContext().state,
          tutorialStarted = _flux$panelContext$st2.started,
          currentStep = _flux$panelContext$st2.currentStep,
          waitingLocationHrefChange = _flux$panelContext$st2.waitingLocationHrefChange;

      // NOTE: here do only the checks that apply to ALL the frames,
      // specific per-frame checks should be done on LocatorSearcher.js

      if (!tutorialStarted) {
        logger.debug("enterStep: tutorial not started");
        return;
      }
      if (!currentStep) {
        logger.debug("enterStep: no current step");
        return;
      }
      if (currentStep.type === 'READ') {
        logger.debug('enterStep: no need to locate READ steps');
      }
      if (document.hidden) {
        logger.debug("enterStep: tab is inactive");
        return;
      }
      if (this.needsLogin) {
        logger.debug("enterStep: needs login");
        return;
      }
      if (this.needsAdminAccess) {
        logger.debug("enterStep: needs admin access");
        return;
      }
      if (this.delayEnterStepTimer) {
        logger.debug("enterStep: delayed");
        return;
      }
      if (document.readyState === "loading") {
        logger.debug("enterStep: page is loading");
        return;
      }
      if (this.beforeunload) {
        logger.debug("enterStep: page is unloading");
        return;
      }
      if (waitingLocationHrefChange) {
        console.log("enterStep: wait for location href change");
        return;
      }

      this.handle({
        step: currentStep,
        onCompleted: this._completed.bind(this),
        onNotCompleted: this._notCompleted.bind(this),
        force: options.forceHandle === true,
        frameId: options.frameId // optional, restricts the search to one frame (and to its sub frames)
      });
    }
  }, {
    key: "drawMarkers",
    value: function drawMarkers(step, locatorData) {
      var _this3 = this;

      var enableMarkerIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var _flux$panelContext$st3 = this.flux.panelContext().state,
          tutorialStarted = _flux$panelContext$st3.started,
          markerColors = _flux$panelContext$st3.markerColors;


      var isMobile = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_31_base_common_utils_isMobileBrowsers__["a" /* default */])();
      if (locatorData != null) {
        var embed = "embed" === "embed";
        var markerColor = embed ? this.extension.embedOptions.colors && this.extension.embedOptions.colors.highlight || defaultColors.highlight : // (markerColors && markerColors[step.type]) ||
        this.extension.panelController && this.extension.panelController.customColors && this.extension.panelController.customColors.highlight || defaultColors.highlight;

        var elementBounds = locatorData.elementBounds.filter(function (l) {
          // filter out elements not visible on the viewport
          return l.visible;
        }).sort(function (l1, l2) {
          // Sort elements in y-axis and x-axis ascending order
          return l1.y - l2.y || l1.x - l2.x;
        });

        // TODO Enable marker is no longer present
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__drawMarker__["a" /* drawMarker */])(elementBounds, step.type, markerColor, enableMarkerIndex, step.number, isMobile, { dblClick: step.event.dblclick }).then(function () {
          // prevent jumping effect by only moving when there are actual markers
          if (elementBounds.length > 0) {
            _this3._adjustPanelPosition(_this3.extension, step);
          }
        });
      } else {
        // just hide the markers (e.g. needed if tutorial ended)
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__drawMarker__["a" /* drawMarker */])(null).then(function () {
          // only move the panel back to its original position if the tutorial ended,
          // otherwise we'll have ugly jumping effects (#750)
          if (!tutorialStarted) {
            _this3._adjustPanelPosition(_this3.extension, step);
          }
        });
      }
    }
  }, {
    key: "findAndHighlight",
    value: function findAndHighlight(step, frameId) {
      var _this4 = this;

      var tutorialStarted = this.flux.panelContext().state.started;


      if (step.component) {
        var multipleMatches = Boolean(step && step.event && step.event.live_multipleMatches);

        var promise = step.type === "DROP" && multipleMatches ? Promise.resolve(this.currentLocatorData) : __WEBPACK_IMPORTED_MODULE_44__LocatorSearcher__["a" /* default */].search(step.component.locator, {
          multipleMatches: multipleMatches,
          frameId: frameId
        });

        promise.then(function (locatorData) {
          if (!_this4.flux.panelContext().state.started) {
            // too late (prevent showing of markers, #839)
            return;
          }
          if (_this4.flux.panelContext().state.currentStep && _this4.flux.panelContext().state.currentStep.number !== step.number) {
            // too late (prevent showing of markers, #937)
            return;
          }
          if (_this4.waitingNextStep) {
            // too late (prevent showing of markers, #1060)
            return;
          }

          _this4.findLaterStepIfNeeded(locatorData, step);

          // we need the step index to do proper equality checks
          if (locatorData) {
            locatorData = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({}, locatorData, {
              stepIndex: step.index
            });
          }
          if (__WEBPACK_IMPORTED_MODULE_16_lodash_isEqual___default()(locatorData, _this4.currentLocatorData)) {
            if (!locatorData && !_this4.currentLocatorData && tutorialStarted) {
              // needed in case the first step isn't found (#694)
              _this4._notifyFoundState();
            }
            return;
          }

          // We send to all (and not just the frame containing the element)
          // because frames without the element may need to hide stuff.
          __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["b" /* ALL */], "ContentPlayer:hookElements", {
            step: step,
            locatorData: locatorData
          });

          _this4.currentLocatorData = locatorData;
          _this4.drawMarkers(step, locatorData);

          if (tutorialStarted) {
            _this4._notifyFoundState();
          }
        });
      } else {
        this.drawMarkers(step, null);
      }
    }

    // Called when locator data hasn't been found for the 1st step. Looks through
    // later steps and if we find a url (fuzzy) match and can find the locator
    // then we offer the user an option to skip ahead

  }, {
    key: "findLaterStep",
    value: function findLaterStep(matchFn) {
      var _this5 = this;

      var lookahead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
      var _flux$panelContext$st4 = this.flux.panelContext().state,
          otherSteps = _flux$panelContext$st4.otherSteps,
          ignoreLaterStep = _flux$panelContext$st4.ignoreLaterStep;

      if (!otherSteps || ignoreLaterStep || this._findingLaterStep) return Promise.resolve(false);
      this._findingLaterStep = true;
      return new Promise(function (resolve, reject) {
        try {
          // Look at the next steps given that the first step didn't match
          var possibleMatches = otherSteps.slice(1).filter(matchFn).slice(0, lookahead + 1);
          var next = function next() {
            if (possibleMatches.length === 0) {
              _this5._findingLaterStep = false;
              resolve(false);
              return;
            }

            var _possibleMatches$shif = possibleMatches.shift(),
                url = _possibleMatches$shif.url,
                locator = _possibleMatches$shif.locator,
                index = _possibleMatches$shif.index;

            __WEBPACK_IMPORTED_MODULE_44__LocatorSearcher__["a" /* default */].search(locator).then(function (locatorData) {
              if (locatorData) {
                _this5._findingLaterStep = false;
                //console.log('FOUND MATCHING STEP', url, locatorData, index);
                _this5._foundLaterStep(index);
                resolve(true);
              } else {
                // Lets look at the next candidate
                next();
              }
            });
          };
          next();
        } catch (err) {
          console.error(err);
          _this5._findingLaterStep = false;
          resolve(false);
        }
      });
    }
  }, {
    key: "findLaterStepIfNeeded",
    value: function () {
      var _ref2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(locatorData, step) {
        var found, stepLoggedOut, loggedIn, _found, elements, el, navActiveAnchor, _found2, _found3;

        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(step.index !== 0)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!isIoradEditorUrl(window.location.href)) {
                  _context.next = 8;
                  break;
                }

                _context.next = 5;
                return this.findLaterStep(function (_ref3) {
                  var url = _ref3.url;
                  return isIoradEditorUrl(url);
                });

              case 5:
                found = _context.sent;

                if (!found) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return");

              case 8:

                // If the tutorial was captured while logged out, but we are already logged in,
                // then see if we can jump after the login took place (if it ever did)
                // (strict === false check since old tutorials might not have this property)
                stepLoggedOut = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_38_base_common_utils_isStepLoggedIn__["a" /* default */])(step) === false;
                loggedIn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_37_base_common_utils_isPageLoggedIn__["a" /* default */])();

                if (!(stepLoggedOut && loggedIn)) {
                  _context.next = 16;
                  break;
                }

                _context.next = 13;
                return this.findLaterStep(function (_ref4) {
                  var loggedIn = _ref4.loggedIn;
                  return loggedIn;
                });

              case 13:
                _found = _context.sent;

                if (!_found) {
                  _context.next = 16;
                  break;
                }

                return _context.abrupt("return");

              case 16:
                if (!(step.type === "LEFT_CLICK")) {
                  _context.next = 27;
                  break;
                }

                elements = locatorData && locatorData.frameId === __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["d" /* frameId */] ? __WEBPACK_IMPORTED_MODULE_44__LocatorSearcher__["a" /* default */]._node.locatedEls : // HACK: we need the actual els references, the query is not enough to reconstruct them (because of similar elements, filtering by text, etc.)
                [];

                if (!(elements.length === 1)) {
                  _context.next = 27;
                  break;
                }

                el = elements[0];
                navActiveAnchor = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_39_base_common_utils_activeNav__["a" /* findNavActiveAnchor */])();

                if (!(el === navActiveAnchor)) {
                  _context.next = 27;
                  break;
                }

                _context.next = 24;
                return this.findLaterStep(function (_ref5) {
                  var index = _ref5.index;
                  return index === step.index + 1;
                });

              case 24:
                _found2 = _context.sent;

                if (!_found2) {
                  _context.next = 27;
                  break;
                }

                return _context.abrupt("return");

              case 27:
                if (!(!locatorData && !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_40_base_common_utils_fuzzyMatchUrl__["a" /* default */])(step.window.url, window.location.href))) {
                  _context.next = 33;
                  break;
                }

                _context.next = 30;
                return this.findLaterStep(function (_ref6) {
                  var url = _ref6.url;
                  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_40_base_common_utils_fuzzyMatchUrl__["a" /* default */])(url, window.location.href);
                });

              case 30:
                _found3 = _context.sent;

                if (!_found3) {
                  _context.next = 33;
                  break;
                }

                return _context.abrupt("return");

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function findLaterStepIfNeeded(_x4, _x5) {
        return _ref2.apply(this, arguments);
      }

      return findLaterStepIfNeeded;
    }()
  }, {
    key: "handle",
    value: function handle(_ref7) {
      var step = _ref7.step,
          parentStep = _ref7.parentStep,
          onCompleted = _ref7.onCompleted,
          onNotCompleted = _ref7.onNotCompleted,
          force = _ref7.force,
          frameId = _ref7.frameId;

      this.findAndHighlight(step, frameId);

      // TOOD: Would this be better handled by just flattening out into seperate
      // TYPING and CLICK actions?
      var isCompositeStep = step.steps && step.steps.length !== 0 && step.summary !== true;

      var isTypingAndClick = step.type === "TYPING" && isCompositeStep && step.steps.length === 2 && step.steps[0].type === "TYPING" && step.steps[1].type === "LEFT_CLICK";

      if (isTypingAndClick) {
        this.handleTypingAndClick(step, onCompleted, onNotCompleted, force, frameId);
      }
    }
  }, {
    key: "handleTypingAndClick",
    value: function handleTypingAndClick(step, onCompleted, onNotCompleted, force, frameId) {
      var _this6 = this;

      // Was TYPING_AND_CLICK handler, but was only one in use that used re-entrant handle call
      var typingStep = step.steps[0];
      var clickStep = step.steps[1];

      var onTypingCompleted = function onTypingCompleted() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (options.advance) onCompleted();else handleClick();
      };

      var onTypingNotCompleted = function onTypingNotCompleted() {
        // no-op:
        // ignore not completed feedback for typing marker
        // (since is not completed after each keypress until the full text has been typed)
      };

      var onClickCompleted = function onClickCompleted() {
        onCompleted();
      };

      var onClickNotCompleted = function onClickNotCompleted() {
        onNotCompleted();
      };

      var handleTyping = function handleTyping() {
        _this6.handle({
          step: typingStep,
          parentStep: step,
          onCompleted: onTypingCompleted.bind(_this6),
          onNotCompleted: onTypingNotCompleted.bind(_this6),
          force: force,
          frameId: frameId
        });
      };

      var handleClick = function handleClick() {
        _this6.handle({
          step: clickStep,
          parentStep: step,
          onCompleted: onClickCompleted.bind(_this6),
          onNotCompleted: onClickNotCompleted.bind(_this6),
          force: force,
          frameId: frameId
        });
      };

      handleTyping();
    }
  }, {
    key: "register",
    value: function register() {
      __WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_33_base_common_utils_frameMessages__["e" /* TOP */], "registerContentPlayer");
    }

    // const { currentStep } = this.flux.panelContext().state;
    // enableMarker(index) {
    //   if (currentStep && this.currentLocatorData) {
    //     this.drawMarkers(currentStep, this.currentLocatorData, index);
    //   }
    // }

    // disableMarker(index) {
    //   if (currentStep && this.currentLocatorData) {
    //     this.drawMarkers(currentStep, this.currentLocatorData, null);
    //   }
    // }

  }, {
    key: "_hideMarkers",
    value: function _hideMarkers() {
      this.drawMarkers(null, null);
    }
  }, {
    key: "_notifyFoundState",
    value: function _notifyFoundState() {
      if (this.currentLocatorData) {
        this._notifyNotFound.cancel();
        this.flux.panelContext().dispatch("stepFound");
      } else {
        this._notifyNotFound();
      }
    }
  }, {
    key: "_notifyNotFound",
    value: function _notifyNotFound() {
      this.flux.panelContext().dispatch("stepNotFound");
    }
  }, {
    key: "_completed",
    value: function _completed() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          options = _ref8.payload;

      this._hideMarkers();

      var _flux$panelContext$st5 = this.flux.panelContext().state,
          currentStep = _flux$panelContext$st5.currentStep,
          otherSteps = _flux$panelContext$st5.otherSteps;

      var nextOtherStep = currentStep && otherSteps && otherSteps[currentStep.index + 1];
      if (!nextOtherStep) {
        this.delayEnterStep();
      }
      this.waitingNextStep = true;
      this.flux.panelContext().dispatch("stepCompleted", options);
    }
  }, {
    key: "_notCompleted",
    value: function _notCompleted() {
      this.flux.panelContext().dispatch("stepNotCompleted");
    }
  }, {
    key: "_goBack",
    value: function _goBack() {
      this.flux.panelContext().dispatch("stepGoBack");
    }
  }, {
    key: "_scrollWindowIntoView",
    value: function _scrollWindowIntoView(message) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_43_base_common_utils_ScrollWindowIntoView__["a" /* default */])(message.payload);
    }
  }, {
    key: "_foundLaterStep",
    value: function _foundLaterStep(stepIndex) {
      this.flux.panelContext().dispatch("foundLaterStep", stepIndex, true);
    }
  }, {
    key: "delayEnterStep",
    value: function delayEnterStep() {
      var _this7 = this;

      if (this.delayEnterStepTimer) return;
      this.delayEnterStepTimer = setTimeout(function () {
        _this7.delayEnterStepTimer = undefined;
        _this7.enterStep();
      }, 1000);
    }
  }]);

  return ContentPlayerTopFrame;
}(__WEBPACK_IMPORTED_MODULE_8_base_common_Component__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/player/ContentPlayerTopFrame.js"))

/***/ }),
/* 612 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__drawMarker__ = __webpack_require__(524);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_utils_getBounds__ = __webpack_require__(314);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_isMobileBrowsers__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_identity__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash_identity___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash_identity__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = adjustPanelPosition;


// Adjust the panel so it doesn't cover the marker. I have extracted this from
// ContentPlayer but surely it really belongs with the panel controller.









var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

function isZendeskPage() {
  return document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_namespace__["a" /* default */])('zendesk-visible'));
}

var previousInfo = null; // { step, markersBounds }

function adjustPanelPosition(extension, step) {
  var embed = "embed" === "embed";
  var panelEl = extension.panelController.panelEl;
  var widgetEl = extension.panelController.closeEl;
  if (!panelEl || !widgetEl) return;

  var isMobile = embed && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_isMobileBrowsers__["a" /* default */])();
  var isZendesk = isZendeskPage();
  var panelOnly = isMobile || isZendesk;
  var panelCSSPosition = calculatePanelCSSPosition(extension, step);

  if (!panelCSSPosition.overlaps) {
    return;
  }

  var panelRealBounds = extension.panelController.panelRealBounds;
  var panelFullBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_utils_getBounds__["a" /* default */])(panelEl);
  var panelRealHeight = panelRealBounds ? panelRealBounds.height : panelFullBounds.height;
  var capturingActive = panelEl.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_namespace__["a" /* default */])('capturing'));
  var panelTopInnerMargin = capturingActive ? 0 : panelFullBounds.height - panelRealHeight;

  if (isZendesk) {
    panelEl.style.top = window.innerHeight - panelCSSPosition.panel.bottom - panelTopInnerMargin + "px";
  } else {
    panelEl.style.bottom = panelCSSPosition.panel.bottom + "px";
  }
  panelEl.style.right = panelCSSPosition.panel.right + "px";
  if (!panelOnly) {
    widgetEl.style.bottom = panelCSSPosition.widget.bottom + "px";
    widgetEl.style.right = panelCSSPosition.widget.right + "px";
  }

  // make sure to update the real bounds whenever they change
  //extension.panelController.calculatePanelRealBounds();
}

// TODO: add support for multiple markers
function calculatePanelCSSPosition(extension, step) {
  var embed = "embed" === "embed";
  var isMobile = embed && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_isMobileBrowsers__["a" /* default */])();
  var isZendesk = isZendeskPage();
  var panelOnly = isMobile || isZendesk;
  var defaultBottom = isMobile ? 0 : isZendesk ? window.innerHeight - 25 : 20;
  var defaultRight = isMobile ? 0 : isZendesk ? -5 : 20;
  var widgetBottomDiff = 35;
  var widgetRightDiff = -40;
  var defaultWidget = { bottom: defaultBottom, right: defaultRight };
  var defaultReturn = {
    widget: defaultWidget,
    panel: panelOnly ? defaultWidget : { bottom: defaultBottom + 35, right: defaultRight - 40 }
  };
  var panelEl = extension.panelController.panelEl;
  var widgetEl = extension.panelController.closeEl;
  var markerBounds = getMergedMarkerBounds(step);
  if (!panelEl || !widgetEl || !markerBounds) return defaultReturn;
  if (markerBounds.visibleHeight <= 0 || markerBounds.visibleWidth <= 0) {
    // marker is outside the viewport
    logger.debug("marker is outside viewport!");
    return defaultReturn;
  }

  var panelBounds = extension.panelController.panelRealBounds || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_utils_getBounds__["a" /* default */])(panelEl);
  var widgetBounds = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_utils_getBounds__["a" /* default */])(widgetEl);

  if (panelBounds.height === 0 || widgetBounds.height === 0) return defaultReturn;

  var panelActiveBottom = isZendesk ? panelBounds.bottom : Math.max(panelBounds.bottom, widgetBounds.bottom);
  var panelActiveRight = isZendesk ? panelBounds.right : Math.max(panelBounds.right, widgetBounds.right);
  var panelVisibleHeight = panelOnly ? panelBounds.height : panelActiveBottom - panelBounds.top;
  var panelVisibleWidth = panelOnly ? panelBounds.width : panelActiveRight - panelBounds.left;

  var panelCSSBottom = defaultBottom;
  var panelCSSRight = defaultRight;
  var panelScreenTop = Number(panelEl.style.top.replace('px', '')) || window.innerHeight - panelVisibleHeight - defaultBottom;
  var panelScreenLeft = Number(panelEl.style.left.replace('px', '')) || window.innerWidth - panelVisibleWidth - defaultRight;
  var overlaps = !(panelActiveRight <= markerBounds.left || panelBounds.left >= markerBounds.right || panelActiveBottom <= markerBounds.top || panelBounds.top >= markerBounds.bottom);

  if (overlaps) {
    if (extension.panelController.panelDragged) {
      extension.panelController.resetCoordinates();
    }

    var overlapHeight = Math.min(markerBounds.bottom - panelScreenTop, markerBounds.visibleHeight, panelVisibleHeight);
    var overlapWidth = Math.min(markerBounds.right - panelScreenLeft, markerBounds.visibleWidth, panelVisibleWidth);
    var overlapFactor = overlapHeight * overlapWidth / (markerBounds.visibleHeight * markerBounds.visibleWidth);

    //logger.debug(overlapFactor, overlapHeight, overlapWidth, markerBounds.visibleHeight, markerBounds.visibleWidth);

    if (overlapFactor >= 0.10) {
      var gap = 10;

      var enoughVerticalSpace = void 0;
      if (isZendesk) {
        // move down
        panelCSSBottom = window.innerHeight - markerBounds.bottom - gap;
        enoughVerticalSpace = window.innerHeight - markerBounds.bottom >= panelVisibleHeight;
      } else {
        // move up
        panelCSSBottom = window.innerHeight - markerBounds.top + gap;
        enoughVerticalSpace = markerBounds.top >= panelVisibleHeight;
      }

      if (!enoughVerticalSpace) {
        // vertical space is not enough! Move left
        panelCSSBottom = defaultBottom;
        panelCSSRight = window.innerWidth - markerBounds.left + gap;
        if (markerBounds.left < panelVisibleWidth) {
          // left space not enough!
          panelCSSRight = defaultRight;
          logger.warn("Not enough space for showing panel without overlapping with markers!");
        }
      }
    }
  }

  var widgetReturn = { bottom: panelCSSBottom, right: panelCSSRight };
  return {
    overlaps: overlaps,
    widget: widgetReturn,
    panel: panelOnly ? widgetReturn : {
      bottom: Math.max(panelCSSBottom + widgetBottomDiff, defaultReturn.panel.bottom),
      right: Math.max(panelCSSRight + widgetRightDiff, defaultReturn.panel.right)
    }
  };
}

// Returns a single bounds object by merging the bounds
// of all the markers on screen
function getMergedMarkerBounds(step) {
  var markersBounds = getMarkerEls().map(function (el) {
    return getMarkerBounds(el);
  }).filter(__WEBPACK_IMPORTED_MODULE_8_lodash_identity___default.a);

  if (step && previousInfo && previousInfo.step && previousInfo.step.index === step.index - 1 && previousInfo.step.type === 'HOVER') {
    // include previous markers too
    markersBounds.push.apply(markersBounds, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(previousInfo.markersBounds));
  } else {
    previousInfo = { step: step, markersBounds: markersBounds };
  }

  if (markersBounds.length === 0) return null;
  if (markersBounds.length === 1) return markersBounds[0]; // optimization

  var mergedMarkerBounds = {
    top: Math.min.apply(Math, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(markersBounds.map(function (b) {
      return b.top;
    }))),
    bottom: Math.max.apply(Math, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(markersBounds.map(function (b) {
      return b.bottom;
    }))),
    left: Math.min.apply(Math, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(markersBounds.map(function (b) {
      return b.left;
    }))),
    right: Math.max.apply(Math, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(markersBounds.map(function (b) {
      return b.right;
    })))
  };

  mergedMarkerBounds.height = mergedMarkerBounds.bottom - mergedMarkerBounds.top;
  mergedMarkerBounds.width = mergedMarkerBounds.right - mergedMarkerBounds.left;

  mergedMarkerBounds.visibleHeight = Math.min(mergedMarkerBounds.height, window.innerHeight - mergedMarkerBounds.top);
  mergedMarkerBounds.visibleWidth = Math.min(mergedMarkerBounds.width, window.innerWidth - mergedMarkerBounds.left);

  return mergedMarkerBounds;
}

function getMarkerEls() {
  return Array.from(document.querySelectorAll("." + __WEBPACK_IMPORTED_MODULE_2__drawMarker__["b" /* SELECTOR_ID */])).filter(function (el) {
    return el.style.display !== "none" && el.style.visibility !== "hidden";
  });
}

function getMarkerBounds(markerEl) {
  if (!markerEl) return null;

  var markerInfoEl = markerEl.querySelector("." + __WEBPACK_IMPORTED_MODULE_2__drawMarker__["b" /* SELECTOR_ID */] + "marker-info");
  var isValidMarkerInfoEl = markerInfoEl && markerInfoEl.style.display !== "none" && markerInfoEl.style.visibility !== "hidden";

  var markerCoords = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__["a" /* default */])(markerEl, true);
  if (!markerCoords) return null;

  var markerInfoCoords = isValidMarkerInfoEl ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__getElementVisualBounds__["a" /* default */])(markerInfoEl, true) : markerCoords;

  var markerBounds = {
    top: Math.min(markerCoords.y, markerInfoCoords.y),
    bottom: Math.max(markerCoords.y + markerCoords.height, markerInfoCoords.y + markerInfoCoords.height),
    left: Math.min(markerCoords.x, markerInfoCoords.x),
    right: Math.max(markerCoords.x + markerCoords.width, markerInfoCoords.x + markerInfoCoords.width)
  };
  markerBounds.height = markerBounds.bottom - markerBounds.top;
  markerBounds.width = markerBounds.right - markerBounds.left;

  var markerVisibleHeight = Math.min(markerBounds.height, window.innerHeight - markerBounds.top);
  var markerVisibleWidth = Math.min(markerBounds.width, window.innerWidth - markerBounds.left);

  return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, markerBounds, {
    visibleHeight: markerVisibleHeight,
    visibleWidth: markerVisibleWidth
  });
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/player/adjustPanelPosition.js"))

/***/ }),
/* 613 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DRAG;
function DRAG(_ref) {
  var el = _ref.el,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  this.listenToDOM(el, 'dragstart', onCompleted, true);
  this.listenToDOM(el, 'mousedown', onCompleted, true);
}

/***/ }),
/* 614 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DROP;
function DROP(_ref) {
  var el = _ref.el,
      step = _ref.step,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  var dropped = false;

  this.listenToDOM(el, 'drop', function () {
    dropped = true;
    onCompleted();
  }, true);

  // some apps don't trigger drop (e.g. google drive)
  this.listenToDOM(el, 'mouseup', function () {
    dropped = true;
    onCompleted();
  }, true);

  this.listenToDOM(window, 'dragend', function () {
    if (!dropped) onNotCompleted();
  }, true);

  // some apps don't trigger drop (e.g. google drive)
  this.listenToDOM(window, 'mouseup', function () {
    if (!dropped) onNotCompleted();
  }, false); // false to trigger callback after the el handler
}

/***/ }),
/* 615 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = HOVER;
function HOVER(_ref) {
  var el = _ref.el,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  this.listenToDOM(el, 'mouseover', onCompleted, true);
}

/***/ }),
/* 616 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (immutable) */ __webpack_exports__["a"] = LEFT_CLICK;



function LEFT_CLICK(_ref) {
  var el = _ref.el,
      step = _ref.step,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  var isDoubleClick = __WEBPACK_IMPORTED_MODULE_0_lodash_get___default()(step, 'event.dblclick') === true;
  var isDropdownChange = __WEBPACK_IMPORTED_MODULE_0_lodash_get___default()(step, 'event.change') === true;

  if (el.tagName === 'SELECT') {
    // Force 'change' event even if the select has one single option, or if the user
    // selects the already selected option.
    // We do this by creating an hidden option on the fly and by setting it as the selected option.
    var option = el.querySelector('option.' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__["a" /* default */])()) || document.createElement('option');
    option.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_namespace__["a" /* default */])();
    option.style.display = 'none';
    option.innerHTML = el.options[el.selectedIndex] ? el.options[el.selectedIndex].innerHTML : '';
    el.appendChild(option);
    el.selectedIndex = el.options.length - 1;
  }

  // mousedown is used instead of mouseup or click because is more reliable (#121)
  this.listenToDOM(el, 'mousedown', function (event) {
    if (event.which === 3) {
      // right click
      onNotCompleted();
      return;
    }

    if (isDoubleClick) {
      // this is the first click of an eventual double click,
      // we can't be sure if action will be a failure or not,
      // => don't do anything
      return;
    }

    if (isDropdownChange) {
      // handled via the change event
      return;
    }

    onCompleted();
  }, true);

  this.listenToDOM(el, 'change', function () {
    if (isDropdownChange) {
      onCompleted();
    }
  }, true);

  this.listenToDOM(el, 'dblclick', function () {
    if (__WEBPACK_IMPORTED_MODULE_0_lodash_get___default()(step, 'event.dblclick') === true) onCompleted();else onNotCompleted();
  }, true);
}

/***/ }),
/* 617 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = READ;
function READ() {
  // nothing to do
}

/***/ }),
/* 618 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RIGHT_CLICK;
function RIGHT_CLICK(_ref) {
  var el = _ref.el,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  var completed = false;

  this.listenToDOM(el, 'mousedown', function (event) {
    // (implicitly also handle failure for left click / double click)
    if (event.which === 3) {
      completed = true;
      onCompleted();
    } else {
      onNotCompleted();
    }
  }, true);

  this.listenToDOM(el, 'contextmenu', function () {
    if (!completed) {
      // (sometimes contextmenu is triggered after mousedown)
      onCompleted();
    }
  }, true);
}

/***/ }),
/* 619 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SCROLL;
function SCROLL() {
  // TODO
}

/***/ }),
/* 620 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_get__);
/* harmony export (immutable) */ __webpack_exports__["a"] = TYPING;


var typingTimeout = 3000;

function findFormSubmitEl(el) {
  var currentEl = el;
  var formEl = void 0;
  while (currentEl) {
    if (currentEl.tagName === 'FORM') {
      formEl = currentEl;
      break;
    }
    currentEl = currentEl.parentNode;
  }
  if (formEl) {
    return formEl.querySelector('[type="submit"]');
  }
  return null;
}

function TYPING(_ref) {
  var _this = this;

  var el = _ref.el,
      elIndex = _ref.elIndex,
      step = _ref.step,
      onCompleted = _ref.onCompleted,
      onNotCompleted = _ref.onNotCompleted;

  var timerName = 'handlers.typing[' + elIndex + '].completed';

  var text = __WEBPACK_IMPORTED_MODULE_0_lodash_get___default()(step, 'event.text');
  var isPassword = __WEBPACK_IMPORTED_MODULE_0_lodash_get___default()(step, 'event.password');

  this.listenToDOM(el, 'keyup', function () {
    _this.clearTimer(timerName);

    var enteredText = typeof el.value !== 'undefined' ? el.value : el.textContent;
    if (isPassword) {
      // check length only, no characters matched
      if (enteredText.length === 0) {
        onNotCompleted();
        return;
      }
    } else {
      // not completed if the user has typed the wrong text
      if (text !== undefined && text !== '' && enteredText !== text) {
        onNotCompleted();
        return;
      }
    }

    // deferred completition
    _this.addTimer(timerName, onCompleted, typingTimeout);
    onNotCompleted();
  }, true);

  this.listenToDOM(el, 'keydown', function (event) {
    if (event.which === 13 || event.which === 9) {
      // enter or tab
      // handle enter/tab interaction wise
      if (_this.getTimer(timerName) || _this.completed) {
        // the user typed something and is waiting the timeout,
        // in the meantime pressed enter/tab
        // => shortcut: advance directly to the next slide
        onCompleted({ advance: true }); // completed with options
      }
    }
  });

  // auto advance on form submit
  // (needed if user manually clicks on submit button, see #672)
  var formSubmitEl = findFormSubmitEl(el);
  if (formSubmitEl) {
    this.listenToDOM(formSubmitEl, 'click', function () {
      if (_this.getTimer(timerName) || _this.completed) {
        onCompleted({ advance: true });
      }
    }, true);
  }
}

/***/ }),
/* 621 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_node_event_emitter__);



var emitter = new __WEBPACK_IMPORTED_MODULE_1_node_event_emitter___default.a();

window[__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__["a" /* default */])('loaded')] = function (className, Class) {
  emitter.emit('loaded:' + className, Class);
};

/* unused harmony default export */ var _unused_webpack_default_export = function (className, onLoaded) {
  var globalVar = window[__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_base_common_utils_namespace__["a" /* default */])('component-' + className)];
  if (globalVar) {
    onLoaded(globalVar);
  } else {
    emitter.once('loaded:' + className, function (Class) {
      return onLoaded(Class);
    });
  }
};

/***/ }),
/* 622 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_common_utils_waitForInit__ = __webpack_require__(322);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = getZoom;




var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var zoom = 1; // educated guess

function getZoom() {
  return zoom;
}

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_waitForInit__["a" /* default */])(function () {
  __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["c" /* onMessage */]('coordinates-zoom', function (_ref) {
    var payload = _ref.payload;

    // console.log('got zoom');
    zoom = payload;
  });
  __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["e" /* TOP */], 'coordinates-getZoom');
});
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/zoom/zoomFrameNode.js"))

/***/ }),
/* 623 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (immutable) */ __webpack_exports__["a"] = start;



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

function start(extension) {
  var zoom = 1; // educated guess

  function sendZoom() {
    __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["a" /* send */](__WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["b" /* ALL */], 'coordinates-zoom', zoom);
  }

  __WEBPACK_IMPORTED_MODULE_0_base_common_utils_frameMessages__["c" /* onMessage */]('coordinates-getZoom', function () {
    // console.log('getZoom');
    sendZoom();
  });

  function retrieveZoom() {
    new Promise(function (resolve, reject) {
      if (false) {
        // https://social.msdn.microsoft.com/Forums/ie/en-US/9e5b8fb6-f592-45e7-a4b8-fd86e3c22393/how-can-i-detect-my-zoom-browser-level-on-a-pageload?forum=iewebdevelopment
        resolve(screen.deviceXDPI / 96);
      } else {
        extension.portManager.backgroundPort.send({ topic: 'getZoom' }, resolve);
      }
    }).then(function (z) {
      //console.log('content getZoom', z);
      if (z !== zoom) {
        // notify child frames of new zoom
        zoom = z;
        sendZoom();
      }
    });
  }

  window.addEventListener('resize', retrieveZoom);
  retrieveZoom();
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "base/content/zoom/zoomTopFrame.js"))

/***/ }),
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BrowserActionManager; });




// Maintain state for the browser action button popup



var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var BrowserActionManager = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(BrowserActionManager, _EventEmitter);

  function BrowserActionManager() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, BrowserActionManager);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (BrowserActionManager.__proto__ || Object.getPrototypeOf(BrowserActionManager)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(BrowserActionManager, [{
    key: 'start',

    // dummy implementation
    value: function start(extension) {
      this.extension = extension;
    }
  }]);

  return BrowserActionManager;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/background/BrowserActionManager.js"))

/***/ }),
/* 692 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedBridge; });



//import Bridge from 'base/background/Bridge';

// OPTIMIZATION: don't extend parent Bridge, since we only need a dummy component.
var EmbedBridge = function () {
  function EmbedBridge() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedBridge);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedBridge, null, [{
    key: "listen",
    value: function listen(extension) {
      // dummy implementation
    }
  }]);

  return EmbedBridge;
}();



/***/ }),
/* 693 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_base_common_Port__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_after__ = __webpack_require__(545);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash_after___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash_after__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_has__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_flatten__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_flatten___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_lodash_flatten__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_sortBy__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_lodash_sortBy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_lodash_sortBy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedDocumentsPort; });











// Note: assumes that there aren't two or more messages sent at the same exact time (millisecond).











var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_19_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var inMessagesKey = 'messages_to_background';
var outMessagesKey = 'messages_to_documents';
var acksMessagesKey = 'messages_acks';

var EmbedDocumentsPort = function (_Port) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(EmbedDocumentsPort, _Port);

  function EmbedDocumentsPort() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, EmbedDocumentsPort);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = EmbedDocumentsPort.__proto__ || Object.getPrototypeOf(EmbedDocumentsPort)).call.apply(_ref, [this].concat(args)));

    _this._outMessagesCounter = 0;
    _this._listeners = [];
    _this._handleInMessagesPromise = null;
    _this._responseHandlers = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(EmbedDocumentsPort, [{
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (this._port) return;
      this._port = this.extension.sharedMemory;
      this._handleInMessagesPromise = Promise.resolve();
      this._responseHandlers = {}; // <out message id, handler>

      // make sure to handle any message that was sent just before page reload
      this.checkIncomingMessages(true).then(function () {
        __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedDocumentsPort.prototype.__proto__ || Object.getPrototypeOf(EmbedDocumentsPort.prototype), 'connect', _this2).call(_this2);
        _this2._onConnected();
      });
    }
  }, {
    key: '_bindHandlers',
    value: function _bindHandlers() {
      var _this3 = this,
          _port$tabs;

      if (!this._port) return;

      var listener = ['change', function () {
        return _this3.checkIncomingMessages();
      }];
      (_port$tabs = this._port.tabs).on.apply(_port$tabs, listener);
      this._listeners.push(listener);

      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedDocumentsPort.prototype.__proto__ || Object.getPrototypeOf(EmbedDocumentsPort.prototype), '_bindHandlers', this).call(this);
    }
  }, {
    key: 'checkIncomingMessages',
    value: function checkIncomingMessages() {
      var _this4 = this;

      var includeInvalidTabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      // make sure to handle the previous messages before
      // starting with the new ones (to prevent double handling)
      this._handleInMessagesPromise = this._handleInMessagesPromise.then(function () {
        return Promise.all([includeInvalidTabs ? _this4._port.tabs.getAllIncludingInvalid() : _this4._port.tabs.getAll(), _this4._port.background.get()]).then(function () {
          var _ref2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.mark(function _callee(_ref3) {
            var _ref4 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
                _ref4$ = _ref4[0],
                tabs = _ref4$ === undefined ? {} : _ref4$,
                _ref4$2 = _ref4[1],
                background = _ref4$2 === undefined ? {} : _ref4$2;

            var incomingMessages, acksMessages, newMessages, setItems, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, newMessage, id, responseHandler;

            return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return _this4._cleanOutgoingMessages(background, tabs);

                  case 2:
                    incomingMessages = _this4._calculateIncomingMessages(tabs);
                    _context.next = 5;
                    return _this4._cleanAcksMessages(background, incomingMessages);

                  case 5:
                    acksMessages = _context.sent;
                    newMessages = _this4._calculateNewIncomingMessages(incomingMessages, acksMessages);
                    setItems = {};
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _iteratorError = undefined;
                    _context.prev = 11;

                    for (_iterator = newMessages[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      newMessage = _step.value;
                      id = newMessage.private.id;


                      if (newMessage.public._echo) {
                        // response
                        logger.debug('EmbedDocumentsPort response message', newMessage);
                        responseHandler = _this4._responseHandlers[newMessage.public._echo];

                        if (responseHandler) {
                          delete _this4._responseHandlers[newMessage.public._echo];
                          responseHandler(newMessage.public.data);
                        }
                      } else {
                        // actual new message
                        logger.debug('EmbedDocumentsPort new message', newMessage);
                        _this4._onMessageReceived(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends___default()({}, newMessage.public, {
                          tab: __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends___default()({}, newMessage.private.tab, {
                            includeInvalidTabs: includeInvalidTabs
                          })
                        }), _this4._makeRespond(newMessage));
                      }

                      // set the ack
                      setItems[acksMessagesKey + '.' + id] = true;
                    }
                    _context.next = 19;
                    break;

                  case 15:
                    _context.prev = 15;
                    _context.t0 = _context['catch'](11);
                    _didIteratorError = true;
                    _iteratorError = _context.t0;

                  case 19:
                    _context.prev = 19;
                    _context.prev = 20;

                    if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                    }

                  case 22:
                    _context.prev = 22;

                    if (!_didIteratorError) {
                      _context.next = 25;
                      break;
                    }

                    throw _iteratorError;

                  case 25:
                    return _context.finish(22);

                  case 26:
                    return _context.finish(19);

                  case 27:
                    _context.next = 29;
                    return _this4._port.background.setByPath(setItems);

                  case 29:
                  case 'end':
                    return _context.stop();
                }
              }
            }, _callee, _this4, [[11, 15, 19, 27], [20,, 22, 26]]);
          }));

          return function (_x2) {
            return _ref2.apply(this, arguments);
          };
        }());
      });
      return this._handleInMessagesPromise;
    }

    // remove from the store the outgoing messages that have been already handled by the relative tab,
    // return the updated object

  }, {
    key: '_cleanOutgoingMessages',
    value: function () {
      var _ref5 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.mark(function _callee2(background, tabs) {
        var outgoingMessages, pathsToRemove, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, id, outgoingMessage, tabId, tab;

        return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                outgoingMessages = __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(background, outMessagesKey) || {}; // object <id, msg>

                pathsToRemove = [];
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context2.prev = 5;

                for (_iterator2 = Object.keys(outgoingMessages)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  id = _step2.value;
                  outgoingMessage = outgoingMessages[id];

                  // check if the associated tab handled the message

                  tabId = outgoingMessage.private.tabId;
                  tab = tabs[tabId];

                  if (!tab || __WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(tab, acksMessagesKey + '.' + id)) {
                    pathsToRemove.push(outMessagesKey + '.' + id);
                    delete outgoingMessages[id];
                  }
                }
                _context2.next = 13;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2['catch'](5);
                _didIteratorError2 = true;
                _iteratorError2 = _context2.t0;

              case 13:
                _context2.prev = 13;
                _context2.prev = 14;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 16:
                _context2.prev = 16;

                if (!_didIteratorError2) {
                  _context2.next = 19;
                  break;
                }

                throw _iteratorError2;

              case 19:
                return _context2.finish(16);

              case 20:
                return _context2.finish(13);

              case 21:
                _context2.next = 23;
                return this._port.background.removeByPath(pathsToRemove);

              case 23:
                return _context2.abrupt('return', outgoingMessages);

              case 24:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 9, 13, 21], [14,, 16, 20]]);
      }));

      function _cleanOutgoingMessages(_x3, _x4) {
        return _ref5.apply(this, arguments);
      }

      return _cleanOutgoingMessages;
    }()

    // return the incoming messages as an array sorted in sent order

  }, {
    key: '_calculateIncomingMessages',
    value: function _calculateIncomingMessages(tabs) {
      var flat = __WEBPACK_IMPORTED_MODULE_17_lodash_flatten___default()(__WEBPACK_IMPORTED_MODULE_16_lodash_values___default()(tabs).map(function (tab) {
        return __WEBPACK_IMPORTED_MODULE_16_lodash_values___default()(tab[inMessagesKey] || {});
      }));
      return __WEBPACK_IMPORTED_MODULE_18_lodash_sortBy___default()(flat, function (msg) {
        return __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(msg, 'private.time');
      });
    }

    // remove from the store the acks associated to no incoming message,
    // return the updated object
    // Note: incomingMessages is an array, not an object!

  }, {
    key: '_cleanAcksMessages',
    value: function () {
      var _ref6 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.mark(function _callee3(background, incomingMessages) {
        var acksMessages, pathsToRemove, _loop, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, id;

        return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_regenerator___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                acksMessages = __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(background, acksMessagesKey) || {};
                pathsToRemove = [];

                _loop = function _loop(id) {
                  // id refer to the incoming message
                  var incomingMessage = __WEBPACK_IMPORTED_MODULE_13_lodash_find___default()(incomingMessages, function (msg) {
                    return msg.private.id === id;
                  });
                  if (!incomingMessage) {
                    pathsToRemove.push(acksMessagesKey + '.' + id);
                    delete acksMessages[id];
                  }
                };

                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context3.prev = 6;

                for (_iterator3 = Object.keys(acksMessages)[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  id = _step3.value;

                  _loop(id);
                }
                _context3.next = 14;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3['catch'](6);
                _didIteratorError3 = true;
                _iteratorError3 = _context3.t0;

              case 14:
                _context3.prev = 14;
                _context3.prev = 15;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 17:
                _context3.prev = 17;

                if (!_didIteratorError3) {
                  _context3.next = 20;
                  break;
                }

                throw _iteratorError3;

              case 20:
                return _context3.finish(17);

              case 21:
                return _context3.finish(14);

              case 22:
                _context3.next = 24;
                return this._port.background.removeByPath(pathsToRemove);

              case 24:
                return _context3.abrupt('return', acksMessages);

              case 25:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 10, 14, 22], [15,, 17, 21]]);
      }));

      function _cleanAcksMessages(_x5, _x6) {
        return _ref6.apply(this, arguments);
      }

      return _cleanAcksMessages;
    }()

    // return the NEW incoming messages by skipping the already handled ones

  }, {
    key: '_calculateNewIncomingMessages',
    value: function _calculateNewIncomingMessages(incomingMessages, acksMessages) {
      return incomingMessages.filter(function (msg) {
        return __WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(acksMessages, msg.private.id) === false;
      });
    }
  }, {
    key: '_makeRespond',
    value: function _makeRespond(newMessage) {
      var _this5 = this;

      return function (response) {
        logger.debug('EmbedDocumentsPort: sending response', response, newMessage);
        _this5.sendToOne(newMessage.private.tab.id, {
          _echo: newMessage.private.id,
          data: response
        });
      };
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (!this._port) return;
      this._unbindHandlers();
      this._port = null;
      this._onDisconnected();
      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedDocumentsPort.prototype.__proto__ || Object.getPrototypeOf(EmbedDocumentsPort.prototype), 'disconnect', this).call(this);
    }
  }, {
    key: '_unbindHandlers',
    value: function _unbindHandlers() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._listeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _port$tabs2;

          var listener = _step4.value;

          (_port$tabs2 = this._port.tabs).removeListener.apply(_port$tabs2, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(listener));
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._listeners = [];
    }

    // send to all tabs
    // Note: responseHandler is called once with an object <tab id, tab response>

  }, {
    key: 'send',
    value: function send(message) {
      var _this6 = this;

      var responseHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      logger.debug('EmbedDocumentsPort: send', message, options);
      this.extension.tabsController.getAllTabs().then(function (tabs) {
        if (options.active) tabs = tabs.filter(function (tab) {
          return tab.active;
        });

        var responses = {};
        var complete = __WEBPACK_IMPORTED_MODULE_12_lodash_after___default()(tabs.length, responseHandler.bind(null, responses));
        tabs.forEach(function (tab) {
          _this6.sendToOne(tab.id, message, function (response) {
            responses[tab.id] = response;
            complete();
          });
        });
      });

      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedDocumentsPort.prototype.__proto__ || Object.getPrototypeOf(EmbedDocumentsPort.prototype), 'send', this).call(this, message, responseHandler);
    }
  }, {
    key: 'sendToOne',
    value: function sendToOne(tabId, message, responseHandler) {
      var _this7 = this;

      logger.debug('EmbedDocumentsPort: sendToOne', message);

      message = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_extends___default()({}, message, { tab: { id: tabId } });

      // HACK: messaging seems to break when sendToOne
      // is called multiple times synchronously, not sure why.
      setTimeout(function () {
        var newOutMessage = {
          private: {
            id: _this7.extension.backgroundId + '_' + _this7._outMessagesCounter,
            time: Date.now(),
            tabId: tabId
          },
          public: message
        };
        _this7._outMessagesCounter++;

        if (responseHandler) {
          _this7._responseHandlers[newOutMessage.private.id] = responseHandler;
        }

        _this7._port.background.setByPath(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, outMessagesKey + '.' + newOutMessage.private.id, newOutMessage));
      }, 0);
    }
  }]);

  return EmbedDocumentsPort;
}(__WEBPACK_IMPORTED_MODULE_11_base_common_Port__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/background/EmbedDocumentsPort.js"))

/***/ }),
/* 694 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_background_Extension__ = __webpack_require__(566);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sharedMemory_SharedMemory__ = __webpack_require__(701);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__EmbedStorage__ = __webpack_require__(698);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__EmbedPortManager__ = __webpack_require__(697);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__EmbedFlux__ = __webpack_require__(695);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__capture_EmbedBrowserCapture__ = __webpack_require__(700);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__BrowserActionManager__ = __webpack_require__(691);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__EmbedBridge__ = __webpack_require__(692);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__EmbedTabsController__ = __webpack_require__(699);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__EmbedPanelController__ = __webpack_require__(696);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_base_common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__common_StubComponent__ = __webpack_require__(535);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedExtension; });


















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_16_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var EmbedExtension = function (_Extension) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedExtension, _Extension);

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(EmbedExtension, [{
    key: 'getURL',
    value: function getURL(path) {
      return __WEBPACK_IMPORTED_MODULE_14_base_common_settings__["a" /* default */].get('extension.embed.basePath') + '/' + path;
    }
  }, {
    key: 'getPortManagerClass',
    value: function getPortManagerClass() {
      return __WEBPACK_IMPORTED_MODULE_7__EmbedPortManager__["a" /* default */];
    }
  }, {
    key: 'getFluxClass',
    value: function getFluxClass() {
      return __WEBPACK_IMPORTED_MODULE_8__EmbedFlux__["a" /* default */];
    }
  }, {
    key: 'getSharedMemoryClass',
    value: function getSharedMemoryClass() {
      return __WEBPACK_IMPORTED_MODULE_5__sharedMemory_SharedMemory__["a" /* default */];
    }
  }, {
    key: 'getStorageClass',
    value: function getStorageClass() {
      return __WEBPACK_IMPORTED_MODULE_6__EmbedStorage__["a" /* default */];
    }
  }, {
    key: 'getTabsControllerClass',
    value: function getTabsControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_12__EmbedTabsController__["a" /* default */];
    }
  }, {
    key: 'getPanelControllerClass',
    value: function getPanelControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_13__EmbedPanelController__["a" /* default */];
    }
  }, {
    key: 'getBrowserCaptureClass',
    value: function getBrowserCaptureClass() {
      return __WEBPACK_IMPORTED_MODULE_9__capture_EmbedBrowserCapture__["a" /* default */];
    }
  }, {
    key: 'getBrowserActionManagerClass',
    value: function getBrowserActionManagerClass() {
      return __WEBPACK_IMPORTED_MODULE_10__BrowserActionManager__["a" /* default */];
    }
  }, {
    key: 'getBridgeClass',
    value: function getBridgeClass() {
      return __WEBPACK_IMPORTED_MODULE_11__EmbedBridge__["a" /* default */];
    }
  }, {
    key: 'getAuthClass',
    value: function getAuthClass() {
      return __WEBPACK_IMPORTED_MODULE_15__common_StubComponent__["a" /* default */];
    }
  }]);

  function EmbedExtension() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedExtension);

    // Note: use same version of chrome extension (VERSION is inserted by webpack)
    return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedExtension.__proto__ || Object.getPrototypeOf(EmbedExtension)).call(this, 'embed', "1.8.0", 'embed'));
  }

  return EmbedExtension;
}(__WEBPACK_IMPORTED_MODULE_4_base_background_Extension__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/background/EmbedExtension.js"))

/***/ }),
/* 695 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_background_Flux__ = __webpack_require__(508);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedFlux; });







var EmbedFlux = function (_Flux) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(EmbedFlux, _Flux);

  function EmbedFlux() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedFlux);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedFlux.__proto__ || Object.getPrototypeOf(EmbedFlux)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedFlux, [{
    key: 'fetch',
    value: function fetch() {
      var _this2 = this;

      return Promise.all([this.extension.sharedMemory.background.get('backgroundState').then(function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _this2.localStateManager.state = state; // HACK: we want to initialize the state immediately
      }).then(function () {
        return _this2.extension.sharedMemory.background.removeByPath('backgroundState');
      }), this.extension.sharedMemory.background.get('contentStates').then(function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _this2.contentStates = state;
      }).then(function () {
        return _this2.extension.sharedMemory.background.removeByPath('contentStates');
      }), this.extension.sharedMemory.background.get('panelStates').then(function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _this2.panelStates = state;
      }).then(function () {
        return _this2.extension.sharedMemory.background.removeByPath('panelStates');
      })]);
    }
  }, {
    key: 'handleBackgroundState',
    value: function handleBackgroundState() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default()(EmbedFlux.prototype.__proto__ || Object.getPrototypeOf(EmbedFlux.prototype), 'handleBackgroundState', this)).call.apply(_get2, [this].concat(args));
      this.extension.sharedMemory.background.extendByPath('backgroundState', this.backgroundState);
    }
  }, {
    key: 'handleContentState',
    value: function handleContentState(state, tabId) {
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default()(EmbedFlux.prototype.__proto__ || Object.getPrototypeOf(EmbedFlux.prototype), 'handleContentState', this).call(this, state, tabId);
      this.extension.sharedMemory.background.extendByPath('contentStates.' + tabId, state);
    }
  }, {
    key: 'handlePanelState',
    value: function handlePanelState(state, tabId) {
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_get___default()(EmbedFlux.prototype.__proto__ || Object.getPrototypeOf(EmbedFlux.prototype), 'handlePanelState', this).call(this, state, tabId);
      this.extension.sharedMemory.background.extendByPath('panelStates.' + tabId, state);
    }
  }]);

  return EmbedFlux;
}(__WEBPACK_IMPORTED_MODULE_5_base_background_Flux__["a" /* default */]);



/***/ }),
/* 696 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_background_PanelController__ = __webpack_require__(509);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedPanelController; });







var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var EmbedPanelController = function (_PanelController) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedPanelController, _PanelController);

  function EmbedPanelController() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedPanelController);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedPanelController.__proto__ || Object.getPrototypeOf(EmbedPanelController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedPanelController, [{
    key: 'isPanelOpen',
    value: function isPanelOpen(tabId) {
      return this.ownContext().state.isPanelOpen;
    }
  }, {
    key: 'shouldPanelOpenOnNewTab',
    value: function shouldPanelOpenOnNewTab() {
      return this.isPanelOpen();
    }
  }]);

  return EmbedPanelController;
}(__WEBPACK_IMPORTED_MODULE_4_base_background_PanelController__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/background/EmbedPanelController.js"))

/***/ }),
/* 697 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_background_PortManager__ = __webpack_require__(567);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EmbedDocumentsPort__ = __webpack_require__(693);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedPortManager; });







var EmbedPortManager = function (_PortManager) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedPortManager, _PortManager);

  function EmbedPortManager() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedPortManager);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedPortManager.__proto__ || Object.getPrototypeOf(EmbedPortManager)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedPortManager, [{
    key: 'getDocumentsPortClass',
    value: function getDocumentsPortClass() {
      return __WEBPACK_IMPORTED_MODULE_5__EmbedDocumentsPort__["a" /* default */];
    }
  }]);

  return EmbedPortManager;
}(__WEBPACK_IMPORTED_MODULE_4_base_background_PortManager__["a" /* default */]);



/***/ }),
/* 698 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_embed_common_EmbedStorage__ = __webpack_require__(534);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_embed_common_sharedMemory_ObjectStore__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedStorage; });











var storageRequestWhitelist = ['set', 'remove', 'clear'];

var EmbedStorage = function (_CommonEmbedStorage) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(EmbedStorage, _CommonEmbedStorage);

  function EmbedStorage() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, EmbedStorage);

    return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedStorage.__proto__ || Object.getPrototypeOf(EmbedStorage)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(EmbedStorage, [{
    key: 'start',
    value: function start() {
      var _get2;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(EmbedStorage.prototype.__proto__ || Object.getPrototypeOf(EmbedStorage.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      this._objectStore = new __WEBPACK_IMPORTED_MODULE_8_embed_common_sharedMemory_ObjectStore__["a" /* default */](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_base_common_utils_namespace__["a" /* default */])('storage'), 'readwrite');
      this.setupDocuments();
    }
  }, {
    key: 'setupDocuments',
    value: function setupDocuments() {
      this.documentsPort = this.extension.portManager.documentsPort;
      this.documentsPort.on('message', this.handleDocumentsMessage.bind(this));
    }
  }, {
    key: 'handleDocumentsMessage',
    value: function handleDocumentsMessage(message, respond) {
      message.data = message.data || {};

      if (message.topic === 'storageRequest') {
        this._executeStorageRequest(message.data).then(function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return respond({ status: 'success', args: args });
        }, function () {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return respond({ status: 'failure', args: args });
        });
      }
    }
  }, {
    key: '_executeStorageRequest',
    value: function () {
      var _ref = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(_ref2) {
        var type = _ref2.type,
            args = _ref2.args;
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(storageRequestWhitelist.indexOf(type) === -1)) {
                  _context.next = 2;
                  break;
                }

                throw 'storageRequest: invalid type ' + type;

              case 2:
                return _context.abrupt('return', this._objectStore[type].apply(this._objectStore, args));

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _executeStorageRequest(_x) {
        return _ref.apply(this, arguments);
      }

      return _executeStorageRequest;
    }()
  }, {
    key: 'get',
    value: function get() {
      var _objectStore;

      return (_objectStore = this._objectStore).get.apply(_objectStore, arguments);
    }
  }, {
    key: 'set',
    value: function set() {
      var _objectStore2;

      return (_objectStore2 = this._objectStore).set.apply(_objectStore2, arguments);
    }
  }, {
    key: 'remove',
    value: function remove() {
      var _objectStore3;

      return (_objectStore3 = this._objectStore).remove.apply(_objectStore3, arguments);
    }
  }, {
    key: 'clear',
    value: function clear() {
      var _objectStore4;

      return (_objectStore4 = this._objectStore).clear.apply(_objectStore4, arguments);
    }
  }]);

  return EmbedStorage;
}(__WEBPACK_IMPORTED_MODULE_7_embed_common_EmbedStorage__["a" /* default */]);



/***/ }),
/* 699 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_background_TabsController__ = __webpack_require__(569);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_filter__ = __webpack_require__(488);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash_filter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash_filter__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedTabsController; });










var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var EmbedTabsController = function (_TabsController) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedTabsController, _TabsController);

  function EmbedTabsController() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedTabsController);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedTabsController.__proto__ || Object.getPrototypeOf(EmbedTabsController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedTabsController, [{
    key: 'listenTabOnUpdated',
    value: function listenTabOnUpdated(callback) {
      // no-op
    }
  }, {
    key: 'listenTabOnActivated',
    value: function listenTabOnActivated(callback) {
      var currentActiveTab = null;
      this.extension.sharedMemory.tabs.on('change', function (_ref) {
        var newValue = _ref.newValue;

        var newTabs = newValue || {};

        var newActiveTabs = __WEBPACK_IMPORTED_MODULE_5_lodash_filter___default()(newTabs, function (tab) {
          return tab.public.active;
        });
        if (newActiveTabs.length !== 1) {
          logger.debug('intermediate change', newTabs);
          return;
        }

        var newActiveTab = newActiveTabs[0];
        if (newActiveTab) {
          // was it already active?
          if (!currentActiveTab || currentActiveTab.public.id !== newActiveTab.public.id) {
            // nope, new activation!
            currentActiveTab = newActiveTab;
            logger.debug('listenTabOnActivated', newTabs);
            callback({ tabId: newActiveTab.public.id });
          }
        }
      });
    }
  }, {
    key: 'listenTabOnRemoved',
    value: function listenTabOnRemoved(callback) {
      // TODO
    }
  }, {
    key: 'getTab',
    value: function getTab(tabId) {
      return this.extension.sharedMemory.tabs.getAll().then(function () {
        var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var tab = __WEBPACK_IMPORTED_MODULE_6_lodash_find___default()(tabs, function (tab) {
          return tab.public.id === tabId;
        });

        if (!tab) throw new Error('There is no tab with id ' + tabId);else return tab.public;
      });
    }
  }, {
    key: 'getActiveTabId',
    value: function getActiveTabId() {
      return this.extension.sharedMemory.tabs.getAll().then(function () {
        var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var tab = __WEBPACK_IMPORTED_MODULE_6_lodash_find___default()(tabs, function (tab) {
          return tab.public.active;
        });
        return tab ? tab.public.id : null;
      });
    }
  }, {
    key: 'getAllTabs',
    value: function getAllTabs() {
      return this.extension.sharedMemory.tabs.getAll().then(function () {
        var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        return __WEBPACK_IMPORTED_MODULE_7_lodash_values___default()(tabs).map(function (tab) {
          return tab.public;
        });
      });
    }
  }]);

  return EmbedTabsController;
}(__WEBPACK_IMPORTED_MODULE_4_base_background_TabsController__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/background/EmbedTabsController.js"))

/***/ }),
/* 700 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedBrowserCapture; });






var EmbedBrowserCapture = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedBrowserCapture, _EventEmitter);

  function EmbedBrowserCapture() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedBrowserCapture);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedBrowserCapture.__proto__ || Object.getPrototypeOf(EmbedBrowserCapture)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedBrowserCapture, [{
    key: 'start',

    // dummy implementation
    value: function start(extension) {
      this.extension = extension;
    }
  }]);

  return EmbedBrowserCapture;
}(__WEBPACK_IMPORTED_MODULE_4_node_event_emitter___default.a);



/***/ }),
/* 701 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_embed_common_sharedMemory_SharedMemory__ = __webpack_require__(536);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_embed_common_sharedMemory_ObjectStore__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_embed_common_sharedMemory_TabsStore__ = __webpack_require__(537);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharedMemory; });








var SharedMemory = function (_CommonSharedMemory) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(SharedMemory, _CommonSharedMemory);

  function SharedMemory() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, SharedMemory);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = SharedMemory.__proto__ || Object.getPrototypeOf(SharedMemory)).call.apply(_ref, [this].concat(args)));

    var backgroundKey = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('background');

    _this.background = new __WEBPACK_IMPORTED_MODULE_4_embed_common_sharedMemory_ObjectStore__["a" /* default */](backgroundKey, 'readwrite');
    _this.tabs = new __WEBPACK_IMPORTED_MODULE_5_embed_common_sharedMemory_TabsStore__["a" /* default */]({ cleanInvalidTabs: true });
    return _this;
  }

  return SharedMemory;
}(__WEBPACK_IMPORTED_MODULE_3_embed_common_sharedMemory_SharedMemory__["a" /* default */]);



/***/ }),
/* 702 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_base_common_Port__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has__ = __webpack_require__(490);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash_has___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash_has__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_lodash_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_lodash_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_sortBy__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_lodash_sortBy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_lodash_sortBy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedBackgroundPort; });




















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var inMessagesKey = 'messages_to_documents';
var outMessagesKey = 'messages_to_background';
var acksMessagesKey = 'messages_acks';

var EmbedBackgroundPort = function (_Port) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(EmbedBackgroundPort, _Port);

  function EmbedBackgroundPort() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, EmbedBackgroundPort);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = EmbedBackgroundPort.__proto__ || Object.getPrototypeOf(EmbedBackgroundPort)).call.apply(_ref, [this].concat(args)));

    _this._outMessagesCounter = 0;
    _this._topFrameId = null;

    _this._listeners = [];
    _this._windowListeners = [];
    _this._handleInMessagesPromise = null;
    _this._responseHandlers = null;
    _this._connectTime = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(EmbedBackgroundPort, [{
    key: 'connect',
    value: function connect() {
      if (this._port) return;
      this._port = this.extension.sharedMemory;
      this._handleInMessagesPromise = Promise.resolve();
      this._responseHandlers = {}; // <out message id, handler>
      this._connectTime = Date.now();
      this._sendWindowMessageToTopFrame('embedBackgroundPort_register');
      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedBackgroundPort.prototype.__proto__ || Object.getPrototypeOf(EmbedBackgroundPort.prototype), 'connect', this).call(this);
      this._onConnected();
    }
  }, {
    key: '_bindHandlers',
    value: function _bindHandlers() {
      var _this2 = this,
          _window;

      if (!this._port) return;

      if (this.extension.isTopFrame) {
        var _port$tabs;

        var listener = ['change', function () {
          // make sure to handle the previous messages before
          // starting with the new ones (to prevent double handling)
          _this2._handleInMessagesPromise = _this2._handleInMessagesPromise.then(function () {
            return Promise.all([_this2._port.tab.get(), _this2._port.background.get()]).then(function () {
              var _ref2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee(_ref3) {
                var _ref4 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
                    _ref4$ = _ref4[0],
                    tab = _ref4$ === undefined ? {} : _ref4$,
                    _ref4$2 = _ref4[1],
                    background = _ref4$2 === undefined ? {} : _ref4$2;

                var incomingMessages, acksMessages, newMessages, setItems, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, newMessage, id;

                return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return _this2._cleanOutgoingMessages(tab, background);

                      case 2:
                        incomingMessages = _this2._calculateIncomingMessages(background);
                        _context.next = 5;
                        return _this2._cleanAcksMessages(tab, incomingMessages);

                      case 5:
                        acksMessages = _context.sent;
                        newMessages = _this2._calculateNewIncomingMessages(incomingMessages, acksMessages);
                        setItems = {};
                        _iteratorNormalCompletion = true;
                        _didIteratorError = false;
                        _iteratorError = undefined;
                        _context.prev = 11;

                        for (_iterator = newMessages[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          newMessage = _step.value;
                          id = newMessage.private.id;


                          _this2._handleIncomingMessage(newMessage);
                          _this2._sendWindowMessageToChildFrames('embedBackgroundPort_newIncomingMessage', newMessage);

                          // set the ack
                          setItems[acksMessagesKey + '.' + id] = true;
                        }
                        _context.next = 19;
                        break;

                      case 15:
                        _context.prev = 15;
                        _context.t0 = _context['catch'](11);
                        _didIteratorError = true;
                        _iteratorError = _context.t0;

                      case 19:
                        _context.prev = 19;
                        _context.prev = 20;

                        if (!_iteratorNormalCompletion && _iterator.return) {
                          _iterator.return();
                        }

                      case 22:
                        _context.prev = 22;

                        if (!_didIteratorError) {
                          _context.next = 25;
                          break;
                        }

                        throw _iteratorError;

                      case 25:
                        return _context.finish(22);

                      case 26:
                        return _context.finish(19);

                      case 27:
                        _context.next = 29;
                        return _this2._port.tab.setByPath(setItems);

                      case 29:
                      case 'end':
                        return _context.stop();
                    }
                  }
                }, _callee, _this2, [[11, 15, 19, 27], [20,, 22, 26]]);
              }));

              return function (_x) {
                return _ref2.apply(this, arguments);
              };
            }());
          });
        }];
        (_port$tabs = this._port.tabs).on.apply(_port$tabs, listener);
        this._listeners.push(listener);
      }

      // Receive child frame messages
      var inWindowListener = ['message', function (event) {
        var message = event.data;
        //if (event.source !== window) return;
        if ((typeof message === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default()(message)) !== 'object' || message === null) return;
        if (message.from !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_namespace__["a" /* default */])('content') || message.to !== __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_namespace__["a" /* default */])('content')) return;
        //logger.debug('EmbedBackgroundPort: received content message', message);

        if (message.topic === 'embedBackgroundPort_register' && _this2.extension.isTopFrame) {
          _this2._topFrameId = _this2.extension.frameId;
          _this2._sendWindowMessageToChildFrames('embedBackgroundPort_topFrameId', _this2.extension.frameId);
        }
        if (message.topic === 'embedBackgroundPort_topFrameId') {
          _this2._topFrameId = message.data;
          _this2._sendWindowMessageToChildFrames(message.topic, message.data);
        }
        if (message.topic === 'embedBackgroundPort_newIncomingMessage') {
          _this2._handleIncomingMessage(message.data);
          _this2._sendWindowMessageToChildFrames(message.topic, message.data);
        }
        if (message.topic === 'embedBackgroundPort_send') _this2._realSend(message.data);
      }, false];
      (_window = window).addEventListener.apply(_window, inWindowListener);
      this._windowListeners.push(inWindowListener);

      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedBackgroundPort.prototype.__proto__ || Object.getPrototypeOf(EmbedBackgroundPort.prototype), '_bindHandlers', this).call(this);
    }

    // remove from the store the outgoing messages that have been already handled by the relative tab,
    // return the updated object

  }, {
    key: '_cleanOutgoingMessages',
    value: function () {
      var _ref5 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee2(tab, background) {
        var outgoingMessages, pathsToRemove, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, id;

        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                outgoingMessages = __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(tab, outMessagesKey) || {}; // object <id, msg>

                pathsToRemove = [];
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context2.prev = 5;

                for (_iterator2 = Object.keys(outgoingMessages)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  id = _step2.value;

                  // check if the background handled the message
                  if (__WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(background, acksMessagesKey + '.' + id)) {
                    pathsToRemove.push(outMessagesKey + '.' + id);
                    delete outgoingMessages[id];
                  }
                }
                _context2.next = 13;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2['catch'](5);
                _didIteratorError2 = true;
                _iteratorError2 = _context2.t0;

              case 13:
                _context2.prev = 13;
                _context2.prev = 14;

                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }

              case 16:
                _context2.prev = 16;

                if (!_didIteratorError2) {
                  _context2.next = 19;
                  break;
                }

                throw _iteratorError2;

              case 19:
                return _context2.finish(16);

              case 20:
                return _context2.finish(13);

              case 21:
                _context2.next = 23;
                return this._port.tab.removeByPath(pathsToRemove);

              case 23:
                return _context2.abrupt('return', outgoingMessages);

              case 24:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 9, 13, 21], [14,, 16, 20]]);
      }));

      function _cleanOutgoingMessages(_x2, _x3) {
        return _ref5.apply(this, arguments);
      }

      return _cleanOutgoingMessages;
    }()

    // return the incoming messages as an array sorted in sent order

  }, {
    key: '_calculateIncomingMessages',
    value: function _calculateIncomingMessages(background) {
      var _this3 = this;

      var vals = __WEBPACK_IMPORTED_MODULE_16_lodash_values___default()(background[inMessagesKey]).filter(function (msg) {
        return msg.private.tabId === _this3._topFrameId;
      });
      return __WEBPACK_IMPORTED_MODULE_17_lodash_sortBy___default()(vals, function (msg) {
        return __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(msg, 'private.time');
      });
    }

    // remove from the store the acks associated to no incoming message,
    // return the updated object
    // Note: incomingMessages is an array, not an object!

  }, {
    key: '_cleanAcksMessages',
    value: function () {
      var _ref6 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_asyncToGenerator___default()(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.mark(function _callee3(tab, incomingMessages) {
        var acksMessages, pathsToRemove, _loop, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, id;

        return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_regenerator___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                acksMessages = __WEBPACK_IMPORTED_MODULE_14_lodash_get___default()(tab, acksMessagesKey) || {};
                pathsToRemove = [];

                _loop = function _loop(id) {
                  // id refer to the incoming message
                  var incomingMessage = __WEBPACK_IMPORTED_MODULE_13_lodash_find___default()(incomingMessages, function (msg) {
                    return msg.private.id === id;
                  });
                  if (!incomingMessage) {
                    pathsToRemove.push(acksMessagesKey + '.' + id);
                    delete acksMessages[id];
                  }
                };

                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context3.prev = 6;

                for (_iterator3 = Object.keys(acksMessages)[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  id = _step3.value;

                  _loop(id);
                }
                _context3.next = 14;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3['catch'](6);
                _didIteratorError3 = true;
                _iteratorError3 = _context3.t0;

              case 14:
                _context3.prev = 14;
                _context3.prev = 15;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 17:
                _context3.prev = 17;

                if (!_didIteratorError3) {
                  _context3.next = 20;
                  break;
                }

                throw _iteratorError3;

              case 20:
                return _context3.finish(17);

              case 21:
                return _context3.finish(14);

              case 22:
                _context3.next = 24;
                return this._port.tab.removeByPath(pathsToRemove);

              case 24:
                return _context3.abrupt('return', acksMessages);

              case 25:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 10, 14, 22], [15,, 17, 21]]);
      }));

      function _cleanAcksMessages(_x4, _x5) {
        return _ref6.apply(this, arguments);
      }

      return _cleanAcksMessages;
    }()

    // return the NEW incoming messages by skipping the already handled ones

  }, {
    key: '_calculateNewIncomingMessages',
    value: function _calculateNewIncomingMessages(incomingMessages, acksMessages) {
      return incomingMessages.filter(function (msg) {
        return __WEBPACK_IMPORTED_MODULE_15_lodash_has___default()(acksMessages, msg.private.id) === false;
      });
    }

    // this function is called with every new incoming message, in every frame (main and childs)

  }, {
    key: '_handleIncomingMessage',
    value: function _handleIncomingMessage(newMessage) {
      if (newMessage.private.time <= this._connectTime) {
        logger.debug('EmbedBackgroundPort old message', newMessage, newMessage.private.time - this._connectTime);
        return;
      }

      if (newMessage.public._echo) {
        // response
        var responseHandler = this._responseHandlers[newMessage.public._echo];
        if (responseHandler) {
          logger.debug('EmbedBackgroundPort response message', newMessage);
          delete this._responseHandlers[newMessage.public._echo];
          responseHandler(newMessage.public.data);
        }
      } else {
        // actual new message
        logger.debug('EmbedBackgroundPort new message', newMessage);
        this._onMessageReceived(newMessage.public, this._makeRespond(newMessage));
      }
    }
  }, {
    key: '_makeRespond',
    value: function _makeRespond(newMessage) {
      var _this4 = this;

      return function (response) {
        logger.debug('EmbedBackgroundPort: sending response', response, newMessage);
        _this4.send({
          _echo: newMessage.private.id,
          data: response
        });
      };
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (!this._port) return;
      this._unbindHandlers();
      this._port = null;
      this._onDisconnected();
      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(EmbedBackgroundPort.prototype.__proto__ || Object.getPrototypeOf(EmbedBackgroundPort.prototype), 'disconnect', this).call(this);
    }
  }, {
    key: '_unbindHandlers',
    value: function _unbindHandlers() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._listeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _port$tabs2;

          var listener = _step4.value;

          (_port$tabs2 = this._port.tabs).removeListener.apply(_port$tabs2, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(listener));
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._listeners = [];

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._windowListeners[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _window2;

          var windowListener = _step5.value;

          (_window2 = window).removeEventListener.apply(_window2, __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(windowListener));
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this._windowListeners = [];
    }
  }, {
    key: 'send',
    value: function send(message, responseHandler) {
      logger.debug('EmbedBackgroundPort: send', message);

      var newOutMessage = {
        private: {
          id: this.extension.frameId + '_' + this._outMessagesCounter,
          time: Date.now(),
          tab: null // the top frame will set it
        },
        public: message
      };
      this._outMessagesCounter++;

      if (responseHandler) {
        this._responseHandlers[newOutMessage.private.id] = responseHandler;
      }

      // send to top frame (our same frame if we are in the top frame)
      this._sendWindowMessageToTopFrame('embedBackgroundPort_send', newOutMessage);
    }

    // Note: this should be used only by the top frame.

  }, {
    key: '_realSend',
    value: function _realSend(newOutMessage) {
      // top frame info (i.e. the tab info)
      newOutMessage.private.tab = {
        id: this.extension.frameId,
        url: window.location.href
      };

      this._port.tab.setByPath(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, outMessagesKey + '.' + newOutMessage.private.id, newOutMessage));
    }
  }, {
    key: '_sendWindowMessageToTopFrame',
    value: function _sendWindowMessageToTopFrame(topic, data) {
      var message = this._makeWindowMessage(topic, data);
      window.top.postMessage(message, '*');
    }
  }, {
    key: '_sendWindowMessageToChildFrames',
    value: function _sendWindowMessageToChildFrames(topic, data) {
      var message = this._makeWindowMessage(topic, data);

      var childFrameWindows = Array.from(document.documentElement.querySelectorAll('iframe')).map(function (iframe) {
        return iframe.contentWindow;
      });
      for (var i = 0; i < childFrameWindows.length; i++) {
        childFrameWindows[i].postMessage(message, '*');
      }
    }
  }, {
    key: '_makeWindowMessage',
    value: function _makeWindowMessage(topic, data) {
      return {
        topic: topic,
        data: data,
        from: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_namespace__["a" /* default */])('content'),
        to: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_utils_namespace__["a" /* default */])('content')
      };
    }
  }]);

  return EmbedBackgroundPort;
}(__WEBPACK_IMPORTED_MODULE_11_base_common_Port__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/content/EmbedBackgroundPort.js"))

/***/ }),
/* 703 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_content_Extension__ = __webpack_require__(603);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sharedMemory_SharedMemory__ = __webpack_require__(707);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__EmbedStorage__ = __webpack_require__(706);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__EmbedPortManager__ = __webpack_require__(705);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_settings__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_defaults__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash_defaults___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash_defaults__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__common_StubComponent__ = __webpack_require__(535);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__EmbedPanelController__ = __webpack_require__(704);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedExtension; });













function getEmbedOptions() {
  if (window.ioradWidgetOptions) return window.ioradWidgetOptions;

  // legacy
  var script = document.querySelector('script[data-iorad-user-id]');
  var colors = {
    main: script.getAttribute('data-iorad-widget-color'),
    navaBar: script.getAttribute('data-iorad-widget-navBarColor'),
    actionButton: script.getAttribute('data-iorad-widget-actionButtonColor'),
    highlight: script.getAttribute('data-iorad-widget-highlightColor')
  };
  return {
    userId: script.getAttribute('data-iorad-user-id'),
    premium: script.getAttribute('data-iorad-premium'),
    colors: __WEBPACK_IMPORTED_MODULE_9_lodash_defaults___default()(colors, __WEBPACK_IMPORTED_MODULE_8_base_common_settings__["a" /* default */].get('defaultColors')),
    icon: script.getAttribute('data-iorad-widget-icon'),
    combineIntercom: script.getAttribute('data-iorad-combine-intercom')
  };
}

var EmbedExtension = function (_Extension) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedExtension, _Extension);

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(EmbedExtension, [{
    key: 'getURL',
    value: function getURL(path) {
      if (!path.startsWith('/')) path = '/' + path;
      var scriptEl = document.querySelector('script[data-iorad-user-id]');
      var scriptURL = scriptEl.src;
      if (scriptURL) {
        return scriptURL.slice(0, scriptURL.lastIndexOf('/')) + path;
      }
      return __WEBPACK_IMPORTED_MODULE_8_base_common_settings__["a" /* default */].get('extension.embed.basePath') + path;
    }
  }, {
    key: 'getPortManagerClass',
    value: function getPortManagerClass() {
      return __WEBPACK_IMPORTED_MODULE_7__EmbedPortManager__["a" /* default */];
    }
  }, {
    key: 'getSharedMemoryClass',
    value: function getSharedMemoryClass() {
      return __WEBPACK_IMPORTED_MODULE_5__sharedMemory_SharedMemory__["a" /* default */];
    }
  }, {
    key: 'getStorageClass',
    value: function getStorageClass() {
      return __WEBPACK_IMPORTED_MODULE_6__EmbedStorage__["a" /* default */];
    }
  }, {
    key: 'getOverlayControllerClass',
    value: function getOverlayControllerClass() {
      // OPTIMIZATION
      return __WEBPACK_IMPORTED_MODULE_10__common_StubComponent__["a" /* default */];
    }
  }, {
    key: 'getPanelControllerClass',
    value: function getPanelControllerClass() {
      return __WEBPACK_IMPORTED_MODULE_11__EmbedPanelController__["a" /* default */];
    }
  }, {
    key: 'getDocumentCaptureClass',
    value: function getDocumentCaptureClass() {
      return __WEBPACK_IMPORTED_MODULE_10__common_StubComponent__["a" /* default */];
    }
  }]);

  function EmbedExtension() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedExtension);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedExtension.__proto__ || Object.getPrototypeOf(EmbedExtension)).call(this, 'embed', "1.8.0", 'embed'));
    // Note: use same version of chrome extension


    _this.embedOptions = getEmbedOptions();
    return _this;
  }

  return EmbedExtension;
}(__WEBPACK_IMPORTED_MODULE_4_base_content_Extension__["a" /* default */]);



/***/ }),
/* 704 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__filename) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_content_PanelController__ = __webpack_require__(522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_base_common_utils_appendOnBodyLater__ = __webpack_require__(514);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_base_common_utils_isMobileBrowsers__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_base_common_utils_intercom__ = __webpack_require__(516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_defaults__ = __webpack_require__(485);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash_defaults___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash_defaults__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_base_common_svgInline_spinner_white__ = __webpack_require__(511);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_base_common_svgInline_widget_icon__ = __webpack_require__(512);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_base_common_utils_logger__ = __webpack_require__(6);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedPanelController; });
















var logger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_base_common_utils_logger__["a" /* getFileLogger */])(__filename);

var EmbedPanelController = function (_PanelController) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(EmbedPanelController, _PanelController);

  function EmbedPanelController() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, EmbedPanelController);

    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedPanelController.__proto__ || Object.getPrototypeOf(EmbedPanelController)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(EmbedPanelController, [{
    key: 'getPanelOptions',
    value: function getPanelOptions() {
      var _get2;

      var liveEmbedForUser = this.extension.embedOptions.userId;
      var premium = this.extension.embedOptions.premium;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, (_get2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(EmbedPanelController.prototype.__proto__ || Object.getPrototypeOf(EmbedPanelController.prototype), 'getPanelOptions', this)).call.apply(_get2, [this].concat(args)), {
        embed: true,
        userId: liveEmbedForUser,
        premium: premium,
        mobileView: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_base_common_utils_isMobileBrowsers__["a" /* default */])()
      });
    }
  }, {
    key: 'toggleWidget',
    value: function toggleWidget(mode) {
      document.documentElement.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('widget-visible'));

      if (mode === 'hide') {
        __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(EmbedPanelController.prototype.__proto__ || Object.getPrototypeOf(EmbedPanelController.prototype), 'hideWidget', this).call(this);
        this.showCloseWidget();
        this.showChatButtonWidget();
      } else {
        __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(EmbedPanelController.prototype.__proto__ || Object.getPrototypeOf(EmbedPanelController.prototype), 'showWidget', this).call(this);
        this.hideCloseWidget();
        this.hideChatButtonWidget();
      }
    }
  }, {
    key: 'getOrMakeWidget',
    value: function getOrMakeWidget(tabId) {
      var _this2 = this;

      return !this.widgetEl ? new Promise(function (resolve) {
        var _createWidget = _this2.createWidget(tabId),
            widget = _createWidget.widget,
            close = _createWidget.close,
            chat = _createWidget.chat;

        _this2.widgetEl = widget;
        _this2.closeEl = close;
        _this2.chatButtonEl = chat;

        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_appendOnBodyLater__["a" /* default */])(widget, function () {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_appendOnBodyLater__["a" /* default */])(chat, function () {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_base_common_utils_appendOnBodyLater__["a" /* default */])(close, function () {
              return resolve(close);
            });
          });
        });
      }) : Promise.resolve(this.widgetEl);
    }
  }, {
    key: 'createWidget',
    value: function createWidget(tabId) {
      var _this3 = this;

      var script = document.querySelector('script[data-iorad-user-id]');
      var iconEl = document.createElement('div');
      var closeEl = document.createElement('div');
      var chatButtonEl = document.createElement('div');
      var hideIcon = this.hideIcon();
      iconEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('widget', 'hide ') + (hideIcon ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('hide-mode') : '');
      closeEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('widget', 'hide') + ' close-widget';
      chatButtonEl.className = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('hide') + ' chatbutton-widget chat-with-us';
      chatButtonEl.style.display = 'none';
      setTimeout(function () {
        chatButtonEl.style.display = 'block';
      }, 500);
      chatButtonEl.textContent = 'Chat with us';
      iconEl.innerHTML = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_base_common_svgInline_widget_icon__["a" /* default */])();
      closeEl.innerHTML = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_base_common_svgInline_spinner_white__["a" /* default */])();

      var _extension$embedOptio = this.extension.embedOptions,
          logo = _extension$embedOptio.logo,
          colors = _extension$embedOptio.colors;


      if (logo) {
        iconEl.style.backgroundImage = 'url(\'' + logo + '\')';
      }

      if (colors.main) {
        iconEl.style.backgroundColor = colors.main;
        closeEl.style.backgroundColor = colors.main;
        chatButtonEl.style.backgroundColor = colors.main;
      }

      this.customColors = __WEBPACK_IMPORTED_MODULE_11_lodash_defaults___default()(this.customColors || {}, colors);

      iconEl.addEventListener('click', function () {
        return _this3.onWidgetClick(tabId);
      });
      closeEl.addEventListener('click', function () {
        return _this3.onCloseWidgetClick(tabId);
      });
      chatButtonEl.addEventListener('click', function () {
        return _this3.onChatButtonWidgetClick(tabId);
      });

      return {
        widget: iconEl,
        close: closeEl,
        chat: chatButtonEl
      };
    }
  }, {
    key: 'updateWidget',
    value: function updateWidget() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$loadingStepPage = _ref.loadingStepPage,
          loadingStepPage = _ref$loadingStepPage === undefined ? false : _ref$loadingStepPage,
          currentStep = _ref.currentStep;

      if (!this.widgetEl) return;

      if (this.customColors && this.customColors.main) {
        this.widgetEl.style.backgroundColor = this.customColors.main;
        this.closeEl.style.backgroundColor = this.customColors.main;
        this.chatButtonEl.style.backgroundColor = this.customColors.main;
      }

      var c = this.closeEl.classList;
      loadingStepPage ? c.add('loading-widget') : c.remove('loading-widget');

      var action = currentStep ? 'add' : 'remove';
      this.closeEl.classList[action](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('live-active'));
      this.widgetEl.classList[action](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('live-active'));
      this.chatButtonEl.classList[action](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('live-active'));
    }
  }, {
    key: 'hideChatButtonWidget',
    value: function hideChatButtonWidget() {
      if (!this.chatButtonEl) return;
      if (!document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('intercom-visible'))) {
        this.chatButtonEl.classList.add(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('hide'));
      }
      return this.chatButtonEl;
    }
  }, {
    key: 'showChatButtonWidget',
    value: function showChatButtonWidget() {
      if (!this.chatButtonEl) return;
      var state = this.ownContext().state;
      if (state.intercomInstalled && !this.widgetDisabled && this.chatButtonEl) {
        this.chatButtonEl.classList.remove(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('hide'));
      }
      return this.chatButtonEl;
    }
  }, {
    key: 'toggleChatButtonWidgetLabel',
    value: function toggleChatButtonWidgetLabel(toggle) {
      if (!this.chatButtonEl) return;
      if (toggle) {
        this.chatButtonEl.textContent = 'Tutorials';
        this.chatButtonEl.classList.remove('chat-with-us');
        this.chatButtonEl.classList.add('chat-with-us-tutorials');
      } else {
        this.chatButtonEl.textContent = 'Chat with us';
        this.chatButtonEl.classList.remove('chat-with-us-tutorials');
        this.chatButtonEl.classList.add('chat-with-us');
      }
    }
  }, {
    key: 'onWidgetClick',
    value: function onWidgetClick(tabId) {
      if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_base_common_utils_intercom__["b" /* getIntercomPendingMessages */])() > 0) {
        this.toggleIntercom();
      } else {
        // don't send tabId: in embed we always want to open panels in all tabs
        this.backgroundPort.send({
          topic: 'showPanel',
          data: { explicit: true, tabId: undefined }
        });
      }
    }
  }, {
    key: 'onChatButtonWidgetClick',
    value: function onChatButtonWidgetClick(tabId) {
      document.documentElement.classList.contains(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('intercom-visible')) ? this.openTutorials() : this.toggleIntercom();
    }
  }, {
    key: 'isCombineIntercom',
    value: function isCombineIntercom() {
      return String(this.extension.embedOptions.combineIntercom) === 'true';
    }
  }, {
    key: 'isGoogleTranslate',
    value: function isGoogleTranslate() {
      return String(this.extension.embedOptions.googleTranslate) === 'true';
    }
  }, {
    key: 'hideIcon',
    value: function hideIcon() {
      return String(this.extension.embedOptions.hideIcon) === 'true';
    }
  }]);

  return EmbedPanelController;
}(__WEBPACK_IMPORTED_MODULE_6_base_content_PanelController__["a" /* default */]);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, "embed/content/EmbedPanelController.js"))

/***/ }),
/* 705 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_base_content_PortManager__ = __webpack_require__(607);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EmbedBackgroundPort__ = __webpack_require__(702);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedPortManager; });







var EmbedPortManager = function (_PortManager) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(EmbedPortManager, _PortManager);

  function EmbedPortManager() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, EmbedPortManager);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (EmbedPortManager.__proto__ || Object.getPrototypeOf(EmbedPortManager)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(EmbedPortManager, [{
    key: 'getBackgroundPortClass',
    value: function getBackgroundPortClass() {
      return __WEBPACK_IMPORTED_MODULE_5__EmbedBackgroundPort__["a" /* default */];
    }
  }]);

  return EmbedPortManager;
}(__WEBPACK_IMPORTED_MODULE_4_base_content_PortManager__["a" /* default */]);



/***/ }),
/* 706 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_embed_common_EmbedStorage__ = __webpack_require__(534);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_embed_common_sharedMemory_ObjectStore__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmbedStorage; });










var EmbedStorage = function (_CommonEmbedStorage) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(EmbedStorage, _CommonEmbedStorage);

  function EmbedStorage() {
    var _ref;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, EmbedStorage);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_ref = EmbedStorage.__proto__ || Object.getPrototypeOf(EmbedStorage)).call.apply(_ref, [this].concat(args)));

    _this._objectStore = new __WEBPACK_IMPORTED_MODULE_7_embed_common_sharedMemory_ObjectStore__["a" /* default */](__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_base_common_utils_namespace__["a" /* default */])('storage'), 'read');
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(EmbedStorage, [{
    key: 'start',
    value: function start() {
      var _get2;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_get2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(EmbedStorage.prototype.__proto__ || Object.getPrototypeOf(EmbedStorage.prototype), 'start', this)).call.apply(_get2, [this].concat(args));

      this.setupBackground();
    }
  }, {
    key: 'setupBackground',
    value: function setupBackground() {
      this.backgroundPort = this.extension.portManager.backgroundPort;
    }
  }, {
    key: 'get',
    value: function get() {
      var _objectStore;

      return (_objectStore = this._objectStore).get.apply(_objectStore, arguments);
    }
  }, {
    key: 'set',
    value: function set() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._makeStorageRequest('set', args);
    }
  }, {
    key: 'remove',
    value: function remove() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this._makeStorageRequest('remove', args);
    }
  }, {
    key: 'clear',
    value: function clear() {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return this._makeStorageRequest('clear', args);
    }
  }, {
    key: '_makeStorageRequest',
    value: function _makeStorageRequest(type, data) {
      var _this2 = this;

      // TODO: check that resolve is correctly called after message is handled by background
      return new Promise(function (resolve, reject) {
        _this2.backgroundPort.send({
          topic: 'storageRequest',
          data: {
            type: type,
            args: data
          }
        }, function () {
          var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (response.status === 'success') resolve.apply(undefined, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(response.args));else reject.apply(undefined, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(response.args));
        });
      });
    }
  }]);

  return EmbedStorage;
}(__WEBPACK_IMPORTED_MODULE_6_embed_common_EmbedStorage__["a" /* default */]);



/***/ }),
/* 707 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_embed_common_sharedMemory_SharedMemory__ = __webpack_require__(536);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_embed_common_sharedMemory_ObjectStore__ = __webpack_require__(284);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_embed_common_sharedMemory_TabsStore__ = __webpack_require__(537);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__ = __webpack_require__(12);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SharedMemory; });








var SharedMemory = function (_CommonSharedMemory) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(SharedMemory, _CommonSharedMemory);

  function SharedMemory(frameId) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, SharedMemory);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SharedMemory.__proto__ || Object.getPrototypeOf(SharedMemory)).call(this));

    var tabKey = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('tab-' + frameId);
    var backgroundKey = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_base_common_utils_namespace__["a" /* default */])('background');

    _this.tab = new __WEBPACK_IMPORTED_MODULE_4_embed_common_sharedMemory_ObjectStore__["a" /* default */](tabKey, window.parent === window ? 'readwrite' : 'read');
    _this.background = new __WEBPACK_IMPORTED_MODULE_4_embed_common_sharedMemory_ObjectStore__["a" /* default */](backgroundKey, 'read');
    _this.tabs = new __WEBPACK_IMPORTED_MODULE_5_embed_common_sharedMemory_TabsStore__["a" /* default */]();
    return _this;
  }

  return SharedMemory;
}(__WEBPACK_IMPORTED_MODULE_3_embed_common_sharedMemory_SharedMemory__["a" /* default */]);



/***/ }),
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

!function(a,b){ true?module.exports=b():"function"==typeof define&&define.amd?define([],b):a.Draggable=b()}(this,function(){"use strict";function a(a,b){var c=this,d=k.bind(c.start,c),e=k.bind(c.drag,c),g=k.bind(c.stop,c);if(!f(a))throw new TypeError("Draggable expects argument 0 to be an Element");b=k.assign({},i,b),k.assign(c,{element:a,handle:b.handle&&f(b.handle)?b.handle:a,handlers:{start:{mousedown:d,touchstart:d},move:{mousemove:e,mouseup:g,touchmove:e,touchend:g}},options:b}),c.initialize()}function b(a){return parseInt(a,10)}function c(a){return"currentStyle"in a?a.currentStyle:getComputedStyle(a)}function d(a){return a instanceof Array}function e(a){return void 0!==a&&null!==a}function f(a){return a instanceof Element||"undefined"!=typeof HTMLDocument&&a instanceof HTMLDocument}function g(a){return a instanceof Function}function h(){}var i={grid:0,filterTarget:null,limit:{x:null,y:null},threshold:0,setCursor:!1,setPosition:!0,smoothDrag:!0,useGPU:!0,onDrag:h,onDragStart:h,onDragEnd:h},j={transform:function(){for(var a=" -o- -ms- -moz- -webkit-".split(" "),b=document.body.style,c=a.length;c--;){var d=a[c]+"transform";if(d in b)return d}}()},k={assign:function(){for(var a=arguments[0],b=arguments.length,c=1;b>c;c++){var d=arguments[c];for(var e in d)a[e]=d[e]}return a},bind:function(a,b){return function(){a.apply(b,arguments)}},on:function(a,b,c){if(b&&c)k.addEvent(a,b,c);else if(b)for(var d in b)k.addEvent(a,d,b[d])},off:function(a,b,c){if(b&&c)k.removeEvent(a,b,c);else if(b)for(var d in b)k.removeEvent(a,d,b[d])},limit:function(a,b){return d(b)?(b=[+b[0],+b[1]],a<b[0]?a=b[0]:a>b[1]&&(a=b[1])):a=+b,a},addEvent:"attachEvent"in Element.prototype?function(a,b,c){a.attachEvent("on"+b,c)}:function(a,b,c){a.addEventListener(b,c,!1)},removeEvent:"attachEvent"in Element.prototype?function(a,b,c){a.detachEvent("on"+b,c)}:function(a,b,c){a.removeEventListener(b,c)}};return k.assign(a.prototype,{setOption:function(a,b){var c=this;return c.options[a]=b,c.initialize(),c},get:function(){var a=this.dragEvent;return{x:a.x,y:a.y}},set:function(a,b){var c=this,d=c.dragEvent;return d.original={x:d.x,y:d.y},c.move(a,b),c},dragEvent:{started:!1,x:0,y:0},initialize:function(){var a,b=this,d=b.element,e=(b.handle,d.style),f=c(d),g=b.options,h=j.transform,i=b._dimensions={height:d.offsetHeight,left:d.offsetLeft,top:d.offsetTop,width:d.offsetWidth};g.useGPU&&h&&(a=f[h],"none"===a&&(a=""),e[h]=a+" translate3d(0,0,0)"),g.setPosition&&(e.display="block",e.left=i.left+"px",e.top=i.top+"px",e.bottom=e.right="auto",e.margin=0,e.position="absolute"),g.setCursor&&(e.cursor="move"),b.setLimit(g.limit),k.assign(b.dragEvent,{x:i.left,y:i.top}),k.on(b.handle,b.handlers.start)},start:function(a){var b=this,c=b.getCursor(a),d=b.element;b.useTarget(a.target||a.srcElement)&&(a.preventDefault?a.preventDefault():a.returnValue=!1,b.dragEvent.oldZindex=d.style.zIndex,d.style.zIndex=1e4,b.setCursor(c),b.setPosition(),b.setZoom(),k.on(document,b.handlers.move))},drag:function(a){var b=this,c=b.dragEvent,d=b.element,e=b._cursor,f=b._dimensions,g=b.options,h=f.zoom,i=b.getCursor(a),j=g.threshold,k=(i.x-e.x)/h+f.left,l=(i.y-e.y)/h+f.top;!c.started&&j&&Math.abs(e.x-i.x)<j&&Math.abs(e.y-i.y)<j||(c.original||(c.original={x:k,y:l}),c.started||(g.onDragStart(d,k,l,a),c.started=!0),b.move(k,l)&&g.onDrag(d,c.x,c.y,a))},move:function(a,b){var c=this,d=c.dragEvent,e=c.options,f=e.grid,g=c.element.style,h=c.limit(a,b,d.original.x,d.original.y);return!e.smoothDrag&&f&&(h=c.round(h,f)),h.x!==d.x||h.y!==d.y?(d.x=h.x,d.y=h.y,g.left=h.x+"px",g.top=h.y+"px",!0):!1},stop:function(a){var b,c=this,d=c.dragEvent,e=c.element,f=c.options,g=f.grid;k.off(document,c.handlers.move),e.style.zIndex=d.oldZindex,f.smoothDrag&&g&&(b=c.round({x:d.x,y:d.y},g),c.move(b.x,b.y),k.assign(c.dragEvent,b)),c.dragEvent.started&&f.onDragEnd(e,d.x,d.y,a),c.reset()},reset:function(){this.dragEvent.started=!1},round:function(a){var b=this.options.grid;return{x:b*Math.round(a.x/b),y:b*Math.round(a.y/b)}},getCursor:function(a){return{x:(a.targetTouches?a.targetTouches[0]:a).clientX,y:(a.targetTouches?a.targetTouches[0]:a).clientY}},setCursor:function(a){this._cursor=a},setLimit:function(a){var b=this,c=function(a,b){return{x:a,y:b}};if(g(a))b.limit=a;else if(f(a)){var d=b._dimensions,h=a.scrollHeight-d.height,i=a.scrollWidth-d.width;b.limit=function(a,b){return{x:k.limit(a,[0,i]),y:k.limit(b,[0,h])}}}else if(a){var j={x:e(a.x),y:e(a.y)};b.limit=j.x||j.y?function(b,c){return{x:j.x?k.limit(b,a.x):b,y:j.y?k.limit(c,a.y):c}}:c}else b.limit=c},setPosition:function(){var a=this,c=a.element,d=c.style;k.assign(a._dimensions,{left:b(d.left)||c.offsetLeft,top:b(d.top)||c.offsetTop})},setZoom:function(){for(var a=this,b=a.element,d=1;b=b.offsetParent;){var e=c(b).zoom;if(e&&"normal"!==e){d=e;break}}a._dimensions.zoom=d},useTarget:function(a){var b=this.options.filterTarget;return b instanceof Function?b(a):!0},destroy:function(){k.off(this.handle,this.handlers.start),k.off(document,this.handlers.move)}}),a});

/***/ }),
/* 712 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;


/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(103);

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;


/***/ }),
/* 723 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(63);

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),
/* 724 */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(103);

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),
/* 725 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),
/* 726 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(152),
    arrayIncludes = __webpack_require__(154),
    arrayIncludesWith = __webpack_require__(230),
    arrayMap = __webpack_require__(33),
    baseUnary = __webpack_require__(122),
    cacheHas = __webpack_require__(160);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;


/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(118),
    assignMergeValue = __webpack_require__(544),
    baseFor = __webpack_require__(287),
    baseMergeDeep = __webpack_require__(729),
    isObject = __webpack_require__(16),
    keysIn = __webpack_require__(89);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(544),
    cloneBuffer = __webpack_require__(292),
    cloneTypedArray = __webpack_require__(293),
    copyArray = __webpack_require__(104),
    initCloneObject = __webpack_require__(297),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(8),
    isArrayLikeObject = __webpack_require__(169),
    isBuffer = __webpack_require__(88),
    isFunction = __webpack_require__(181),
    isObject = __webpack_require__(16),
    isPlainObject = __webpack_require__(548),
    isTypedArray = __webpack_require__(125),
    toPlainObject = __webpack_require__(755);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 730 */
/***/ (function(module, exports) {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

module.exports = baseRandom;


/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

var arraySample = __webpack_require__(543),
    values = __webpack_require__(82);

/**
 * The base implementation of `_.sample`.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 */
function baseSample(collection) {
  return arraySample(values(collection));
}

module.exports = baseSample;


/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(33);

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

module.exports = baseToPairs;


/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(79),
    last = __webpack_require__(492),
    parent = __webpack_require__(742),
    toKey = __webpack_require__(61);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLikeObject = __webpack_require__(169);

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;


/***/ }),
/* 735 */,
/* 736 */,
/* 737 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(285),
    noop = __webpack_require__(39),
    setToArray = __webpack_require__(124);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),
/* 738 */
/***/ (function(module, exports, __webpack_require__) {

var baseToPairs = __webpack_require__(732),
    getTag = __webpack_require__(107),
    mapToArray = __webpack_require__(165),
    setToPairs = __webpack_require__(743);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag(object);
    if (tag == mapTag) {
      return mapToArray(object);
    }
    if (tag == setTag) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

module.exports = createToPairs;


/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(81);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;


/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__(548);

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value, key) {
  return (key !== undefined && isPlainObject(value)) ? undefined : value;
}

module.exports = customOmitClone;


/***/ }),
/* 741 */
/***/ (function(module, exports) {

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;


/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(121),
    baseSlice = __webpack_require__(412);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),
/* 743 */
/***/ (function(module, exports) {

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

module.exports = setToPairs;


/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    createAssigner = __webpack_require__(244),
    keysIn = __webpack_require__(89);

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;


/***/ }),
/* 745 */
/***/ (function(module, exports, __webpack_require__) {

var baseDifference = __webpack_require__(397),
    baseFlatten = __webpack_require__(157),
    baseRest = __webpack_require__(78),
    isArrayLikeObject = __webpack_require__(169);

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;


/***/ }),
/* 746 */,
/* 747 */
/***/ (function(module, exports) {

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

module.exports = head;


/***/ }),
/* 748 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(288),
    toInteger = __webpack_require__(128);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

module.exports = indexOf;


/***/ }),
/* 749 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isArray = __webpack_require__(8),
    isObjectLike = __webpack_require__(34);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 750 */
/***/ (function(module, exports, __webpack_require__) {

var baseExtremum = __webpack_require__(723),
    baseGt = __webpack_require__(725),
    identity = __webpack_require__(43);

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(728),
    createAssigner = __webpack_require__(244);

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

module.exports = mergeWith;


/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

var arraySample = __webpack_require__(543),
    baseSample = __webpack_require__(731),
    isArray = __webpack_require__(8);

/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */
function sample(collection) {
  var func = isArray(collection) ? arraySample : baseSample;
  return func(collection);
}

module.exports = sample;


/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(46),
    copyArray = __webpack_require__(104),
    getTag = __webpack_require__(107),
    isArrayLike = __webpack_require__(29),
    isString = __webpack_require__(749),
    iteratorToArray = __webpack_require__(741),
    mapToArray = __webpack_require__(165),
    setToArray = __webpack_require__(124),
    stringToArray = __webpack_require__(479),
    values = __webpack_require__(82);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;


/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

var createToPairs = __webpack_require__(738),
    keys = __webpack_require__(38);

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

module.exports = toPairs;


/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(47),
    keysIn = __webpack_require__(89);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 756 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(157),
    baseRest = __webpack_require__(78),
    baseUniq = __webpack_require__(416),
    isArrayLikeObject = __webpack_require__(169);

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq = __webpack_require__(416);

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;


/***/ }),
/* 758 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq = __webpack_require__(416);

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
}

module.exports = uniqWith;


/***/ }),
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */
/***/ (function(module, exports, __webpack_require__) {

var convert = __webpack_require__(765);

module.exports = function (cstr) {
    var m, conv, parts, alpha;
    if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        var base = name.replace(/a$/, '');
        var size = base === 'cmyk' ? 4 : 3;
        conv = convert[base];
        
        parts = m[2].replace(/^\s+|\s+$/g, '')
            .split(/\s*,\s*/)
            .map(function (x, i) {
                if (/%$/.test(x) && i === size) {
                    return parseFloat(x) / 100;
                }
                else if (/%$/.test(x)) {
                    return parseFloat(x);
                }
                return parseFloat(x);
            })
        ;
        if (name === base) parts.push(1);
        alpha = parts[size] === undefined ? 1 : parts[size];
        parts = parts.slice(0, size);
        
        conv[base] = function () { return parts };
    }
    else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
        var base = cstr.replace(/^#/,'');
        var size = base.length;
        conv = convert.rgb;
        parts = base.split(size === 3 ? /(.)/ : /(..)/);
        parts = parts.filter(Boolean)
            .map(function (x) {
                if (size === 3) {
                    return parseInt(x + x, 16);
                }
                else {
                    return parseInt(x, 16)
                }
            })
        ;
        alpha = 1;
        conv.rgb = function () { return parts };
        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
    }
    else {
        conv = convert.keyword;
        conv.keyword = function () { return cstr };
        parts = cstr;
        alpha = 1;
    }
    
    var res = {
        rgb: undefined,
        hsl: undefined,
        hsv: undefined,
        cmyk: undefined,
        keyword: undefined,
        hex: undefined
    };
    try { res.rgb = conv.rgb(parts) } catch (e) {}
    try { res.hsl = conv.hsl(parts) } catch (e) {}
    try { res.hsv = conv.hsv(parts) } catch (e) {}
    try { res.cmyk = conv.cmyk(parts) } catch (e) {}
    try { res.keyword = conv.keyword(parts) } catch (e) {}
    
    if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {
        var s = x.toString(16);
        if (s.length === 1) return '0' + s;
        return s;
    }).join('');
    
    if (res.rgb) res.rgba = res.rgb.concat(alpha);
    if (res.hsl) res.hsla = res.hsl.concat(alpha);
    if (res.hsv) res.hsva = res.hsv.concat(alpha);
    if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);
    
    return res;
};


/***/ }),
/* 764 */
/***/ (function(module, exports) {

/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}


/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(764);

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;

/***/ }),
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(561);
__webpack_require__(560);
module.exports = __webpack_require__(562);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODM0NzU3Y2VkYWNhZWQzN2Y3N2Y/Yzk3ZSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanM/YWQ3MyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanM/OGZjZCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcz83OWI3Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9lZmUyIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzPzI5NjgiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyLmpzP2I0ZjYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzPzQxYzQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2lzQXJyYXkuanM/NTkwYyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcz9kZTI5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzPzg5MTIiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlLmpzPzkzNDIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19yb290LmpzPzY1NDIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanM/OTVmMCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcz8wNzRjIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc09iamVjdC5qcz81ZjVlIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzPzBlMWEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcz8xOTZiIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanM/MTkyYSIsIndlYnBhY2s6Ly8vLi4vfi9ub2RlLWV2ZW50LWVtaXR0ZXIvaW5kZXguanM/YTY0YiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/OGFmZSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanM/ZTcxNyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcz9kOGEzIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcz85MWJkIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcz82M2VmIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzPzNiYjUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcz9hODE2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qcz9hYjcwIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3NldHRpbmdzLmpzPzM0ODMiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanM/YTA1YSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcz9lOTYzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYXJyYXlNYXAuanM/NmQ4NSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzPzZiNDgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzPzU3ZDciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSXRlcmF0ZWUuanM/NWU0MCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gva2V5cy5qcz9iZTA5Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9ub29wLmpzPzc4M2QiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanM/ZDNhMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcz80MTI2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9nZXQuanM/NmRiZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaWRlbnRpdHkuanM/NTQ5YiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcz9iNWQ0Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzPzQzMTEiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19TeW1ib2wuanM/ZTAzOSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NvcHlPYmplY3QuanM/NDJjYyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzP2Q5NzYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzPzY4OTgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz9jNTljIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcz9hZTM5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/NTQyNCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcz82ZWY4Iiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanM/NmNjZiIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcz83Yjc3Iiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzP2Q0ZmMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzP2ZjNTkiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlR2V0VGFnLmpzP2JkOTgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz9mZTQwIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcz85MWNhIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fdG9LZXkuanM/MTY5YSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZmluZC5qcz84MWI4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc1N5bWJvbC5qcz9iZTQ5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzPzE0ZTQiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzPzRjMTYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzP2M3MWIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzP2QxMDAiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzPzk3YWUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanM/ZDNlZiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanM/YzA3OSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcz8zODA5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzPzQ3OGIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzPzk0NTEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzPzRjNTYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanM/NzNkNyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcz82OTAzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzPzkxN2YiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlUmVzdC5qcz9jMGEzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY2FzdFBhdGguanM/MGYxZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzSW5kZXguanM/ZTIyZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZXEuanM/MGNlYyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvdmFsdWVzLmpzPzdmMmEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzPzRjN2IiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzP2I5ZjgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcz9mYTM3Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9jdXJyeS5qcz9kNzZmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qcz84ZmJmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc0J1ZmZlci5qcz8yMzQ2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9rZXlzSW4uanM/N2NlNiIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzPzYyYTYiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvZnJhbWVNZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzPzJkOGIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanM/NzVlNCIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcz80MjlhIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcz80NDBkIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanM/YjRhMyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcz82MmQ4Iiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanM/ZTFkYiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX0xpc3RDYWNoZS5qcz9hMGJiIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzPzE5M2QiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlQ3JlYXRlLmpzP2UwOGUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlRWFjaC5qcz83ZjdiIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY29weUFycmF5LmpzPzU2MmIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVDdG9yLmpzPzEyNzIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19nZXRNYXBEYXRhLmpzP2NjOWUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19nZXRUYWcuanM/MzdlMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzP2NmNzgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19uYXRpdmVDcmVhdGUuanM/ZWQ1YiIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy93aW5kb3dFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz82N2MyIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanM/NGI1NCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzPzgxYzgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcz83MTA5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanM/MWMxNSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX1N0YWNrLmpzPzk5YjgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hcHBseS5qcz9hMjUzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzPzhjMzYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlR2V0LmpzPzE3ZjQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlVW5hcnkuanM/ODAxNiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzPzEwZjMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19zZXRUb0FycmF5LmpzPzVjMDEiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcz8yYjg4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9waWNrLmpzP2IyY2YiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3NvcnRCeS5qcz9jYWQzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC90b0ludGVnZXIuanM/ODE1MiIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzPzE3YTgiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vQ29tcG9uZW50LmpzPzgxOTIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanM/OWJlMCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanM/M2JjYyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanM/M2M1NSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanM/MmU2NiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanM/ZDlmMSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanM/ZWNkNiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzPzQ4MDgiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanM/MWNhNCIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanM/ZWUwYyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanM/OTAyNSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanM/N2MyNiIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/ZTdjYyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzPzFhYWEiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanM/ODcyZiIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcz9lNzFjIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fTGF6eVdyYXBwZXIuanM/NTUwNSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX0xvZGFzaFdyYXBwZXIuanM/ODI0ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX01hcC5qcz9hOWVmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fTWFwQ2FjaGUuanM/M2JiMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX1NldENhY2hlLmpzPzBiMDgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hcnJheUVhY2guanM/ZmViOSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanM/Yjk2ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FycmF5UHVzaC5qcz8xZjg3Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYXNzaWduVmFsdWUuanM/YTdkZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzPzdiN2IiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSXNFcXVhbC5qcz8wYTlhIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUxvZGFzaC5qcz84ODVhIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY2FjaGVIYXMuanM/OGYwZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanM/Yjg0ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldERhdGEuanM/N2VjMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldFN5bWJvbHMuanM/OWMxMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzS2V5LmpzPzQ1ZWMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19tYXBUb0FycmF5LmpzPzRkZTMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19yZXBsYWNlSG9sZGVycy5qcz80YWUzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc2V0VG9TdHJpbmcuanM/OTEyMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZmxvd1JpZ2h0LmpzP2EzZTciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzPzA1MTciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2lzTGVuZ3RoLmpzPzY0NGQiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvaXNNb2JpbGVCcm93c2Vycy5qcz8xMDBmIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzPzQ2MjMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19mbGF0UmVzdC5qcz8xZjY0Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzPzJiY2UiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanM/ZjA0YSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaXNFcXVhbC5qcz9kYWY0Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzPzdiZDMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3Rocm90dGxlLmpzP2NjNTUiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvd2FpdEZvci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvZ2V0RWxlbWVudFZpc3VhbEJvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9jaHJvbWUvYnJvd3Nlci5qcz9kMGQ5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanM/YTRiNCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzPzVkN2YiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzPzc2MmUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanM/YWNhYiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcz9iNDA3Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzP2IwOWIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz80M2ZkIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzPzczYTciLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzP2MyMDUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcz84MDQ0Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzPzcxNDAiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcz82NDQ5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanM/ZjAxMyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcz85ZTIxIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcz80ZjhkIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcz8zMTIxIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzP2JhZjIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzPzc3YzIiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzPzliNmYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanM/YWNiZSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanM/MjM3MiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcz80NzMxIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcz9iZWQ3Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanM/MTg1MCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzPzI2OWEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzPzJkM2MiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanM/ZDViOSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcz8zN2Y1Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanM/MDg3NiIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanM/M2FhMSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzPzExZDAiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzg5ZTAiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcz83MTgwIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanM/YzY5MyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzPzRjOTkiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzP2RmZmUiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzPzQyYzciLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzP2M3NzEiLCJ3ZWJwYWNrOi8vLy4uL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzPzU0NjUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19VaW50OEFycmF5LmpzPzkxZDAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19XZWFrTWFwLmpzP2Q1Y2UiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hcnJheUZpbHRlci5qcz9lZDg0Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanM/N2M1OSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanM/NzE3ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzPzdhNGYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hcnJheVNvbWUuanM/NTlhNCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanM/ZDgxMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VGb3JPd24uanM/MDRlMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzP2RmMzAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlS2V5cy5qcz9jNTcxIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVBpY2tCeS5qcz84MjJmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVNldC5qcz9mNDdkIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVNldERhdGEuanM/OTA4YyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VUaW1lcy5qcz82Zjc5Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY29tcG9zZUFyZ3MuanM/NjdiOCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NvbXBvc2VBcmdzUmlnaHQuanM/MjhmNyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzPzNlODEiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVIeWJyaWQuanM/NTlmYiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NyZWF0ZVJlY3VycnkuanM/MmU5NSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzP2MzN2IiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19lcXVhbEFycmF5cy5qcz82MTY2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcz9lOGVhIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZ2V0QWxsS2V5cy5qcz9jMGNlIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZ2V0RnVuY05hbWUuanM/NzY1MSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldEhvbGRlci5qcz8yYzQ4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzPzBkN2MiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19pc0xhemlhYmxlLmpzPzMwZTkiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanM/OWI5YSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzP2Y2NzIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19tZXRhTWFwLmpzPzQ0Y2IiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19vdmVyQXJnLmpzPzBmNDciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19vdmVyUmVzdC5qcz9hZDA2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc2V0RGF0YS5qcz82Njc2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc2V0V3JhcFRvU3RyaW5nLmpzP2M0MzUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19zaG9ydE91dC5qcz83YWUyIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanM/YmY5NyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZGVib3VuY2UuanM/MDI3YiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZmxhdHRlbi5qcz84MWRjIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9mb3JFYWNoLmpzPzAzMmYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2hhc0luLmpzP2MwNTAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL21lbW9pemUuanM/ZjIxZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvc3R1YkFycmF5LmpzPzk4ZDUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3RvTnVtYmVyLmpzP2IwYzMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3RvU3RyaW5nLmpzPzY4MDIiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vRmx1eC5qcz80Y2JjIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2F1dGhGZXRjaC5qcz81MjA5Iiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2Nvb3JkaW5hdGVzLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9wbGF5ZXIuanM/NTBhMyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvZWxlbWVudExvY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29tbW9uL3NoYXJlZE1lbW9yeS9PYmplY3RTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX1NldC5qcz8wYWM2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUNsb25lLmpzP2U0MjgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlRm9yLmpzPzY4ZWMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSW5kZXhPZi5qcz9mYjZlIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZU1hcC5qcz9lNTZiIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzPzkzMzciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jYXN0RnVuY3Rpb24uanM/ODMwZSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzP2M2MWMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanM/Y2IxMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NyZWF0ZUZsb3cuanM/MzBlNyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc1BhdGguanM/N2Y5ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc1VuaWNvZGUuanM/YjExYSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcz85OTk0Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9hc3NpZ25Jbi5qcz9lNzg5Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9jbG9uZURlZXAuanM/YjE1NyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2lzRW1wdHkuanM/YWJlYiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvbWFwLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9tYXBWYWx1ZXMuanM/ZmNmYiIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9wcmFjdGljZVBsYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL2VzNi9zeW1ib2wuanM/ZGFjZCIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi9Qb3J0LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL2Vudi5qcz83MjQ1Iiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3NldHRpbmdzLmNvbmZpZy5qcz82NDI3Iiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnkuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvZG9jdW1lbnRTaXplLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2V4cGFuZE1hcmtlci5qcz9lNTcxIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2Z1enp5TWF0Y2hVcmwuanM/MzUzYSIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9nZXRCb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvZ2V0UGFyZW50UG9wdXAuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvaXNTdGVwTG9nZ2VkSW4uanM/NzVmNiIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9yZXBsYWNlQWxsLmpzP2U2M2EiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvdHV0b3JpYWxNYXRjaFVybC5qcz8yMzRiIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL3dhaXRGb3JJbml0LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9nZXRXaW5kb3dTY3JvbGxPZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanM/YjQ3YiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzPzE2YTkiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzP2E1ODciLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanM/YzUxNiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcz9mYzIxIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzdjYzkiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzPzJmOGUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzPzllYmQiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanM/YjQ2MyIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanM/YjdkOCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcz84NTg5Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanM/MWQzZSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanM/MDBmOCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanM/Y2I2MSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/NDM5ZiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzPzE2MmUiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz9jOTljIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcz84NjliIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanM/YjQ2OSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcz9iMGE4Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzPzNhYjciLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanM/ZTFhYSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcz8zNGZlIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcz9iYjZmIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzP2UzMjEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanM/MDk4NiIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzPzZlYTEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzPzE4YzEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUuanM/NmNmNSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanM/YTA3YSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanM/ODU2NSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanM/MDE1NCIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanM/NTM4YSIsIndlYnBhY2s6Ly8vLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzP2EzODYiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcz8wOGIyIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcz85Nzg1Iiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzPzA3MDgiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcz9kZTRjIiwid2VicGFjazovLy8uLi9+L2JhYmVsLXJ1bnRpbWUvfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzPzNiOGEiLCJ3ZWJwYWNrOi8vLy4uL34vYmFiZWwtcnVudGltZS9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9kN2EzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcz83YjVlIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanM/YzI4YyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanM/ODgwYSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcz8zZjYzIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcz8wOWQ3Iiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzPzNiYzgiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanM/YmY4ZSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanM/NDM5YSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanM/ZWVhYSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzP2UzMGUiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qcz81MjFmIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcz82NGNhIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcz80OWVhIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcz82OTAwIiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanM/MDU1YiIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcz9kMGQ5Iiwid2VicGFjazovLy8uLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanM/MzgwNCIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzP2EzZjkiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/MTY5NyIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanM/NDMyOSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanM/ZTQxMSIsIndlYnBhY2s6Ly8vLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcz84ODI3Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fRGF0YVZpZXcuanM/NjBlZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX0hhc2guanM/NjEwOSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX1Byb21pc2UuanM/YTY1ZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzP2ZiM2QiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hZGRTZXRFbnRyeS5qcz8wYzIxIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYXNjaWlUb0FycmF5LmpzPzc1NGIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlQXNzaWduLmpzPzQ4OWUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlQXNzaWduSW4uanM/MDMwMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VEaWZmZXJlbmNlLmpzPzRiODYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSGFzSW4uanM/MjFjMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcz9lNzhmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzP2QwNzIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSXNNYXRjaC5qcz8yMzY3Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUlzTmFOLmpzPzE2OGIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlSXNOYXRpdmUuanM/ZDdlNiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanM/ODZmZSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VLZXlzSW4uanM/YjZlMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzPzVkZTUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzPzg0MWUiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlT3JkZXJCeS5qcz82ZDIwIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVBpY2suanM/YWNmNSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanM/MjVkMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcz8zYTE4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVNsaWNlLmpzP2JiZmQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlU29tZS5qcz9iZDBlIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVNvcnRCeS5qcz8xYzQwIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzP2JkMzYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanM/MWE3ZCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanM/ZTJkYSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nsb25lTWFwLmpzP2I3ZjMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jbG9uZVJlZ0V4cC5qcz9kZWJmIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY2xvbmVTZXQuanM/ZTQzMiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzPzhlMTAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzPzhjYWIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanM/YWQ4YiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzPzM1YTgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzP2ExMzYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jb3JlSnNEYXRhLmpzPzkzNGQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jb3VudEhvbGRlcnMuanM/ZjdhNyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzP2EzMTIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzPzQ4ODYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVCaW5kLmpzPzExMTgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVDdXJyeS5qcz80MTFhIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY3JlYXRlRmluZC5qcz84NmY4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY3JlYXRlUGFydGlhbC5qcz9kMzE0Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY3JlYXRlV3JhcC5qcz8zMDBjIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZXF1YWxCeVRhZy5qcz9mZWYzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzPzNhZTgiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19nZXRNYXRjaERhdGEuanM/MWFhMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcz85NjliIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanM/Mjk0YiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2dldFdyYXBEZXRhaWxzLmpzPzhjM2EiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19oYXNoQ2xlYXIuanM/OWY5NCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc2hEZWxldGUuanM/ZDQzNiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc2hHZXQuanM/ZjU2OSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc2hIYXMuanM/OWNiYyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2hhc2hTZXQuanM/MDEwNyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzPzYwZGQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcz8yYzk2Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9faW5zZXJ0V3JhcERldGFpbHMuanM/OWY0OCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanM/MjBjMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcz9jYjg1Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9faXNNYXNrZWQuanM/ZTgwNyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzPzJjYmQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanM/NmViMCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcz80ZWI4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzPzU3ZmIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanM/ZDQ3NiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanM/NjdjOSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzPzhmOTAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcz9jZmU3Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanM/MTBiMSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzP2Y5N2IiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzPzRjM2YiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19tZXJnZURhdGEuanM/ZjlmNCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanM/OTIxMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcz80MzIyIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fbm9kZVV0aWwuanM/YTZlZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzP2FmZTIiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19yZWFsTmFtZXMuanM/NzlmNSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3Jlb3JkZXIuanM/ZTNiYiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3NldENhY2hlQWRkLmpzP2U5ODEiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19zZXRDYWNoZUhhcy5qcz8xZmExIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qcz9kYWU1Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanM/NDAwYSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3N0YWNrR2V0LmpzPzNmYjQiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19zdGFja0hhcy5qcz9jNDUxIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fc3RhY2tTZXQuanM/ZTA5NCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanM/ZmUwYiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3N0cmluZ1RvQXJyYXkuanM/MTY0NyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcz9iYTU1Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fdW5pY29kZVRvQXJyYXkuanM/Nzk2ZiIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3VwZGF0ZVdyYXBEZXRhaWxzLmpzP2JhMzMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL193cmFwcGVyQ2xvbmUuanM/NWUzMCIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvY29uc3RhbnQuanM/ODUxZSIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2VhY2guanM/ZDcxMyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZXh0ZW5kLmpzP2ZiNDEiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZmluZEluZGV4LmpzPzY2NjAiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2hhcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9sYXN0LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9ub3cuanM/MTA2NyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvcGlja0J5LmpzPzg4YzciLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3Byb3BlcnR5LmpzPzY3NDYiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3NldC5qcz9mZWQzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9zb21lLmpzP2UzN2MiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3N0dWJGYWxzZS5qcz9lMTBiIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC90b0Zpbml0ZS5qcz8wNDc4Iiwid2VicGFjazovLy8uLi9+L2xvZGFzaC93cmFwcGVyTG9kYXNoLmpzPzIwY2UiLCJ3ZWJwYWNrOi8vLy4uL34vc2Nyb2xsLWludG8tdmlldy9zY3JvbGxJbnRvVmlldy5qcz83MWIxIiwid2VicGFjazovLy8uL2Jhc2UvYmFja2dyb3VuZC9GbHV4LmpzIiwid2VicGFjazovLy8uL2Jhc2UvYmFja2dyb3VuZC9QYW5lbENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vU3RhdGVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9zcGlubmVyLXdoaXRlLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS93aWRnZXQtaWNvbi5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9hY3RpdmVOYXYuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvYXBwZW5kT25Cb2R5TGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvaW50ZXJjb20uanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvaXNQYWdlTG9nZ2VkSW4uanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvcmFuZG9tU3RyaW5nLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL3Njcm9sbEVsZW1lbnRJbnRvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy90aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L1BhbmVsQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvcGxheWVyL0xvY2F0b3JTZWFyY2hlci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvcGxheWVyL2RyYXdNYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3BsYXllci9lbGVtZW50T25Ub3AuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3BsYXllci9oYW5kbGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9jb21tb24vRW1iZWRTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2NvbW1vbi9TdHViQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5LmpzIiwid2VicGFjazovLy8uL2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvVGFic1N0b3JlLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvc2hhcmVkRW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jc3MuZXNjYXBlL2Nzcy5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19hcnJheVNhbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2FmdGVyLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9jb21wYWN0LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9vbWl0LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC90aW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9pbmplY3RfZWRpdG9yRnJhbWVOb2RlLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2luamVjdF9wbGF5ZXJGcmFtZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvaW5qZWN0X3RvcEZyYW1lLmpzIiwid2VicGFjazovLy8uL2Jhc2UvYmFja2dyb3VuZC9BdWRpb0NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9iYWNrZ3JvdW5kL0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2JhY2tncm91bmQvUG9ydE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9iYWNrZ3JvdW5kL1Nob3J0Y3V0c0NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9iYWNrZ3JvdW5kL1RhYnNDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2Jhc2UvYmFja2dyb3VuZC9Vc2VyRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2JhY2tncm91bmQvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi9BdWRpb1BsYXllci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9kcmFnLW4tZHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvaG92ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vc3ZnSW5saW5lL2xlZnQtY2xpY2suanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vc3ZnSW5saW5lL3JlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vc3ZnSW5saW5lL3JpZ2h0LWNsaWNrLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vc3ZnSW5saW5lL3Rvb2xzLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS90eXBlLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS96ZW5kZXNrLXdpZGdldC1jbG9zZS1pY29uLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3N2Z0lubGluZS96ZW5kZXNrLXdpZGdldC1pY29uLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL1Njcm9sbFdpbmRvd0ludG9WaWV3LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2FkZE5ld1N0eWxlLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL2ZldGNoRW1iZWRUdXRvcmlhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvZ2V0UXVlcnlMaXZlSWQuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb21tb24vdXRpbHMvaGlkZUNvbnNvbGVNZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9pc1Nwcml0ZUhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbW1vbi91dGlscy9yZ2JUb0FycmF5LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29tbW9uL3V0aWxzL3JnYmFUb0FycmF5LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9CcmlkZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L0VkaXRvckZyYW1lTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvRXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9GbHV4LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9LZXlib2FyZFNob3J0Y3V0cy5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvUGFuZWxQb3J0LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9Qb3J0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvYWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvZWxlbWVudEluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3BsYXllci9Db250ZW50UGxheWVyRnJhbWVOb2RlLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvQ29udGVudFBsYXllclRvcEZyYW1lLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvYWRqdXN0UGFuZWxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL0RSQUcuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3BsYXllci9oYW5kbGVycy9EUk9QLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvSE9WRVIuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3BsYXllci9oYW5kbGVycy9MRUZUX0NMSUNLLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvUkVBRC5qcyIsIndlYnBhY2s6Ly8vLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL1JJR0hUX0NMSUNLLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvU0NST0xMLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvVFlQSU5HLmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC93YWl0Rm9yQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2Jhc2UvY29udGVudC96b29tL3pvb21GcmFtZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vYmFzZS9jb250ZW50L3pvb20vem9vbVRvcEZyYW1lLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2JhY2tncm91bmQvQnJvd3NlckFjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZEJyaWRnZS5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9iYWNrZ3JvdW5kL0VtYmVkRG9jdW1lbnRzUG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9iYWNrZ3JvdW5kL0VtYmVkRXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2JhY2tncm91bmQvRW1iZWRGbHV4LmpzIiwid2VicGFjazovLy8uL2VtYmVkL2JhY2tncm91bmQvRW1iZWRQYW5lbENvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZFBvcnRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2JhY2tncm91bmQvRW1iZWRTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2VtYmVkL2JhY2tncm91bmQvRW1iZWRUYWJzQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9iYWNrZ3JvdW5kL2NhcHR1cmUvRW1iZWRCcm93c2VyQ2FwdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9iYWNrZ3JvdW5kL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnkuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29udGVudC9FbWJlZEJhY2tncm91bmRQb3J0LmpzIiwid2VicGFjazovLy8uL2VtYmVkL2NvbnRlbnQvRW1iZWRFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29udGVudC9FbWJlZFBhbmVsQ29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9lbWJlZC9jb250ZW50L0VtYmVkUG9ydE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29udGVudC9FbWJlZFN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29udGVudC9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5LmpzIiwid2VicGFjazovLy8uLi9+L2RyYWdnYWJsZS9kaXN0L2RyYWdnYWJsZS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vZW1iZWQvY29udGVudC9zdHlsZXMvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2FycmF5RXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlRXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlRXh0cmVtdW0uanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlRmlsdGVyLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUd0LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VJbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fYmFzZVJhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VTYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19iYXNlVG9QYWlycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Jhc2VVbnNldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2Nhc3RBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL19jcmVhdGVUb1BhaXJzLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2N1c3RvbU9taXRDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX2l0ZXJhdG9yVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3BhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvX3NldFRvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL2Fzc2lnbkluV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvZGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvaXNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL21heC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gvbWVyZ2VXaXRoLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC9zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3RvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoL3VuaW9uLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC91bmlxLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC91bmlxV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wYXJzZS1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wYXJzZS1jb2xvci9+L2NvbG9yLWNvbnZlcnQvY29udmVyc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGFyc2UtY29sb3Ivfi9jb2xvci1jb252ZXJ0L2luZGV4LmpzIl0sIm5hbWVzIjpbImlzRWRnZSIsImNvbnNvbGUiLCJsb2ciLCJiaW5kIiwiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwiTE9HX0xFVkVMUyIsIkVSUk9SIiwiV0FSTiIsIklORk8iLCJERUJVRyIsIlRSQUNFIiwic3RhcnRzV2l0aCIsImhheXN0YWNrIiwibmVlZGxlIiwic2xpY2UiLCJsZW5ndGgiLCJMb2dnZXIiLCJpZCIsIl9pZCIsIl9sZXZlbCIsImxldmVsIiwibG9nTGV2ZWwiLCJtc2ciLCJhcmdzIiwiaXNFbmFibGVkIiwiZ2V0TG9nZ2VyIiwiZ2V0RmlsZUxvZ2dlciIsImZpbGVuYW1lIiwicmVwbGFjZSIsImdldERlZmF1bHRMb2dnZXIiLCJwcmVmaXgiLCJuYW1lc3BhY2UiLCJtYXAiLCJzdHIiLCJqb2luIiwiZW52IiwiZW52cyIsInNldHRpbmdzQ29uZmlnIiwidmFsdWVzIiwiZ2V0IiwibmFtZSIsInZhcmlhYmxlcyIsInNlbGYiLCJwYXRoRnJhZ21lbnRzIiwic3BsaXQiLCJzdGFydCIsImVudlBhcmVudCIsImVudlBhcmVudEluZGV4IiwiaSIsImZyYWdtZW50IiwidW5kZWZpbmVkIiwiY2xvbmVEZWVwIiwicmVtb3ZlRW52cyIsInRhcmdldCIsImVhY2giLCJ2YWx1ZSIsImtleSIsImlzQXJyYXkiLCJleHRlbmQiLCJwb3NzaWJsZUVudiIsInJlcGxhY2VWYXJzIiwicHJvcCIsImhhc093blByb3BlcnR5IiwidmFyaWFibGUiLCJyZXBsYWNlQWxsIiwibG9nZ2VyIiwiX19maWxlbmFtZSIsIlBBUkVOVCIsIkNISUxEUkVOIiwiQUxMIiwiVE9QIiwiRFVQRV9DSEVDS19LRVkiLCJ3aW5kb3ciLCJFcnJvciIsImZyYW1lSWQiLCJTdHJpbmciLCJEYXRlIiwiTWF0aCIsInJhbmRvbSIsIm1lc3NhZ2VMaXN0ZW5lcnMiLCJpc0JhY2tncm91bmQiLCJicm93c2VyIiwidGFicyIsImNvbnRlbnRQYWdlTGlzdGVuZXIiLCJzZW5kIiwiZGVzdGluYXRpb24iLCJ0b3BpYyIsInBheWxvYWQiLCJmcmFtZXMiLCJwYXJlbnQiLCJBcnJheSIsImZyb20iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpZnJhbWUiLCJjb250ZW50V2luZG93IiwidG9wIiwibWVzc2FnZSIsImlzRnJhbWVNZXNzYWdlIiwiZm9yRWFjaCIsImZyYW1lIiwicG9zdE1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJjYWxsYmFjayIsInVuc3Vic2NyaWJlIiwiZmlsdGVyIiwiZiIsImRlbGl2ZXIiLCJsaXN0ZW5lcnMiLCJsIiwiZXZlbnQiLCJkYXRhIiwibWVzc2FnZUhhbmRsZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJicm9hZGNhc3REb3duIiwiY2hpbGRGcmFtZVdpbmRvd3MiLCJhY2NlcHQiLCJhZGRXaW5kb3dMaXN0ZW5lciIsImV2ZW50cyIsInJlYXR0YWNoTGlzdGVuZXJzIiwiU2V0Iiwic2V0dXBXaW5kb3dFdmVudCIsImV2ZW50TmFtZSIsImF0dGFjaG1lbnRzIiwidG90YWxBdHRhY2htZW50c0NvdW50IiwiaGFuZGxlZCIsInR5cGUiLCJ3aW5kb3dFdmVudHNUZXN0TWVzc2FnZSIsImhhbmRsZXIiLCJyZWF0dGFjaCIsImluZGV4IiwiYXR0YWNobWVudE51bWJlciIsImlzTmV3QXR0YWNobWVudCIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdXNoIiwic2V0dXAiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiYWRkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZ2V0RXZlbnQiLCJhZGRSZWF0dGFjaE1lc3NhZ2VMaXN0ZW5lciIsInJlbW92ZVdpbmRvd0xpc3RlbmVyIiwiY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIiwic3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJDb21wb25lbnQiLCJleHRlbnNpb24iLCJmbHV4Iiwib3duQ29udGV4dCIsIm93bkNvbnRleHROYW1lIiwib24iLCJmbk5hbWUiLCJhcHBseSIsImlzTW9iaWxlQnJvd3NlcnMiLCJjaGVjayIsImEiLCJ0ZXN0Iiwic3Vic3RyIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidmVuZG9yIiwib3BlcmEiLCJ3YWl0Rm9yIiwidGltZSIsInJlc3VsdCIsInNldFRpbWVvdXQiLCJwYXJzZU51bWJlciIsIm4iLCJwYXJzZUludCIsImlzTmFOIiwiZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyIsImVsIiwicGFnZUJvdW5kcyIsImNsaWVudFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwibGVmdCIsInRhZ05hbWUiLCJzdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJub0JvcmRlciIsImV2ZXJ5IiwiZCIsIm1hdGNoIiwibm9CYWNrZ3JvdW5kIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZENvbG9yIiwicGFkZGluZ1RvcCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImdldEF0dHJpYnV0ZSIsIm9wYWNpdHkiLCJidXR0b25FbCIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yIiwiZmlyc3RDb250YWluZXJGb3VuZCIsImNsb3Nlc3QiLCJjdXJyZW50RWwiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJjb21wdXRlZFN0eWxlcyIsImluY2x1ZGVzIiwicG9zaXRpb24iLCJwYXJlbnRCb3VuZHMiLCJvdmVyZmxvd1giLCJtaW4iLCJnZXRXaW5kb3dTY3JvbGxPZmZzZXQiLCJCUk9XU0VSIiwiY2hyb21lIiwiRmx1eCIsIm9sZFN0YXRlIiwic3RhdGUiLCJydWxlcyIsInJ1bGVPYmoiLCJydWxlIiwicGF0aCIsImNvbXBhcmUiLCJvbGRWYWx1ZSIsImNvbnRleHQiLCJhY3Rpb25OYW1lIiwiYWN0aW9uQXJncyIsImNhbGxSZW1vdGVBY3Rpb24iLCJjYWxsTG9jYWxBY3Rpb24iLCJzZW5kVG9Db250ZXh0IiwiYWN0aW9uIiwiX2FjdGlvbnMiLCJhdXRoRmV0Y2giLCJ1cmwiLCJvcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsImFwaUZldGNoIiwiaXNUb3AiLCJjb250ZW50U2NyZWVuT2Zmc2V0WCIsInNjcmVlblgiLCJvdXRlcldpZHRoIiwiaW5uZXJXaWR0aCIsImNvbnRlbnRTY3JlZW5PZmZzZXRZIiwic2NyZWVuWSIsIm91dGVySGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJpc1RydXN0ZWQiLCJpZnJhbWVzIiwic2NyZWVuQm91bmRzIiwicGFnZTJzY3JlZW4iLCJmcmFtZU1lc3NhZ2VzIiwidXBkYXRlT2Zmc2V0cyIsImNoYW5nZWQiLCJ0cnVzdGVkIiwiaGFuZGxlRXZlbnQiLCJtb3VzZUV2ZW50IiwiYm9keSIsInJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImdldFpvb20iLCJjbGllbnRYIiwiY2xpZW50WSIsIndhaXRGb3JJbml0IiwibWFwQm91bmRzUG9zaXRpb24iLCJib3VuZHNQb3NpdGlvbiIsImhvcml6b250YWxGbiIsInZlcnRpY2FsRm4iLCJob3Jpem9udGFsIiwibWFwVmFsdWVzIiwicGljayIsImgiLCJ2ZXJ0aWNhbCIsInYiLCJvZmZzZXQiLCJyb3VuZCIsInNjcmVlbjJwYWdlIiwic2NyZWVuMnRhYiIsInBhZ2Vib3VuZHMyc2NyZWVuIiwiYm91bmRzIiwic2NyZWVuYm91bmRzMnBhZ2UiLCJzY3JlZW5ib3VuZHMydGFiIiwiYXBwbHlab29tMmJvdW5kcyIsInpvb20iLCJ3aXRoRGVmYXVsdFByZXZlbnRlZCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInBhcmVudEVsZW1lbnQiLCJub3JtYWxpemVkVXJsV2l0aG91dE9yaWdpbiIsInBhcnNlZFVybCIsIm5vcm1hbGl6ZWRQYXRobmFtZSIsInBhdGhuYW1lIiwibm9ybWFsaXplZFNlYXJjaCIsInNlYXJjaCIsIm5vcm1hbGl6ZWRIYXNoIiwiaGFzaCIsImdldFJlZGlyZWN0Iiwic3RlcFVybFN0cmluZyIsImN1cnJlbnRVcmxTdHJpbmciLCJmb3JjZSIsInN0ZXBVcmwiLCJVUkwiLCJjdXJyZW50VXJsIiwiaHJlZiIsIndoaXRlbGlzdGVkIiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImV4ZWMiLCJpc1plbmRlc2tTdWJkb21haW4iLCJaZW5kZXNrIiwic3RlcFVybFBhcnRzIiwiY3VycmVudFVybFBhcnRzIiwic2FtZUluaXRpYWxVcmwiLCJzYW1lRmluYWxVcmwiLCJyZWRpcmVjdElmTmVlZGVkIiwicmVkaXJlY3RVcmwiLCJsb2NhdGlvbiIsIndpbGxCcm93c2VyUmVsb2FkIiwib2xkVXJsU3RyaW5nIiwibmV3VXJsU3RyaW5nIiwib2xkVXJsUGFyc2VyIiwiY3JlYXRlRWxlbWVudCIsIm5ld1VybFBhcnNlciIsIm9yaWdpbiIsIm5hcnJvd1BhcnQiLCJxdWVyeUZpbmQiLCJxdWVyeSIsInRyaW0iLCJlbHMiLCJzdGFjayIsImZpbHRlckJ5VGV4dCIsInRleHQiLCJzaW1wbGlmeVRleHQiLCJhVGV4dCIsImdldFRleHQiLCJjbGFzc0xpc3QiLCJ0ZXh0Q29udGVudCIsImhhc0F0dHJpYnV0ZSIsImZpbHRlckJ5RGV0ZWN0ZWROYW1lIiwic2ltcGxpZnlOYW1lIiwiYU5hbWUiLCJnZXROYW1lIiwiZGV0ZWN0TmFtZSIsImFyZUVsZW1lbnRzU2libGluZ3MiLCJmaXJzdFBhcmVudCIsImdldEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwicmVkdWNlIiwiYXR0cnMiLCJub2RlIiwibm9kZU5hbWUiLCJub2RlVmFsdWUiLCJnZXROZXN0ZWRpbmZvIiwiY29udGV4dFByb3AiLCJpbmZvUHJvcE5hbWUiLCJuZXN0aW5nTGV2ZWwiLCJjb250ZXh0Tm9kZSIsImVsZW1lbnRJbmZvIiwiZ2V0UGFyZW50cyIsImxpbWl0IiwiZ2V0UHJldlNpYmxpbmdzIiwiZ2V0TmV4dFNpYmxpbmdzIiwiZ2V0Q29udGV4dEluZm8iLCJwcmV2U2libGluZyIsIm5leHRTaWJsaW5nIiwid2l0aENvbnRleHQiLCJkZXRlY3RlZE5hbWUiLCJpbmRleE9mIiwicGxhY2Vob2xkZXIiLCJzcmMiLCJjaGlsZEluZGV4IiwiY2hpbGRyZW4iLCJwcm90b3R5cGUiLCJjYWxsIiwiY29udGV4dEluZm8iLCJhcmlhTGFiZWwiLCJjbGFzc2VzIiwidG9BcnJheSIsImdldExvY2F0b3IiLCJsb2NhdG9yIiwiTUFYX0xFVkVMIiwidW5zaGlmdCIsIklNUE9SVEFOVF9JTkZPX1BST1BTIiwiaW1wb3J0YW50QXR0cmlidXRlcyIsIm1ha2VRdWVyeSIsIkNTU0VzY2FwZSIsImNscyIsImhyZWZTdWZmaXgiLCJvbWl0IiwiT2JqZWN0Iiwia2V5cyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVWYWx1ZSIsInF1ZXJ5TG9jYXRvciIsInF1ZXJpZXMiLCJjdXJyZW50UXVlcnkiLCJxdWVyeVNlcGFyYXRvciIsImRpcmVjdENoaWxkIiwibGFzdCIsImNvdW50TG9jYXRvciIsImNhbGN1bGF0ZUluZm9TY29yZSIsImltcG9ydGFudFByb3BzU2NvcmUiLCJ0ZXh0U2NvcmUiLCJhQ2xhc3NTY29yZSIsImFuQXR0cmlidXRlU2NvcmUiLCJjdXJyZW50U2NvcmUiLCJpbmZvUHJvcCIsInByb3BTY29yZSIsImF0dHJpYnV0ZU5hbWVzIiwiY2FsY3VsYXRlTG9jYXRvclNjb3JlIiwiYXJlRWxlbWVudHNTaW1pbGFyIiwiZWxlbWVudHMiLCJtaW5FcXVhbENsYXNzZXMiLCJ0aHJlc2hvbGQiLCJhcmVMaXN0VGFibGVFbGVtZW50cyIsInNlZW5DbGFzc2VzIiwic2hhcmVkQ2xhc3NlcyIsInRvdGFsQ2xhc3NlcyIsImNsIiwiaiIsImMiLCJ2YWwiLCJoYXZlTm9DbGFzc2VzIiwiZmluZFNpbWlsYXJCb3R0b21EZXNjZW5kYW50cyIsImRlc2NlbmRhbnRzIiwib3B0aW9ucyIsIm9yaWdpbmFsRGVzY2VuZGFudHNMZW5ndGgiLCJzaW1pbGFyVG9wRGVzY2VuZGFudHMiLCJjaGlsZCIsInNpbWlsYXJUb3BEZXNjZW5kYW50Iiwic2ltaWxhckJvdHRvbURlc2NlbmRhbnRzIiwic2tpcHBlZE9uZSIsIm1vcmVTaW1pbGFyQm90dG9tRGVzY2VuZGFudHMiLCJmaW5kU2ltaWxhckVsZW1lbnRzIiwic2libGluZ3MiLCJNSU5fU0lCTElOR1MiLCJ1bmlxIiwiTUlOX0xFTkdUSCIsInJlZHVjZUJ5VGFnTmFtZSIsInJlZHVjZUJ5U2hhcmVkQ2xhc3NlcyIsInNlbHMiLCJzZWwiLCJoYXNDbGFzc2VzUmVxdWlyZWQiLCJpbnRlcnNlY3Rpb24iLCJtaW5MZW5ndGgiLCJyZWR1Y2VkTGlzdCIsImxlbmd0aFJlcXVpcmVkIiwib3JpZ2luYWxJbmZvIiwib25seUltcG9ydGFudCIsImluY2x1ZGVUZXh0IiwiaW5jbHVkZURpcmVjdENoaWxkIiwiYUNsYXNzIiwicmVwbGFjZUluZGV4IiwiYXJyYXkiLCJtYXhpbWl6ZU5hcnJvd2luZ0luZGV4IiwiZnVsbExvY2F0b3IiLCJpc0VtcHR5IiwibmFycm93ZWRQYXJ0IiwibmFycm93ZWRMb2NhdG9yIiwibmFycm93ZWRDb3VudCIsIm1heGltaXplTmFycm93aW5nIiwibWluaW1hbExvY2F0b3IiLCJsb29zZSIsInNlZ21lbnQiLCJpc0ludmFsaWRMb2NhdG9yIiwibm9uVHJpdmlhbExvY2F0b3IiLCJtYXRjaExvY2F0b3IiLCJhbGxvd011bHRpcGxlIiwibWluTG9jYXRvciIsIm1pbkNvdW50IiwibG9jYXRlRWxlbWVudCIsInNjb3JlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hdGNoaW5nTG9jYXRvciIsIm11bHRpcGxlTWF0Y2hlcyIsIm9yaWdpbmFsRWxzIiwiY29uY2F0IiwidW5pcVdpdGgiLCJlbEEiLCJlbEIiLCJjb250YWlucyIsImVtaXR0ZXIiLCJPYmplY3RTdG9yZSIsInBlcm1pc3Npb24iLCJfbGlzdGVuRm9yQ2hhbmdlcyIsImNoYW5nZUluZm8iLCJwYXJzZSIsIm5ld1ZhbHVlIiwiY2hhbmdlVGltZSIsIm5vdyIsImVtaXQiLCJyZXN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibWFpbk9iamVjdCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJkZWZhdWx0cyIsImlzRXF1YWwiLCJzZXRJdGVtIiwic2hhcmVkRW1pdHRlciIsIml0ZW1zIiwic2V0QnlGdW5jdGlvbiIsImFzc2lnbiIsImNhbGN1bGF0ZWRWYWx1ZSIsInNldCIsInJlbW92ZUl0ZW0iLCJzZW5kVG9FeHRlbnNpb24iLCJ0byIsImxpc3RlblRvUHJhY3RpY2VNZXNzYWdlIiwiaXNUb3BGcmFtZSIsIlBvcnQiLCJfcG9ydCIsIl9iaW5kSGFuZGxlcnMiLCJyZXNwb25zZUhhbmRsZXIiLCJfd2FpdEV4dGVuc2lvblJlYWR5UHJvbWlzZSIsImlzUmVhZHkiLCJvbmNlIiwicmVzcG9uZCIsIl93YWl0RXh0ZW5zaW9uUmVhZHkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGV2ZWxvcG1lbnQiLCJ0ZXN0SW9yYWRDb20iLCJwcm9kdWN0aW9uIiwibm9kZUFwaSIsIm5vZGVBcHBQcmVmaXgiLCJyZWxhdGl2ZVBhdGgiLCJwcm9wTmFtZSIsInZhZ3JhbnQiLCJyZWxhdGl2ZVBhZ2UiLCJpc0Rpc2FibGVkIiwibWFpbiIsIm5hdkJhciIsImFjdGlvbkJ1dHRvbiIsImhpZ2hsaWdodCIsImJ1aWxkIiwiYmFzZVBhdGgiLCJwYWdlcyIsImNyZWF0ZU5ld0Jyb3dzZXJUdXRvcmlhbFVybCIsImNyZWF0ZU5ld0Rlc2t0b3BUdXRvcmlhbFVybCIsInR1dG9yaWFsUGxheWVyIiwiaGVscCIsInRlcm1zIiwicHJpY2luZyIsImV4dGVuc2lvbkluc3RhbGxlZCIsInNlcnZlciIsInNlYXJjaFR1dG9yaWFscyIsInR1dG9yaWFsTGl2ZUxpc3QiLCJnZXRUdXRvcmlhbCIsImdldE5vdGlmaWNhdGlvbnMiLCJ0dXRvcmlhbFNhdmVTdGF0aXN0aWNzIiwic2lnbnVwIiwiZ29vZ2xlQXV0aCIsImxvZ2luIiwic2FtbExvZ2luVVJMIiwicmVzZXRQYXNzd29yZCIsInJlc2VuZEFjdGl2YXRpb24iLCJsb2dvdXQiLCJsb2FkQXV0aCIsIm1lIiwiaW1hZ2VSZW1vdGVQYXRoIiwiYXVkaW9SZW1vdGVQYXRoIiwiYXZhdGFyIiwiU2hhcmVkTWVtb3J5IiwiZ2V0RG9jdW1lbnRIZWlnaHQiLCJEIiwibWF4Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0RG9jdW1lbnRXaWR0aCIsInNjcm9sbFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImFtb3VudCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWFya2VyQm91bmRzIiwiZnV6enlNYXRjaFVybCIsInVybGEiLCJ1cmxiIiwibm9ybWFsaXplIiwicGFyc2VkIiwiZ2V0UGFyZW50UG9wdXAiLCJwYXJlbnRFbCIsInN0eWxlcyIsImlzRHJvcGRvd24iLCJpc1N0ZXBMb2dnZWRJbiIsInN0ZXAiLCJsb2dnZWRJbiIsImdldFN0ZXBMb2dnZWRJblR5cGUiLCJsb2dnZWRJblR5cGUiLCJyZXBsYWNlbWVudCIsInR1dG9yaWFsTWF0Y2hVcmwiLCJ0dXRvcmlhbERhdGEiLCJzdGVwcyIsInBhZ2VCYXNlRG9tYWluIiwic3RlcEJhc2VEb21haW5zIiwicyIsImhlYWQiLCJzdW1DU1NQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsImNvbXB1dGVkU3R5bGUiLCJjb3VudCIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJib2R5Q29tcHV0ZWRTdHlsZSIsIm9sZEJhY2tncm91bmRTdGF0ZSIsImJhY2tncm91bmRTdGF0ZSIsInBhbmVsU3RhdGVzIiwib2xkUGFuZWxTdGF0ZXMiLCJjb250ZW50U3RhdGVzIiwib2xkQ29udGVudFN0YXRlcyIsImRvY3VtZW50c1BvcnQiLCJwb3J0TWFuYWdlciIsImxvY2FsU3RhdGVNYW5hZ2VyIiwiZ2V0SW5pdGlhbFN0YXRlIiwiYWN0aW9uRmFjdG9yeSIsInNldFN0YXRlIiwiZ2V0U3RhdGUiLCJleGNsdWRlZFRhYnMiLCJoYW5kbGVCYWNrZ3JvdW5kU3RhdGUiLCJoYW5kbGVDb250ZW50U3RhdGUiLCJ0YWIiLCJoYW5kbGVQYW5lbFN0YXRlIiwiZGlzcGF0Y2giLCJzZW5kVG9PbmUiLCJ0YWJzQ29udHJvbGxlciIsInRhYklkIiwiY29udGVudCIsIm9sZENvbnRlbnRTdGF0ZSIsImNvbnRlbnRTdGF0ZSIsInBhbmVsIiwib2xkUGFuZWxTdGF0ZSIsInBhbmVsU3RhdGUiLCJQYW5lbENvbnRyb2xsZXIiLCJzZXR1cERvY3VtZW50cyIsInNldHVwQnJvd3NlckFjdGlvbiIsInNldHVwVGFicyIsInNldHVwQXV0aCIsInVwZGF0ZVRhYnNDb3VudCIsImhhbmRsZURvY3VtZW50c01lc3NhZ2UiLCJicm93c2VyQWN0aW9uIiwiYnJvd3NlckFjdGlvbk1hbmFnZXIiLCJfb25Ccm93c2VyQWN0aW9uTWVzc2FnZSIsIm1vbml0b3JQYW5lbFN1cHBvcnRlZCIsImF1dGgiLCJ1c2VyIiwic2hvd1BhbmVsIiwiZXhwbGljaXQiLCJoaWRlUGFuZWwiLCJyZWxvYWRBbGxUYWJzIiwidmlld0xpdmUiLCJnZXRBY3RpdmVUYWJJZCIsInRhYkluZm8iLCJnZXRUYWJJbmZvIiwiZW5hYmxlZCIsImFjdGl2ZVRhYklkIiwid2lsbE9wZW4iLCJzaG91bGRQYW5lbE9wZW5Pbk5ld1RhYiIsInNldFBhbmVsT3BlbiIsImlzUGFuZWxPcGVuIiwiYnJvd3NlckNhcHR1cmUiLCJjYXB0dXJpbmciLCJhY3RpdmVUYWJUaW1lIiwiYWN0aXZlVGFiU3RhcnRUaW1lIiwiaW5jbHVkZUludmFsaWRUYWJzIiwiZXh0ZW5kUGFuZWxTdGF0ZSIsInVwZGF0ZSIsInJlbG9hZCIsImxpdmVVUkwiLCJkb21haW4iLCJjb29raWVzIiwiZ2V0QWxsIiwidmFsaWRDb29raWVzIiwicmVzdWx0cyIsImNvb2tpZSIsInN1YkRvbWFpbkNvb2tpZSIsImV4cGlyYXRpb25EYXRlIiwic29ydCIsImIiLCJwYXJzZWRMaXZlVVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY2hlY2tUYWIiLCJnZXRUYWIiLCJpc1BhbmVsU3VwcG9ydGVkT25UYWIiLCJnZXRBbGxUYWJzIiwiY3VycmVudFRhYnMiLCJjdXJyZW50VGFiIiwiY2FwdHVyZVN0YXRlIiwiaXNPcGVuIiwiQm9vbGVhbiIsImN1cnJlbnRUdXRvcmlhbCIsInN0YXJ0ZWQiLCJnZXRUYWJzQ291bnQiLCJ0YWJzQ291bnQiLCJTdGF0ZU1hbmFnZXIiLCJpbml0aWFsU3RhdGUiLCJuZXdTdGF0ZSIsIkFDVElWRV9MSU5LX1BST1BfTkFNRVMiLCJmaW5kQWN0aXZlQW5jaG9yIiwiYW5jaG9yRWxzIiwiZ3JvdXBzIiwiZWxTdHlsZXMiLCJlbFByb3AiLCJhY3RpdmVFbCIsImZpbmQiLCJlbFByb3BzIiwib3RoZXJQcm9wIiwiZmluZE5hdkVscyIsImZpbmROYXZBY3RpdmVBbmNob3IiLCJuYXZFbHMiLCJuYXZFbCIsImZpbmRQYXJlbnROYXZFbCIsImFwcGVuZE9uQm9keUxhdGVyIiwiYXBwZW5kQ2hpbGQiLCJnZXRJbnRlcmNvbU1lc3NlbmdlciIsIm1lc3NlbmdlcklmcmFtZSIsIm1lc3NlbmdlckRvY3VtZW50IiwiY29udGVudERvY3VtZW50IiwiZ2V0SW50ZXJjb21MYXVuY2hlciIsImxhdW5jaGVySWZyYW1lIiwibGF1bmNoZXJEb2N1bWVudCIsImdldEludGVyY29tUGVuZGluZ01lc3NhZ2VzIiwibGF1bmNoZXJCYWRnZUlmcmFtZSIsImxhdW5jaGVyQmFkZ2VEb2N1bWVudCIsImJhZGdlRWwiLCJpbm5lclRleHQiLCJpc1BhZ2VMb2dnZWRJbiIsInplbmRlc2tMb2dnZWRJbiIsImlzUGFnZUxvZ2dlZE91dCIsImNsYXNzTmFtZSIsImdldENsaWVudFJlY3RzIiwiZ2V0UGFnZUxvZ2dlZEluVHlwZSIsImlzWmVuZGVzayIsInJhbmRvbVN0cmluZyIsImNoYXJzIiwidGltZXMiLCJzYW1wbGUiLCJnZXRFbGVtZW50U2Nyb2xsIiwiZWxlbWVudCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJib3R0b20iLCJyaWdodCIsImdldFJlbGF0aXZlTWFyZ2lucyIsInRhcmdldFBvc2l0aW9uIiwicGFyZW50UG9zaXRpb24iLCJzY3JvbGxBdmFpbGFibGUiLCJ0YXJnZXRJblZpZXdwb3J0IiwibWluTWFyZ2luIiwibWFyZ2luIiwic2Nyb2xsYWJsZUF4aXNlcyIsInNpZGUiLCJuZWFyZXN0QWxpZ24iLCJjdXJyeSIsImF1dG9BbGlnbiIsImFuaW1hdGlvblRpbWUiLCJhbGlnbiIsInBhcmFtcyIsInZhbGlkVGFyZ2V0IiwiaXNTY3JvbGxhYmxlIiwiZGVmYXVsdElzU2Nyb2xsYWJsZSIsInNjcm9sbGVkUGFyZW50cyIsInNjcm9sbEludG9WaWV3Iiwic2FmZVNldEludGVydmFsIiwiZnVuYyIsIndhaXQiLCJpbnRlcnYiLCJ3IiwidCIsInRvU3RyaW5nIiwiWkVOREVTS19XSURHRVRfQ09OVEFJTkVSIiwiaXNQb3B1cCIsIm9wZW5lciIsIm1lbnViYXIiLCJ2aXNpYmxlIiwiZG9tYWluTWF0Y2hVcmwiLCJwYW5lbEVsIiwicGFuZWxIZWlnaHQiLCJwYW5lbEVsU3RhcnRlZCIsInBhbmVsRGlzYWJsZWQiLCJwYW5lbERyYWdnZWQiLCJocmVmSGFzVHV0b3JpYWxzIiwiY3VzdG9tQ29sb3JzIiwiaW50ZXJjb21JbnN0YWxsZWQiLCJvdmVybGF5RGlzbWlzc2VkIiwiY2FjaGVIZWlnaHQiLCJ0aHJvdHRsZSIsInVwZGF0ZVBhbmVsTWF4SGVpZ2h0IiwiZHJhZ2dhYmxlSW5zdGFuY2UiLCJwYW5lbERyYWdIYW5kbGVyIiwiZW1iZWQiLCJyZXRyaWV2ZUhlaWdodCIsInNldHVwQmFja2dyb3VuZCIsInNldHVwUGFuZWwiLCJzZXR1cFByYWN0aWNlUGxheWVyIiwic2V0dXBQYWdlIiwibW9uaXRvckludGVyY29tIiwibW9uaXRvclplbmRlc2siLCJyZWdpc3RlclRvQmFja2dyb3VuZCIsImxpc3Rlbk92ZXJsYXkiLCJjaGVja0xlZ2FjeVBhZ2VTdGF0dXMiLCJjaGVja1BvcHVwUGFnZVN0YXR1cyIsInNldENsb3NlRWxlbWVudENvb3JkaW5hdGVzIiwiYmFja2dyb3VuZFBvcnQiLCJoYW5kbGVCYWNrZ3JvdW5kTWVzc2FnZSIsInBhbmVsUG9ydCIsImhhbmRsZVBhbmVsTWVzc2FnZSIsImN1cnJlbnRIcmVmIiwic2V0SW50ZXJ2YWwiLCJjdXJyZW50UGFnZUxvZ2dlZEluVHlwZSIsInBhZ2VMb2dnZWRJblR5cGUiLCJoYW5kbGVQcmFjdGljZU1lc3NhZ2UiLCJoYW5kbGVQYWdlTWVzc2FnZSIsIkJBQ0tHUk9VTkRfVE9QSUNTIiwiaXNHb29nbGVUcmFuc2xhdGUiLCJpbnRlcmNvbUxhdW5jaGVyRWwiLCJpc0NvbWJpbmVJbnRlcmNvbSIsIkludGVyY29tIiwidG9nZ2xlQ2hhdEJ1dHRvbldpZGdldExhYmVsIiwiaGlkZUNoYXRCdXR0b25XaWRnZXQiLCJhZGROZXdTdHlsZSIsImZpbmRaZW5kZXNrQWN0aW9uQnV0dG9uQ29sb3IiLCJuYXZiYXJFbCIsImFuY2hvckJhY2tncm91bmRDb2xvcnMiLCJhbmNob3JFbCIsInplbmRlc2tBY3Rpb25CdXR0b25Db2xvciIsImNvbG9yIiwiaGFuZGxlQ29sb3JzIiwiemVuZGVza01haW5Db2xvciIsImhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UiLCJpc0Z1bGxzY3JlZW4iLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsIndpZGdldEVsIiwibm90aWZ5T3ZlcmxheURpc21pc3NlZCIsImdldE9yTWFrZVdpZGdldCIsImNsb3NlRWwiLCJ0b2dnbGVXaWRnZXQiLCJxdWVyeUxpdmVJZCIsImdldFF1ZXJ5TGl2ZUlkIiwiYXV0b09wZW5MaXZlSWQiLCJnZXRPck1ha2VQYW5lbCIsInRvZ2dsZVBhbmVsIiwibG9hZENvb3JkaW5hdGVzIiwic2V0RHJhZ2dhYmxlIiwiZGlzYWJsZVBhbmVsIiwibW9kZSIsIm92ZXJsYXlDb250cm9sbGVyIiwidG9nZ2xlQmxhbmtWaXNpYmlsaXR5IiwiYmFja2dyb3VuZENvbnRleHQiLCJ0dXRvcmlhbFN0YXJ0ZWQiLCJwYW5lbENvbnRleHQiLCJiYWNrZ3JvdW5kU3RhdGVSZWNlaXZlZCIsImxlYXJuIiwiY291bnRkb3duIiwiZG9jdW1lbnRDYXB0dXJlIiwiaXNBY3RpdmUiLCJjYXB0dXJlUGF1c2VkIiwidG9nZ2xlT3ZlcmxheUZhZGUiLCJzaG91bGRTdXBwcmVzc092ZXJsYXkiLCJjaGVja092ZXJsYXkiLCJkaXNhYmxlUGFuZWxUaW1lciIsImRpc2FibGUiLCJ0aW1lciIsImNsZWFyVGltZW91dCIsImRpc2FibGVQYW5lbExhdGVyIiwiZW5hYmxlIiwiaGlkZGVuIiwic3RhdHVzIiwic3RvcmFnZSIsImlzQWN0aXZlVGFiIiwic2hvdyIsImZvdW5kIiwicmVnaXN0ZXJQYW5lbCIsInNldHVwR29vZ2xlVHJhbnNsYXRlIiwiYmFja2dyb3VuZFJlZGlyZWN0VG9waWNzIiwiaXNDYXB0dXJlU3RhcnRDb25maXJtYXRpb25OZWVkZWQiLCJjb25maXJtTmVlZGVkIiwiY29uZmlybUNhcHR1cmVTdGFydCIsInN1Y2Nlc3MiLCJ0b2dnbGVQcmFjdGljZVR1dG9yaWFsIiwicGxheWVyVVJMIiwic2hvd0Nsb3NlV2lkZ2V0IiwidG9nZ2xlRHJhZ0hhbmRsZXIiLCJzZXRVc2VyRGF0YSIsInRvZ2dsZUludGVyY29tIiwiY29udGFpbmVySGVpZ2h0IiwidXBkYXRlQ29udGFpbmVyIiwiY3VycmVudFN0ZXAiLCJsb2FkVVJMIiwiaXNSZWRpcmVjdGluZyIsInJlZGlyZWN0SWZOZWVkZWRCeU5hdiIsImxvY2F0aW9uSHJlZiIsIm5hdkFjdGl2ZUFuY2hvckluZm8iLCJkb21haW5NYXRjaGVzIiwic3RlcE5hdkFjdGl2ZUFuY2hvciIsIm5hdkFjdGl2ZUFuY2hvciIsIm5vdGlmeUJhY2tncm91bmQiLCJoYW5kbGVycyIsInRvZ2dsZSIsImNsb3NlUGFuZWwiLCJoaWRlQ2xvc2VXaWRnZXQiLCJzdGFydFBhbmVsIiwib3BlblBhbmVsIiwicmVzZXRDb29yZGluYXRlcyIsIl93YWl0SWZyYW1lTG9hZCIsInBhbmVsU3JjIiwidXB3YXJkU3RhdGUiLCJiYWNrZ3JvdW5kIiwiY29udGVudENvbnRleHQiLCJnZXRQYW5lbE9wdGlvbnMiLCJpbXBsaWNpdERvbWFpbnMiLCJnZXRJbXBsaWNpdERvbWFpbnMiLCJlc2NhcGUiLCJob3N0IiwiY29sb3JzIiwid2FpdEZvckxvYWQiLCJjcmVhdGVQYW5lbCIsInNlbmRFbWJlZFR1dG9yaWFscyIsImlzRW1iZWQiLCJjbG9zZSIsImNyZWF0ZVplbmRlc2tDbG9zZVBhbmVsIiwiY3JlYXRlQ2xvc2VQYW5lbCIsImFmdGVyUGFuZWxBcHBlbmQiLCJlbWJlZFR1dG9yaWFscyIsInBvc3QiLCJhZnRlciIsImZldGNoRW1iZWRUdXRvcmlhbHMiLCJlbWJlZE9wdGlvbnMiLCJ1c2VySWQiLCJfZW1iZWRUdXRvcmlhbHMiLCJwcmVmZXRjaGVkUGFuZWwiLCJwcmVmZXRjaGVkSWZyYW1lIiwiZGlzcGxheSIsImFsbG93VHJhbnNwYXJlbmN5IiwiZ2V0VVJMIiwicGFuZWxDb29yZGluYXRlcyIsImdldFBhbmVsQ29vcmRpbmF0ZXMiLCJnZXRDbG9zZUVsZW1lbnRDb29yZGluYXRlcyIsIk51bWJlciIsInRvcE9mZnNldCIsImxlZnRPZmZzZXQiLCJjbG9zZUVsVG9wIiwiY2xvc2VFbExlZnQiLCJpc1BhbmVsSGlkZGVuIiwiZHJhZ0hhbmRsZXIiLCJoaWRlQ2xhc3MiLCJyZXMiLCJEcmFnZ2FibGUiLCJyZXF1aXJlIiwiY3JlYXRlRHJhZ0hhbmRsZXIiLCJwcmVwZW5kIiwiY2xvc2VFbFRyYW5zaXRpb25TdHlsZSIsImRlc3Ryb3kiLCJ1c2VHUFUiLCJoYW5kbGUiLCJzZXRQb3NpdGlvbiIsIm9uRHJhZ1N0YXJ0IiwidHJhbnNpdGlvbiIsIm9uRHJhZyIsIm9uRHJhZ0VuZCIsInN0b3JlQ29vcmRpbmF0ZXMiLCJpbm5lckhUTUwiLCJzcGlubmVyV2hpdGUiLCJvbkNsb3NlV2lkZ2V0Q2xpY2siLCJ6ZW5kZXNDbG9zZUljb24iLCJpc0RldkVtYmVkIiwiaGlkZVdpZGdldCIsInNob3dXaWRnZXQiLCJzaG91bGRTaG93QnV0dG9uIiwiRU1CRUQiLCJ3aWRnZXQiLCJjcmVhdGVaZW5kZXNrV2lkZ2V0IiwiY3JlYXRlV2lkZ2V0IiwiaWNvbkVsIiwid2lkZ2V0SWNvbiIsIm9uV2lkZ2V0Q2xpY2siLCJ6ZW5kZXNrV2lkZ2V0SWNvbiIsImxvYWRpbmdTdGVwUGFnZSIsImNhcHR1cmluZ0FjdGl2ZSIsImZpbGwiLCJmaW5hbEhlaWdodCIsInBhbmVsSW5uZXJIZWlnaHQiLCJwYW5lbEJvdW5kcyIsInBhbmVsUmVhbEhlaWdodCIsInBhbmVsUmVhbEJvdW5kcyIsImFzc2lnbkluIiwibXV0YXRlIiwic2F2ZURvbnRTaG93IiwiZG9udFNob3ciLCJkaWFsb2ciLCJjbG9zZURpYWxvZyIsInJlbW92ZUNoaWxkIiwicmVuZGVyIiwicmVhY3RSZW5kZXIiLCJvblN0YXJ0IiwiZmxvd1JpZ2h0Iiwib25DbG9zZSIsImNhcHR1cmUiLCJicm93c2VyU3RhdGUiLCJ1cGRhdGVyIiwiaXNDdXJyZW50UGFnZVBvcHVwIiwiZW5hYmxlUGFuZWwiLCJ1cGRhdGVXaWRnZXQiLCJ0dXRvcmlhbHNDb3VudCIsInRvZ2dsZUludGVyY29tRXhpc3RlbmNlIiwiZ2V0VXNlckRhdGEiLCJvcGVuIiwidXNlckRhdGEiLCJzaG93Q2hhdEJ1dHRvbldpZGdldCIsImNsaWNrIiwiX3dhaXRJZnJhbWVMb2FkUHJvbWlzZSIsInJlamVjdCIsImhhbmRsZUxvYWQiLCJsaXN0ZW5lciIsImlmcmFtZVNyYyIsIm9ubG9hZCIsImlvcmFkUGFuZWxJZnJhbWVMb2FkZWQiLCJtYXhCeSIsImFyeSIsIm1hcHBlciIsInNvbWUiLCJ3aXRob3V0IiwiaXRlbSIsInVuaXF1ZUlkIiwiY291bnRlciIsImRlZXBFcXVhbCIsImtleXNBIiwia2V5c0IiLCJlbGVtZW50SW5WaWV3cG9ydCIsInJlY3QiLCJmbG9vciIsImVsZW1lbnRPblRvcCIsIlJQQ1RpbWVvdXQiLCJtIiwicnBjdGltZW91dCIsIkZyYW1lUlBDIiwidGltZW91dCIsIl9wZW5kaW5nIiwiX21ldGhvZHMiLCJfbmFtZXNwYWNlIiwiX3JlY2VpdmVDYWxsIiwiX3JlY2VpdmVSZXNwb25zZSIsIl9yZWNlaXZlZEhlYXJ0YmVhdCIsIl90aW1lb3V0IiwibWV0aG9kIiwiYXJnIiwic2VudCIsImhlYXJ0YmVhdCIsImxlYWRpbmciLCJ0aW1lb3V0SWQiLCJfcmVzZXRUaW1lb3V0IiwidGltZW91dEZuIiwibmV3VGltZW91dElkIiwiTG9jYXRvclNlYXJjaGVyTm9kZSIsIl9ycGMiLCJyZWdpc3RlciIsIl9waW5nUmVjZWl2ZWQiLCJfaXNEb21Db250ZW50TG9hZGVkIiwibG9jYXRlZEVscyIsIl9zZXR1cEV2ZW50TGlzdGVuZXJzIiwiX2ZyYW1lUmVzcG9uZHMiLCJXZWFrTWFwIiwiX2RvbVZlcnNpb24iLCJoYXMiLCJyZXNwb25kcyIsIl9ub3RpZnlGcmFtZUNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdWJ0cmVlIiwiaXNHb29kRWxlbWVudCIsInNlbmRIZWFydGJlYXQiLCJhbGwiLCJpc0V4dGVuc2lvbkJhc2VVcmwiLCJmcmFtZU9wdGlvbnMiLCJkZXB0aCIsIl9kb2VzRnJhbWVSZXNwb25kIiwiZnJhbWVEb2N1bWVudCIsImNhbmRpZGF0ZXMiLCJiZXN0Q2FuZGlkYXRlIiwibG9jYXRvckRhdGEiLCJsb2NhdG9ySWQiLCJtYWtlQW5jZXN0b3JzVmlzaWJsZSIsImRvbVZlcnNpb24iLCJlbGVtZW50Qm91bmRzIiwiZWxlbWVudFZpc2libGUiLCJ2aXNpYmlsaXR5IiwiaGlkZGVuVmFsdWUiLCJ2aXNpYmxlVmFsdWUiLCJMb2NhdG9yU2VhcmNoZXJDb250cm9sbGVyIiwicGVuZGluZ1NlYXJjaGVzIiwicGVuZGluZyIsIm8iLCJwIiwibGFzdFBlbmRpbmciLCJsYXN0UGVuZGluZ1Byb21pc2UiLCJwcm9taXNlIiwicGVuZGluZ0l0ZW0iLCJMb2NhdG9yU2VhcmNoZXJJbnRlcmZhY2UiLCJfbm9kZSIsIl9jb250cm9sbGVyIiwiZW5hYmxlZE1hcmtlckluZGV4IiwiaXNNb2JpbGUiLCJuZXdUaW1lIiwiY3VycmVudEVscyIsIlNFTEVDVE9SX0lEIiwibmV3RWxzIiwibWFya2VyRWwiLCJleHBhbmRNYXJrZXIiLCJib3JkZXJXaWR0aCIsInJlcGxhY2VJbmZvIiwiaW5mb0tleSIsImdpdmVuSWQiLCJ1aWQiLCJzZXRBdHRyaWJ1dGUiLCJtYWtlTWFya2VySW5mbyIsInN0eWxlT2JqVG9JbXBvcnRhbnRTdHJpbmciLCJzZWxlY3RvclN0eWxlIiwiaW5zZXJ0QmVmb3JlIiwibWFya2VySW5mb0VsIiwiZmlyc3RDaGlsZCIsImRpcmVjdGlvbnMiLCJpbmZvUG9zaXRpb24iLCJtYXJrZXJJbmZvUG9zaXRpb24iLCJib3JkZXJDb2xvciIsImJvcmRlckNvbG9yU3RyIiwicGFyc2VDb2xvciIsInJnYiIsIkJHX09QQUNJVFkiLCJFTkFCTEVEX09QQUNJVFkiLCJESVNBQkxFRF9PUEFDSVRZIiwiZGVsYXkiLCJfZHJhd01hcmtlciIsIm1zIiwiYWRkQ29sb3JPcGFjaXR5IiwicmdiYUFycmF5IiwicmdiVG9BcnJheSIsInJnYmFUb0FycmF5IiwiaW5mb1N0eWxlIiwiaWNvblN0eWxlIiwidHlwZVRvVGV4dCIsImRibENsaWNrIiwiUkVBRCIsIkxFRlRfQ0xJQ0siLCJSSUdIVF9DTElDSyIsIlNDUk9MTCIsIlRZUElORyIsIkRSQUciLCJEUk9QIiwiSE9WRVIiLCJhcHBlbmRJbXBvcnRhbnQiLCJtYWtlU3R5bGVJbXBvcnRhbnQiLCJzdHlsZU9ialRvU3RyaW5nIiwidG9QYWlycyIsImsiLCJpbmZvRWwiLCJpY29uIiwic3ZnQmdTdHlsZSIsInN2Z1N0eWxlIiwiaWNvblN2ZyIsInRvb2xUeXBlVG9TdmciLCJhbmltYXRlTWFya2VySW5mbyIsInZlcnRpY2FsU3RhcnQiLCJ2ZXJ0aWNhbEFmdGVyU3RhcnQiLCJhZnRlclN0YXJ0IiwiY29udGFpbmVyV2lkdGgiLCJ0b2xlcmFuY2UiLCJyZXF1aXJlZFhTaXplIiwicmVxdWlyZWRZU2l6ZSIsIm1hcmtlckhDZW50ZXIiLCJtYXJrZXJWQ2VudGVyIiwibWFya2VyQm90dG9tIiwibWFya2VyUmlnaHQiLCJtaW5YU3BhY2UiLCJtaW5ZU3BhY2UiLCJpc0hvcml6b250YWxTdWl0YWJsZSIsImlzVmVydGljYWxTdWl0YWJsZSIsImlzVG9wU3VpdGFibGUiLCJpc0JvdHRvbVN1aXRhYmxlIiwiaXNMZWZ0U3VpdGFibGUiLCJpc1JpZ2h0U3VpdGFibGUiLCJwb3NpdGlvblRvQ2xhc3MiLCJjdXJyZW50UHJvbWlzZSIsImRyYXdNYXJrZXIiLCJoaWRlTWFya2VyIiwidmlzaWJsZU1hcmtlcnMiLCJnZXRQYW5lbEVsIiwiTUFSR0lOIiwiZWxlbWVudEF0Q2VudGVyIiwiZWxlbWVudEZyb21Qb2ludCIsImVsZW1lbnRBdENlbnRlckxlZnQiLCJlbGVtZW50QXRDZW50ZXJSaWdodCIsIkVtYmVkU3RvcmFnZSIsIlN0dWJDb21wb25lbnQiLCJ0YWJLZXlQcmVmaXgiLCJUQUJfVElNRU9VVCIsIlRBQl9DTEVBTl9USU1FT1VUIiwiZmlsdGVyVGFicyIsImNsZWFuSW52YWxpZFRhYnMiLCJ2YWxpZFRhYnMiLCJkYXRlTm93IiwiaW52YWxpZCIsInByaXZhdGUiLCJnZXRUYWJJZEZyb21LZXkiLCJnZXRUYWJzIiwic2tpcEludmFsaWRUYWJzIiwibGVuIiwiVGFic1N0b3JlIiwiX3RhYnMiLCJjaGFuZ2VkVGFiSWQiLCJjaGFuZ2VkVGFiIiwib2xkVGFicyIsIm5ld1RhYnMiLCJlZGl0b3JOb2RlIiwiY29udGVudFBsYXllck5vZGUiLCJjaGVja0JvZHkiLCJjb250ZW50RXh0ZW5zaW9uIiwibGluayIsInJlbCIsImluaXQiLCJpbnRlcnZhbHMiLCJhZGRJbnRlcnZhbCIsImNiIiwiY2xlYXJJbnRlcnZhbHMiLCJleHRlbmRDdXJyZW50VGFiIiwicHVibGljT2JqIiwicHJpdmF0ZU9iaiIsInNoYXJlZE1lbW9yeSIsInB1YmxpYyIsIm9uQWN0aXZlQ2hhbmdlIiwiYWN0aXZlIiwiY2hlY2tUYWJzIiwiYmFja2dyb3VuZFRhYiIsIm5ld0JhY2tncm91bmRUYWIiLCJzb3J0QnkiLCJzZXRCeVBhdGgiLCJiYWNrZ3JvdW5kRXh0ZW5zaW9uIiwiaW9yYWRXaWRnZXQiLCJzaG93T3JIaWRlIiwidXBkYXRlQ29sb3JzIiwicGFuZWxDb250cm9sbGVyIiwidXBkYXRlSW50ZXJjb20iLCJ1cGRhdGVHb29nbGVUcmFuc2xhdGUiLCJyZXNldENvbG9ycyIsIkF1ZGlvQ29udHJvbGxlciIsInNldHVwQXVkaW9QbGF5ZXIiLCJhdWRpbyIsImF1ZGlvSGFuZGxlcnMiLCJnZXRVcmwiLCJzZXRVcmwiLCJwbGF5Iiwic3RvcCIsInNldFZvbHVtZSIsIm11dGVkIiwiRXh0ZW5zaW9uIiwiZGVza3RvcFN0YXRlIiwiY2FwdHVyZXMiLCJjYXB0dXJlU2VydmljZUluc3RhbGxlZCIsImNhcHR1cmVkU3RlcHMiLCJpc1BhbmVsU3VwcG9ydGVkIiwiaXNDdXJyZW50UGFnZUxlZ2FjeSIsImlzRXh0ZW5zaW9uSnVzdEluc3RhbGxlZCIsImF1ZGlvUGxheWluZyIsImF1ZGlvTXV0ZWQiLCJpc1N0YXJ0Q2FwdHVyZU92ZXJsYXlWaXNpYmxlIiwidmVyc2lvbiIsImJhY2tncm91bmRJZCIsIlBvcnRNYW5hZ2VyQ2xhc3MiLCJnZXRQb3J0TWFuYWdlckNsYXNzIiwiRmx1eENsYXNzIiwiZ2V0Rmx1eENsYXNzIiwiU2hhcmVkTWVtb3J5Q2xhc3MiLCJnZXRTaGFyZWRNZW1vcnlDbGFzcyIsIlN0b3JhZ2VDbGFzcyIsImdldFN0b3JhZ2VDbGFzcyIsIlBhbmVsQ29udHJvbGxlckNsYXNzIiwiZ2V0UGFuZWxDb250cm9sbGVyQ2xhc3MiLCJCcm93c2VyQ2FwdHVyZUNsYXNzIiwiZ2V0QnJvd3NlckNhcHR1cmVDbGFzcyIsIkJyb3dzZXJBY3Rpb25NYW5hZ2VyQ2xhc3MiLCJnZXRCcm93c2VyQWN0aW9uTWFuYWdlckNsYXNzIiwiQXVkaW9Db250cm9sbGVyQ2xhc3MiLCJnZXRBdWRpb0NvbnRyb2xsZXJDbGFzcyIsImF1ZGlvQ29udHJvbGxlciIsIlNob3J0Y3V0c0NvbnRyb2xsZXJDbGFzcyIsImdldFNob3J0Y3V0c0NvbnRyb2xsZXJDbGFzcyIsInNob3J0Y3V0c0NvbnRyb2xsZXIiLCJVc2VyRGF0YUNsYXNzIiwiZ2V0VXNlckRhdGFDbGFzcyIsIlRhYnNDb250cm9sbGVyQ2xhc3MiLCJnZXRUYWJzQ29udHJvbGxlckNsYXNzIiwiQXV0aENsYXNzIiwiZ2V0QXV0aENsYXNzIiwiQ2hyb21lQnJpZGdlQ2xhc3MiLCJnZXRCcmlkZ2VDbGFzcyIsInNldHVwSW9yYWRFeHRlbnNpb25FeGlzdGVuY2UiLCJsaXN0ZW4iLCJjYXRjaCIsIlBvcnRNYW5hZ2VyIiwic2V0dXBEb2N1bWVudHNQb3J0IiwiRG9jdW1lbnRzUG9ydENsYXNzIiwiZ2V0RG9jdW1lbnRzUG9ydENsYXNzIiwiY29ubmVjdCIsIlNob3J0Y3V0c0NvbnRyb2xsZXIiLCJob3RLZXkiLCJzaG9ydGN1dHMiLCJrZXlEb25lIiwiZG9uZSIsImtleUNhcHR1cmUiLCJ0b2dnbGVDYXB0dXJlIiwidG9Mb3dlckNhc2UiLCJUYWJzQ29udHJvbGxlciIsInRhYkluZm9NYXAiLCJNYXAiLCJtb25pdG9yQWN0aXZlVGFiSWQiLCJsaXN0ZW5UYWJPblVwZGF0ZWQiLCJfIiwib25UYWJVcGRhdGVkIiwibGlzdGVuVGFiT25SZW1vdmVkIiwib25UYWJSZW1vdmVkIiwib25BY3RpdmVUYWJDaGFuZ2VkIiwibGlzdGVuVGFiT25BY3RpdmF0ZWQiLCJ1cGRhdGVkSW5mbyIsIlVzZXJEYXRhIiwicmVmcmVzaFVzZXJEYXRhIiwibWF0Y2hlZEhhbmRsZXJzIiwicGlja0J5Iiwidmlld2VkVHV0b3JpYWxzIiwicHJlZnMiLCJzaG93bk1lc3NhZ2VzIiwia2V5X2NhcHR1cmUiLCJrZXlfZG9uZSIsImFjdGlvbnNGYWN0b3J5IiwiY2xlYXJQYW5lbE9wZW4iLCJzZXRQYW5lbCIsImV4dGVuZENhcHR1cmVTdGF0ZSIsInRvZ2dsZUlzQ3VycmVudFBhZ2VMZWdhY3kiLCJ0b2dnbGVJc0N1cnJlbnRQYWdlUG9wdXAiLCJ0b2dnbGVJc0V4dGVuc2lvbkp1c3RJbnN0YWxsZWQiLCJ0b2dnbGVJc1BhbmVsU3VwcG9ydGVkIiwic2V0QXVkaW9QbGF5aW5nIiwic2V0QXVkaW9NdXRlZCIsInNldEFjdGl2ZVRhYklkIiwic2V0VGFic0NvdW50IiwidG9nZ2xlSXNTdGFydENhcHR1cmVPdmVybGF5VmlzaWJsZSIsIkF1ZGlvUGxheWVyIiwic291bmQiLCJBdWRpbyIsInBhdXNlZCIsImN1cnJlbnRUaW1lIiwicGF1c2UiLCJ2b2x1bWUiLCJTdG9yYWdlIiwibGVmdENsaWNrIiwicmlnaHRDbGljayIsInJlYWQiLCJzY3JvbGwiLCJkcmFnQW5kRHJvcCIsImhvdmVyIiwidG9vbFR5cGUiLCJzY3JvbGxXaW5kb3dJbnRvVmlldyIsImZpbmRIb3Jpem9udGFsU2Nyb2xsIiwicG9zIiwiZmluZFZlcnRpY2FsU2Nyb2xsIiwiZmluZFRhcmdldFNjcm9sbCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1hdGUiLCJzdGFydFRpbWUiLCJ0YXJnZXRTY3JvbGwiLCJ0aW1lVmFsdWUiLCJwb3ciLCJzY3JvbGxUbyIsIm5ld1N0eWxlIiwic3R5bGVFbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVUZXh0Tm9kZSIsInVybHMiLCJtb2JpbGVNb2RlIiwic2V0dGluZ3MiLCJzZWFyY2hLZXkiLCJyIiwianNvbiIsImxpdmVJZE1hdGNoIiwibGl2ZUlkQ29ycmVjdEJyb3dzZXIiLCJkZWZhdWx0Q29uc29sZU1ldGhvZHMiLCJoaWRlQ29uc29sZU1lc3NhZ2VzIiwiY29uc29sZU1ldGhvZHMiLCJoaWRlRXhjZXB0aW9ucyIsIm9uZXJyb3IiLCJNSU5fQkFDS0dST1VORF9NQVRDSEVTIiwiVEVTVF9GVU5DVElPTlMiLCJmaW5kQmFja2dyb3VuZCIsImJnIiwiaXNTcHJpdGVIb2xkZXIiLCJoYXNQb3NpdGlvbkFic29sdXRlIiwiZWxlbWVudERpbWVuc2lvbnMiLCJwYXJlbnREaW1lbnNpb25zIiwiaXNMYXJnZXIiLCJxdWVyeVN0cmluZyIsIm90aGVyRWxzIiwibWF0Y2hlcyIsImJnQ29tcGFyZSIsInJnYkNvbG9yIiwicmdiQXJyYXkiLCJwYXJzZUZsb2F0IiwicmdiYUNvbG9yIiwiQnJpZGdlIiwiZWRpdG9yQ29ubmVjdFBvcnQiLCJwb3J0cyIsImJhY2tncm91bmRDb25uZWN0UG9ydCIsInJ1bnRpbWUiLCJjb25uZWN0RGF0YSIsImluc3RhbmNlIiwiYmluZEVkaXRvckV2ZW50cyIsImJpbmRCYWNrZ3JvdW5kRXZlbnRzIiwib25tZXNzYWdlIiwiZGlzY29ubmVjdCIsIm9uRGlzY29ubmVjdCIsImFkZExpc3RlbmVyIiwiRWRpdG9yRnJhbWVOb2RlIiwiQnJpZGdlQ2xhc3MiLCJsb2NhdGlvbkhyZWZDaGFuZ2VkQXQiLCJnb29nbGVUcmFuc2xhdGVJbnN0YWxsZWQiLCJLZXlib2FyZFNob3J0Y3V0c0NsYXNzIiwiZ2V0S2V5Ym9hcmRTaG9ydGN1dHNDbGFzcyIsImtleWJvYXJkU2hvcnRjdXRzIiwiT3ZlcmxheUNvbnRyb2xsZXJDbGFzcyIsImdldE92ZXJsYXlDb250cm9sbGVyQ2xhc3MiLCJDb250ZW50UGxheWVyQ2xhc3MiLCJnZXRDb250ZW50UGxheWVyQ2xhc3MiLCJjb250ZW50UGxheWVyIiwiRG9jdW1lbnRDYXB0dXJlQ2xhc3MiLCJnZXREb2N1bWVudENhcHR1cmVDbGFzcyIsInNldHVwTG9nZ2luZyIsInN0YXJ0Wm9vbSIsInBvcnRzQnlDb250ZXh0IiwiZXhjbHVkZWQiLCJtZXJnZVdpdGgiLCJvbGQiLCJ1cGRhdGVkIiwiZml4QmFja2dyb3VuZFN0YXRlIiwiS2V5Ym9hcmRTaG9ydGN1dHMiLCJzcGVjaWFsIiwic2hpZnRLZXkiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsIndoaWNoIiwia2V5Q29kZSIsImNoYXJDb2RlIiwiZnJvbUNoYXJDb2RlIiwiUGFuZWxQb3J0IiwiX2JvdW5kIiwiX29uTWVzc2FnZVJlY2VpdmVkIiwiX2Rpc2FibGVkIiwicGFuZWxJZnJhbWUiLCJzZXR1cEJhY2tncm91bmRQb3J0Iiwic2V0dXBQYW5lbFBvcnQiLCJCYWNrZ3JvdW5kUG9ydENsYXNzIiwiZ2V0QmFja2dyb3VuZFBvcnRDbGFzcyIsIlBhbmVsUG9ydENsYXNzIiwiZ2V0UGFuZWxQb3J0Q2xhc3MiLCJzZXRMb2NhdGlvbkhyZWYiLCJjaGFuZ2VkQXQiLCJzZXRQYWdlTG9nZ2VkSW5UeXBlIiwidG9nZ2xlSW50ZXJjb21JbnN0YWxsZWQiLCJ0b2dnbGVHb29nbGVUcmFuc2xhdGVJbnN0YWxsZWQiLCJCQVNJQ19UWVBFX1JVTEVTIiwiSU5QVVRfVFlQRV9NQVBQSU5HIiwiYnV0dG9uIiwiY2hlY2tib3giLCJyYWRpbyIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJST0xFX01BUFBJTkciLCJhbGVydGRpYWxvZyIsIm9wdGlvbiIsImNvbWJvYm94IiwicHJlc2VudGF0aW9uIiwiU1RZTEVfUFJPUEVSVElFUyIsIkhJR0hfUFJJT1JJVFkiLCJOQU1FX1RFWFRDT05URU5UX01BWF9MRU5HVEgiLCJnZXRUYWdOYW1lIiwiZGV0ZWN0VHlwZUZyb21CYXNpY1J1bGVzIiwiZWxUYWdOYW1lIiwiY3VycmVudFR5cGUiLCJkZXRlY3RUeXBlIiwicm9sZSIsInNlbGVjdGVkT3B0aW9ucyIsImxhYmVsIiwibGFiZWxFbCIsImxhYmVsRWxOYW1lIiwiaXNQcml2YXRlSW5wdXQiLCJkZXRlY3RTdHlsZSIsImRldGVjdE9wdGlvbnMiLCJkZXRlY3RWYWx1ZSIsImRldGVjdEluZm8iLCJmaW5kQWN0aXZlRWxlbWVudCIsImlzVmFsaWQiLCJmaXJzdEVsZW1lbnQiLCJmaXJzdEVsZW1lbnRCb3VuZHMiLCJtYWtlQ2FuZGlkYXRlIiwiaXNGaXJzdCIsImhpZ2hQcmlvcml0eSIsInR5cGVJbmZvIiwibmFtZUluZm8iLCJjb250YWluc1NvRmFyIiwiY3VycmVudEJvdW5kcyIsImNhbmRpZGF0ZSIsImJlc3RHdWVzcyIsImFsdGVybmF0aXZlcyIsImdldEVsZW1lbnRJbmZvIiwiYWRkU2NyZWVuQm91bmRzIiwiaXNJblBvcHVwIiwiQ29udGVudFBsYXllckZyYW1lTm9kZSIsImN1cnJlbnRseUhvb2tlZCIsImhvb2tFbGVtZW50cyIsImxvY2F0b3JTZWFyY2hlciIsImdldEVscyIsIm5ld0hvb2tlZCIsInN0ZXBJbmRleCIsImFscmVhZHlIb29rZWQiLCJjbGVhckRPTUxpc3RlbmVycyIsImNsZWFyVGltZXJzIiwiX2NvbXBsZXRlZCIsIm9uQ29tcGxldGVkIiwic2tpcFVybENoZWNrIiwiYW5jaG9yIiwib3RoZXJFbCIsImNvbXBsZXRlZEF0Iiwib25Ob3RDb21wbGV0ZWQiLCJtYXJrZXJCb3JkZXIiLCJzY3JvbGxFbGVtZW50SW50b1ZpZXciLCJzZXR1cFBhcmVudFBvcHVwTGlzdGVuZXJzIiwiaGFuZGxlclR5cGUiLCJlbEluZGV4IiwicGFyZW50UG9wdXAiLCJlbEluUG9wdXAiLCJjdXJyZW50UGFyZW50UG9wdXAiLCJ0aW1lck5hbWUiLCJtZXNzYWdlU2VudCIsImNsZWFyVGltZXIiLCJhZGRUaW1lciIsInRhcmdldFBvcHVwIiwiaW50ZXJhY3Rpb25PdXRzaWRlUG9wdXAiLCJsaXN0ZW5Ub0RPTSIsInVzZUNhcHR1cmUiLCJkb21MaXN0ZW5lcnMiLCJkb21MaXN0ZW5lciIsImRvbUxpc3RlbmVySW5kZXgiLCJzdG9wRE9NTGlzdGVuaW5nIiwidGltZXJzIiwiZXNjYXBlUmVnRXhwIiwicGF0dGVybiIsInJlZ2V4IiwiUmVnRXhwIiwic2VyaWFsaXphYmxlQm91bmRzIiwiZ2V0Qm91bmRzIiwiZGVmYXVsdENvbG9ycyIsImlzSW9yYWRFZGl0b3JVcmwiLCJDb250ZW50UGxheWVyVG9wRnJhbWUiLCJjdXJyZW50TG9jYXRvckRhdGEiLCJiZWZvcmV1bmxvYWQiLCJlbnRlclN0ZXAiLCJfbm90aWZ5Tm90Rm91bmQiLCJ0cmFpbGluZyIsIl9hZGp1c3RQYW5lbFBvc2l0aW9uIiwiZGVib3VuY2UiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwiY2hlY2tMb2dpbiIsImNyZWF0ZUxvY2F0b3JUZXN0IiwiX25vdENvbXBsZXRlZCIsIl9nb0JhY2siLCJfc2Nyb2xsV2luZG93SW50b1ZpZXciLCJuZWVkc0xvZ2luIiwidG9nZ2xlTmVlZHNMb2dpbiIsIm5lZWRzQWRtaW5BY2Nlc3MiLCJwcmV2aW91c1N0ZXAiLCJudW1iZXIiLCJjYW5jZWwiLCJ3YWl0aW5nTmV4dFN0ZXAiLCJzd2l0Y2hUdXRvcmlhbFN0YXJ0ZWQiLCJfaGlkZU1hcmtlcnMiLCJ0b2dnbGVOZWVkc0FkbWluQWNjZXNzIiwid2FpdGluZ0xvY2F0aW9uSHJlZkNoYW5nZSIsImRlbGF5RW50ZXJTdGVwVGltZXIiLCJmb3JjZUhhbmRsZSIsImVuYWJsZU1hcmtlckluZGV4IiwibWFya2VyQ29sb3JzIiwibWFya2VyQ29sb3IiLCJsMSIsImwyIiwiZGJsY2xpY2siLCJjb21wb25lbnQiLCJsaXZlX211bHRpcGxlTWF0Y2hlcyIsImZpbmRMYXRlclN0ZXBJZk5lZWRlZCIsIl9ub3RpZnlGb3VuZFN0YXRlIiwiZHJhd01hcmtlcnMiLCJtYXRjaEZuIiwibG9va2FoZWFkIiwib3RoZXJTdGVwcyIsImlnbm9yZUxhdGVyU3RlcCIsIl9maW5kaW5nTGF0ZXJTdGVwIiwicG9zc2libGVNYXRjaGVzIiwibmV4dCIsInNoaWZ0IiwiX2ZvdW5kTGF0ZXJTdGVwIiwiZXJyIiwiZmluZExhdGVyU3RlcCIsInN0ZXBMb2dnZWRPdXQiLCJwYXJlbnRTdGVwIiwiZmluZEFuZEhpZ2hsaWdodCIsImlzQ29tcG9zaXRlU3RlcCIsInN1bW1hcnkiLCJpc1R5cGluZ0FuZENsaWNrIiwiaGFuZGxlVHlwaW5nQW5kQ2xpY2siLCJ0eXBpbmdTdGVwIiwiY2xpY2tTdGVwIiwib25UeXBpbmdDb21wbGV0ZWQiLCJhZHZhbmNlIiwiaGFuZGxlQ2xpY2siLCJvblR5cGluZ05vdENvbXBsZXRlZCIsIm9uQ2xpY2tDb21wbGV0ZWQiLCJvbkNsaWNrTm90Q29tcGxldGVkIiwiaGFuZGxlVHlwaW5nIiwibmV4dE90aGVyU3RlcCIsImRlbGF5RW50ZXJTdGVwIiwiaXNaZW5kZXNrUGFnZSIsInByZXZpb3VzSW5mbyIsImFkanVzdFBhbmVsUG9zaXRpb24iLCJwYW5lbE9ubHkiLCJwYW5lbENTU1Bvc2l0aW9uIiwiY2FsY3VsYXRlUGFuZWxDU1NQb3NpdGlvbiIsIm92ZXJsYXBzIiwicGFuZWxGdWxsQm91bmRzIiwicGFuZWxUb3BJbm5lck1hcmdpbiIsImRlZmF1bHRCb3R0b20iLCJkZWZhdWx0UmlnaHQiLCJ3aWRnZXRCb3R0b21EaWZmIiwid2lkZ2V0UmlnaHREaWZmIiwiZGVmYXVsdFdpZGdldCIsImRlZmF1bHRSZXR1cm4iLCJnZXRNZXJnZWRNYXJrZXJCb3VuZHMiLCJ2aXNpYmxlSGVpZ2h0IiwidmlzaWJsZVdpZHRoIiwid2lkZ2V0Qm91bmRzIiwicGFuZWxBY3RpdmVCb3R0b20iLCJwYW5lbEFjdGl2ZVJpZ2h0IiwicGFuZWxWaXNpYmxlSGVpZ2h0IiwicGFuZWxWaXNpYmxlV2lkdGgiLCJwYW5lbENTU0JvdHRvbSIsInBhbmVsQ1NTUmlnaHQiLCJwYW5lbFNjcmVlblRvcCIsInBhbmVsU2NyZWVuTGVmdCIsIm92ZXJsYXBIZWlnaHQiLCJvdmVybGFwV2lkdGgiLCJvdmVybGFwRmFjdG9yIiwiZ2FwIiwiZW5vdWdoVmVydGljYWxTcGFjZSIsIndpZGdldFJldHVybiIsIm1hcmtlcnNCb3VuZHMiLCJnZXRNYXJrZXJFbHMiLCJnZXRNYXJrZXJCb3VuZHMiLCJtZXJnZWRNYXJrZXJCb3VuZHMiLCJpc1ZhbGlkTWFya2VySW5mb0VsIiwibWFya2VyQ29vcmRzIiwibWFya2VySW5mb0Nvb3JkcyIsIm1hcmtlclZpc2libGVIZWlnaHQiLCJtYXJrZXJWaXNpYmxlV2lkdGgiLCJkcm9wcGVkIiwiaXNEb3VibGVDbGljayIsImlzRHJvcGRvd25DaGFuZ2UiLCJzZWxlY3RlZEluZGV4IiwiY29tcGxldGVkIiwidHlwaW5nVGltZW91dCIsImZpbmRGb3JtU3VibWl0RWwiLCJmb3JtRWwiLCJpc1Bhc3N3b3JkIiwiZW50ZXJlZFRleHQiLCJnZXRUaW1lciIsImZvcm1TdWJtaXRFbCIsIkNsYXNzIiwib25Mb2FkZWQiLCJnbG9iYWxWYXIiLCJzZW5kWm9vbSIsInJldHJpZXZlWm9vbSIsInNjcmVlbiIsImRldmljZVhEUEkiLCJ6IiwiQnJvd3NlckFjdGlvbk1hbmFnZXIiLCJFbWJlZEJyaWRnZSIsImluTWVzc2FnZXNLZXkiLCJvdXRNZXNzYWdlc0tleSIsImFja3NNZXNzYWdlc0tleSIsIkVtYmVkRG9jdW1lbnRzUG9ydCIsIl9vdXRNZXNzYWdlc0NvdW50ZXIiLCJfbGlzdGVuZXJzIiwiX2hhbmRsZUluTWVzc2FnZXNQcm9taXNlIiwiX3Jlc3BvbnNlSGFuZGxlcnMiLCJjaGVja0luY29taW5nTWVzc2FnZXMiLCJfb25Db25uZWN0ZWQiLCJnZXRBbGxJbmNsdWRpbmdJbnZhbGlkIiwiX2NsZWFuT3V0Z29pbmdNZXNzYWdlcyIsImluY29taW5nTWVzc2FnZXMiLCJfY2FsY3VsYXRlSW5jb21pbmdNZXNzYWdlcyIsIl9jbGVhbkFja3NNZXNzYWdlcyIsImFja3NNZXNzYWdlcyIsIm5ld01lc3NhZ2VzIiwiX2NhbGN1bGF0ZU5ld0luY29taW5nTWVzc2FnZXMiLCJzZXRJdGVtcyIsIm5ld01lc3NhZ2UiLCJfZWNobyIsIl9tYWtlUmVzcG9uZCIsIm91dGdvaW5nTWVzc2FnZXMiLCJwYXRoc1RvUmVtb3ZlIiwib3V0Z29pbmdNZXNzYWdlIiwicmVtb3ZlQnlQYXRoIiwiZmxhdCIsImZsYXR0ZW4iLCJpbmNvbWluZ01lc3NhZ2UiLCJyZXNwb25zZSIsIl91bmJpbmRIYW5kbGVycyIsIl9vbkRpc2Nvbm5lY3RlZCIsInJlbW92ZUxpc3RlbmVyIiwicmVzcG9uc2VzIiwiY29tcGxldGUiLCJuZXdPdXRNZXNzYWdlIiwiRW1iZWRFeHRlbnNpb24iLCJFbWJlZEZsdXgiLCJleHRlbmRCeVBhdGgiLCJFbWJlZFBhbmVsQ29udHJvbGxlciIsIkVtYmVkUG9ydE1hbmFnZXIiLCJzdG9yYWdlUmVxdWVzdFdoaXRlbGlzdCIsIl9vYmplY3RTdG9yZSIsIl9leGVjdXRlU3RvcmFnZVJlcXVlc3QiLCJjbGVhciIsIkVtYmVkVGFic0NvbnRyb2xsZXIiLCJjdXJyZW50QWN0aXZlVGFiIiwibmV3QWN0aXZlVGFicyIsIm5ld0FjdGl2ZVRhYiIsIkVtYmVkQnJvd3NlckNhcHR1cmUiLCJiYWNrZ3JvdW5kS2V5IiwiRW1iZWRCYWNrZ3JvdW5kUG9ydCIsIl90b3BGcmFtZUlkIiwiX3dpbmRvd0xpc3RlbmVycyIsIl9jb25uZWN0VGltZSIsIl9zZW5kV2luZG93TWVzc2FnZVRvVG9wRnJhbWUiLCJfaGFuZGxlSW5jb21pbmdNZXNzYWdlIiwiX3NlbmRXaW5kb3dNZXNzYWdlVG9DaGlsZEZyYW1lcyIsImluV2luZG93TGlzdGVuZXIiLCJfcmVhbFNlbmQiLCJ2YWxzIiwid2luZG93TGlzdGVuZXIiLCJfbWFrZVdpbmRvd01lc3NhZ2UiLCJnZXRFbWJlZE9wdGlvbnMiLCJpb3JhZFdpZGdldE9wdGlvbnMiLCJzY3JpcHQiLCJuYXZhQmFyIiwicHJlbWl1bSIsImNvbWJpbmVJbnRlcmNvbSIsInNjcmlwdEVsIiwic2NyaXB0VVJMIiwibGFzdEluZGV4T2YiLCJsaXZlRW1iZWRGb3JVc2VyIiwibW9iaWxlVmlldyIsImNoYXQiLCJjaGF0QnV0dG9uRWwiLCJoaWRlSWNvbiIsImxvZ28iLCJvbkNoYXRCdXR0b25XaWRnZXRDbGljayIsIndpZGdldERpc2FibGVkIiwib3BlblR1dG9yaWFscyIsImdvb2dsZVRyYW5zbGF0ZSIsIl9tYWtlU3RvcmFnZVJlcXVlc3QiLCJ0YWJLZXkiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBC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QUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDBCQUEwQixlQUFlO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQyxlOzs7Ozs7O0FDaFpEOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNMQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsRUFBRTtBQUNiLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFlBQVksUUFBUTtBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuQkE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ25DQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsRUFBRTtBQUNiLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPLFlBQVk7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDM0xBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0IsU0FBUyxHQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN0QkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JBOztBQUVBO0FBQ0E7O0lBRXFCNkksSTs7Ozs7Ozs7Ozs7O0FBQ25CO0FBQ0E7NEJBQ1FDLFEsRUFBVUMsSyxFQUFPQyxLLEVBQU87QUFDOUJBLFlBQU03SCxPQUFOLENBQWMsZ0JBQVE7QUFDcEIsWUFBSThILFVBQVVDLElBQWQ7QUFDQSxZQUFJekksTUFBTWpDLE9BQU4sQ0FBYzBLLElBQWQsQ0FBSixFQUF5QjtBQUN2QkQsb0JBQVU7QUFDUkUsa0JBQU1ELEtBQUssQ0FBTCxDQURFO0FBRVJsRyxxQkFBU2tHLEtBQUssQ0FBTCxDQUZEO0FBR1JFLHFCQUFTRixLQUFLLENBQUw7QUFIRCxXQUFWO0FBS0Q7QUFDREQsZ0JBQVFHLE9BQVIsR0FBa0JILFFBQVFHLE9BQVIsSUFBbUIsc0RBQXJDOztBQUVBLFlBQUlILFFBQVFFLElBQVosRUFBa0I7QUFBRTtBQUNsQixjQUFNN0ssUUFBUSxrREFBQWhCLENBQUl5TCxLQUFKLEVBQVdFLFFBQVFFLElBQW5CLENBQWQ7QUFDQSxjQUFJLENBQUNMLFFBQUwsRUFBZUcsUUFBUWpHLE9BQVIsQ0FBZ0IxRSxLQUFoQixFQUFmLEtBQ0s7QUFDSCxnQkFBTStLLFdBQVcsa0RBQUEvTCxDQUFJd0wsUUFBSixFQUFjRyxRQUFRRSxJQUF0QixDQUFqQjtBQUNBLGdCQUFJLENBQUNGLFFBQVFHLE9BQVIsQ0FBZ0I5SyxLQUFoQixFQUF1QitLLFFBQXZCLENBQUwsRUFBdUM7QUFDckNKLHNCQUFRakcsT0FBUixDQUFnQjFFLEtBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsT0FyQkQ7QUFzQkQ7Ozs2QkFFUWdMLE8sRUFBU0MsVSxFQUEyQjtBQUFBLHdDQUFaQyxVQUFZO0FBQVpBLGtCQUFZO0FBQUE7O0FBQzNDLFVBQUlGLFFBQVEvTCxJQUFSLEtBQWlCLEtBQUtxSCxjQUExQixFQUEwQztBQUN4QyxhQUFLNkUsZ0JBQUwsQ0FBc0JILE9BQXRCLEVBQStCQyxVQUEvQixFQUEyQ0MsVUFBM0M7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBLGFBQUtFLGVBQUwsQ0FBcUJILFVBQXJCLEVBQWlDQyxVQUFqQztBQUNEO0FBQ0Y7OztxQ0FFZ0JGLE8sRUFBU0MsVSxFQUFZQyxVLEVBQVk7QUFDaEQsV0FBS0csYUFBTCxDQUFtQkwsT0FBbkIsRUFBNEI7QUFDMUJqSixlQUFPLGdCQURtQjtBQUUxQjBCLGNBQU07QUFDSnVILDBCQURJO0FBRUpDLGdDQUZJO0FBR0pDO0FBSEk7QUFGb0IsT0FBNUI7QUFRRDs7O2tDQUVhRixPLEVBQVNySSxPLEVBQVM7QUFDOUIsWUFBTSxJQUFJekIsS0FBSixDQUFVLHdDQUFWLENBQU47QUFDRDs7O29DQUVlK0osVSxFQUFZQyxVLEVBQVk7QUFDdEMsVUFBTUksU0FBUyxLQUFLQyxRQUFMLENBQWNOLFVBQWQsQ0FBZjtBQUNBLFVBQUksQ0FBQ0ssTUFBTCxFQUFhO0FBQ1gsY0FBTSxJQUFJcEssS0FBSixDQUFVLHVCQUF1QitKLFVBQWpDLENBQU47QUFDRDtBQUNESyw4QkFBQSwrRUFBQUEsQ0FBVUosVUFBVjtBQUNEOzs7O0VBMUQrQiwwRDs7Ozs7Ozs7Ozs7OztBQ0xsQyxJQUFNTSxZQUFZLFNBQVpBLFNBQVksQ0FBQ0MsR0FBRCxFQUFvQjtBQUFBLE1BQWRDLElBQWMsdUVBQVAsRUFBTzs7QUFDcEMsU0FBT0MsTUFBTUYsR0FBTiwwRUFBYUcsYUFBYSxTQUExQixJQUF3Q0YsSUFBeEMsRUFBUDtBQUNELENBRkQ7QUFHQSx3REFBZUYsU0FBZjs7QUFFTyxJQUFNSyxXQUFZLEtBQUQsR0FBb0NGLEtBQXBDLEdBQTRDSCxTQUE3RCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTFA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQU05SyxTQUFTLHNHQUFBdkMsQ0FBY3dDLFVBQWQsQ0FBZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTW1MLFFBQVE3SyxXQUFXQSxPQUFPeUIsR0FBaEM7QUFDQSxJQUFJcUosdUJBQXVCOUssT0FBTytLLE9BQVAsSUFBa0JGLFFBQVMsQ0FBQzdLLE9BQU9nTCxVQUFQLEdBQW9CaEwsT0FBT2lMLFVBQTVCLElBQTBDLENBQW5ELEdBQXdELENBQTFFLENBQTNCO0FBQ0EsSUFBSUMsdUJBQXVCbEwsT0FBT21MLE9BQVAsSUFBa0JOLFFBQVM3SyxPQUFPb0wsV0FBUCxHQUFxQnBMLE9BQU9xTCxXQUE1QixHQUEwQ1Asb0JBQW5ELEdBQTJFLENBQTdGLENBQTNCO0FBQ0EsSUFBSVEsWUFBWSxLQUFoQjs7QUFFQSxTQUFTM0ksYUFBVCxHQUF5QjtBQUN2QixNQUFNNEksVUFBVXJLLE1BQU1DLElBQU4sQ0FBV0MsU0FBU0MsZUFBVCxDQUF5QkMsZ0JBQXpCLENBQTBDLFFBQTFDLENBQVgsQ0FBaEI7QUFDQWlLLFVBQVEzSixPQUFSLENBQWdCLGtCQUFVO0FBQ3hCLFFBQU00SixlQUFlQyxZQUFZbEssT0FBT3VGLHFCQUFQLEVBQVosQ0FBckI7QUFDQTRFLElBQUEsOEVBQW1CbkssT0FBT0MsYUFBMUIsRUFBeUMsMkJBQXpDLEVBQXNFO0FBQ3BFc0osNEJBQXNCVSxhQUFhckUsSUFEaUM7QUFFcEUrRCw0QkFBc0JNLGFBQWEvSixHQUZpQztBQUdwRTZKO0FBSG9FLEtBQXRFO0FBS0QsR0FQRDtBQVFEOztBQUVELFNBQVNLLGFBQVQsQ0FBdUI3TixNQUF2QixFQUErQjtBQUM3QixNQUFNOE4sVUFBVTlOLE9BQU9nTixvQkFBUCxLQUFnQ0Esb0JBQWhDLElBQ2RoTixPQUFPb04sb0JBQVAsS0FBZ0NBLG9CQURsQixJQUVkcE4sT0FBT3dOLFNBQVAsS0FBcUJBLFNBRnZCOztBQUlBLE1BQUlNLE9BQUosRUFBYTtBQUNSZCx3QkFEUSxHQUNrRGhOLE1BRGxELENBQ1JnTixvQkFEUTtBQUNjSSx3QkFEZCxHQUNrRHBOLE1BRGxELENBQ2NvTixvQkFEZDtBQUNvQ0ksYUFEcEMsR0FDa0R4TixNQURsRCxDQUNvQ3dOLFNBRHBDOztBQUVYM0k7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsSUFBSSxDQUFDa0ksS0FBTCxFQUFZO0FBQ1ZhLEVBQUEsbUZBQXdCLDJCQUF4QixFQUFxRCxnQkFBaUI7QUFBQSxRQUFkM0ssT0FBYyxRQUFkQSxPQUFjOztBQUNwRSxRQUFJdUssYUFBYSxDQUFDdkssUUFBUThLLE9BQTFCLEVBQW1DO0FBQ25DRixrQkFBYzVLLE9BQWQ7QUFDRCxHQUhEO0FBSUEySyxFQUFBLDhFQUFtQiwrRUFBbkIsRUFBeUMsOEJBQXpDO0FBQ0Q7QUFDRCxtRkFBd0IsOEJBQXhCLEVBQXdELFlBQU07QUFDNUQvSTtBQUNELENBRkQ7O0FBSUEsU0FBU21KLFdBQVQsQ0FBcUJDLFVBQXJCLEVBQWlDO0FBQy9CLE1BQUksQ0FBQzNLLFNBQVM0SyxJQUFkLEVBQW9CLE9BRFcsQ0FDSDtBQUM1QixNQUFJRCxXQUFXeEksSUFBWCxLQUFvQixPQUFwQixJQUErQndJLFdBQVdoQixPQUFYLEtBQXVCLENBQXRELElBQTJEZ0IsV0FBV1osT0FBWCxLQUF1QixDQUF0RixFQUF5RixPQUYxRCxDQUVrRTtBQUNqRyxNQUFNYyxRQUFRLFNBQWlDak0sT0FBT2tNLGdCQUF4QyxHQUEyRCx1R0FBQUMsRUFBekU7QUFDQVIsZ0JBQWM7QUFDWmIsMEJBQXNCaUIsV0FBV2hCLE9BQVgsR0FBc0JnQixXQUFXSyxPQUFYLEdBQXFCSCxLQURyRDtBQUVaZiwwQkFBc0JhLFdBQVdaLE9BQVgsR0FBc0JZLFdBQVdNLE9BQVgsR0FBcUJKLEtBRnJEO0FBR1pYLGVBQVc7QUFIQyxHQUFkO0FBS0Q7QUFDRCxxR0FBQWdCLENBQVksWUFBTTtBQUNoQnhKLEVBQUEsZ0hBQUFBLENBQWtCLE9BQWxCLEVBQTJCZ0osV0FBM0IsRUFBd0MsSUFBeEM7QUFDQWhKLEVBQUEsZ0hBQUFBLENBQWtCLFdBQWxCLEVBQStCZ0osV0FBL0IsRUFBNEMsSUFBNUM7QUFDQWhKLEVBQUEsZ0hBQUFBLENBQWtCLFdBQWxCLEVBQStCZ0osV0FBL0IsRUFBNEMsSUFBNUMsRUFIZ0IsQ0FHbUM7QUFDcEQsQ0FKRDs7QUFNQSxTQUFTUyxpQkFBVCxDQUEyQkMsY0FBM0IsRUFBMkNDLFlBQTNDLEVBQXlEQyxVQUF6RCxFQUFxRTtBQUNuRSxNQUFNQyxhQUFhLHdEQUFBQyxDQUFVLG1EQUFBQyxDQUFLTCxjQUFMLEVBQXFCLENBQUMsR0FBRCxFQUFNLE1BQU4sRUFBYyxPQUFkLENBQXJCLENBQVYsRUFBd0Q7QUFBQSxXQUN6RUMsYUFBYUssQ0FBYixDQUR5RTtBQUFBLEdBQXhELENBQW5COztBQUlBLE1BQU1DLFdBQVcsd0RBQUFILENBQVUsbURBQUFDLENBQUtMLGNBQUwsRUFBcUIsQ0FBQyxHQUFELEVBQU0sS0FBTixFQUFhLFFBQWIsQ0FBckIsQ0FBVixFQUF3RDtBQUFBLFdBQ3ZFRSxXQUFXTSxDQUFYLENBRHVFO0FBQUEsR0FBeEQsQ0FBakI7O0FBSUEsbUZBQVlMLFVBQVosRUFBMkJJLFFBQTNCO0FBQ0Q7O0FBRUQsU0FBU3RCLFdBQVQsQ0FBcUJlLGNBQXJCLEVBQWtEO0FBQUEsTUFBYlMsTUFBYSx1RUFBTixJQUFNOztBQUNoREEsV0FBU0EsVUFBVSxFQUFDbEcsR0FBRytELG9CQUFKLEVBQTBCOUQsR0FBR2tFLG9CQUE3QixFQUFuQjtBQUNBLE1BQU1lLFFBQVEsdUdBQUFFLEVBQWQ7O0FBRUEsU0FBT0ksa0JBQ0xDLGNBREssRUFFTDtBQUFBLFdBQUtuTSxLQUFLNk0sS0FBTCxDQUFZSixJQUFJYixLQUFMLEdBQWNnQixPQUFPbEcsQ0FBaEMsQ0FBTDtBQUFBLEdBRkssRUFHTDtBQUFBLFdBQUsxRyxLQUFLNk0sS0FBTCxDQUFZRixJQUFJZixLQUFMLEdBQWNnQixPQUFPakcsQ0FBaEMsQ0FBTDtBQUFBLEdBSEssQ0FBUDtBQUtEOztBQUVEO0FBQ08sU0FBU21HLFdBQVQsQ0FBcUJYLGNBQXJCLEVBQXFDO0FBQzFDLE1BQU1QLFFBQVEsdUdBQUFFLEVBQWQ7O0FBRUEsU0FBT0ksa0JBQ0xDLGNBREssRUFFTDtBQUFBLFdBQU0sQ0FBQ00sSUFBSWhDLG9CQUFMLElBQTZCbUIsS0FBbkM7QUFBQSxHQUZLLEVBR0w7QUFBQSxXQUFNLENBQUNlLElBQUk5QixvQkFBTCxJQUE2QmUsS0FBbkM7QUFBQSxHQUhLLENBQVA7QUFLRDs7QUFFRCxTQUFTbUIsVUFBVCxDQUFvQlosY0FBcEIsRUFBb0M7QUFDbEMsU0FBT0Qsa0JBQ0xDLGNBREssRUFFTDtBQUFBLFdBQUtNLElBQUloQyxvQkFBVDtBQUFBLEdBRkssRUFHTDtBQUFBLFdBQUtrQyxJQUFJOUIsb0JBQVQ7QUFBQSxHQUhLLENBQVA7QUFLRDs7QUFHTSxTQUFTbUMsaUJBQVQsQ0FBMkJDLE1BQTNCLEVBQWdEO0FBQUEsTUFBYkwsTUFBYSx1RUFBTixJQUFNOztBQUNyRCxNQUFNaEIsUUFBUSx1R0FBQUUsRUFBZDtBQUNBLE1BQU1LLGlCQUFpQixtREFBQUssQ0FBS1MsTUFBTCxFQUFhLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxNQUFYLEVBQW1CLEtBQW5CLEVBQTBCLE9BQTFCLEVBQW1DLFFBQW5DLENBQWIsQ0FBdkI7O0FBRUEsbUZBQ0s3QixZQUFZZSxjQUFaLEVBQTRCUyxNQUE1QixDQURMO0FBRUVoRyxXQUFPNUcsS0FBSzZNLEtBQUwsQ0FBV0ksT0FBT3JHLEtBQVAsR0FBZWdGLEtBQTFCLENBRlQ7QUFHRS9FLFlBQVE3RyxLQUFLNk0sS0FBTCxDQUFXSSxPQUFPcEcsTUFBUCxHQUFnQitFLEtBQTNCO0FBSFY7QUFLRDs7QUFFRDtBQUNPLFNBQVNzQixpQkFBVCxDQUEyQkQsTUFBM0IsRUFBbUM7QUFDeEMsTUFBTXJCLFFBQVEsdUdBQUFFLEVBQWQ7QUFDQSxNQUFNSyxpQkFBaUIsbURBQUFLLENBQUtTLE1BQUwsRUFBYSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsTUFBWCxFQUFtQixLQUFuQixFQUEwQixPQUExQixFQUFtQyxRQUFuQyxDQUFiLENBQXZCOztBQUVBLG1GQUNLSCxZQUFZWCxjQUFaLENBREw7QUFFRXZGLFdBQU9xRyxPQUFPckcsS0FBUCxHQUFlZ0YsS0FGeEI7QUFHRS9FLFlBQVFvRyxPQUFPcEcsTUFBUCxHQUFnQitFO0FBSDFCO0FBS0Q7O0FBRUQ7QUFDTyxTQUFTdUIsZ0JBQVQsQ0FBMEJGLE1BQTFCLEVBQWtDO0FBQ3ZDLE1BQU1kLGlCQUFpQixtREFBQUssQ0FBS1MsTUFBTCxFQUFhLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxNQUFYLEVBQW1CLEtBQW5CLEVBQTBCLE9BQTFCLEVBQW1DLFFBQW5DLENBQWIsQ0FBdkI7O0FBRUEsbUZBQ0tGLFdBQVdaLGNBQVgsQ0FETDtBQUVFdkYsV0FBT3FHLE9BQU9yRyxLQUZoQjtBQUdFQyxZQUFRb0csT0FBT3BHO0FBSGpCO0FBS0Q7O0FBRUQ7QUFDQTtBQUNPLFNBQVN1RyxnQkFBVCxRQUFtREMsSUFBbkQsRUFBeUQ7QUFBQSxNQUE3QjNHLENBQTZCLFNBQTdCQSxDQUE2QjtBQUFBLE1BQTFCQyxDQUEwQixTQUExQkEsQ0FBMEI7QUFBQSxNQUF2QkMsS0FBdUIsU0FBdkJBLEtBQXVCO0FBQUEsTUFBaEJDLE1BQWdCLFNBQWhCQSxNQUFnQjs7QUFDOUR6SCxTQUFPaEUsS0FBUCxDQUFhLGFBQWIsRUFBNEIsRUFBRXNMLElBQUYsRUFBS0MsSUFBTCxFQUFRQyxZQUFSLEVBQWVDLGNBQWYsRUFBNUI7O0FBRUFILE1BQUkxRyxLQUFLNk0sS0FBTCxDQUFXbkcsSUFBSTJHLElBQWYsQ0FBSjtBQUNBMUcsTUFBSTNHLEtBQUs2TSxLQUFMLENBQVdsRyxJQUFJMEcsSUFBZixDQUFKO0FBQ0F6RyxVQUFRNUcsS0FBSzZNLEtBQUwsQ0FBV2pHLFFBQVF5RyxJQUFuQixDQUFSO0FBQ0F4RyxXQUFTN0csS0FBSzZNLEtBQUwsQ0FBV2hHLFNBQVN3RyxJQUFwQixDQUFUOztBQUVBak8sU0FBT2hFLEtBQVAsQ0FBYSxZQUFiLEVBQTJCLEVBQUVzTCxJQUFGLEVBQUtDLElBQUwsRUFBUUMsWUFBUixFQUFlQyxjQUFmLEVBQTNCO0FBQ0EsU0FBTyxFQUFFSCxJQUFGLEVBQUtDLElBQUwsRUFBUUMsWUFBUixFQUFlQyxjQUFmLEVBQVA7QUFDRCxDOzs7Ozs7Ozs7O0FDaktNLElBQU15Ryx1QkFBdUIsU0FBdkJBLG9CQUF1QixDQUFDN0osRUFBRCxFQUFRO0FBQzFDLFNBQU8sVUFBQzhKLENBQUQsRUFBTztBQUNaQSxNQUFFQyxjQUFGO0FBQ0EsV0FBTy9KLEdBQUc4SixDQUFILENBQVA7QUFDRCxHQUhEO0FBSUQsQ0FMTTs7QUFPQSxJQUFNcEYsVUFBVSxTQUFWQSxPQUFVLENBQUM3QixFQUFELEVBQUs3QyxFQUFMLEVBQVk7QUFDakMsTUFBSTJFLFlBQVk5QixFQUFoQjtBQUNBLFNBQU84QixTQUFQLEVBQWtCO0FBQ2hCLFFBQUkzRSxHQUFHMkUsU0FBSCxDQUFKLEVBQW1CLE9BQU9BLFNBQVA7QUFDbkJBLGdCQUFZQSxVQUFVcUYsYUFBdEI7QUFDRDtBQUNGLENBTk0sQzs7Ozs7Ozs7O0FDUFA7QUFBQSxTQUFTQywwQkFBVCxDQUFvQ0MsU0FBcEMsRUFBK0M7QUFDN0M7QUFDQTtBQUNBLE1BQU1DLHFCQUFxQkQsVUFBVUUsUUFBVixLQUF1QixFQUF2QixHQUE0QixHQUE1QixHQUFrQ0YsVUFBVUUsUUFBdkU7O0FBRUE7QUFDQTtBQUNBLE1BQUlDLG1CQUFtQkgsVUFBVUksTUFBVixDQUFpQjFHLEtBQWpCLENBQXVCLHFCQUF2QixJQUNyQnNHLFVBQVVJLE1BQVYsQ0FBaUJoUixPQUFqQixDQUF5QixxQkFBekIsRUFBZ0QsRUFBaEQsQ0FEcUIsR0FDaUM0USxVQUFVSSxNQURsRTtBQUVBRCxxQkFBbUJBLGlCQUFpQmhTLFVBQWpCLENBQTRCLEdBQTVCLElBQW1DZ1MsbUJBQW1CLE1BQU1BLGlCQUFpQjdSLEtBQWpCLENBQXVCLENBQXZCLENBQTVELEdBQXdGNlIsZ0JBQTNHO0FBQ0FBLHFCQUFtQkEscUJBQXFCLEdBQXJCLEdBQTJCLEVBQTNCLEdBQWdDQSxnQkFBbkQ7O0FBRUEsTUFBTUUsaUJBQWlCTCxVQUFVTSxJQUFWLEtBQW1CLEdBQW5CLEdBQXlCLEVBQXpCLEdBQThCTixVQUFVTSxJQUEvRDs7QUFFQSxTQUFPTCxxQkFBcUJFLGdCQUFyQixHQUF3Q0UsY0FBL0M7QUFDRDs7QUFFTSxTQUFTRSxXQUFULENBQXFCQyxhQUFyQixFQUFvQ0MsZ0JBQXBDLEVBQXNEQyxLQUF0RCxFQUE2RDtBQUNsRSxNQUFJLENBQUNGLGFBQUwsRUFBb0IsT0FBTyxJQUFQO0FBQ3BCLE1BQU1HLFVBQVUsSUFBSUMsR0FBSixDQUFRSixhQUFSLENBQWhCO0FBQ0EsTUFBTUssYUFBYSxJQUFJRCxHQUFKLENBQVFILGdCQUFSLENBQW5COztBQUVBLE1BQUlDLEtBQUosRUFBVztBQUNULFdBQU9DLFFBQVFHLElBQWY7QUFDRDs7QUFFRCxNQUFNQyxjQUNKSixRQUFRSyxRQUFSLENBQWlCQyxRQUFqQixDQUEwQixjQUExQixLQUNBTixRQUFRSyxRQUFSLENBQWlCQyxRQUFqQixDQUEwQixZQUExQixDQURBLElBRUFOLFFBQVFLLFFBQVIsQ0FBaUJDLFFBQWpCLENBQTBCLFlBQTFCLENBSEY7QUFLQSxNQUFJLENBQUNGLFdBQUwsRUFBa0I7QUFDaEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUksY0FBY0csSUFBZCxDQUFtQlAsUUFBUVQsUUFBM0IsQ0FBSixFQUEwQztBQUN4QyxXQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFNaUIscUJBQXFCUixRQUFRSyxRQUFSLENBQWlCQyxRQUFqQixDQUEwQixjQUExQixNQUN4QkosV0FBV0csUUFBWCxDQUFvQkMsUUFBcEIsQ0FBNkIsY0FBN0IsS0FBZ0RqUCxPQUFPb1AsT0FEL0IsS0FFekJQLFdBQVdHLFFBQVgsS0FBd0IsaUJBRkMsSUFHekJMLFFBQVFLLFFBQVIsS0FBcUIsaUJBSHZCO0FBSUEsTUFBSUcsa0JBQUosRUFBd0I7QUFDdEJSLFlBQVFLLFFBQVIsR0FBbUJILFdBQVdHLFFBQTlCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSUwsUUFBUUssUUFBUixLQUFxQkgsV0FBV0csUUFBcEMsRUFBOEM7QUFDNUMsUUFBTUssZUFBZXRCLDJCQUEyQlksT0FBM0IsRUFBb0N2USxLQUFwQyxDQUEwQyxHQUExQyxDQUFyQjtBQUNBLFFBQU1rUixrQkFBa0J2QiwyQkFBMkJjLFVBQTNCLEVBQXVDelEsS0FBdkMsQ0FBNkMsR0FBN0MsQ0FBeEI7QUFDQSxRQUFNbVIsaUJBQWlCRixhQUFhL1MsS0FBYixDQUFtQixDQUFuQixFQUFzQixDQUFDLENBQXZCLEVBQTBCb0IsSUFBMUIsQ0FBK0IsR0FBL0IsTUFBd0M0UixnQkFBZ0JoVCxLQUFoQixDQUFzQixDQUF0QixFQUF5QixDQUFDLENBQTFCLEVBQTZCb0IsSUFBN0IsQ0FBa0MsR0FBbEMsQ0FBL0Q7QUFDQSxRQUFNOFIsZUFBZUgsYUFBYS9TLEtBQWIsQ0FBbUIsQ0FBQyxDQUFwQixFQUF1Qm9CLElBQXZCLENBQTRCLEdBQTVCLE1BQXFDNFIsZ0JBQWdCaFQsS0FBaEIsQ0FBc0IsQ0FBQyxDQUF2QixFQUEwQm9CLElBQTFCLENBQStCLEdBQS9CLENBQTFEO0FBQ0EsUUFBSTZSLGtCQUFrQixDQUFDQyxZQUF2QixFQUFxQztBQUNuQyxhQUFPYixRQUFRRyxJQUFmO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTVyxnQkFBVCxDQUEwQmpCLGFBQTFCLEVBQXlDRSxLQUF6QyxFQUFnRDtBQUNyRCxNQUFNZ0IsY0FBY25CLFlBQVlDLGFBQVosRUFBMkJ4TyxPQUFPMlAsUUFBUCxDQUFnQmIsSUFBM0MsRUFBaURKLEtBQWpELENBQXBCO0FBQ0EsTUFBSWdCLGVBQWVBLGdCQUFnQjFQLE9BQU8yUCxRQUFQLENBQWdCYixJQUFuRCxFQUF5RDtBQUN2RDlPLFdBQU8yUCxRQUFQLENBQWdCYixJQUFoQixHQUF1QlksV0FBdkI7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBU0UsaUJBQVQsQ0FBMkJDLFlBQTNCLEVBQXlDQyxZQUF6QyxFQUF1RDtBQUM1RCxNQUFJRCxpQkFBaUJDLFlBQXJCLEVBQW1DLE9BQU8sS0FBUDs7QUFFbkMsTUFBTUMsZUFBZTNPLFNBQVM0TyxhQUFULENBQXVCLEdBQXZCLENBQXJCO0FBQ0FELGVBQWFqQixJQUFiLEdBQW9CZSxZQUFwQjs7QUFFQSxNQUFNSSxlQUFlN08sU0FBUzRPLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBckI7QUFDQUMsZUFBYW5CLElBQWIsR0FBb0JnQixZQUFwQjs7QUFFQSxTQUFPQyxhQUFhRyxNQUFiLEdBQXNCSCxhQUFhN0IsUUFBbkMsR0FBOEM2QixhQUFhM0IsTUFBM0QsS0FBc0U2QixhQUFhQyxNQUFiLEdBQXNCRCxhQUFhL0IsUUFBbkMsR0FBOEMrQixhQUFhN0IsTUFBeEk7QUFDRCxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUNrVlMrQixVOztBQTFhVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBTTFRLFNBQVMsdUdBQUF2QyxDQUFjd0MsVUFBZCxDQUFmOztBQUVBLFNBQVMwUSxTQUFULENBQW1CaFAsUUFBbkIsRUFBNkJpUCxLQUE3QixFQUFvQztBQUNsQyxNQUFJO0FBQ0YsUUFBSSxDQUFDQSxLQUFELElBQVVBLE1BQU1DLElBQU4sR0FBYS9ULE1BQWIsS0FBd0IsQ0FBdEMsRUFBeUMsT0FBTyxFQUFQO0FBQ3pDLFFBQUlnVSxNQUFNblAsU0FBU0UsZ0JBQVQsQ0FBMEIrTyxLQUExQixDQUFWOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBLFdBQU9FLEdBQVA7QUFDRCxHQVhELENBV0UsT0FBTzNDLENBQVAsRUFBVTtBQUNWbk8sV0FBTzdELEtBQVAsQ0FBYSx1Q0FBdUN5VSxLQUF2QyxHQUErQyxnQkFBNUQsRUFBOEV6QyxDQUE5RSxFQUFpRixJQUFqRixFQUF1RkEsRUFBRTRDLEtBQXpGO0FBQ0EsV0FBTyxFQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxZQUFULENBQXNCRixHQUF0QixFQUEyQkcsSUFBM0IsRUFBaUM7QUFDL0IsTUFBSUEsSUFBSixFQUFVO0FBQUEsUUFDQ0MsWUFERCxHQUNSLFNBQVNBLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCO0FBQzNCO0FBQ0E7QUFDQSxhQUFPQSxNQUFNeFQsT0FBTixDQUFjLE1BQWQsRUFBc0IsRUFBdEIsRUFBMEJrVCxJQUExQixFQUFQO0FBQ0QsS0FMTzs7QUFBQSxRQU9DTyxPQVBELEdBT1IsU0FBU0EsT0FBVCxDQUFpQmpELENBQWpCLEVBQW9CO0FBQ2xCLFVBQUksQ0FBQ0EsRUFBRWtELFNBQVAsRUFBa0IsT0FBTyxFQUFQO0FBQ2xCLFVBQUlDLGNBQWNuRCxLQUFLQSxFQUFFbUQsV0FBekI7QUFDQSxVQUFJbkQsRUFBRW9ELFlBQUYsQ0FBZSxLQUFmLENBQUosRUFBMkI7QUFDekJELHNCQUFjbkQsRUFBRTFGLFlBQUYsQ0FBZSxLQUFmLENBQWQ7QUFDRDtBQUNELGFBQVE2SSxlQUFlLEVBQXZCO0FBQ0QsS0FkTzs7QUFnQlJSLFVBQU0scURBQUFyTyxDQUFPcU8sR0FBUCxFQUFZO0FBQUEsYUFBS0ksYUFBYUUsUUFBUWpELENBQVIsQ0FBYixNQUE2QitDLGFBQWFELElBQWIsQ0FBbEM7QUFBQSxLQUFaLENBQU47QUFDRDtBQUNELFNBQU9ILEdBQVA7QUFDRDs7QUFFRCxTQUFTVSxvQkFBVCxDQUE4QlYsR0FBOUIsRUFBbUN2UyxJQUFuQyxFQUF5QztBQUN2QyxNQUFJQSxJQUFKLEVBQVU7QUFBQSxRQUNDa1QsWUFERCxHQUNSLFNBQVNBLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCO0FBQzNCO0FBQ0E7QUFDQSxhQUFPQSxNQUFNL1QsT0FBTixDQUFjLE1BQWQsRUFBc0IsRUFBdEIsRUFBMEJrVCxJQUExQixFQUFQO0FBQ0QsS0FMTzs7QUFBQSxRQU9DYyxPQVBELEdBT1IsU0FBU0EsT0FBVCxDQUFpQnhELENBQWpCLEVBQW9CO0FBQ2xCLGFBQU8sdUZBQUF5RCxDQUFXekQsQ0FBWCxLQUFpQixFQUF4QjtBQUNELEtBVE87O0FBV1IyQyxVQUFNLHFEQUFBck8sQ0FBT3FPLEdBQVAsRUFBWTtBQUFBLGFBQUtXLGFBQWFFLFFBQVF4RCxDQUFSLENBQWIsTUFBNkJzRCxhQUFhbFQsSUFBYixDQUFsQztBQUFBLEtBQVosQ0FBTjtBQUNEO0FBQ0QsU0FBT3VTLEdBQVA7QUFDRDs7QUFFRCxTQUFTZSxtQkFBVCxDQUE2QmYsR0FBN0IsRUFBa0M7QUFDaEMsTUFBSUEsSUFBSWhVLE1BQUosR0FBYSxDQUFqQixFQUFvQixPQUFPLEtBQVA7QUFDcEIsTUFBTWdWLGNBQWNoQixJQUFJLENBQUosRUFBT2xJLFVBQTNCO0FBQ0EsU0FBTywwRkFBSWtJLEdBQUosR0FBU3JPLE1BQVQsQ0FBZ0I7QUFBQSxXQUFNeUUsR0FBRzBCLFVBQUgsS0FBa0JrSixXQUF4QjtBQUFBLEdBQWhCLEVBQXFEaFYsTUFBckQsS0FBZ0UsQ0FBdkU7QUFDRDs7QUFFRCxTQUFTaVYsYUFBVCxDQUF1QjdLLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0EsR0FBRzhLLFVBQVIsRUFBb0IsT0FBTyxFQUFQLENBREssQ0FDTTs7QUFFL0IsU0FBUztBQUNQdlEsVUFBTUMsSUFBTixDQUFXd0YsR0FBRzhLLFVBQWQsRUFBMEJDLE1BQTFCLENBQWlDLFVBQUNDLEtBQUQsRUFBUUMsSUFBUixFQUFpQjtBQUNoRCx1RkFBV0QsS0FBWCxtRkFBbUJDLEtBQUtDLFFBQXhCLEVBQW1DRCxLQUFLRSxTQUF4QztBQUNELEtBRkQsRUFFRyxFQUZIO0FBREY7QUFLRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCcEwsRUFBdkIsRUFBMkJxTCxXQUEzQixFQUF3Q0MsWUFBeEMsRUFBc0RDLFlBQXRELEVBQW9FO0FBQ2xFLE1BQU1DLGNBQWN4TCxHQUFHcUwsV0FBSCxDQUFwQjtBQUNBLE1BQUksQ0FBQ0csV0FBRCxJQUFnQkQsZ0JBQWdCLENBQXBDLEVBQXVDLE9BQU8sSUFBUDs7QUFFdkMsTUFBTXhXLE9BQU8wVyxZQUFZRCxXQUFaLEVBQXlCLEtBQXpCLENBQWI7QUFDQXpXLE9BQUt1VyxZQUFMLElBQXFCRixjQUNuQnBMLEVBRG1CLEVBQ2ZxTCxXQURlLEVBQ0ZDLFlBREUsRUFDWUMsZUFBZSxDQUQzQixDQUFyQjtBQUdBLFNBQU94VyxJQUFQO0FBQ0Q7QUFDRCxTQUFTMlcsVUFBVCxDQUFvQjFMLEVBQXBCLEVBQW9DO0FBQUEsTUFBWjJMLEtBQVksdUVBQUosRUFBSTs7QUFDbEMsTUFBTTVXLE9BQVFxVyxjQUFjcEwsRUFBZCxFQUFrQixZQUFsQixFQUFnQyxRQUFoQyxFQUEwQzJMLEtBQTFDLENBQWQ7QUFDQSxTQUFPNVcsSUFBUDtBQUNEO0FBQ0QsU0FBUzZXLGVBQVQsQ0FBeUI1TCxFQUF6QixFQUF5QztBQUFBLE1BQVoyTCxLQUFZLHVFQUFKLEVBQUk7O0FBQ3ZDLFNBQU9QLGNBQWNwTCxFQUFkLEVBQWtCLHdCQUFsQixFQUE0QyxhQUE1QyxFQUEyRDJMLEtBQTNELENBQVA7QUFDRDtBQUNELFNBQVNFLGVBQVQsQ0FBeUI3TCxFQUF6QixFQUF5QztBQUFBLE1BQVoyTCxLQUFZLHVFQUFKLEVBQUk7O0FBQ3ZDLFNBQU9QLGNBQWNwTCxFQUFkLEVBQWtCLG9CQUFsQixFQUF3QyxhQUF4QyxFQUF1RDJMLEtBQXZELENBQVA7QUFDRDtBQUNELFNBQVNHLGNBQVQsQ0FBd0I5TCxFQUF4QixFQUE0QjtBQUMxQixTQUFPO0FBQ0wxRixZQUFRb1IsV0FBVzFMLEVBQVgsQ0FESDtBQUVMK0wsaUJBQWFILGdCQUFnQjVMLEVBQWhCLENBRlI7QUFHTGdNLGlCQUFhSCxnQkFBZ0I3TCxFQUFoQjtBQUhSLEdBQVA7QUFLRDs7QUFFRCxTQUFTeUwsV0FBVCxDQUFxQnpMLEVBQXJCLEVBQThDO0FBQUEsTUFBckJpTSxXQUFxQix1RUFBUCxLQUFPO0FBQUEsTUFDcEN4TCxPQURvQyxHQUNiVCxFQURhLENBQ3BDUyxPQURvQztBQUFBLE1BQzNCMEosU0FEMkIsR0FDYm5LLEVBRGEsQ0FDM0JtSyxTQUQyQjs7QUFFNUMsTUFBTXJVLEtBQU1rSyxHQUFHbUssU0FBSCxJQUFnQm5LLEdBQUd1QixZQUFILENBQWdCLElBQWhCLENBQWpCLElBQTJDeEosU0FBdEQ7QUFDQSxNQUFNVixPQUFRMkksR0FBR21LLFNBQUgsSUFBZ0JuSyxHQUFHdUIsWUFBSCxDQUFnQixNQUFoQixDQUFqQixJQUE2Q3hKLFNBQTFEO0FBQ0EsTUFBTW1VLGVBQWdCLENBQUMsT0FBRCxFQUFVLFVBQVYsRUFBc0JDLE9BQXRCLENBQThCbk0sR0FBR1MsT0FBakMsTUFBOEMsQ0FBQyxDQUEvQyxJQUFvRCx1RkFBQWlLLENBQVcxSyxFQUFYLENBQXJELElBQXdFakksU0FBN0Y7QUFDQSxNQUFNcVUsY0FBZXBNLEdBQUdtSyxTQUFILElBQWdCbkssR0FBR3VCLFlBQUgsQ0FBZ0IsYUFBaEIsQ0FBakIsSUFBb0R4SixTQUF4RTtBQUNBLE1BQU1vUSxPQUFRbkksR0FBR21LLFNBQUgsSUFBZ0JuSyxHQUFHdUIsWUFBSCxDQUFnQixNQUFoQixDQUFqQixJQUE2Q3hKLFNBQTFEO0FBQ0EsTUFBTXNVLE1BQU9yTSxHQUFHbUssU0FBSCxJQUFnQm5LLEdBQUd1QixZQUFILENBQWdCLEtBQWhCLENBQWpCLElBQTRDeEosU0FBeEQ7QUFDQSxNQUFNdVUsYUFBY3RNLEdBQUcwQixVQUFILElBQWlCMUIsR0FBRzBCLFVBQUgsQ0FBYzZLLFFBQWhDLEdBQTRDaFMsTUFBTWlTLFNBQU4sQ0FBZ0JMLE9BQWhCLENBQXdCTSxJQUF4QixDQUE2QnpNLEdBQUcwQixVQUFILENBQWM2SyxRQUEzQyxFQUFxRHZNLEVBQXJELENBQTVDLEdBQXVHakksU0FBMUg7QUFDQSxNQUFNcVMsY0FBY3BLLEdBQUdtSyxTQUFILEdBQWdCbkssR0FBR29LLFdBQUgsQ0FBZVQsSUFBZixNQUF5QjNKLEdBQUd1QixZQUFILENBQWdCLEtBQWhCLENBQXpDLEdBQW1FeEosU0FBdkY7QUFDQSxNQUFNK1MsYUFBYUQsY0FBYzdLLEVBQWQsQ0FBbkI7QUFDQSxNQUFNME0sY0FBY1QsY0FBY0gsZUFBZTlMLEVBQWYsQ0FBZCxHQUFtQyxFQUF2RDtBQUNBLE1BQU0yTSxZQUFhM00sR0FBR21LLFNBQUgsSUFBZ0JuSyxHQUFHdUIsWUFBSCxDQUFnQixZQUFoQixDQUFqQixJQUFtRHhKLFNBQXJFOztBQUVBO0FBQ0UwSSxvQkFERjtBQUVFM0ssVUFGRjtBQUdFOFcsYUFBVXpDLGFBQWFBLFVBQVV2VSxNQUFWLEdBQW1CLENBQWpDLEdBQXNDLHVEQUFBaVgsQ0FBUTFDLFNBQVIsQ0FBdEMsR0FBMkRwUyxTQUh0RTtBQUlFZ1MsVUFBT0ssZUFBZ0JBLFlBQVl4VSxNQUFaLEdBQXFCLEVBQXRDLEdBQTZDd1UsV0FBN0MsR0FBMkRyUyxTQUpuRTtBQUtFcVUsNEJBTEY7QUFNRU8sd0JBTkY7QUFPRXRWLGNBUEY7QUFRRTZVLDhCQVJGO0FBU0UvRCxjQVRGO0FBVUVrRSxZQVZGO0FBV0VDLDBCQVhGO0FBWUV4QjtBQVpGLEtBYUs0QixXQWJMO0FBZUQ7O0FBRU0sU0FBU0ksVUFBVCxDQUFvQjlNLEVBQXBCLEVBQXdCO0FBQzdCLE1BQU0rTSxVQUFVLEVBQWhCOztBQUVBLE1BQU1DLFlBQVksRUFBbEI7QUFDQSxNQUFJbEwsWUFBWTlCLEVBQWhCO0FBQ0EsU0FBTzhCLGNBQWMsSUFBZCxJQUFzQmlMLFFBQVFuWCxNQUFSLEdBQWlCb1gsU0FBOUMsRUFBeUQ7QUFDdkQsUUFBTWpZLE9BQU8wVyxZQUFZM0osU0FBWixDQUFiO0FBQ0FpTCxZQUFRRSxPQUFSLENBQWdCbFksSUFBaEI7O0FBRUErTSxnQkFBWUEsVUFBVUosVUFBVixJQUF3QixJQUFwQztBQUNEOztBQUVELFNBQU9xTCxPQUFQO0FBQ0Q7O0FBRUQsSUFBTUcsdUJBQXVCLENBQUMsU0FBRCxFQUFZLElBQVosRUFBa0IsTUFBbEIsRUFBMEIsY0FBMUIsRUFBMEMsTUFBMUMsRUFBa0QsS0FBbEQsRUFBeUQsYUFBekQsRUFBd0UsV0FBeEUsQ0FBN0I7QUFDQSxJQUFNQyxzQkFBc0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QixFQUFnQyxLQUFoQyxFQUF1QyxhQUF2QyxFQUFzRCxZQUF0RCxDQUE1Qjs7QUFFQSxTQUFTQyxTQUFULENBQW1CclksSUFBbkIsRUFBeUI7QUFDdkIsTUFBSTJVLFFBQVEsRUFBWjtBQUNBLE1BQUkzVSxLQUFLMEwsT0FBVCxFQUFrQmlKLGNBQVksa0RBQUEyRCxDQUFVdFksS0FBSzBMLE9BQWYsQ0FBWjtBQUNsQixNQUFJMUwsS0FBS2UsRUFBVCxFQUFhO0FBQ1g0VCxtQkFBYSxrREFBQTJELENBQVV0WSxLQUFLZSxFQUFmLENBQWI7QUFDRDtBQUNENFQsV0FBUyxtREFBQTdTLENBQUk5QixLQUFLNlgsT0FBVCxFQUFrQjtBQUFBLGlCQUFXLGtEQUFBUyxDQUFVQyxHQUFWLENBQVg7QUFBQSxHQUFsQixFQUErQ3ZXLElBQS9DLENBQW9ELEVBQXBELENBQVQ7QUFDQSxNQUFJaEMsS0FBS3NDLElBQVQsRUFBZTtBQUNicVMseUJBQW1CLGtEQUFBMkQsQ0FBVXRZLEtBQUtzQyxJQUFmLENBQW5CO0FBQ0Q7QUFDRCxNQUFJdEMsS0FBS29ULElBQVQsRUFBZTtBQUNidUIseUJBQW1CLGtEQUFBMkQsQ0FBVXRZLEtBQUtvVCxJQUFmLENBQW5CO0FBQ0Q7QUFDRCxNQUFJcFQsS0FBS3dZLFVBQVQsRUFBcUI7QUFDbkI3RCwwQkFBb0Isa0RBQUEyRCxDQUFVdFksS0FBS3dZLFVBQWYsQ0FBcEI7QUFDRDtBQUNELE1BQUl4WSxLQUFLc1gsR0FBVCxFQUFjO0FBQ1ozQyx3QkFBa0Isa0RBQUEyRCxDQUFVdFksS0FBS3NYLEdBQWYsQ0FBbEI7QUFDRDtBQUNELE1BQUl0WCxLQUFLdVgsVUFBTCxJQUFtQixJQUF2QixFQUE2QjtBQUMzQjVDLDhCQUF1QjNVLEtBQUt1WCxVQUFMLEdBQWtCLENBQXpDO0FBQ0Q7QUFDRCxNQUFJdlgsS0FBS3FYLFdBQVQsRUFBc0I7QUFDcEIxQyxnQ0FBMEIsa0RBQUEyRCxDQUFVdFksS0FBS3FYLFdBQWYsQ0FBMUI7QUFDRDtBQUNELE1BQUlyWCxLQUFLNFgsU0FBVCxFQUFvQjtBQUNsQmpELCtCQUF5QixrREFBQTJELENBQVV0WSxLQUFLNFgsU0FBZixDQUF6QjtBQUNEO0FBQ0QsTUFBSTVYLEtBQUsrVixVQUFULEVBQXFCO0FBQ25CLFFBQU1BLGFBQWEsb0RBQUEwQyxDQUFLelksS0FBSytWLFVBQVYsRUFBc0JxQyxtQkFBdEIsQ0FBbkI7QUFEbUI7QUFBQTtBQUFBOztBQUFBO0FBRW5CLDJCQUE0Qk0sT0FBT0MsSUFBUCxDQUFZNUMsVUFBWixDQUE1Qiw4SEFBcUQ7QUFBQSxZQUExQzZDLGFBQTBDOztBQUNuRCxZQUFJQSxjQUFjeEIsT0FBZCxDQUFzQixHQUF0QixNQUErQixDQUFDLENBQXBDLEVBQXVDLFNBRFksQ0FDRjtBQUNqRCxZQUFNeUIsaUJBQWlCOUMsV0FBVzZDLGFBQVgsQ0FBdkI7QUFDQWpFLHVCQUFhaUUsYUFBYixVQUErQixrREFBQU4sQ0FBVU8sY0FBVixDQUEvQjtBQUNEO0FBTmtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPcEI7QUFDRCxTQUFPbEUsS0FBUDtBQUNEOztBQUVELFNBQVNtRSxZQUFULENBQXNCcFQsUUFBdEIsRUFBZ0NzUyxPQUFoQyxFQUF5QztBQUN2QyxNQUFJLENBQUN4UyxNQUFNakMsT0FBTixDQUFjeVUsT0FBZCxDQUFMLEVBQTZCO0FBQzNCQSxjQUFVLENBQUNBLE9BQUQsQ0FBVjtBQUNEOztBQUVELE1BQU1lLFVBQVVmLFFBQVFsVyxHQUFSLENBQVl1VyxTQUFaLENBQWhCO0FBQ0EsTUFBSTFELFFBQVEsQ0FBQ29FLFFBQVEsQ0FBUixLQUFjLEVBQWYsRUFBbUJuRSxJQUFuQixFQUFaO0FBQ0EsT0FBSyxJQUFJOVIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaVcsUUFBUWxZLE1BQTVCLEVBQW9DaUMsR0FBcEMsRUFBeUM7QUFDdkMsUUFBTWtXLGVBQWVELFFBQVFqVyxDQUFSLEVBQVc4UixJQUFYLEVBQXJCO0FBQ0EsUUFBTXFFLGlCQUFrQixDQUFDdEUsS0FBRCxJQUFVLENBQUNxRSxZQUFaLEdBQTRCLEVBQTVCLEdBQWlDaEIsUUFBUWxWLENBQVIsRUFBV29XLFdBQVgsR0FBeUIsS0FBekIsR0FBaUMsR0FBekY7QUFDQXZFLGFBQVNzRSxpQkFBaUJELFlBQTFCO0FBQ0Q7O0FBRUQsTUFBSW5FLE1BQU1ILFVBQVVoUCxRQUFWLEVBQW9CaVAsS0FBcEIsQ0FBVjs7QUFFQSxNQUFJLG1EQUFBd0UsQ0FBS25CLE9BQUwsRUFBY2hELElBQWxCLEVBQXdCO0FBQ3RCSCxVQUFNRSxhQUFhRixHQUFiLEVBQWtCLG1EQUFBc0UsQ0FBS25CLE9BQUwsRUFBY2hELElBQWhDLENBQU47QUFDRDs7QUFFRCxNQUFJLG1EQUFBbUUsQ0FBS25CLE9BQUwsRUFBY2IsWUFBbEIsRUFBZ0M7QUFDOUJ0QyxVQUFNVSxxQkFBcUJWLEdBQXJCLEVBQTBCLG1EQUFBc0UsQ0FBS25CLE9BQUwsRUFBY2IsWUFBeEMsQ0FBTjtBQUNEOztBQUVELFNBQU8sRUFBRXhDLFlBQUYsRUFBU0UsUUFBVCxFQUFQO0FBQ0Q7O0FBRUQsU0FBU3VFLFlBQVQsQ0FBc0IxVCxRQUF0QixFQUFnQ3NTLE9BQWhDLEVBQXlDO0FBQ3ZDLFNBQU9jLGFBQWFwVCxRQUFiLEVBQXVCc1MsT0FBdkIsRUFBZ0NuRCxHQUFoQyxDQUFvQ2hVLE1BQTNDO0FBQ0Q7O0FBRU0sU0FBU3dZLGtCQUFULENBQTRCclosSUFBNUIsRUFBa0M7QUFDdkMsTUFBTXNaLHNCQUFzQixFQUE1QjtBQUNBLE1BQU1DLFlBQVksRUFBbEI7QUFDQSxNQUFNQyxjQUFjLENBQXBCO0FBQ0EsTUFBTUMsbUJBQW1CLENBQXpCOztBQUVBLFNBQU9mLE9BQU9DLElBQVAsQ0FBWTNZLElBQVosRUFBa0JnVyxNQUFsQixDQUF5QixVQUFDMEQsWUFBRCxFQUFlQyxRQUFmLEVBQTRCO0FBQzFELFFBQUlDLFlBQVksQ0FBaEI7QUFDQSxRQUFJekIscUJBQXFCZixPQUFyQixDQUE2QnVDLFFBQTdCLE1BQTJDLENBQUMsQ0FBaEQsRUFBbUQ7QUFDakRDLGtCQUFZTixtQkFBWjtBQUNELEtBQUMsSUFBSUssYUFBYSxNQUFqQixFQUF5QjtBQUN6QkMsa0JBQVlMLFNBQVo7QUFDRCxLQUZDLE1BRUssSUFBSUksYUFBYSxTQUFiLElBQTBCM1osS0FBSzZYLE9BQW5DLEVBQTRDO0FBQ2pEK0Isa0JBQVk1WixLQUFLNlgsT0FBTCxDQUFhaFgsTUFBYixHQUFzQjJZLFdBQWxDO0FBQ0QsS0FGTSxNQUVBLElBQUlHLGFBQWEsWUFBYixJQUE2QjNaLEtBQUsrVixVQUF0QyxFQUFrRDtBQUN2RCxVQUFNOEQsaUJBQWlCbkIsT0FBT0MsSUFBUCxDQUFZLG9EQUFBRixDQUFLelksS0FBSytWLFVBQVYsR0FBdUIsT0FBdkIsU0FBbUNvQyxvQkFBbkMsRUFBWixDQUF2QjtBQUNBeUIsa0JBQVlDLGVBQWVoWixNQUFmLEdBQXdCNFksZ0JBQXBDO0FBQ0Q7QUFDRCxXQUFPQyxlQUFlRSxTQUF0QjtBQUNELEdBYk0sRUFhSixDQWJJLENBQVA7QUFjRDs7QUFFTSxTQUFTRSxxQkFBVCxDQUErQjlCLE9BQS9CLEVBQXdDO0FBQzdDLFNBQU9BLFFBQVFoQyxNQUFSLENBQWUsVUFBQzBELFlBQUQsRUFBZTFaLElBQWY7QUFBQSxXQUF3QjBaLGVBQWVMLG1CQUFtQnJaLElBQW5CLENBQXZDO0FBQUEsR0FBZixFQUFnRixDQUFoRixDQUFQO0FBQ0Q7O0FBR0Q7O0FBRUE7QUFDTyxTQUFTK1osa0JBQVQsQ0FBNEJDLFFBQTVCLEVBQXNDQyxlQUF0QyxFQUF1REMsU0FBdkQsRUFBa0U7QUFDdkUsTUFBSUYsU0FBU25aLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkIsT0FBTyxLQUFQO0FBQzNCLE1BQUltWixTQUFTblosTUFBVCxLQUFvQixDQUF4QixFQUEyQixPQUFPLElBQVA7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLE1BQUksT0FBT29aLGVBQVAsS0FBMkIsV0FBL0IsRUFBNENBLGtCQUFrQixDQUFsQjtBQUM1QztBQUNBLE1BQUksT0FBT0MsU0FBUCxLQUFxQixXQUF6QixFQUFzQ0EsWUFBWSxHQUFaLENBVGlDLENBU2hCOztBQUV2RDtBQUNBLE1BQU14TyxVQUFVc08sU0FBUyxDQUFULEVBQVl0TyxPQUFaLENBQW9CcEMsV0FBcEIsRUFBaEI7QUFDQSxPQUFLLElBQUl4RyxJQUFJLENBQWIsRUFBZ0JBLElBQUlrWCxTQUFTblosTUFBN0IsRUFBcUNpQyxHQUFyQyxFQUEwQztBQUN4QyxRQUFJLENBQUNrWCxTQUFTbFgsQ0FBVCxFQUFZNEksT0FBYixJQUF3QnNPLFNBQVNsWCxDQUFULEVBQVk0SSxPQUFaLENBQW9CcEMsV0FBcEIsT0FBc0NvQyxPQUFsRSxFQUEyRTtBQUN6RSxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxNQUFNeU8sdUJBQXdCek8sWUFBWSxJQUFaLElBQW9CQSxZQUFZLElBQWhDLElBQXdDQSxZQUFZLElBQWxGO0FBQ0EsTUFBSXlPLG9CQUFKLEVBQTBCO0FBQ3hCLFdBQU8sSUFBUDtBQUNEO0FBQ0Q7O0FBRUEsTUFBTUMsY0FBYyxFQUFwQjtBQUNBLE1BQUlDLGdCQUFnQixDQUFwQjtBQUFBLE1BQXVCQyxlQUFlLENBQXRDO0FBQ0EsT0FBSyxJQUFJeFgsS0FBSSxDQUFiLEVBQWdCQSxLQUFJa1gsU0FBU25aLE1BQTdCLEVBQXFDaUMsSUFBckMsRUFBMEM7QUFDeEMsUUFBTXlYLEtBQUtQLFNBQVNsWCxFQUFULEVBQVlzUyxTQUF2QjtBQUNBLFNBQUssSUFBSW9GLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsR0FBRzFaLE1BQXZCLEVBQStCMlosR0FBL0IsRUFBb0M7QUFDbEMsVUFBTUMsSUFBSUYsR0FBR0MsQ0FBSCxDQUFWO0FBQ0EsVUFBTUUsTUFBTSxDQUFDTixZQUFZSyxDQUFaLEtBQWtCLENBQW5CLElBQXdCLENBQXBDO0FBQ0FMLGtCQUFZSyxDQUFaLElBQWlCQyxHQUFqQjtBQUNBLFVBQUlBLE9BQU9WLFNBQVNuWixNQUFULElBQW1CLElBQUlxWixTQUF2QixDQUFYLEVBQThDO0FBQzVDRztBQUNBLFlBQUlBLGlCQUFpQkosZUFBckIsRUFBc0M7QUFDcEMsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDREs7QUFDRDtBQUNGO0FBQ0QsTUFBTUssZ0JBQWdCTCxpQkFBaUIsQ0FBdkM7QUFDQSxNQUFJSyxhQUFKLEVBQW1CO0FBQ2pCLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBU0MsNEJBQVQsQ0FBc0MzUCxFQUF0QyxFQUEwQzRQLFdBQTFDLEVBQXFFO0FBQUEsTUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUMxRSxNQUFJLE9BQU9BLFFBQVFDLHlCQUFmLEtBQTZDLFdBQWpELEVBQThEO0FBQzVERCxjQUFBLHFFQUFBQSxLQUFlQSxPQUFmLElBQXdCQywyQkFBMkJGLFlBQVloYSxNQUEvRDtBQUNEOztBQUVELE1BQUlnYSxZQUFZaGEsTUFBWixLQUF1QixDQUEzQixFQUE4QixPQUFPLENBQUNvSyxFQUFELENBQVAsQ0FMNEMsQ0FLL0I7O0FBRTNDLE1BQU1QLFNBQVMsRUFBZjtBQUNBLE1BQU04TSxXQUFXaFMsTUFBTUMsSUFBTixDQUFXd0YsR0FBR3VNLFFBQWQsQ0FBakI7O0FBRUEsTUFBTXdELHdCQUF3QnhELFNBQVNoUixNQUFULENBQWdCLGlCQUFTO0FBQ3JELFdBQU91VCxtQkFBbUIsQ0FBQ2tCLEtBQUQsRUFBUUosWUFBWSxDQUFaLENBQVIsQ0FBbkI7QUFDTDtBQUNDQSxnQkFBWWhhLE1BQVosR0FBcUIsQ0FBdEIsR0FBMkIsQ0FBM0IsR0FBK0JpYSxRQUFRYixlQUZsQyxDQUFQO0FBSUQsR0FMNkIsQ0FBOUI7QUFWMEU7QUFBQTtBQUFBOztBQUFBO0FBZ0IxRSwwQkFBbUNlLHFCQUFuQyxtSUFBMEQ7QUFBQSxVQUEvQ0Usb0JBQStDOztBQUN4RCxVQUFNQywyQkFBMkJQLDZCQUE2Qk0sb0JBQTdCLEVBQW1ETCxZQUFZamEsS0FBWixDQUFrQixDQUFsQixDQUFuRCxFQUF5RWthLE9BQXpFLENBQWpDO0FBQ0FwUSxhQUFPbkMsSUFBUCwrRkFBZTRTLHdCQUFmO0FBQ0Q7QUFuQnlFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBcUIxRSxNQUFJM0QsU0FBUzNXLE1BQVQsS0FBb0IsQ0FBcEIsSUFBeUJtYSxzQkFBc0JuYSxNQUF0QixLQUFpQzJXLFNBQVMzVyxNQUFuRSxJQUE2RWlhLFFBQVFDLHlCQUFSLEdBQW9DLENBQWpILElBQXNILENBQUNELFFBQVFNLFVBQW5JLEVBQStJO0FBQzdJO0FBQ0E7QUFDQSxRQUFNRCwyQkFBMkJQLDZCQUE2QjNQLEVBQTdCLEVBQWlDNFAsWUFBWWphLEtBQVosQ0FBa0IsQ0FBbEIsQ0FBakMsNEVBQzVCa2EsT0FENEI7QUFFL0JNLGtCQUFZO0FBRm1CLE9BQWpDO0FBSUExUSxXQUFPbkMsSUFBUCwrRkFBZTRTLHdCQUFmOztBQUVBO0FBQ0E7QUFDQSxRQUFJbFEsR0FBR3VNLFFBQUgsQ0FBWTNXLE1BQVosS0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUIsVUFBTXdhLCtCQUErQlQsNkJBQTZCM1AsR0FBR3VNLFFBQUgsQ0FBWSxDQUFaLENBQTdCLEVBQTZDcUQsV0FBN0MsNEVBQ2hDQyxPQURnQztBQUVuQ00sb0JBQVk7QUFGdUIsU0FBckM7QUFJQTFRLGFBQU9uQyxJQUFQLCtGQUFlOFMsNEJBQWY7QUFDRDtBQUNGOztBQUVELFNBQU8zUSxNQUFQO0FBQ0Q7O0FBR0Q7QUFDQTtBQUNPLFNBQVM0USxtQkFBVCxDQUE2QnJRLEVBQTdCLEVBQWlDO0FBQ3RDLE1BQUlQLFNBQVMsQ0FBQ08sRUFBRCxDQUFiOztBQUVBLE1BQU00UCxjQUFjLEVBQXBCO0FBQ0EsTUFBSTlOLFlBQVk5QixFQUFoQjtBQUNBLFNBQU84QixhQUFhQSxVQUFVSixVQUF2QixJQUFxQ0ksVUFBVUosVUFBVixDQUFxQnlJLFNBQWpFLEVBQTRFO0FBQzFFLFFBQU1tRyxXQUFXeE8sVUFBVUosVUFBVixDQUFxQjZLLFFBQXRDO0FBQ0EsUUFBTWdFLGVBQWUsQ0FBckI7QUFDQSxRQUFJRCxTQUFTMWEsTUFBVCxJQUFtQjJhLFlBQW5CLElBQW1DekIsbUJBQW1Cd0IsUUFBbkIsQ0FBdkMsRUFBcUU7QUFDbkU7QUFDQSxXQUFLLElBQUl6WSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5WSxTQUFTMWEsTUFBN0IsRUFBcUNpQyxHQUFyQyxFQUEwQztBQUFBOztBQUN4QywyQkFBT3lGLElBQVAsZ0dBQWVxUyw2QkFBNkJXLFNBQVN6WSxDQUFULENBQTdCLEVBQTBDK1gsV0FBMUMsQ0FBZjtBQUNEO0FBQ0Y7O0FBRURBLGdCQUFZM0MsT0FBWixDQUFvQm5MLFNBQXBCO0FBQ0FBLGdCQUFZQSxVQUFVSixVQUF0QjtBQUNEOztBQUVEakMsV0FBUyxvREFBQStRLENBQUsvUSxNQUFMLENBQVQ7QUFDQSxNQUFNZ1IsYUFBYSxDQUFuQjtBQUNBLE1BQUloUixPQUFPN0osTUFBUCxHQUFnQjZhLFVBQXBCLEVBQWdDO0FBQzlCaFIsYUFBU2lSLGdCQUFnQjFRLEVBQWhCLEVBQW9CUCxNQUFwQixDQUFUO0FBQ0Q7QUFDRCxNQUFJQSxPQUFPN0osTUFBUCxHQUFnQjZhLFVBQXBCLEVBQWdDO0FBQzlCaFIsYUFBU2tSLHNCQUFzQjNRLEVBQXRCLEVBQTBCUCxNQUExQixFQUFrQ2dSLFVBQWxDLENBQVQ7QUFDRDtBQUNELFNBQU9oUixNQUFQO0FBQ0Q7O0FBRUQsU0FBU2lSLGVBQVQsQ0FBeUIxUSxFQUF6QixFQUE2QjRRLElBQTdCLEVBQW1DO0FBQ2pDLFNBQU9BLEtBQUtyVixNQUFMLENBQVk7QUFBQSxXQUFPc1YsSUFBSXBRLE9BQUosS0FBZ0JULEdBQUdTLE9BQTFCO0FBQUEsR0FBWixDQUFQO0FBQ0Q7O0FBRUQsSUFBTXFRLHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQUNsYixNQUFELEVBQVN1VSxTQUFUO0FBQUEsU0FBdUIsVUFBQzBHLEdBQUQ7QUFBQSxXQUNoRCwyREFBQUUsQ0FBYUYsSUFBSTFHLFNBQWpCLEVBQTRCQSxTQUE1QixFQUF1Q3ZVLE1BQXZDLElBQWlEQSxNQUREO0FBQUEsR0FBdkI7QUFBQSxDQUEzQjs7QUFHTyxTQUFTK2EscUJBQVQsQ0FBK0IzUSxFQUEvQixFQUFtQzRRLElBQW5DLEVBQXlDSSxTQUF6QyxFQUFvRDtBQUN6RCxNQUFJQyxjQUFjLEVBQWxCO0FBQ0EsTUFBTTNCLEtBQUt0UCxHQUFHbUssU0FBZDs7QUFFQSxPQUNFLElBQUkrRyxpQkFBaUI1QixHQUFHMVosTUFEMUIsRUFFRXFiLFlBQVlyYixNQUFaLEdBQXFCb2IsU0FBckIsSUFBa0NFLGlCQUFpQixDQUZyRCxFQUdFQSxnQkFIRixFQUlFO0FBQ0FELGtCQUFjTCxLQUFLclYsTUFBTCxDQUFZdVYsbUJBQW1CSSxjQUFuQixFQUFtQzVCLEVBQW5DLENBQVosQ0FBZDtBQUNEO0FBQ0QsU0FBTzJCLFlBQVlyYixNQUFaLEdBQXFCb2IsU0FBckIsR0FBaUNKLElBQWpDLEdBQXdDSyxXQUEvQztBQUNEOztBQUlEO0FBQ0EsU0FBVXpILFVBQVYsQ0FBcUJ6VSxJQUFyQixFQUEyQm9jLFlBQTNCO0FBQUEsTUFBeUN0QixPQUF6Qyx1RUFBbUQsRUFBbkQ7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQ0FDcUZBLE9BRHJGLENBQ1V1QixhQURWLEVBQ1VBLGFBRFYseUNBQzBCLEtBRDFCLGlEQUNxRnZCLE9BRHJGLENBQ2lDd0IsV0FEakMsRUFDaUNBLFdBRGpDLHdDQUMrQyxLQUQvQyxpREFDcUZ4QixPQURyRixDQUNzRHlCLGtCQUR0RCxFQUNzREEsa0JBRHRELHlDQUMyRSxLQUQzRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBR21CcEUsb0JBSG5COztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR1d4VSxjQUhYOztBQUFBLGdCQUtRLEVBQUVBLFFBQVEzRCxJQUFWLEtBQW1Cb2MsYUFBYXpZLElBQWIsQ0FMM0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSwyRkFNZ0IzRCxJQU5oQixtRkFNdUIyRCxJQU52QixFQU04QnlZLGFBQWF6WSxJQUFiLENBTjlCOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQSxlQVVNMlksV0FWTjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxlQVdRRixhQUFhcEgsSUFYckI7QUFBQTtBQUFBO0FBQUE7O0FBWVlBLGNBWlosR0FZbUJvSCxhQUFhcEgsSUFaaEM7O0FBQUEsZ0JBY1UsT0FBT2hWLEtBQUtnVixJQUFaLEtBQXFCLFdBZC9CO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkZBZ0JhaFYsSUFoQmI7QUFpQlVnVjtBQWpCVjs7QUFBQTtBQUFBLGVBdUJNb0gsYUFBYXZFLE9BdkJuQjtBQUFBO0FBQUE7QUFBQTs7QUF3QlVBLGlCQXhCVixHQXdCb0J1RSxhQUFhdkUsT0F4QmpDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkEwQnlCQSxPQTFCekI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQmUyRSxnQkExQmY7O0FBQUEsZ0JBMkJVLENBQUN4YyxLQUFLNlgsT0FBTixJQUFpQjdYLEtBQUs2WCxPQUFMLENBQWFULE9BQWIsQ0FBcUJvRixNQUFyQixNQUFpQyxDQUFDLENBM0I3RDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDJGQThCYXhjLElBOUJiO0FBK0JVNlgsK0JBQUEsK0VBQUFBLENBQ003WCxLQUFLNlgsT0FBTCxJQUFnQixFQUR0QixJQUVFMkUsTUFGRjtBQS9CVjs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUEsZUF3Q01KLGFBQWFyRyxVQXhDbkI7QUFBQTtBQUFBO0FBQUE7O0FBeUNVQSxvQkF6Q1YsR0F5Q3VCLG9EQUFBMEMsQ0FBSzJELGFBQWFyRyxVQUFsQixFQUE4QnFDLG1CQUE5QixDQXpDdkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQTJDZ0NNLE9BQU9DLElBQVAsQ0FBWTVDLFVBQVosQ0EzQ2hDOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBMkNlNkMsdUJBM0NmO0FBNENZQyx3QkE1Q1osR0E0QzZCOUMsV0FBVzZDLGFBQVgsQ0E1QzdCOztBQUFBLGdCQTZDVSxDQUFDNVksS0FBSytWLFVBQU4sSUFBb0IsT0FBTy9WLEtBQUsrVixVQUFMLENBQWdCNkMsYUFBaEIsQ0FBUCxLQUEwQyxXQTdDeEU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSwyRkFnRGE1WSxJQWhEYjtBQWlEVStWLHdCQUFBLHFFQUFBQSxLQUNLL1YsS0FBSytWLFVBRFYsbUZBRUc2QyxhQUZILEVBRW1CQyxjQUZuQjtBQWpEVjs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUEsY0EwRE93RCxhQTFEUDtBQUFBO0FBQUE7QUFBQTs7QUFBQSxnQkEyRFFELGFBQWE3RSxVQUFiLElBQTJCLElBM0RuQztBQUFBO0FBQUE7QUFBQTs7QUE0RFlBLG9CQTVEWixHQTREeUI2RSxhQUFhN0UsVUE1RHRDOztBQUFBLGdCQThEVSxPQUFPdlgsS0FBS3VYLFVBQVosS0FBMkIsV0E5RHJDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkZBZ0VldlgsSUFoRWY7QUFpRVV1WDtBQWpFVjs7QUFBQTtBQUFBLGVBdUVNZ0Ysa0JBdkVOO0FBQUE7QUFBQTtBQUFBOztBQUFBLGNBd0VTdmMsS0FBS2taLFdBeEVkO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsMkZBMEVhbFosSUExRWI7QUEyRVFrWix5QkFBYTtBQTNFckI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBbUZBLFNBQVN1RCxZQUFULENBQXNCQyxLQUF0QixFQUE2QnpVLEtBQTdCLEVBQW9DNUUsS0FBcEMsRUFBMkM7QUFDekMsbUdBQVdxWixNQUFNOWIsS0FBTixDQUFZLENBQVosRUFBZXFILEtBQWYsQ0FBWCxJQUFrQzVFLEtBQWxDLG1GQUE0Q3FaLE1BQU05YixLQUFOLENBQVlxSCxRQUFNLENBQWxCLENBQTVDO0FBQ0Q7O0FBRUQsU0FBUzBVLHNCQUFULENBQWdDalgsUUFBaEMsRUFBMENzUyxPQUExQyxFQUFtRDRFLFdBQW5ELEVBQWdFOVosQ0FBaEUsRUFBbUU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDakUsMEJBQTJCMlIsV0FBV3VELFFBQVFsVixDQUFSLENBQVgsRUFBdUI4WixZQUFZOVosQ0FBWixDQUF2QixFQUF1QztBQUNoRXVaLHFCQUFlLEtBRGlEO0FBRWhFQyxtQkFBYXhaLE1BQU1rVixRQUFRblgsTUFBUixHQUFpQixDQUY0QjtBQUdoRTBiLDBCQUFvQnpaLElBQUksQ0FBSixJQUFTLENBQUMsdURBQUErWixDQUFRN0UsUUFBUWxWLElBQUksQ0FBWixDQUFSO0FBSGtDLEtBQXZDLENBQTNCLG1JQUlJO0FBQUEsVUFKT2dhLFlBSVA7O0FBQ0YsVUFBTUMsa0JBQWtCTixhQUFhekUsT0FBYixFQUFzQmxWLENBQXRCLEVBQXlCZ2EsWUFBekIsQ0FBeEI7QUFDQSxVQUFNRSxnQkFBZ0I1RCxhQUFhMVQsUUFBYixFQUF1QnFYLGVBQXZCLENBQXRCO0FBQ0EsVUFBSUMsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCO0FBQ0EsZUFBT0wsdUJBQXVCalgsUUFBdkIsRUFBaUNxWCxlQUFqQyxFQUFrREgsV0FBbEQsRUFBK0Q5WixDQUEvRCxDQUFQO0FBQ0Q7QUFDRjtBQVpnRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWNqRSxTQUFPa1YsT0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxTQUFTaUYsaUJBQVQsQ0FBMkJ2WCxRQUEzQixFQUFxQ3NTLE9BQXJDLEVBQThDNEUsV0FBOUMsRUFBMkQ7QUFDekQsT0FBSyxJQUFJOVosSUFBSWtWLFFBQVFuWCxNQUFSLEdBQWlCLENBQTlCLEVBQWlDaUMsS0FBSyxDQUF0QyxFQUF5Q0EsR0FBekMsRUFBOEM7QUFDNUNrVixjQUFVMkUsdUJBQXVCalgsUUFBdkIsRUFBaUNzUyxPQUFqQyxFQUEwQzRFLFdBQTFDLEVBQXVEOVosQ0FBdkQsQ0FBVjtBQUNEOztBQUVELFNBQU9rVixPQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQVNrRixjQUFULENBQXdCTixXQUF4QixFQUFvRDtBQUFBLE1BQWZPLEtBQWUsdUVBQVAsS0FBTzs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBT1AsWUFBWTlhLEdBQVosQ0FBZ0IsVUFBQzhFLENBQUQsRUFBSTlELENBQUosRUFBVTtBQUMvQixRQUFJcWEsU0FBVXJhLE1BQU04WixZQUFZL2IsTUFBWixHQUFxQixDQUFyQyxJQUEyQytGLEVBQUU4RSxPQUFGLEtBQWMsS0FBN0QsRUFBb0UsT0FBTyxFQUFQLENBRHJDLENBQ2dEOztBQUUvRSxRQUFNMFIsVUFBVTtBQUNkMVIsZUFBUzlFLEVBQUU4RTtBQURHLEtBQWhCO0FBR0E7QUFDQSxRQUFJOUUsRUFBRThFLE9BQUYsS0FBYyxPQUFkLElBQXlCOUUsRUFBRW1QLFVBQTNCLElBQXlDblAsRUFBRW1QLFVBQUYsQ0FBYWxPLElBQTFELEVBQWdFO0FBQzlEdVYsY0FBUXJILFVBQVIsR0FBcUIsRUFBQ2xPLE1BQU1qQixFQUFFbVAsVUFBRixDQUFhbE8sSUFBcEIsRUFBckI7QUFDRDtBQUNELFdBQU91VixPQUFQO0FBQ0QsR0FYTSxDQUFQO0FBWUQ7O0FBRUQ7QUFDQTtBQUNBLFNBQVNDLGdCQUFULENBQTBCckYsT0FBMUIsRUFBbUM7QUFDakMsTUFBTXNGLG9CQUFvQnRGLFFBQVF4UixNQUFSLENBQWU7QUFBQSxXQUFLLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUJ4RCxTQUFqQixFQUE0Qm9VLE9BQTVCLENBQW9DeFEsRUFBRThFLE9BQXRDLE1BQW1ELENBQUMsQ0FBekQ7QUFBQSxHQUFmLENBQTFCO0FBQ0EsU0FBTzRSLGtCQUFrQnpjLE1BQWxCLEtBQTZCLENBQTdCLElBQWtDLHFEQUFBaUwsQ0FBTXdSLGlCQUFOLEVBQXlCO0FBQUEsV0FDaEUscURBQUF4UixDQUFNNE0sT0FBT0MsSUFBUCxDQUFZL1IsQ0FBWixDQUFOLEVBQXNCO0FBQUEsYUFBTyxDQUFDLFNBQUQsRUFBWSxZQUFaLEVBQTBCLGFBQTFCLEVBQXlDd1EsT0FBekMsQ0FBaUQ5VCxHQUFqRCxLQUF5RCxDQUFoRTtBQUFBLEtBQXRCLENBRGdFO0FBQUEsR0FBekIsQ0FBekM7QUFHRDs7QUFFRCxTQUFTaWEsWUFBVCxDQUFzQjdYLFFBQXRCLEVBQWdDa1gsV0FBaEMsRUFBa0U7QUFBQSxNQUFyQlksYUFBcUIsdUVBQVAsS0FBTzs7QUFDaEU7O0FBRUEsTUFBSUMsYUFBYVAsZUFBZU4sV0FBZixDQUFqQjtBQUNBLE1BQUljLFdBQVd0RSxhQUFhMVQsUUFBYixFQUF1QitYLFVBQXZCLENBQWY7QUFDQSxNQUFJQyxhQUFhLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0FELGlCQUFhUCxlQUFlTixXQUFmLEVBQTRCLElBQTVCLENBQWI7QUFDQWMsZUFBV3RFLGFBQWExVCxRQUFiLEVBQXVCK1gsVUFBdkIsQ0FBWDtBQUNBLFFBQUlDLGFBQWEsQ0FBakIsRUFBb0I7QUFDbEIzWixhQUFPaEUsS0FBUCxDQUFhLHFFQUFiLEVBQW9GNmMsV0FBcEY7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELE1BQU1HLGtCQUFrQkUsa0JBQWtCdlgsUUFBbEIsRUFBNEIrWCxVQUE1QixFQUF3Q2IsV0FBeEMsQ0FBeEI7QUFDQSxNQUFNSSxnQkFBZ0I1RCxhQUFhMVQsUUFBYixFQUF1QnFYLGVBQXZCLENBQXRCO0FBQ0FoWixTQUFPaEUsS0FBUCxDQUFhLGNBQWIsRUFBNkJnZCxlQUE3QixFQUE4Q0MsYUFBOUM7O0FBRUEsTUFBSUEsa0JBQWtCLENBQWxCLElBQXVCUSxhQUEzQixFQUEwQztBQUN4QyxRQUFJSCxpQkFBaUJOLGVBQWpCLENBQUosRUFBdUMsT0FBTyxJQUFQO0FBQ3ZDLFdBQU9BLGVBQVA7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTWSxhQUFULENBQXVCM0YsT0FBdkIsRUFBOEM7QUFBQSxNQUFkOEMsT0FBYyx1RUFBSixFQUFJOztBQUNuRCxNQUFJLENBQUM5QyxPQUFMLEVBQWMsT0FBTyxFQUFFL00sSUFBSSxJQUFOLEVBQVkwSixPQUFPLElBQW5CLEVBQXlCaUosT0FBTyxDQUFoQyxFQUFQO0FBQ2QsTUFBSSxDQUFDcFksTUFBTWpDLE9BQU4sQ0FBY3lVLE9BQWQsQ0FBTCxFQUE2QjtBQUMzQixVQUFNLElBQUl6VCxLQUFKLENBQVUsc0NBQXNDc1osS0FBS0MsU0FBTCxDQUFlOUYsT0FBZixDQUFoRCxDQUFOO0FBQ0Q7QUFDRCxNQUFNdFMsV0FBV29WLFFBQVFwVixRQUFSLElBQW9CcEIsT0FBT29CLFFBQTVDOztBQUVBM0IsU0FBT2hFLEtBQVAsQ0FBYSxVQUFiLEVBQXlCaVksT0FBekI7O0FBRUEsTUFBTStGLGtCQUFrQlIsYUFBYTdYLFFBQWIsRUFBdUJzUyxPQUF2QixFQUFnQzhDLFFBQVFrRCxlQUF4QyxDQUF4Qjs7QUFFQSxNQUFJRCxlQUFKLEVBQXFCO0FBQUEsd0JBQ0VqRixhQUFhcFQsUUFBYixFQUF1QnFZLGVBQXZCLENBREY7QUFBQSxRQUNicEosS0FEYSxpQkFDYkEsS0FEYTtBQUFBLFFBQ05FLEdBRE0saUJBQ05BLEdBRE07O0FBR25CLFFBQUlpRyxRQUFRa0QsZUFBWixFQUE2QjtBQUMzQixVQUFNQyxjQUFjcEosR0FBcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFJQSxJQUFJaFUsTUFBUixFQUFnQjtBQUNkZ1UsY0FBTUEsSUFBSXFKLE1BQUosQ0FBVzVDLG9CQUFvQnpHLElBQUksQ0FBSixDQUFwQixDQUFYLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQUEsWUFBTSx3REFBQXNKLENBQVN0SixHQUFULEVBQWMsVUFBQ3VKLEdBQUQsRUFBTUMsR0FBTjtBQUFBLGVBQWNELFFBQVFDLEdBQVIsSUFBZUQsSUFBSUUsUUFBSixDQUFhRCxHQUFiLENBQTdCO0FBQUEsT0FBZCxDQUFOO0FBQ0EsYUFBTyxFQUFFMUosWUFBRixFQUFTMUosSUFBSTRKLEdBQWIsRUFBa0IrSSxPQUFPOUQsc0JBQXNCaUUsZUFBdEIsQ0FBekIsRUFBUDtBQUNELEtBaEJELE1BZ0JPO0FBQ0wsYUFBTyxFQUFFcEosWUFBRixFQUFTMUosSUFBSTRKLElBQUksQ0FBSixDQUFiLEVBQXFCK0ksT0FBTzlELHNCQUFzQmlFLGVBQXRCLENBQTVCLEVBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sRUFBRTlTLElBQUksSUFBTixFQUFZMEosT0FBTyxFQUFuQixFQUF1QmlKLE9BQU8sQ0FBOUIsRUFBUDtBQUVELEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDem5CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBTTdaLFNBQVMsdUdBQUF2QyxDQUFjd0MsVUFBZCxDQUFmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQU11YSxVQUFVLElBQUksMkRBQUosRUFBaEI7O0lBRXFCQyxXOzs7QUFDbkIsdUJBQVlsYixHQUFaLEVBQWlCbWIsVUFBakIsRUFBNkI7QUFBQTs7QUFBQTs7QUFHM0IsVUFBS25iLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFVBQUttYixVQUFMLEdBQWtCQSxVQUFsQjs7QUFFQSxVQUFLQyxpQkFBTDtBQU4yQjtBQU81Qjs7Ozt3Q0FFbUI7QUFBQTs7QUFDbEI7QUFDQXBhLGFBQU9nRSxnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxVQUFDNEosQ0FBRCxFQUFPO0FBQ3hDLFlBQUlBLEVBQUU1TyxHQUFGLEtBQVUsT0FBS0EsR0FBbkIsRUFBd0I7QUFDdEIsY0FBTXFiLGFBQWE7QUFDakJ2USxzQkFBVThELEVBQUU5RCxRQUFGLElBQWN5UCxLQUFLZSxLQUFMLENBQVcxTSxFQUFFOUQsUUFBYixDQURQO0FBRWpCeVEsc0JBQVUzTSxFQUFFMk0sUUFBRixJQUFjaEIsS0FBS2UsS0FBTCxDQUFXMU0sRUFBRTJNLFFBQWIsQ0FGUDtBQUdqQkMsd0JBQVlwYSxLQUFLcWEsR0FBTDtBQUhLLFdBQW5CO0FBS0EsaUJBQUtDLElBQUwsQ0FBVSxRQUFWLEVBQW9CTCxVQUFwQjtBQUNEO0FBQ0YsT0FURDs7QUFXQUosY0FBUTNVLEVBQVIsQ0FBVyxRQUFYLEVBQXFCLFVBQUN0RyxHQUFELEVBQWtCO0FBQUEsMENBQVQyYixJQUFTO0FBQVRBLGNBQVM7QUFBQTs7QUFDckMsWUFBSTNiLFFBQVEsT0FBS0EsR0FBakIsRUFBc0I7QUFDcEIsaUJBQUswYixJQUFMLGdCQUFVLFFBQVYsU0FBdUJDLElBQXZCO0FBQ0Q7QUFDRixPQUpEO0FBS0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7d0JBQ0l0RyxJLEVBQU07QUFBQTs7QUFDUjtBQUNBLGFBQU91RyxRQUFRQyxPQUFSLEdBQWtCQyxJQUFsQixDQUF1QixZQUFNO0FBQ2xDLFlBQUlDLGFBQWFDLGFBQWFDLE9BQWIsQ0FBcUIsT0FBS2pjLEdBQTFCLENBQWpCOztBQUVBLFlBQUksQ0FBQytiLFVBQUwsRUFBaUJBLGFBQWEsRUFBYixDQUFqQixLQUNLQSxhQUFheEIsS0FBS2UsS0FBTCxDQUFXUyxVQUFYLENBQWI7O0FBRUwsWUFBSTFHLFNBQVMsSUFBVCxJQUFpQixPQUFPQSxJQUFQLEtBQWdCLFdBQXJDLEVBQWtELE9BQU8wRyxVQUFQO0FBQ2xELFlBQUk3WixNQUFNakMsT0FBTixDQUFjb1YsSUFBZCxDQUFKLEVBQXlCLE9BQU8sb0RBQUF4SCxDQUFLa08sVUFBTCxFQUFpQjFHLElBQWpCLENBQVA7QUFDekIsWUFBSSxRQUFPQSxJQUFQLHNHQUFPQSxJQUFQLE9BQWdCLFFBQXBCLEVBQThCO0FBQzVCLGNBQU1qTyxTQUFTLG9EQUFBeUcsQ0FBS2tPLFVBQUwsRUFBaUIzRyxPQUFPQyxJQUFQLENBQVlBLElBQVosQ0FBakIsQ0FBZjtBQUNBLGlCQUFPLHVEQUFBNkcsQ0FBUzlVLE1BQVQsRUFBaUJpTyxJQUFqQixDQUFQO0FBQ0Q7QUFDRCxlQUFPMEcsV0FBVzFHLElBQVgsQ0FBUDtBQUNELE9BYk0sQ0FBUDtBQWNEOztBQUVEO0FBQ0E7Ozs7a0NBQ2N2USxFLEVBQUk7QUFBQTs7QUFDaEIsVUFBSSxLQUFLcVcsVUFBTCxLQUFvQixXQUF4QixFQUFxQztBQUNuQyxjQUFNLHdDQUFOO0FBQ0Q7O0FBRUQsYUFBT1MsUUFBUUMsT0FBUixHQUFrQkMsSUFBbEIsQ0FBdUIsWUFBTTtBQUNsQyxZQUFJQyxhQUFhQyxhQUFhQyxPQUFiLENBQXFCLE9BQUtqYyxHQUExQixDQUFqQjs7QUFFQSxZQUFJOEssaUJBQUo7QUFDQSxZQUFJLENBQUNpUixVQUFMLEVBQWlCO0FBQ2ZBLHVCQUFhLEVBQWI7QUFDQWpSLHFCQUFXLElBQVg7QUFDRCxTQUhELE1BR087QUFDTGlSLHVCQUFheEIsS0FBS2UsS0FBTCxDQUFXUyxVQUFYLENBQWI7QUFDQWpSLHFCQUFXLHdEQUFBbkwsQ0FBVW9jLFVBQVYsQ0FBWCxDQUZLLENBRTZCO0FBQ25DOztBQUVEQSxxQkFBYWpYLEdBQUdpWCxVQUFILENBQWI7O0FBRUEsWUFBSSxDQUFDLHVEQUFBSSxDQUFRSixVQUFSLEVBQW9CalIsUUFBcEIsQ0FBTCxFQUFvQztBQUFFO0FBQ3BDa1IsdUJBQWFJLE9BQWIsQ0FBcUIsT0FBS3BjLEdBQTFCLEVBQStCdWEsS0FBS0MsU0FBTCxDQUFldUIsVUFBZixDQUEvQjs7QUFFQTtBQUNBLGNBQU1WLGFBQWEsRUFBRXZRLGtCQUFGLEVBQVl5USxVQUFVUSxVQUF0QixFQUFrQ1AsWUFBWXBhLEtBQUtxYSxHQUFMLEVBQTlDLEVBQW5CO0FBQ0FSLGtCQUFRUyxJQUFSLENBQWEsUUFBYixFQUF1QixPQUFLMWIsR0FBNUIsRUFBaUNxYixVQUFqQztBQUNBO0FBQ0E7QUFDQWdCLFVBQUEsZ0VBQUFBLENBQWNYLElBQWQsQ0FBbUIsUUFBbkIsRUFBNkIsT0FBSzFiLEdBQWxDLEVBQXVDcWIsVUFBdkM7QUFDRDtBQUNGLE9BeEJNLENBQVA7QUF5QkQ7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3dCQUNJaUIsSyxFQUFPO0FBQ1QsVUFBSSxLQUFLbkIsVUFBTCxLQUFvQixXQUF4QixFQUFxQztBQUNuQyxjQUFNLHdDQUFOO0FBQ0Q7O0FBRUQxYSxhQUFPaEUsS0FBUCxDQUFhLEtBQWIsRUFBb0I2ZixLQUFwQjtBQUNBLGFBQU8sS0FBS0MsYUFBTCxDQUFtQjtBQUFBLGVBQWNuSCxPQUFPb0gsTUFBUCxDQUFjLEVBQWQsRUFBa0JULFVBQWxCLEVBQThCTyxLQUE5QixDQUFkO0FBQUEsT0FBbkIsQ0FBUDtBQUNEOzs7OEJBRVNBLEssRUFBTztBQUNmLFVBQUksS0FBS25CLFVBQUwsS0FBb0IsV0FBeEIsRUFBcUM7QUFDbkMsY0FBTSx3Q0FBTjtBQUNEOztBQUVELFVBQUksQ0FBQ21CLEtBQUQsSUFBVSxzREFBQS9DLENBQVErQyxLQUFSLENBQWQsRUFBOEIsT0FBT1YsUUFBUUMsT0FBUixFQUFQO0FBQzlCcGIsYUFBT2hFLEtBQVAsQ0FBYSxXQUFiLEVBQTBCNmYsS0FBMUI7QUFDQSxhQUFPLEtBQUtDLGFBQUwsQ0FBbUIsc0JBQWM7QUFDdEMzWixRQUFBLHNEQUFBQSxDQUFRMFosS0FBUixFQUFlLFVBQUN2YyxLQUFELEVBQVE2SyxJQUFSLEVBQWlCO0FBQzlCLGNBQUk2Uix3QkFBSjtBQUNBLGNBQUksT0FBTzFjLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0IwYyw4QkFBa0IxYyxNQUFNLGtEQUFBaEIsQ0FBSWdkLFVBQUosRUFBZ0JuUixJQUFoQixDQUFOLENBQWxCO0FBQ0QsV0FGRCxNQUVPO0FBQ0w2Uiw4QkFBa0IxYyxLQUFsQjtBQUNEOztBQUVEZ2MsdUJBQWEsbURBQUFXLENBQUlYLFVBQUosRUFBZ0JuUixJQUFoQixFQUFzQjZSLGVBQXRCLENBQWI7QUFDRCxTQVREO0FBVUEsZUFBT1YsVUFBUDtBQUNELE9BWk0sQ0FBUDtBQWFEOzs7aUNBRVluUixJLEVBQU03SyxLLEVBQU87QUFDeEIsVUFBSSxLQUFLb2IsVUFBTCxLQUFvQixXQUF4QixFQUFxQztBQUNuQyxjQUFNLHdDQUFOO0FBQ0Q7O0FBRUQxYSxhQUFPaEUsS0FBUCxDQUFhLGNBQWIsRUFBNkJtTyxJQUE3QixFQUFtQzdLLEtBQW5DO0FBQ0EsYUFBTyxLQUFLd2MsYUFBTCxDQUFtQixzQkFBYztBQUN0QyxZQUFJRSx3QkFBSjtBQUNBLFlBQUksT0FBTzFjLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0IwYyw0QkFBa0IxYyxNQUFNLGtEQUFBaEIsQ0FBSWdkLFVBQUosRUFBZ0JuUixJQUFoQixDQUFOLENBQWxCO0FBQ0QsU0FGRCxNQUVPO0FBQ0w2Uiw0QkFBa0IxYyxLQUFsQjtBQUNEOztBQUVEO0FBQ0EsWUFBSSxPQUFPMGMsZUFBUCxLQUEyQixXQUEvQixFQUE0QyxPQUFPVixVQUFQOztBQUU1QyxlQUFPLG1EQUFBVyxDQUFJWCxVQUFKLEVBQWdCblIsSUFBaEIsRUFBc0J3SyxPQUFPb0gsTUFBUCxDQUFjLEVBQWQsRUFBa0Isa0RBQUF6ZCxDQUFJZ2QsVUFBSixFQUFnQm5SLElBQWhCLEVBQXNCLEVBQXRCLENBQWxCLEVBQTZDNlIsZUFBN0MsQ0FBdEIsQ0FBUDtBQUNELE9BWk0sQ0FBUDtBQWFEOzs7NEJBRU87QUFBQTs7QUFDTixVQUFJLEtBQUt0QixVQUFMLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ25DLGNBQU0sd0NBQU47QUFDRDs7QUFFRDFhLGFBQU9oRSxLQUFQLENBQWEsT0FBYjtBQUNBLGFBQU9tZixRQUFRQyxPQUFSLEdBQWtCQyxJQUFsQixDQUF1QixZQUFNO0FBQ2xDLFlBQUlDLGFBQWFDLGFBQWFDLE9BQWIsQ0FBcUIsT0FBS2pjLEdBQTFCLENBQWpCO0FBQ0EsWUFBSSxDQUFDK2IsVUFBTCxFQUFpQkEsYUFBYSxFQUFiLENBQWpCLEtBQ0tBLGFBQWF4QixLQUFLZSxLQUFMLENBQVdTLFVBQVgsQ0FBYjs7QUFFTEMscUJBQWFXLFVBQWIsQ0FBd0IsT0FBSzNjLEdBQTdCOztBQUVBO0FBQ0EsWUFBTXFiLGFBQWEsRUFBRXZRLFVBQVVpUixVQUFaLEVBQXdCUixVQUFVLElBQWxDLEVBQXdDQyxZQUFZcGEsS0FBS3FhLEdBQUwsRUFBcEQsRUFBbkI7QUFDQVIsZ0JBQVFTLElBQVIsQ0FBYSxRQUFiLEVBQXVCLE9BQUsxYixHQUE1QixFQUFpQ3FiLFVBQWpDO0FBQ0E7QUFDQTtBQUNBZ0IsUUFBQSxnRUFBQUEsQ0FBY1gsSUFBZCxDQUFtQixRQUFuQixFQUE2QixPQUFLMWIsR0FBbEMsRUFBdUNxYixVQUF2QztBQUNELE9BYk0sQ0FBUDtBQWNEOzs7OEJBRVN6USxJLEVBQU07QUFBQTs7QUFDZDtBQUNBLGFBQU9nUixRQUFRQyxPQUFSLEdBQWtCQyxJQUFsQixDQUF1QixZQUFNO0FBQ2xDLFlBQUlDLGFBQWFDLGFBQWFDLE9BQWIsQ0FBcUIsT0FBS2pjLEdBQTFCLENBQWpCOztBQUVBLFlBQUksQ0FBQytiLFVBQUwsRUFBaUJBLGFBQWEsRUFBYixDQUFqQixLQUNLQSxhQUFheEIsS0FBS2UsS0FBTCxDQUFXUyxVQUFYLENBQWI7O0FBRUwsZUFBTyxrREFBQWhkLENBQUlnZCxVQUFKLEVBQWdCblIsSUFBaEIsQ0FBUDtBQUNELE9BUE0sQ0FBUDtBQVFEOzs7aUNBRVlBLEksRUFBTTtBQUNqQixVQUFJLEtBQUt1USxVQUFMLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ25DLGNBQU0sd0NBQU47QUFDRDs7QUFFRCxVQUFJLENBQUN2USxJQUFMLEVBQVcsT0FBT2dSLFFBQVFDLE9BQVIsRUFBUDtBQUNYLFVBQUksQ0FBQzNaLE1BQU1qQyxPQUFOLENBQWMySyxJQUFkLENBQUwsRUFBMEJBLE9BQU8sQ0FBQ0EsSUFBRCxDQUFQO0FBQzFCLFVBQUlBLEtBQUtyTixNQUFMLEtBQWdCLENBQXBCLEVBQXVCLE9BQU9xZSxRQUFRQyxPQUFSLEVBQVA7QUFDdkJwYixhQUFPaEUsS0FBUCxDQUFhLGNBQWIsRUFBNkJtTyxJQUE3QjtBQUNBLGFBQU8sS0FBSzJSLGFBQUwsQ0FBbUI7QUFBQSxlQUFjLG9EQUFBcEgsQ0FBSzRHLFVBQUwsRUFBaUJuUixJQUFqQixDQUFkO0FBQUEsT0FBbkIsQ0FBUDtBQUNEOzs7O0VBNUxzQywyRDs7Ozs7Ozs7O0FDcEJ6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOzs7Ozs7O0FDeEpBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBOzs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2xDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTLEdBQUcsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQStDO0FBQ3JELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsRUFBRTtBQUNuRCxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTs7QUFFTyxJQUFNZ1Msa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFDOWEsS0FBRCxFQUFRMEIsSUFBUixFQUFpQjtBQUM5QyxNQUFNZCxVQUFVO0FBQ2RaLGdCQURjLEVBQ1AwQixVQURPLEVBQ0RyQixNQUFNLGtGQUFBNUQsQ0FBVSxVQUFWLENBREwsRUFDNEJzZSxJQUFJLGtGQUFBdGUsQ0FBVSxTQUFWO0FBRGhDLEdBQWhCO0FBR0F5QyxTQUFPeUIsR0FBUCxDQUFXSyxXQUFYLENBQXVCSixPQUF2QixFQUFnQyxHQUFoQztBQUNELENBTE07O0FBT0EsSUFBTW9hLDBCQUEwQixTQUExQkEsdUJBQTBCLENBQUNyWSxPQUFELEVBQWE7QUFDbERYLEVBQUEsZ0hBQUFBLENBQWtCLFNBQWxCLEVBQTZCLFVBQUNQLEtBQUQsRUFBVztBQUN0QyxRQUFNYixVQUFVYSxNQUFNQyxJQUF0QjtBQUNBLFFBQUksUUFBT2QsT0FBUCxzR0FBT0EsT0FBUCxPQUFtQixRQUFuQixJQUErQkEsWUFBWSxJQUEvQyxFQUFxRDtBQUNyRCxRQUNFQSxRQUFRUCxJQUFSLEtBQWlCLGtGQUFBNUQsQ0FBVSxVQUFWLENBQWpCLElBQ0FtRSxRQUFRbWEsRUFBUixLQUFlLGtGQUFBdGUsQ0FBVSxTQUFWLENBRmpCLEVBR0U7O0FBRUYsUUFBTXdlLGFBQWMvYixPQUFPaUIsTUFBUCxLQUFrQmpCLE1BQXRDO0FBQ0EsUUFBSSxDQUFDK2IsVUFBTCxFQUFpQjs7QUFFakJ0WSxZQUFRL0IsT0FBUjtBQUNELEdBWkQ7QUFhRCxDQWRNLEM7Ozs7OztBQ1ZQO0FBQ0E7QUFDQSxnRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBOztBQUVBOztJQUVxQnNhLEk7OztBQUVuQixrQkFBZ0Q7QUFBQSxRQUFwQ0MsS0FBb0MsdUVBQTVCLElBQTRCOztBQUFBLFFBQXRCamUsSUFBc0IsdUVBQWYsRUFBZTtBQUFBLFFBQVhrSCxTQUFXOztBQUFBOztBQUFBOztBQUU5QyxVQUFLQSxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFVBQUsrVyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxVQUFLamUsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsVUFBS2tlLGFBQUw7QUFMOEM7QUFNL0M7Ozs7OEJBTVM7QUFDUixXQUFLQSxhQUFMO0FBQ0Q7OztvQ0FFZTtBQUNkO0FBQ0Q7OztpQ0FFWTtBQUNYO0FBQ0Q7OztzQ0FFaUI7QUFDaEI7QUFDRDs7O3lCQUVJeGEsTyxFQUFTeWEsZSxFQUErQjtBQUMzQzs7QUFEMkMsVUFBZDNGLE9BQWMsdUVBQUosRUFBSTtBQUU1Qzs7O21DQUVjO0FBQ2IsV0FBS2tFLElBQUwsQ0FBVSxXQUFWO0FBQ0Q7OztvQ0FFZTllLEssRUFBTztBQUNyQixXQUFLcWdCLEtBQUwsR0FBYSxJQUFiO0FBQ0EsV0FBS3ZCLElBQUwsQ0FBVSxjQUFWLEVBQTBCOWUsS0FBMUI7QUFDRDs7OzBDQUVxQjtBQUFBOztBQUNwQixVQUFJLEtBQUt3Z0IsMEJBQVQsRUFBcUMsT0FBTyxLQUFLQSwwQkFBWjtBQUNyQyxhQUFPLEtBQUtBLDBCQUFMLEdBQWtDLElBQUl4QixPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFhO0FBQ2hFLFlBQUksT0FBSzNWLFNBQUwsQ0FBZW1YLE9BQW5CLEVBQTRCeEIsVUFBNUIsS0FDSyxPQUFLM1YsU0FBTCxDQUFlb1gsSUFBZixDQUFvQixPQUFwQixFQUE2QnpCLE9BQTdCO0FBQ04sT0FId0MsQ0FBekM7QUFJRDs7O3VDQUVrQm5aLE8sRUFBUzZhLE8sRUFBUztBQUFBOztBQUNuQztBQUNBO0FBQ0E7QUFDQSxXQUFLQyxtQkFBTCxHQUEyQjFCLElBQTNCLENBQWdDLFlBQU07QUFDcEMsZUFBS0osSUFBTCxDQUFVLFNBQVYsRUFBcUJoWixPQUFyQixFQUE4QjZhLE9BQTlCO0FBQ0QsT0FGRDtBQUdEOzs7MkJBaERhdmEsUSxFQUFVO0FBQ3RCO0FBQ0Q7Ozs7RUFaK0IsMEQ7Ozs7Ozs7O0FDSmxDeWEsT0FBT0MsT0FBUCxHQUFpQixnQkFBakIsQzs7Ozs7Ozs7OztBQ0FBO0FBQ0EsSUFBTUMsY0FBYyx3QkFBcEI7QUFDQSxJQUFNQyxlQUFlLHdCQUFyQjtBQUNBLElBQU1DLGFBQWEsdUJBQW5COztBQUVBLElBQU1DLFVBQVUsMEJBQWhCO0FBQ0E7QUFDQSxJQUFNQyxnQkFBZ0Isc0JBQXRCOztBQUVBLElBQU1DLGVBQWUsU0FBZkEsWUFBZSxDQUFDcFQsSUFBRDtBQUFBLE1BQU9xVCxRQUFQLHVFQUFrQixLQUFsQjtBQUFBLFNBQTZCO0FBQ2hETixpQkFBQSw0RUFBQUEsS0FBZ0JNLFFBQWhCLEVBQTJCTixjQUFjLE1BQWQsR0FBdUIvUyxJQUFsRCxDQURnRDtBQUVoRHNULGFBQUEsNEVBQUFBLEtBQVlELFFBQVosRUFBdUJILFVBQVVsVCxJQUFqQyxDQUZnRDtBQUdoRCx1R0FBcUJxVCxRQUFyQixFQUFnQ0wsZUFBZSxNQUFmLEdBQXdCaFQsSUFBeEQsQ0FIZ0Q7QUFJaERpVCxnQkFBQSw0RUFBQUEsS0FBZUksUUFBZixFQUEwQkosYUFBYSxNQUFiLEdBQXNCalQsSUFBaEQ7QUFKZ0QsR0FBN0I7QUFBQSxDQUFyQjtBQU1BLElBQU11VCxlQUFlLFNBQWZBLFlBQWUsQ0FBQ3ZULElBQUQ7QUFBQSxNQUFPcVQsUUFBUCx1RUFBa0IsS0FBbEI7QUFBQSxTQUE2QjtBQUNoRE4saUJBQUEsNEVBQUFBLEtBQWdCTSxRQUFoQixFQUEyQk4sY0FBYy9TLElBQXpDLENBRGdEO0FBRWhEc1QsYUFBQSw0RUFBQUEsS0FBWUQsUUFBWixFQUF1QkYsZ0JBQWdCblQsSUFBdkMsQ0FGZ0Q7QUFHaEQsdUdBQXFCcVQsUUFBckIsRUFBZ0NMLGVBQWVoVCxJQUEvQyxDQUhnRDtBQUloRGlULGdCQUFBLDRFQUFBQSxLQUFlSSxRQUFmLEVBQTBCSixhQUFhalQsSUFBdkM7QUFKZ0QsR0FBN0I7QUFBQSxDQUFyQjs7QUFPQSx3REFBZTtBQUNiO0FBQ0FoTSxRQUFNLENBQUMsYUFBRCxFQUFnQixTQUFoQixFQUEyQixnQkFBM0IsRUFBNkMsWUFBN0MsQ0FGTzs7QUFJYkUsVUFBUTs7QUFFTixhQUFTO0FBQ1A2ZSxtQkFBYTtBQUNYUyxvQkFBWTtBQURELE9BRE47QUFJUEYsZUFBUztBQUNQRSxvQkFBWTtBQURMLE9BSkY7QUFPUCx3QkFBa0I7QUFDaEJBLG9CQUFZO0FBREksT0FQWDtBQVVQUCxrQkFBWTtBQUNWTyxvQkFBWTtBQURGO0FBVkwsS0FGSDs7QUFpQk4scUJBQWlCO0FBQ2YsV0FBSztBQUNIQyxjQUFNLFNBREg7QUFFSEMsZ0JBQVEsU0FGTDtBQUdIQyxzQkFBYyxTQUhYO0FBSUhDLG1CQUFXO0FBSlI7QUFEVSxLQWpCWDs7QUEwQk4saUJBQWE7QUFDWCxnQkFBVTtBQUNSLGVBQU87QUFDTCw4Q0FBb0M7QUFDbEMscUJBQVM7QUFEeUIsV0FEL0I7QUFJTCw4Q0FBb0M7QUFDbENDLG1CQUFPO0FBRDJCO0FBSi9CO0FBREMsT0FEQztBQVdYO0FBQ0EsZUFBUztBQUNQLHVCQUFlO0FBQ2JDLG9CQUFVO0FBREcsU0FEUjtBQUlQLG1CQUFXO0FBQ1Qsc0JBQVk7QUFESCxTQUpKO0FBT1AsMEJBQWtCO0FBQ2hCLHNCQUFZO0FBREksU0FQWDtBQVVQLHNCQUFjO0FBQ1osc0JBQVk7QUFEQTtBQVZQO0FBWkUsS0ExQlA7O0FBc0ROQyxXQUFPO0FBQ0xDLG1DQUE2QjtBQUMzQmpCLHFCQUFhO0FBQ1huUyxlQUFLO0FBRE0sU0FEYztBQUkzQjBTLGlCQUFTO0FBQ1AxUyxlQUFRdVMsYUFBUjtBQURPLFNBSmtCO0FBTzNCLDBCQUFrQjtBQUNoQnZTLGVBQUs7QUFEVyxTQVBTO0FBVTNCcVMsb0JBQVk7QUFDVnJTLGVBQUs7QUFESztBQVZlLE9BRHhCOztBQWdCTHFULG1DQUE2QjtBQUMzQmxCLHFCQUFhO0FBQ1huUyxlQUFLO0FBRE0sU0FEYztBQUkzQjBTLGlCQUFTO0FBQ1AxUyxlQUFRdVMsYUFBUjtBQURPLFNBSmtCO0FBTzNCLDBCQUFrQjtBQUNoQnZTLGVBQUs7QUFEVyxTQVBTO0FBVTNCcVMsb0JBQVk7QUFDVnJTLGVBQUs7QUFESztBQVZlLE9BaEJ4Qjs7QUErQkwscUJBQWU7QUFDYixzQkFBYztBQUNaLGlCQUFPO0FBREssU0FERDtBQUliMFMsaUJBQVM7QUFDUCxpQkFBVUgsYUFBVjtBQURPLFNBSkk7QUFPYixhQUFLO0FBQ0gsaUJBQU87QUFESjtBQVBRLE9BL0JWOztBQTJDTCxtQkFBYTtBQUNYLHNCQUFjO0FBQ1osaUJBQU87QUFESyxTQURIO0FBSVhHLGlCQUFTO0FBQ1AsaUJBQVVILGFBQVY7QUFETyxTQUpFO0FBT1gsYUFBSztBQUNILGlCQUFPO0FBREo7QUFQTSxPQTNDUjtBQXNETGUsc0JBQWdCO0FBQ2RuQixxQkFBYTtBQUNYblMsZUFBSztBQURNLFNBREM7QUFJZDBTLGlCQUFTO0FBQ1AxUyxlQUFRdVMsYUFBUjtBQURPLFNBSks7QUFPZCwwQkFBa0I7QUFDaEJ2UyxlQUFLO0FBRFcsU0FQSjtBQVVkcVMsb0JBQVk7QUFDVnJTLGVBQUs7QUFESztBQVZFLE9BdERYO0FBb0VMdVQsWUFBTTtBQUNKLGFBQUs7QUFDSHZULGVBQUs7QUFERjtBQURELE9BcEVEO0FBeUVMd1QsYUFBTztBQUNMckIscUJBQWE7QUFDWG5TLGVBQUs7QUFETSxTQURSO0FBSUwwUyxpQkFBUztBQUNQMVMsZUFBUXVTLGFBQVI7QUFETyxTQUpKO0FBT0wsMEJBQWtCO0FBQ2hCdlMsZUFBSztBQURXLFNBUGI7QUFVTHFTLG9CQUFZO0FBQ1ZyUyxlQUFLO0FBREs7QUFWUCxPQXpFRjtBQXVGTHlULGVBQVNkLGFBQWEsVUFBYixDQXZGSjs7QUF5RkxlLDBCQUFvQjtBQUNsQixhQUFLO0FBQ0gxVCxlQUFLO0FBREY7QUFEYTtBQXpGZixLQXRERDs7QUFzSk4sZUFBVztBQUNULGlCQUFXO0FBQ1Qsc0JBQWM7QUFDWixzQkFBWTtBQUNWLHVCQUFXO0FBQ1QseUJBQVcseURBREY7QUFFVCxxQkFBTztBQUZFLGFBREQ7QUFLVix1QkFBVztBQUNULHlCQUFXLDZEQURGO0FBRVQscUJBQU87QUFGRTtBQUxEO0FBREEsU0FETDtBQWFULGFBQUs7QUFDSCxzQkFBWTtBQUNWLHVCQUFXO0FBQ1QseUJBQVcsMERBREY7QUFFVCxxQkFBTztBQUZFLGFBREQ7QUFLVix1QkFBVztBQUNULHlCQUFXLDhEQURGO0FBRVQscUJBQU87QUFGRTtBQUxEO0FBRFQ7QUFiSTtBQURGLEtBdEpMOztBQW1MTjJULFlBQVE7QUFDTkMsdUJBQWlCcEIsYUFDZiw2R0FEZSxDQURYO0FBSU5xQix3QkFBa0JyQixhQUNoQiw0RkFEZ0IsQ0FKWjtBQU9Oc0IsbUJBQWF0QixhQUFhLHlDQUFiLENBUFA7QUFRTnVCLHdCQUFrQnZCLGFBQWEsdUJBQWIsQ0FSWjtBQVNOd0IsOEJBQXdCeEIsYUFBYSwwQkFBYixDQVRsQjs7QUFXTnlCLGNBQVF6QixhQUFhLFNBQWIsQ0FYRjtBQVlOMEIsa0JBQVkxQixhQUFhLGFBQWIsQ0FaTjtBQWFOMkIsYUFBTzNCLGFBQWEsUUFBYixDQWJEO0FBY040QixvQkFBYzVCLGFBQWEsd0JBQWIsQ0FkUjtBQWVONkIscUJBQWU3QixhQUFhLGdCQUFiLENBZlQ7QUFnQk44Qix3QkFBa0I5QixhQUFhLG1CQUFiLENBaEJaO0FBaUJOK0IsY0FBUS9CLGFBQWEsU0FBYixDQWpCRjtBQWtCTmdDLGdCQUFVaEMsYUFBYSxXQUFiLENBbEJKO0FBbUJOaUMsVUFBSWpDLGFBQWEsK0JBQWIsQ0FuQkU7O0FBcUJOa0MsdUJBQWlCO0FBQ2Z2QyxxQkFBYTtBQUNYblMsZUFBSztBQURNLFNBREU7QUFJZjBTLGlCQUFTO0FBQ1AxUyxlQUFRdVMsYUFBUjtBQURPLFNBSk07QUFPZiwwQkFBa0I7QUFDaEJ2UyxlQUFLO0FBRFcsU0FQSDtBQVVmcVMsb0JBQVk7QUFDVnJTLGVBQUs7QUFESztBQVZHLE9BckJYOztBQW9DTjJVLHVCQUFpQjtBQUNmeEMscUJBQWE7QUFDWG5TLGVBQUs7QUFETSxTQURFO0FBSWYwUyxpQkFBUztBQUNQMVMsZUFBUXVTLGFBQVI7QUFETyxTQUpNO0FBT2YsMEJBQWtCO0FBQ2hCdlMsZUFBSztBQURXLFNBUEg7QUFVZnFTLG9CQUFZO0FBQ1ZyUyxlQUFLO0FBREs7QUFWRyxPQXBDWDs7QUFtRE40VSxjQUFRcEMsYUFBYSwrQkFBYjtBQW5ERjtBQW5MRjtBQUpLLENBQWYsQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEJBO0lBQ3FCcUMsWTs7Ozs7OzswQkFDYm5hLFMsRUFBVztBQUNmLFdBQUtBLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7O0FDSkg7QUFBQTtBQUNBO0FBQ0E7QUFDTyxTQUFTb2EsaUJBQVQsR0FBNkI7QUFDbEMsTUFBTUMsSUFBSW5lLFFBQVY7QUFDQSxTQUFPZixLQUFLbWYsR0FBTCxDQUNMbmYsS0FBS21mLEdBQUwsQ0FBU0QsRUFBRXZULElBQUYsR0FBU3VULEVBQUV2VCxJQUFGLENBQU95VCxZQUFoQixHQUErQixDQUF4QyxFQUEyQ0YsRUFBRWxlLGVBQUYsR0FBb0JrZSxFQUFFbGUsZUFBRixDQUFrQm9lLFlBQXRDLEdBQXFELENBQWhHLENBREssRUFFTHBmLEtBQUttZixHQUFMLENBQVNELEVBQUV2VCxJQUFGLEdBQVN1VCxFQUFFdlQsSUFBRixDQUFPMFQsWUFBaEIsR0FBK0IsQ0FBeEMsRUFBMkNILEVBQUVsZSxlQUFGLEdBQW9Ca2UsRUFBRWxlLGVBQUYsQ0FBa0JxZSxZQUF0QyxHQUFxRCxDQUFoRyxDQUZLLEVBR0xyZixLQUFLbWYsR0FBTCxDQUFTRCxFQUFFdlQsSUFBRixHQUFTdVQsRUFBRXZULElBQUYsQ0FBTzJULFlBQWhCLEdBQStCLENBQXhDLEVBQTJDSixFQUFFbGUsZUFBRixHQUFvQmtlLEVBQUVsZSxlQUFGLENBQWtCc2UsWUFBdEMsR0FBcUQsQ0FBaEcsQ0FISyxDQUFQO0FBS0Q7O0FBRU0sU0FBU0MsZ0JBQVQsR0FBNEI7QUFDakMsTUFBTUwsSUFBSW5lLFFBQVY7QUFDQSxTQUFPZixLQUFLbWYsR0FBTCxDQUNMbmYsS0FBS21mLEdBQUwsQ0FBU0QsRUFBRXZULElBQUYsR0FBU3VULEVBQUV2VCxJQUFGLENBQU82VCxXQUFoQixHQUE4QixDQUF2QyxFQUEwQ04sRUFBRWxlLGVBQUYsR0FBb0JrZSxFQUFFbGUsZUFBRixDQUFrQndlLFdBQXRDLEdBQW9ELENBQTlGLENBREssRUFFTHhmLEtBQUttZixHQUFMLENBQVNELEVBQUV2VCxJQUFGLEdBQVN1VCxFQUFFdlQsSUFBRixDQUFPOFQsV0FBaEIsR0FBOEIsQ0FBdkMsRUFBMENQLEVBQUVsZSxlQUFGLEdBQW9Ca2UsRUFBRWxlLGVBQUYsQ0FBa0J5ZSxXQUF0QyxHQUFvRCxDQUE5RixDQUZLLEVBR0x6ZixLQUFLbWYsR0FBTCxDQUFTRCxFQUFFdlQsSUFBRixHQUFTdVQsRUFBRXZULElBQUYsQ0FBTytULFdBQWhCLEdBQThCLENBQXZDLEVBQTBDUixFQUFFbGUsZUFBRixHQUFvQmtlLEVBQUVsZSxlQUFGLENBQWtCMGUsV0FBdEMsR0FBb0QsQ0FBOUYsQ0FISyxDQUFQO0FBS0QsQzs7Ozs7OztBQ25CRDtBQUNBLHdEQUFlLFVBQUNDLE1BQUQsRUFBU0MsUUFBVCxFQUFtQkMsU0FBbkIsRUFBOEJDLFlBQTlCLEVBQStDO0FBQzVELE1BQU1wWixJQUFJMUcsS0FBS21mLEdBQUwsQ0FBUyxDQUFULEVBQVlXLGFBQWFwWixDQUFiLEdBQWlCaVosTUFBN0IsQ0FBVjtBQUNBLE1BQU1oWixJQUFJM0csS0FBS21mLEdBQUwsQ0FBUyxDQUFULEVBQVlXLGFBQWFuWixDQUFiLEdBQWlCZ1osTUFBN0IsQ0FBVjs7QUFFQSxNQUFNL1ksUUFBUTVHLEtBQUs2SSxHQUFMLENBQ1orVyxRQURZLEVBRVpFLGFBQWFwWixDQUFiLEdBQWlCQSxDQUFqQixHQUFxQm9aLGFBQWFsWixLQUFsQyxHQUEwQytZLE1BRjlCLENBQWQ7QUFJQSxNQUFNOVksU0FBUzdHLEtBQUs2SSxHQUFMLENBQ2JnWCxTQURhLEVBRWJDLGFBQWFuWixDQUFiLEdBQWlCQSxDQUFqQixHQUFxQm1aLGFBQWFqWixNQUFsQyxHQUEyQzhZLE1BRjlCLENBQWY7QUFJQSxTQUFPLEVBQUVqWixJQUFGLEVBQUtDLElBQUwsRUFBUUMsWUFBUixFQUFlQyxjQUFmLEVBQVA7QUFDRCxDQWJELEM7Ozs7Ozs7QUNEQTtBQUFBO0FBQ0E7QUFDZSxTQUFTa1osYUFBVCxDQUF1QkMsSUFBdkIsRUFBNkJDLElBQTdCLEVBQW1DO0FBQ2hELE1BQU1DLFlBQVksU0FBWkEsU0FBWSxDQUFDL1YsR0FBRCxFQUFTO0FBQ3pCLFFBQU1nVyxTQUFTLElBQUk1UixHQUFKLENBQVFwRSxHQUFSLENBQWY7QUFDQWdXLFdBQU94UixRQUFQLEdBQWtCd1IsT0FBT3hSLFFBQVAsQ0FBZ0I1USxLQUFoQixDQUFzQixHQUF0QixFQUEyQjlCLEtBQTNCLENBQWlDLENBQUMsQ0FBbEMsRUFBcUNvQixJQUFyQyxDQUEwQyxHQUExQyxDQUFsQjtBQUNBOGlCLFdBQU90UyxRQUFQLEdBQWtCc1MsT0FBT3RTLFFBQVAsQ0FBZ0I5USxPQUFoQixDQUF3QixjQUF4QixFQUF3QyxhQUF4QyxDQUFsQjtBQUNBb2pCLFdBQU9wUyxNQUFQLEdBQWdCb1MsT0FBT3BTLE1BQVAsQ0FBY2hSLE9BQWQsQ0FBc0IsWUFBdEIsRUFBb0MsYUFBcEMsQ0FBaEI7QUFDQSxXQUFPb2pCLE9BQU8xUixJQUFkO0FBQ0QsR0FORDs7QUFRQSxTQUFPeVIsVUFBVUYsSUFBVixNQUFvQkUsVUFBVUQsSUFBVixDQUEzQjtBQUNELEM7Ozs7Ozs7OztBQ1pEOztBQUVBLHdEQUFlLFVBQUMzWixFQUFELEVBQVE7QUFDckIsU0FBTyxtREFBQWtHLENBQUtsRyxHQUFHRyxxQkFBSCxFQUFMLEVBQWlDLENBQ3RDLEtBRHNDLEVBQy9CLE1BRCtCLEVBQ3ZCLE9BRHVCLEVBQ2QsUUFEYyxFQUNKLE9BREksRUFDSyxRQURMLENBQWpDLENBQVAsQ0FEcUIsQ0FHakI7QUFDTCxDQUpELEM7Ozs7Ozs7OztBQ0ZlLFNBQVMyWixjQUFULENBQXdCOVosRUFBeEIsRUFBNEI7QUFDekMsTUFBSStaLFdBQVcvWixHQUFHMEIsVUFBbEI7QUFDQSxTQUFPcVksWUFBWUEsU0FBUzVQLFNBQXJCLElBQWtDNFAsYUFBYXRmLFNBQVM0SyxJQUEvRCxFQUFxRTtBQUNuRSxRQUFNMlUsU0FBUzNnQixPQUFPc0gsZ0JBQVAsQ0FBd0JvWixRQUF4QixDQUFmO0FBQ0EsUUFBTXBULFNBQVNvVCxTQUFTNVoscUJBQVQsRUFBZjs7QUFFQSxRQUFNOFosYUFBYUQsT0FBTzVYLFFBQVAsS0FBb0IsVUFBcEIsSUFDakJ1RSxPQUFPckcsS0FBUCxJQUFnQixHQURDLElBRWpCcUcsT0FBT3BHLE1BQVAsSUFBaUIsR0FGQSxJQUdqQm9HLE9BQU9yRyxLQUFQLElBQWdCLEdBSEMsSUFJakJxRyxPQUFPcEcsTUFBUCxJQUFpQixHQUpuQjtBQUtBLFFBQUkwWixVQUFKLEVBQWdCO0FBQ2QsYUFBT0YsUUFBUDtBQUNEOztBQUVEQSxlQUFXQSxTQUFTclksVUFBcEI7QUFDRDtBQUNELFNBQU8sSUFBUDtBQUNELEM7Ozs7Ozs7O0FDbEJEO0FBQUE7QUFDZSxTQUFTd1ksY0FBVCxDQUF3QkMsSUFBeEIsRUFBOEI7QUFDM0MsTUFBSUEsS0FBSzlnQixNQUFMLElBQWUsT0FBTzhnQixLQUFLOWdCLE1BQUwsQ0FBWStnQixRQUFuQixLQUFnQyxXQUFuRCxFQUFnRTtBQUM5RCxXQUFPRCxLQUFLOWdCLE1BQUwsQ0FBWStnQixRQUFuQjtBQUNEO0FBQ0Q7QUFDQSxTQUFPRCxLQUFLdmUsS0FBTCxJQUFjdWUsS0FBS3ZlLEtBQUwsQ0FBV3dlLFFBQWhDO0FBQ0Q7O0FBRU0sU0FBU0MsbUJBQVQsQ0FBNkJGLElBQTdCLEVBQW1DO0FBQ3hDLFNBQU9BLEtBQUs5Z0IsTUFBTCxDQUFZaWhCLFlBQW5CO0FBQ0QsQzs7Ozs7Ozs7QUNYRDtBQUFBO0FBQ0E7QUFDZSxTQUFTemhCLFVBQVQsQ0FBb0JYLE1BQXBCLEVBQTRCdVAsTUFBNUIsRUFBc0Q7QUFBQSxNQUFsQjhTLFdBQWtCLHVFQUFKLEVBQUk7O0FBQ25FLFNBQU9yaUIsT0FBT1QsS0FBUCxDQUFhZ1EsTUFBYixFQUFxQjFRLElBQXJCLENBQTBCd2pCLFdBQTFCLENBQVA7QUFDRCxDOzs7Ozs7O0FDSkQ7QUFBQTtBQUNlLFNBQVNDLGdCQUFULENBQTBCQyxZQUExQixFQUF3Q3ZTLFVBQXhDLEVBQW9EO0FBQ2pFLE1BQUksQ0FBQ3VTLFlBQUQsSUFBaUIsQ0FBQ0EsYUFBYUMsS0FBL0IsSUFBd0MsQ0FBQ3hTLFVBQTdDLEVBQXlELE9BQU8sS0FBUDtBQUN6RCxNQUFNeVMsaUJBQWtCLElBQUkxUyxHQUFKLENBQVFDLFVBQVIsQ0FBRCxDQUFzQkcsUUFBdEIsQ0FBK0I1USxLQUEvQixDQUFxQyxHQUFyQyxFQUEwQzlCLEtBQTFDLENBQWdELENBQUMsQ0FBakQsRUFBb0RvQixJQUFwRCxDQUF5RCxHQUF6RCxDQUF2QjtBQUNBLE1BQU02akIsa0JBQWtCSCxhQUFhQyxLQUFiLENBQW1CN2pCLEdBQW5CLENBQXVCO0FBQUEsV0FDNUMsSUFBSW9SLEdBQUosQ0FBUTRTLEVBQUV4aEIsTUFBRixDQUFTd0ssR0FBakIsQ0FBRCxDQUF3QndFLFFBQXhCLENBQWlDNVEsS0FBakMsQ0FBdUMsR0FBdkMsRUFBNEM5QixLQUE1QyxDQUFrRCxDQUFDLENBQW5ELEVBQXNEb0IsSUFBdEQsQ0FBMkQsR0FBM0QsQ0FENkM7QUFBQSxHQUF2QixDQUF4QjtBQUdBLFNBQU82akIsZ0JBQWdCek8sT0FBaEIsQ0FBd0J3TyxjQUF4QixNQUE0QyxDQUFDLENBQXBEO0FBQ0QsQzs7Ozs7Ozs7OztBQ1JEOztBQUVlLFNBQVNoVixXQUFULENBQXFCdEssUUFBckIsRUFBK0JtRSxJQUEvQixFQUFxQztBQUNsRCxNQUFJbkcsV0FBV0EsT0FBT3lCLEdBQWxCLElBQXlCTCxTQUFTdU8sUUFBVCxDQUFrQmIsSUFBbEIsS0FBMkIsYUFBeEQsRUFBdUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E1SSxJQUFBLGlHQUFBQSxDQUFRO0FBQUEsYUFBTSxDQUFDLENBQUM5RSxTQUFTcWdCLElBQWpCO0FBQUEsS0FBUixFQUErQnpmLFFBQS9CLEVBQXlDbUUsSUFBekM7QUFDRCxHQUxELE1BS087QUFDTG5FO0FBQ0Q7QUFDRixDOzs7Ozs7O0FDWEQ7QUFBQTtBQUNBOztBQUVBLFNBQVNzRSxXQUFULENBQXFCQyxDQUFyQixFQUF3QjtBQUN0QixNQUFNeEgsUUFBUXlILFNBQVNELENBQVQsRUFBWSxFQUFaLENBQWQ7QUFDQSxNQUFJRSxNQUFNMUgsS0FBTixDQUFKLEVBQWtCLE9BQU8sQ0FBUDtBQUNsQixTQUFPQSxLQUFQO0FBQ0Q7O0FBRUQsU0FBUzJpQixnQkFBVCxDQUEwQkMsVUFBMUIsRUFBc0NDLGFBQXRDLEVBQXFEO0FBQ25ELFNBQU9ELFdBQVdqUSxNQUFYLENBQWtCLFVBQUNtUSxLQUFELEVBQVF4aUIsSUFBUixFQUFpQjtBQUN4QyxXQUFPd2lCLFFBQVF2YixZQUFZc2IsY0FBY3ZpQixJQUFkLENBQVosQ0FBZjtBQUNELEdBRk0sRUFFSixDQUZJLENBQVA7QUFHRDs7QUFFYyxTQUFTOEoscUJBQVQsR0FBaUM7QUFDOUMsTUFBSTFILE1BQU16QixPQUFPOGhCLFdBQWpCO0FBQ0EsTUFBSTNhLE9BQU9uSCxPQUFPK2hCLFdBQWxCO0FBQ0EsTUFBTUMsb0JBQW9CaGlCLE9BQU9zSCxnQkFBUCxDQUF3QmxHLFNBQVM0SyxJQUFqQyxDQUExQjtBQUNBLE1BQUlnVyxrQkFBa0JqWixRQUFsQixLQUErQixVQUFuQyxFQUErQztBQUM3Q3RILFdBQU9pZ0IsaUJBQWlCLENBQUMsS0FBRCxFQUFRLFdBQVIsRUFBcUIsZ0JBQXJCLENBQWpCLEVBQXlETSxpQkFBekQsQ0FBUDtBQUNBN2EsWUFBUXVhLGlCQUFpQixDQUFDLE1BQUQsRUFBUyxZQUFULEVBQXVCLGlCQUF2QixDQUFqQixFQUE0RE0saUJBQTVELENBQVI7QUFDRDtBQUNELFNBQU8sRUFBQ2piLEdBQUdJLElBQUosRUFBVUgsR0FBR3ZGLEdBQWIsRUFBUDtBQUNELEM7Ozs7Ozs7O0FDeEJELGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCLGtCQUFrQix5RDs7Ozs7O0FDQWxCO0FBQ0E7QUFDQTs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7OztBQ0ZBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBOzs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQixFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQSxHQUFHLDRDQUE0QyxnQ0FBZ0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxFQUFFO0FBQ2hELG1CQUFtQixzQ0FBc0M7QUFDekQsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7QUNqQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsR0FBRztBQUNIOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkVBQTRFLGtCQUFrQixFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdDQUFnQztBQUN2RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDcENEO0FBQ0E7O0FBRUEsMENBQTBDLG1DQUFzQzs7Ozs7OztBQ0hoRjtBQUNBO0FBQ0EsOEJBQThCLGtDQUFzQzs7Ozs7OztBQ0ZwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDUkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ1JEO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQThDOzs7Ozs7OztBQ0Y1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsa0NBQWtDO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHVDQUF1QztBQUN0RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQix5QkFBeUIsS0FBSztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDdlJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVLEVBQUU7QUFDMUUsS0FBSztBQUNMO0FBQ0EsOERBQThELFNBQVMsRUFBRTtBQUN6RSxLQUFLO0FBQ0w7QUFDQSxDQUFDLEVBQUU7Ozs7Ozs7O0FDbkJIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOzs7Ozs7O0FDWEg7QUFDQTtBQUNBLHFCQUFxQixjQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4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ckMsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyw4QkFBOEI7QUFDdkMsU0FBUyxvQ0FBb0M7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLFFBQVE7QUFDakMsa0JBQWtCLE9BQU8sUUFBUTtBQUNqQyxtQkFBbUIsT0FBTyxPQUFPO0FBQ2pDLG1CQUFtQixPQUFPLE9BQU87QUFDakMsa0JBQWtCLFFBQVEsT0FBTztBQUNqQyxrQkFBa0IsUUFBUSxPQUFPO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pyQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQseUIiLCJmaWxlIjoiaW5qZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzg4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4MzQ3NTdjZWRhY2FlZDM3Zjc3ZiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9hc3NpZ25cIik7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qZXNsaW50IG5vLWNvbnNvbGU6IDAqL1xudmFyIGlzRWRnZSA9IHR5cGVvZiBjb25zb2xlLmxvZy5iaW5kID09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGRlYnVnID0gaXNFZGdlID8gKGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cpLmJpbmQoY29uc29sZSkgOiAgZnVuY3Rpb24oKXt9O1xuY29uc3QgaW5mbyA9IGlzRWRnZSA/IChjb25zb2xlLmluZm8gfHwgY29uc29sZS5sb2cpLmJpbmQoY29uc29sZSkgOiBmdW5jdGlvbigpe307XG5jb25zdCB3YXJuID0gaXNFZGdlID8gKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykuYmluZChjb25zb2xlKSA6IGZ1bmN0aW9uKCl7fTtcbmNvbnN0IGVycm9yID0gaXNFZGdlID8gKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpLmJpbmQoY29uc29sZSkgOiBmdW5jdGlvbigpe307XG5cblxuXG5jb25zdCBMT0dfTEVWRUxTID0ge0VSUk9SOiAxLCBXQVJOOiAyLCBJTkZPOiAzLCBERUJVRzogNCwgVFJBQ0U6IDV9O1xuXG5mdW5jdGlvbiBzdGFydHNXaXRoKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgcmV0dXJuIGhheXN0YWNrLnNsaWNlKDAsIG5lZWRsZS5sZW5ndGgpID09PSBuZWVkbGU7XG59XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IGlkO1xuICAgIHRoaXMuX2xldmVsID0ge1xuICAgICAgLy9cImJhc2UuY29udGVudC5lbGVtZW50TG9jYXRvclwiOiBcIkRFQlVHXCIsXG4gICAgICAvL1wiYmFzZS5jb250ZW50LnBsYXllci5Db250ZW50UGxheWVyXCI6IFwiREVCVUdcIixcbiAgICAgIC8vIFwiYmFzZS5jb250ZW50LnBsYXllci5Mb2NhdG9yU2VhcmNoZXJcIjogXCJERUJVR1wiLFxuICAgICAgLy8gXCJlbWJlZC5jb21tb24uRW1iZWRTdG9yYWdlXCI6IFwiREVCVUdcIixcbiAgICAgIC8vXCJlbWJlZC5jb250ZW50LkVtYmVkQmFja2dyb3VuZFBvcnRcIjogXCJERUJVR1wiLFxuICAgICAgLy9cImVtYmVkLmJhY2tncm91bmQuRW1iZWREb2N1bWVudHNQb3J0XCI6IFwiREVCVUdcIixcbiAgICAgIC8vXCJlbWJlZC5iYWNrZ3JvdW5kLkVtYmVkVGFic0NvbnRyb2xsZXJcIjogXCJERUJVR1wiLFxuICAgICAgLy9cImJhc2UuYmFja2dyb3VuZC5jYXB0dXJlLlByb2Nlc3MuaGFuZGxlcnMuTU9VU0VcIjogXCJERUJVR1wiLFxuICAgICAgLy8gXCJlbWJlZC5pbmplY3RcIjogXCJERUJVR1wiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiV0FSTlwiLFxuICAgIH07XG4gIH1cblxuICBpc0VuYWJsZWQgKGxldmVsKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX2xldmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG9nTGV2ZWwgPSB0aGlzLl9sZXZlbFt0aGlzLl9pZF0gfHwgdGhpcy5fbGV2ZWxbJ2RlZmF1bHQnXTtcbiAgICByZXR1cm4gKGxvZ0xldmVsICE9IG51bGwpICYmIExPR19MRVZFTFNbbGV2ZWxdIDw9IExPR19MRVZFTFNbbG9nTGV2ZWxdO1xuICB9XG5cbiAgZGVidWcgKG1zZywgLi4uYXJncykge1xuICAgIGlmKHRoaXMuaXNFbmFibGVkKFwiREVCVUdcIikpIGRlYnVnKGBbJHt0aGlzLl9pZH1dIERFQlVHYCwgbXNnLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHRyYWNlIChtc2csIC4uLmFyZ3MpIHtcbiAgICBpZih0aGlzLmlzRW5hYmxlZChcIlRSQUNFXCIpKSBkZWJ1ZyhgWyR7dGhpcy5faWR9XSBUUkFDRWAsIG1zZywgLi4uYXJncyk7XG4gIH1cblxuICBpbmZvIChtc2csIC4uLmFyZ3MpIHtcbiAgICBpZih0aGlzLmlzRW5hYmxlZChcIklORk9cIikpIGluZm8oYFske3RoaXMuX2lkfV0gSU5GT2AsIG1zZywgLi4uYXJncyk7XG4gIH1cblxuICB3YXJuIChtc2csIC4uLmFyZ3MpIHtcbiAgICBpZih0aGlzLmlzRW5hYmxlZChcIldBUk5cIikpIHdhcm4oYFske3RoaXMuX2lkfV0gV0FSTklOR2AsIG1zZywgLi4uYXJncyk7XG4gIH1cblxuICBlcnJvciAobXNnLCAuLi5hcmdzKSB7XG4gICAgaWYodGhpcy5pc0VuYWJsZWQoXCJFUlJPUlwiKSkgZXJyb3IoYFske3RoaXMuX2lkfV0gRVJST1JgLCBtc2csIC4uLmFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIoaWQpIHtcbiAgcmV0dXJuIG5ldyBMb2dnZXIoaWQpO1xufVxuXG4vLyBHZXQgYSBsb2dnZXIgaW4uZG90dGVkLmZvcm0gZnJvbSBhIGZpbGVuYW1lIChmcm9tIHdlYnBhY2sncyBfX2ZpbGVuYW1lIHNwZWNpYWwgdmFyKVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVMb2dnZXIoZmlsZW5hbWUpIHtcbiAgY29uc3QgaWQgPSBmaWxlbmFtZS5yZXBsYWNlKC9eLipcXC9zcmNcXC8vLCAnJykucmVwbGFjZSgvWy9cXFxcXS9nLCAnLicpLnJlcGxhY2UoLy5qcyQvLCcnKTtcbiAgcmV0dXJuIG5ldyBMb2dnZXIoaWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdExvZ2dlcigpIHtcbiAgcmV0dXJuIG5ldyBMb2dnZXIoJ2RlZmF1bHQnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlci5qcyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lzQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsImNvbnN0IHByZWZpeCA9ICgocHJvY2Vzcy5lbnYuQlJPV1NFUiA9PT0gJ2VtYmVkJykgPyAnaW9yYWQtZW1iZWQnIDogJ2lvcmFkLWV4dGVuc2lvbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuYW1lc3BhY2UoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiBwcmVmaXg7XG4gIHJldHVybiBhcmdzLm1hcChzdHIgPT4gcHJlZml4ICsgJy0nICsgc3RyKS5qb2luKCcgJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYga2V5IGluIGV4cG9ydHMpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvaXNPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICovXG5cbnZhciB1dGlsID0ge307XG5cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxudXRpbC5pc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbnV0aWwuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG51dGlsLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZyl7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKlxuICogRXZlbnRFbWl0dGVyIGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InICYmICF0aGlzLl9ldmVudHMuZXJyb3IpIHtcbiAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgdXRpbC5pc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAodXRpbC5pc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG5cbiAgICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oY29uc29sZS5lcnJvcikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNvbnNvbGUudHJhY2UpKVxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAodXRpbC5pc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L25vZGUtZXZlbnQtZW1pdHRlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2Zyb20gPSByZXF1aXJlKFwiLi4vY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZnJvbTIuZGVmYXVsdCkoYXJyKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgc2V0dGluZ3NDb25maWcgZnJvbSAnLi9zZXR0aW5ncy5jb25maWcnO1xuaW1wb3J0IGVudiBmcm9tICcuL2Vudic7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC9jbG9uZURlZXAnO1xuaW1wb3J0IGVhY2ggZnJvbSAnbG9kYXNoL2VhY2gnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICdsb2Rhc2gvZXh0ZW5kJztcbmltcG9ydCBpc0FycmF5IGZyb20gJ2xvZGFzaC9pc0FycmF5JztcbmltcG9ydCByZXBsYWNlQWxsIGZyb20gJy4vdXRpbHMvcmVwbGFjZUFsbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZW52LCAvLyBjdXJyZW50IHVzZWQgZW52aXJvbm1lbnRcblxuICBlbnZzOiBzZXR0aW5nc0NvbmZpZy5lbnZzLCAvLyBwb3NzaWJsZSBlbnZzXG4gIHZhbHVlczogc2V0dGluZ3NDb25maWcudmFsdWVzLCAvLyBhY3R1YWwgY29uZmlnXG5cbiAgZ2V0OiBmdW5jdGlvbihuYW1lLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhdGhGcmFnbWVudHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy52YWx1ZXM7XG4gICAgdmFyIGVudiA9IHRoaXMuZW52O1xuICAgIHZhciBlbnZQYXJlbnQ7XG4gICAgdmFyIGVudlBhcmVudEluZGV4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyYWdtZW50ID0gcGF0aEZyYWdtZW50c1tpXTtcbiAgICAgIGlmICgnKicgaW4gc3RhcnQgJiYgZW52UGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3Qgd2lsZGNhcmQgZW52XG4gICAgICAgIGVudlBhcmVudCA9IHN0YXJ0O1xuICAgICAgICBlbnZQYXJlbnRJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRbZW52XSkge1xuICAgICAgICAvLyB1c2UgY3VycmVudCBlbnZcbiAgICAgICAgZW52UGFyZW50ID0gc3RhcnQ7XG4gICAgICAgIGVudlBhcmVudEluZGV4ID0gaTtcbiAgICAgICAgc3RhcnQgPSBzdGFydFtlbnZdO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydFtmcmFnbWVudF07XG4gICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZW52UGFyZW50ICE9PSB1bmRlZmluZWQgJiYgJyonIGluIGVudlBhcmVudCAmJiBlbnYgIT0gJyonKSB7XG4gICAgICAgICAgLy8gdHJ5IHdpdGggKiBlbnZcbiAgICAgICAgICBlbnYgPSAnKic7XG4gICAgICAgICAgc3RhcnQgPSBlbnZQYXJlbnQ7XG4gICAgICAgICAgaSA9IGVudlBhcmVudEluZGV4IC0gMTsgLy8gYmVjYXVzZSBvZiB0aGUgaSsrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IGZvdW5kXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRvbid0IG1vZGlmeSBvcmlnaW5hbCBzZXR0aW5nc1xuICAgIHN0YXJ0ID0gY2xvbmVEZWVwKHN0YXJ0KTtcblxuICAgIC8vIGlmIHRoZSBnZXR0ZWQgc2V0dGluZyBzdGlsbCBjb250YWlucyBlbnYgcHJvcGVydGllcywgcmVtb3ZlIHRob3NlIG5vdCByZWxhdGVkIHRvIHRoZSBjdXJyZW50XG4gICAgLy8gYW5kIG1lcmdlIHRoZSBjdXJyZW50IGVudiB3aXRoIHRoZSB3aWxkY2FyZCBlbnYuXG4gICAgdmFyIHJlbW92ZUVudnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0JykgeyAvLyBvYmplY3Qgb3IgYXJyYXlcbiAgICAgICAgLy8gcmVjdXJzaW9uIChkZXB0aC1maXJzdCBzbyB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggXCJzdWIgZW52c1wiKVxuICAgICAgICBlYWNoKHRhcmdldCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gcmVtb3ZlRW52cyh0YXJnZXRba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7IC8vIG9iamVjdHMgb25seVxuICAgICAgICAgIGlmICgnKicgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBtZXJnZSAqIHdpdGggdGFyZ2V0XG4gICAgICAgICAgICBleHRlbmQodGFyZ2V0LCB0YXJnZXRbJyonXSk7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0WycqJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGVhY2goc2VsZi5lbnZzLCBmdW5jdGlvbihwb3NzaWJsZUVudikge1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRW52IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVFbnYgPT09IHNlbGYuZW52KSB7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgZW52XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHRhcmdldCwgdGFyZ2V0W3Bvc3NpYmxlRW52XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gKHRydWUgYWxzbyBmb3IgZm9yZWlnbiBlbnZzKVxuICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Bvc3NpYmxlRW52XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgc3RhcnQgPSByZW1vdmVFbnZzKHN0YXJ0KTtcblxuICAgIHZhciByZXBsYWNlVmFycyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSByZXBsYWNlVmFycyh0YXJnZXRbcHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgdmFyaWFibGVzIGluIHN0cmluZyB3aXRoIHRoZWlyIHNwZWNpZmllZCB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgdmFyaWFibGUgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgICAgaWYgKHZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eSh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHJlcGxhY2VBbGwodGFyZ2V0LCAnJScgKyB2YXJpYWJsZSArICclJywgdmFyaWFibGVzW3ZhcmlhYmxlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodmFyaWFibGVzKSBzdGFydCA9IHJlcGxhY2VWYXJzKHN0YXJ0KTtcblxuICAgIHJldHVybiBzdGFydDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3NldHRpbmdzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9ub29wLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lkZW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NvcHlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSAoMCwgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIuZGVmYXVsdCkob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fdG9LZXkuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNyZWF0ZUZpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVGaW5kJyksXG4gICAgZmluZEluZGV4ID0gcmVxdWlyZSgnLi9maW5kSW5kZXgnKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9maW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lzU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc3RlcChcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlUmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jYXN0UGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2lzSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9lcS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3ZhbHVlcy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGNyZWF0ZVdyYXAgPSByZXF1aXJlKCcuL19jcmVhdGVXcmFwJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQ1VSUllfRkxBRyA9IDg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gKiBpcyBub3Qgc3VmZmljaWVudC5cbiAqXG4gKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gKiAgIHJldHVybiBbYSwgYiwgY107XG4gKiB9O1xuICpcbiAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICpcbiAqIGN1cnJpZWQoMSkoMikoMyk7XG4gKiAvLyA9PiBbMSwgMiwgM11cbiAqXG4gKiBjdXJyaWVkKDEsIDIpKDMpO1xuICogLy8gPT4gWzEsIDIsIDNdXG4gKlxuICogY3VycmllZCgxLCAyLCAzKTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICpcbiAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICogLy8gPT4gWzEsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbmN1cnJ5LnBsYWNlaG9sZGVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gY3Vycnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9jdXJyeS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9rZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGZyYW1lcyB1c2luZyBwb3N0TWVzc2FnZS5cblxuaW1wb3J0IHsgZ2V0RmlsZUxvZ2dlciB9IGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9sb2dnZXJcIjtcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5pbXBvcnQgd2FpdEZvckluaXQgZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL3dhaXRGb3JJbml0XCI7XG5cbmltcG9ydCBuYW1lc3BhY2UgZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZVwiO1xuaW1wb3J0IGZpbHRlciBmcm9tIFwibG9kYXNoL2ZpbHRlclwiO1xuaW1wb3J0IGZpbmQgZnJvbSBcImxvZGFzaC9maW5kXCI7XG5pbXBvcnQgaW5kZXhPZiBmcm9tIFwibG9kYXNoL2luZGV4T2ZcIjtcbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC9tYXBcIjtcbmltcG9ydCBzb3J0QnkgZnJvbSBcImxvZGFzaC9zb3J0QnlcIjtcbmltcG9ydCB7IGFkZFdpbmRvd0xpc3RlbmVyIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL3dpbmRvd0V2ZW50c1wiO1xuaW1wb3J0IGJyb3dzZXIgZnJvbSBcImNocm9tZS9icm93c2VyXCI7XG5cbmV4cG9ydCBjb25zdCBQQVJFTlQgPSBcIlBBUkVOVFwiO1xuZXhwb3J0IGNvbnN0IENISUxEUkVOID0gXCJDSElMRFJFTlwiO1xuZXhwb3J0IGNvbnN0IEFMTCA9IFwiQUxMXCI7XG5leHBvcnQgY29uc3QgVE9QID0gXCJUT1BcIjtcblxuY29uc3QgRFVQRV9DSEVDS19LRVkgPSBuYW1lc3BhY2UoXCJmcmFtZU1lc3NhZ2VzLWxvYWRlZFwiKTtcbmlmICh3aW5kb3dbRFVQRV9DSEVDS19LRVldKSB7XG4gIC8vIFdlYnBhY2sgQ29tbW9uc0NodW5rUGx1Z2luIHNob3VsZCBlbnN1cmUgdGhpcywgYnV0IGl0J2xsIGNhdXNlIGNyYXp5IGhhcmRcbiAgLy8gdG8gZmluZCBidWdzIGlmIGl0IGJyZWFrc1xuICB0aHJvdyBuZXcgRXJyb3IoXCJJT1JBRDogU2hvdWxkIGJlIG9ubHkgb25lIGluc3RhbmNlIG9mIGZyYW1lTWVzc2FnZXMgcGVyIGNvbnRlbnRcIik7XG59XG53aW5kb3dbRFVQRV9DSEVDS19LRVldID0gdHJ1ZTtcblxuLy8gTU9EVUxFIExFVkVMIFNUQVRFISBXRSBTSEFSRSBUSElTIFdJVEggT1RIRVIgSU5TVEFOQ0VTIE9GIFRISVMgTU9EVUxFIExPQURFRFxuZXhwb3J0IGNvbnN0IGZyYW1lSWQgPSBcIkZSQU1FSUQ6XCIgKyBTdHJpbmcoK25ldyBEYXRlKCkpICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuY29uc3QgbWVzc2FnZUxpc3RlbmVycyA9IHt9O1xuY29uc3QgaXNCYWNrZ3JvdW5kID0gISEoYnJvd3NlciAmJiBicm93c2VyLnRhYnMpO1xuXG5pZiAoIWlzQmFja2dyb3VuZCkge1xuICBjb250ZW50UGFnZUxpc3RlbmVyKCk7XG59XG5cbi8vIGRlc3RpbmF0aW9uIGNhbiBiZSBQQVJFTlQsIENISUxEUkVOLCBBTEwsIFRPUCwgZnJhbWVJZCAgb3IgYSBmcmFtZS93aW5kb3cgb2JqZWN0XG5leHBvcnQgZnVuY3Rpb24gc2VuZChkZXN0aW5hdGlvbiwgdG9waWMsIHBheWxvYWQgPSBudWxsKSB7XG4gIGlmIChpc0JhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbGxvd2VkIG9uIGJhY2tncm91bmRcIik7XG4gIGxvZ2dlci5kZWJ1ZyhcIlNlbmQgTWVzc2FnZVwiLCBkZXN0aW5hdGlvbiwgdG9waWMpO1xuICBsZXQgZnJhbWVzO1xuICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgLy8gSXQncyBhIGZyYW1lL3dpbmRvdyBvYmplY3RcbiAgICBmcmFtZXMgPSBbZGVzdGluYXRpb25dO1xuICAgIGRlc3RpbmF0aW9uID0gXCJcIjtcbiAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbiA9PT0gUEFSRU5UKSB7XG4gICAgZnJhbWVzID0gW3dpbmRvdy5wYXJlbnRdO1xuICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uID09PSBDSElMRFJFTikge1xuICAgIGZyYW1lcyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIikpXG4gICAgICAubWFwKGlmcmFtZSA9PiBpZnJhbWUuY29udGVudFdpbmRvdyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIGFueSBvdGhlciB0eXBlIHdlIG5lZWQgdG8gc3RhcnQgYXQgdGhlIHJvb3RcbiAgICBmcmFtZXMgPSBbd2luZG93LnRvcF07XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0ge1xuICAgIGlzRnJhbWVNZXNzYWdlOiB0cnVlLFxuICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlKCksXG4gICAgZGVzdGluYXRpb24sXG4gICAgdG9waWMsXG4gICAgcGF5bG9hZCxcbiAgICBmcmFtZUlkXG4gIH07XG5cbiAgZnJhbWVzLmZvckVhY2goZnJhbWUgPT4ge1xuICAgIGZyYW1lLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgfSk7XG59XG5cbi8vIHRvcGljIGlzIG9wdGlvbmFsLCBkZWZhdWx0cyB0byAnKidcbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UodG9waWMsIGNhbGxiYWNrKSB7XG4gIGlmIChpc0JhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbGxvd2VkIG9uIGJhY2tncm91bmRcIik7IC8vIFRPRE86XG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSB0b3BpYztcbiAgICB0b3BpYyA9IFwiKlwiO1xuICB9XG5cbiAgbWVzc2FnZUxpc3RlbmVyc1t0b3BpY10gPSBbLi4uKG1lc3NhZ2VMaXN0ZW5lcnNbdG9waWNdIHx8IFtdKSwgY2FsbGJhY2tdO1xuXG4gIHJldHVybiB7XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICBtZXNzYWdlTGlzdGVuZXJzW3RvcGljXSA9IG1lc3NhZ2VMaXN0ZW5lcnNbdG9waWNdLmZpbHRlcihcbiAgICAgICAgZiA9PiBmICE9PSBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGl2ZXIobWVzc2FnZSkge1xuICAvLyBUaGlzIG1lc3NhZ2UgaXMgZGlyZWN0ZWQgdG8gdGhpcyBmcmFtZVxuICBbXCIqXCIsIG1lc3NhZ2UudG9waWNdLmZvckVhY2godG9waWMgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1lc3NhZ2VMaXN0ZW5lcnNbdG9waWNdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGwgPT4gbChtZXNzYWdlKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNGcmFtZU1lc3NhZ2UoZXZlbnQpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgIG1lc3NhZ2UgIT0gbnVsbCAmJlxuICAgIG1lc3NhZ2UuaXNGcmFtZU1lc3NhZ2UgJiZcbiAgICBtZXNzYWdlLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKCk7XG59XG5cbmZ1bmN0aW9uIG1lc3NhZ2VIYW5kbGVyKGV2ZW50KSB7XG4gIGlmICghaXNGcmFtZU1lc3NhZ2UoZXZlbnQpKSByZXR1cm47XG4gIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICBmdW5jdGlvbiBicm9hZGNhc3REb3duKCkge1xuICAgIC8vIHJvdXRlIHRvIGNoaWxkIGlmcmFtZXMgKGNvbnRpbnVlIGJyb2FkY2FzdClcbiAgICAvLyBOT1RFOiB3ZSBkb24ndCB1c2Ugd2luZG93LmZyYW1lcyBzaW5jZSBpcyBicm9rZW4gaW4gRURHRVxuICAgIGNvbnN0IGNoaWxkRnJhbWVXaW5kb3dzID0gQXJyYXlcbiAgICAgIC5mcm9tKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpKVxuICAgICAgLm1hcChpZnJhbWUgPT4gaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRGcmFtZVdpbmRvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkRnJhbWVXaW5kb3dzW2ldLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFwiKlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhY2NlcHQoKSB7XG4gICAgZGVsaXZlcihtZXNzYWdlKTtcbiAgfVxuXG4gIGNvbnN0IHsgZGVzdGluYXRpb24gfSA9IG1lc3NhZ2U7XG5cbiAgaWYgKFxuICAgIGRlc3RpbmF0aW9uID09PSBQQVJFTlQgfHxcbiAgICBkZXN0aW5hdGlvbiA9PT0gQ0hJTERSRU4gfHxcbiAgICBkZXN0aW5hdGlvbiA9PT0gVE9QIHx8XG4gICAgZGVzdGluYXRpb24gPT09IFwiXCJcbiAgKSB7XG4gICAgYWNjZXB0KCk7XG4gIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gPT09IEFMTCkge1xuICAgIGJyb2FkY2FzdERvd24oKTtcbiAgICBhY2NlcHQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXN0aW5hdGlvbiBpcyBhIHNwZWNpZmljIGZyYW1lIGlkXG4gICAgaWYgKGZyYW1lSWQgPT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICBhY2NlcHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJvYWRjYXN0RG93bigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb250ZW50UGFnZUxpc3RlbmVyKCkge1xuICBhZGRXaW5kb3dMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZUhhbmRsZXIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvZnJhbWVNZXNzYWdlcy5qcyIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX0xpc3RDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VDcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jb3B5QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUN0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQ3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19nZXRNYXBEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fZ2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBXZSB3YW50IHRvIGxpc3RlbiBmcm9tIFwibWVzc2FnZVwiIChhbmQgb3RoZXIpIGV2ZW50IG9uIHdpbmRvdy4gSG93ZXZlcjpcbi8vICAtIFdoZW4gdGhlIGhvc3QgcGFnZSBjYWxscyBkb2N1bWVudC53cml0ZSBpdCBvYmxpdGVyYXRlcyBtZXNzYWdlIGxpc3RuZXJzIFxuLy8gIC0gV2Ugd2FudCB0byBzdG9wIGFueSBtZXNzYWdlcyB3ZSBoYW5kbGUgZnJvbSBiZWluZyBoYW5kbGVkIGJ5IHRoZSBob3N0IHBhZ2VcbmltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuLy8gTW9kdWxlIGxldmVsIHN0YXRlXG5sZXQgZXZlbnRzID0ge307XG5sZXQgcmVhdHRhY2hMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIHNldHVwV2luZG93RXZlbnQoZXZlbnROYW1lKSB7XG4gIC8vIFN0YXRlXG4gIGxldCBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gIGxldCBhdHRhY2htZW50cyA9IFtdO1xuICBsZXQgdG90YWxBdHRhY2htZW50c0NvdW50ID0gMDsgLy8gSnVzdCBmb3IgZGVidWdcblxuICBmdW5jdGlvbiBtZXNzYWdlSGFuZGxlcihldmVudCkge1xuICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAvLyBJcyB0aGlzIGEgdGVzdCBtZXNzYWdlIGdlbmVyYXRlZCBieSB0aGlzIG1vZHVsZSBpdHNlbGY/XG4gICAgLy8gTk9URTogdGhlIGV2ZW50LnR5cGUgY2hlY2sgaXMgcmVxdWlyZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgIC8vICdcIkVycm9yOiBQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJkYXRhXCInIGVycm9yXG4gICAgaWYgKFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ21lc3NhZ2UnICYmXG4gICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGV2ZW50LmRhdGEgIT09IG51bGwgJiZcbiAgICAgIGV2ZW50LmRhdGEud2luZG93RXZlbnRzVGVzdE1lc3NhZ2UgPT09IG5hbWVzcGFjZSgpXG4gICAgKSB7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdObyBsaXN0ZW5lcnMgZm9yIHdpbmRvdycsIGV2ZW50TmFtZSwgJ2V2ZW50JywgZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZXZlbnQpKTtcbiAgfVxuXG5cbiAgLy8gU28gd2Ugb2Z0ZW4gYXJlbid0IHN1cmUgaWYgd2UgbmVlZCB0byByZWF0dGFjaCwgd2UgaGF2ZSBubyB3YXkgb2YgdGVsbGluZ1xuICAvLyBpZiBhbiBldmVudCBoYW5kbGVyIGlzIHN0aWxsIGF0dGFjaGVkLiBIb3dldmVyLCB3ZSBkb24ndCB3YW50IHRvIGJ1aWxkIHVwIG1vcmUgYW5kXG4gIC8vIG1vcmUgYXR0YWNoZWQgaGFuZGxlcnMuIFdlIGFsc28gd2FudCB0byBrZWVwIHRoZSBlYXJsaWVzdCBvbmUgYXR0YWNoZWQgaWZcbiAgLy8gYXQgYWxsIHBvc3NpYmxlIGJlY2F1c2UgdGhhdCBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjYW5jZWwgZXZlbnRzIGJlZm9yZVxuICAvLyBhbnl0aGluZyBlbHNlIGNhbiBzZWUgdGhlbS4gU28gd2hhdCB3ZSBkbyBpcyB3ZSBhZGQgYSBuZXcgb25lIHdoZW5ldmVyIHdlXG4gIC8vIHRoaW5rIHdlIG5lZWQgaXQgdGhlbiB3aGVuZXZlciB3ZSBnZXQgYSBjYWxsYmFjayB0aHJvdWdoIG9uZSB3ZSByZW1vdmUgYW55XG4gIC8vIG90aGVycy5cbiAgZnVuY3Rpb24gcmVhdHRhY2goKSB7XG4gICAgbGV0IGluZGV4ID0gYXR0YWNobWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGF0dGFjaG1lbnROdW1iZXIgPSB0b3RhbEF0dGFjaG1lbnRzQ291bnQrKztcbiAgICBsb2dnZXIuZGVidWcoJ1JlYXR0YWNoIHdpbmRvdycsIGV2ZW50TmFtZSwnZXZlbnQgIycsIGF0dGFjaG1lbnROdW1iZXIpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGlmIChhdHRhY2htZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGlzTmV3QXR0YWNobWVudCA9IGluZGV4ICE9PSAwOyAvLyBJcyB0aGlzIGEgbmV3IGF0dGFjaG1lbnQgb3IgZGlkIHRoZSBvbGQgb25lIHN0aWxsIHdvcms/XG5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdSZW1vdmUnLCBhdHRhY2htZW50cy5sZW5ndGgtMSwgJ3VuZWVkZWQgd2luZG93JywgZXZlbnROYW1lLCAnZXZlbnQgYXR0YWNobWVudHMuIExvd2VzdCB3b3JraW5nIGluZGV4OicsIGluZGV4KTtcbiAgICAgICAgYXR0YWNobWVudHMuZm9yRWFjaCgoZm4sIGkpID0+IHtcbiAgICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vIHdlIG9ubHkgaGF2ZSB0aGlzIG9uZSBhdHRhY2htZW50IGxlZnRcbiAgICAgICAgYXR0YWNobWVudHMgPSBbYXR0YWNobWVudHNbaW5kZXhdXTtcbiAgICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIElzIGlja3kgdG8gdGVzdCBmb3Igc3BlY2lmaWMgZXZlbnROYW1lLCBidXQgdGhpcyBtZWNoYW5pc20gb25seSB3b3JrcyBmb3IgbWVzc2FnZVxuICAgICAgICBpZiAoaXNOZXdBdHRhY2htZW50ICYmIGV2ZW50TmFtZSA9PT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgICByZWF0dGFjaExpc3RlbmVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVzc2FnZUhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIHRydWUpO1xuICAgIGF0dGFjaG1lbnRzLnB1c2goaGFuZGxlcik7XG5cblxuICAgIGlmIChpbmRleCAhPT0gMCAmJiBldmVudE5hbWUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAvLyBUZXN0IHRoZSBuZXcgYXR0YWNobWVudFxuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHt3aW5kb3dFdmVudHNUZXN0TWVzc2FnZTogbmFtZXNwYWNlKCl9LCAnKicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIHJlYXR0YWNoKCk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIE11dGF0aW9uT2JzZXJ2ZXIgc28gYXMgbm90IHRvIGZhaWwgdGhlIHRlc3RzXG4gICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVXNlIGFuIG9ic2VydmVyIHRvIGRldGVjdCB3aGVuIHJvb3QgZWxlbWVudCBjaGFuZWdzICh3aGljaCBzZWVtcyB0byBtZWFuXG4gICAgICAvLyB0aGF0IGRvY3VtZW50LndyaXRlIGhhcyBiZWVuIGNhbGxlZCwgd2hhdCBlbHNlIHdvdWxkIHJlcGxhY2UgdGhlIEhUTUxcbiAgICAgIC8vIGVsZW1lbnQ/KVxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdSb290IGVsZW1lbnQgY2hhbmdlZCwgdGhpcyBpcyBwcm9iYWJseSBkb2N1bWVudC53cml0ZS4nKTtcbiAgICAgICAgcmVhdHRhY2goKTtcblxuICAgICAgICAvLyBzZXRUaW1lb3V0KHJlYXR0YWNoLCAxKTtcbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZX0pXG4gICAgfVxuICB9XG4gIHNldHVwKCk7XG5cbi8vIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBpdCBwcm9jZXNzZXMgdGhlIG1lc3NhZ2VcbiAgcmV0dXJuIHtcbiAgICBhZGQgKGNhbGxiYWNrKSB7XG4gICAgICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHJlbW92ZSAoY2FsbGJhY2spIHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZSkge1xuICByZXR1cm4gKGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnRzW2V2ZW50TmFtZV0gfHwgc2V0dXBXaW5kb3dFdmVudChldmVudE5hbWUpKTtcbn1cblxuXG4vLyBHZXQgYSBjYWxsYmFjayB3aGVuIHdlIGhhdmUgcmVhdHRhY2hlZCBcIm1lc3NhZ2VcIiBldmVudCB0byB0aGUgd2luZG93LCB0aGlzIGlzXG4vLyBhIG5vdGlmaWNhdGlvbiB0aGF0IGV2ZW50cyBtYXkgaGF2ZSBiZWVuIGxvc3RcbmV4cG9ydCBmdW5jdGlvbiBhZGRSZWF0dGFjaE1lc3NhZ2VMaXN0ZW5lcihjYWxsYmFjaykge1xuICByZWF0dGFjaExpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkV2luZG93TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBnZXRFdmVudChldmVudE5hbWUpLmFkZChjYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVXaW5kb3dMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIGdldEV2ZW50KGV2ZW50TmFtZSkucmVtb3ZlKGNhbGxiYWNrKTtcbn1cblxuLy8gUHJlLWxvYWQgbWVzc2FnZSBldmVudFxuZ2V0RXZlbnQoJ21lc3NhZ2UnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL3dpbmRvd0V2ZW50cy5qcyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX1N0YWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYXBwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VVbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3NldFRvQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVBpY2sgPSByZXF1aXJlKCcuL19iYXNlUGljaycpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9waWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VPcmRlckJ5ID0gcmVxdWlyZSgnLi9fYmFzZU9yZGVyQnknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9zb3J0QnkuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC90b0ludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuXG5mdW5jdGlvbiBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHN0YXJ0KGV4dGVuc2lvbikge1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgIHRoaXMuZmx1eCA9IHRoaXMuZXh0ZW5zaW9uLmZsdXg7XG4gICAgdGhpcy5vd25Db250ZXh0ID0gdGhpcy5mbHV4W3RoaXMuZmx1eC5vd25Db250ZXh0TmFtZSArICdDb250ZXh0J10uYmluZCh0aGlzLmZsdXgpO1xuXG4gICAgdGhpcy5mbHV4Lm9uKCd1cGRhdGUnLCAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZm5OYW1lID0gJ3VwZGF0ZUZvcicgKyBjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSk7XG4gICAgICBjb25zdCBmbiA9IHRoaXNbZm5OYW1lXTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vQ29tcG9uZW50LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBiYXNlTG9kYXNoID0gcmVxdWlyZSgnLi9fYmFzZUxvZGFzaCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xudmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gIHRoaXMuX192aWV3c19fID0gW107XG59XG5cbi8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbkxhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF6eVdyYXBwZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fTGF6eVdyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGJhc2VMb2Rhc2ggPSByZXF1aXJlKCcuL19iYXNlTG9kYXNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAqL1xuZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgdGhpcy5fX2luZGV4X18gPSAwO1xuICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG59XG5cbkxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG5Mb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9kYXNoV3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19Mb2Rhc2hXcmFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fU2V0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYXJyYXlFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hcnJheVB1c2guanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUlzRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTG9kYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VMb2Rhc2guanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1ldGFNYXAgPSByZXF1aXJlKCcuL19tZXRhTWFwJyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpO1xuXG4vKipcbiAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqL1xudmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19nZXREYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldFN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19pc0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX21hcFRvQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZUhvbGRlcnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fcmVwbGFjZUhvbGRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjcmVhdGVGbG93ID0gcmVxdWlyZSgnLi9fY3JlYXRlRmxvdycpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDMuMC4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICogQHNlZSBfLmZsb3dcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICogYWRkU3F1YXJlKDEsIDIpO1xuICogLy8gPT4gOVxuICovXG52YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbG93UmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9mbG93UmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvaXNMZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTEzODE2NzMvZGV0ZWN0aW5nLWEtbW9iaWxlLWJyb3dzZXJcbiAqIGh0dHA6Ly9kZXRlY3Rtb2JpbGVicm93c2Vycy5jb20vXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTW9iaWxlQnJvd3NlcnMoKSB7XG4gIGxldCBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24oYSl7aWYoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCw0KSkpIGNoZWNrID0gdHJ1ZTt9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuICByZXR1cm4gY2hlY2s7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9pc01vYmlsZUJyb3dzZXJzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXNJdGVyYWJsZTIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9pcy1pdGVyYWJsZVwiKTtcblxudmFyIF9pc0l0ZXJhYmxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSXRlcmFibGUyKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShhcnIpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaXNJdGVyYWJsZTMuZGVmYXVsdCkoT2JqZWN0KGFycikpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fZmxhdFJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lzRXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC90aHJvdHRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FpdEZvcihmbiwgY2FsbGJhY2ssIHRpbWUgPSA1MCkge1xuICBjb25zdCByZXN1bHQgPSBmbigpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIC8vIHRyeSBsYXRlclxuICAgIHNldFRpbWVvdXQod2FpdEZvci5iaW5kKG51bGwsIGZuLCBjYWxsYmFjayksIHRpbWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHJlc3VsdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy93YWl0Rm9yLmpzIiwiLy8gR2V0IHRoZSB2aXN1YWwgYm91bmRzIG9mIHRoZSBlbGVtZW50LCBhcyBjbG9zZSB0byB3aGF0IHdvdWxkIGJlIHBlcmNlaXZlZCBieVxuLy8gdGhlIHVzZXIgYXMgd2UgY2FuIG11c3Rlci4gQnkgZGVmYXVsdCBnaXZlcyBpdCBpbiB2aWV3cG9ydCBib3VuZHMgYnV0IHBhc3MgaW5cbi8vIHRydWUgdG8gdGhlIHNlY29uZCBhcmd1bWVudCB0byBnZXQgcGFnZSBib3VuZHMgKHRoYXQncyB0aGUgcGFnZSBsb2FkZWQgaW5zaWRlXG4vLyB0aGlzIGZyYW1lKVxuXG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsT2Zmc2V0IGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsT2Zmc2V0JztcbmltcG9ydCBldmVyeSBmcm9tICdsb2Rhc2gvZXZlcnknO1xuaW1wb3J0IHsgY2xvc2VzdCB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKG4pIHtcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUludChuLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiAwO1xuICByZXR1cm4gdmFsdWU7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyhlbCwgcGFnZUJvdW5kcz1mYWxzZSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB3aW5kb3cud2lkdGgsIGhlaWdodDogd2luZG93LmhlaWdodCB9O1xuICBsZXQgeyB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQgfSA9IGNsaWVudFJlY3Q7XG5cbiAgaWYgKGVsLnRhZ05hbWUgPT09IFwiSU1HXCIpIHtcbiAgICAvLyBJc3N1ZSAjMzc4OiBJZiBhbiBJTUcgZWxlbWVudCBoYXMgbm8gYmFja2dyb3VuZCBvciBib3JkZXIgdGhlbiBpZ25vcmUgaXRzIHBhZGRpbmdcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBjb25zdCBub0JvcmRlciA9IGV2ZXJ5KFtcIkxlZnRcIiwgXCJSaWdodFwiLCBcIlRvcFwiLCBcIkJvdHRvbVwiXSwgZCA9PiBzdHlsZVtcImJvcmRlclwiICsgZF0ubWF0Y2goLyheMHB4ICl8dHJhbnNwYXJlbnQvKSk7XG4gICAgY29uc3Qgbm9CYWNrZ3JvdW5kID0gc3R5bGUuYmFja2dyb3VuZEltYWdlID09PSBcIm5vbmVcIiAmJiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IubWF0Y2goL3JnYmEoLiosXFxzKjApfHJnYigwLDAsMCl8dHJhbnNwYXJlbnR8Lyk7XG4gICAgaWYgKG5vQmFja2dyb3VuZCAmJiBub0JvcmRlcikge1xuICAgICAgdG9wICs9IHBhcnNlTnVtYmVyKHN0eWxlLnBhZGRpbmdUb3ApO1xuICAgICAgbGVmdCArPSBwYXJzZU51bWJlcihzdHlsZS5wYWRkaW5nTGVmdCk7XG4gICAgICB3aWR0aCAtPSAocGFyc2VOdW1iZXIoc3R5bGUucGFkZGluZ1JpZ2h0KSArIHBhcnNlTnVtYmVyKHN0eWxlLnBhZGRpbmdMZWZ0KSk7XG4gICAgICBoZWlnaHQgLT0gKHBhcnNlTnVtYmVyKHN0eWxlLnBhZGRpbmdCb3R0b20pICsgcGFyc2VOdW1iZXIoc3R5bGUucGFkZGluZ1RvcCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50YWdOYW1lID09PSAnSU5QVVQnICYmIGVsLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnZmlsZScpIHtcbiAgICAvLyBpc3N1ZSAjNzgxXG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgaWYgKHN0eWxlLm9wYWNpdHkgPT09ICcwJykge1xuICAgICAgY29uc3QgYnV0dG9uRWwgPSBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgW3R5cGU9XCJidXR0b25cIl0nKTtcbiAgICAgIGlmIChidXR0b25FbCkge1xuICAgICAgICAoeyB3aWR0aCwgaGVpZ2h0LCB0b3AsIGxlZnQgfSA9IGJ1dHRvbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaXNzdWUgIzEwNzc6IGVsZW1lbnQgaW5zaWRlIGEgcG9zaXRpb246YWJzb2x1dGUgZWxlbWVudFxuICAgIC8vIHdoaWNoIGlzIHBhcnRpYWxseSBoaWRkZW4gdmlhIGEgc21hbGxlciBwb3NpdGlvbjpmaXhlZCBwYXJlbnRcbiAgICAvLyA9PiBvbmx5IGNvbnNpZGVyIHdoYXQgaXMgYWN0dWFsbHkgdmlzaWJsZVxuICAgIGxldCBmaXJzdENvbnRhaW5lckZvdW5kID0gZmFsc2U7XG4gICAgY2xvc2VzdChlbCwgY3VycmVudEVsID0+IHtcbiAgICAgIGlmIChjdXJyZW50RWwubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm47XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRFbCk7XG4gICAgICBpZiAoWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGNvbXB1dGVkU3R5bGVzLnBvc2l0aW9uKSkge1xuICAgICAgICBpZiAoIWZpcnN0Q29udGFpbmVyRm91bmQpIHtcbiAgICAgICAgICBmaXJzdENvbnRhaW5lckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRCb3VuZHMgPSBjdXJyZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dYICE9PSAndmlzaWJsZScgJiZcbiAgICAgICAgICAgIChwYXJlbnRCb3VuZHMubGVmdCArIHBhcmVudEJvdW5kcy53aWR0aCkgLSBsZWZ0ID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbigocGFyZW50Qm91bmRzLmxlZnQgKyBwYXJlbnRCb3VuZHMud2lkdGgpIC0gbGVmdCwgd2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAoIXBhZ2VCb3VuZHMpIHtcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgZml4ZWQgYW5kIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCwgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgYm9keVxuICAgIGNvbnN0IHt4LHl9ID0gZ2V0V2luZG93U2Nyb2xsT2Zmc2V0KCk7XG4gICAgdG9wICs9IHk7XG4gICAgbGVmdCArPSB4O1xuICB9XG5cblxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCB5OiB0b3AsIHg6IGxlZnQgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9nZXRFbGVtZW50VmlzdWFsQm91bmRzLmpzIiwiLy8gVGhlIGV4dGVuc2lvbiBBUEkgcG9pbnQgKGNocm9tZSBvbiBDaHJvbWUgYW5kIGJyb3dzZXIgb24gRWRnZSlcbi8vIE5PVEU6IGFjdHVhbGx5IGZvciB0aGUgdGltZSBiZWluZyB3ZSBhcmUgc3RpbGwgdXNpbmcgY2hyb21lIG9uIEVkZ2Vcbi8vIHNpbmNlIHN1cHBvcnQgaXMgc3RpbGwgc2hha3kgYW5kIHdlIHdhbnQgdG8gbGV2ZXJhZ2UgdGhlIGFwaSBicmlkZ2VcblxuLy8gVGhpcyBtb2R1bGUgY2FuIHByb2JhYmx5IGp1c3Qgc3RheSBsaWtlIHRoaXMsIGJ1dCBjb3VsZCAqUE9URU5USUFMTFkqIGdyb3cgdG9cbi8vIGFkZCBjcm9zcyBjb21wYXRpYmlsaXR5IHN0dWZmIGluIHRoZSBmdXR1cmUuIE9yIGl0IGNvdWxkIGdldCB3YXJuaW5ncyBmb3Jcbi8vIEFQSXMgbm90IHN1cHBvcnRlZCBvbiBib3RoLlxuXG4vLyBOT1RFOiBpbiBGaXJlZm94IGNvbnRlbnQgc2NyaXB0cyBgd2luZG93ICE9PSB0aGlzYFxuLy8gdGh1cyBgd2luZG93LmJyb3dzZXJgIGlzIHVuZGVmaW5lZFxuLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNDQwNjZcblxuXG5leHBvcnQgZGVmYXVsdCAoKEJST1dTRVIgPT09ICdlbWJlZCcpID8gdW5kZWZpbmVkXG4gIDogKEJST1dTRVIgPT09IFwiY2hyb21lXCIgfHwgQlJPV1NFUiA9PT0gJ2VkZ2UnIHx8IEJST1dTRVIgPT09ICd0ZXN0JykgPyB3aW5kb3cuY2hyb21lXG4gIDogYnJvd3NlciAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2hyb21lL2Jyb3dzZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDIxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbihmdW5jdGlvbigpIHtcblxuKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgICAgfSBlbHNlIGlmICghYm9keSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgLy8gT25seSBzdXBwb3J0IEFycmF5QnVmZmVycyBmb3IgUE9TVCBtZXRob2QuXG4gICAgICAgIC8vIFJlY2VpdmluZyBBcnJheUJ1ZmZlcnMgaGFwcGVucyB2aWEgQmxvYnMsIGluc3RlYWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIEJvZHlJbml0IHR5cGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQgOiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG4gICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpKSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgIGJvZHkudHJpbSgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gaGVhZGVycyh4aHIpIHtcbiAgICB2YXIgaGVhZCA9IG5ldyBIZWFkZXJzKClcbiAgICB2YXIgcGFpcnMgPSAoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKS50cmltKCkuc3BsaXQoJ1xcbicpXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHNwbGl0LnNoaWZ0KCkudHJpbSgpXG4gICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1c1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHRcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gb3B0aW9ucy5oZWFkZXJzIDogbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdFxuICAgICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpICYmICFpbml0KSB7XG4gICAgICAgIHJlcXVlc3QgPSBpbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgZnVuY3Rpb24gcmVzcG9uc2VVUkwoKSB7XG4gICAgICAgIGlmICgncmVzcG9uc2VVUkwnIGluIHhocikge1xuICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIHNlY3VyaXR5IHdhcm5pbmdzIG9uIGdldFJlc3BvbnNlSGVhZGVyIHdoZW4gbm90IGFsbG93ZWQgYnkgQ09SU1xuICAgICAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzKSA/IDIwNCA6IHhoci5zdGF0dXNcbiAgICAgICAgaWYgKHN0YXR1cyA8IDEwMCB8fCBzdGF0dXMgPiA1OTkpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMoeGhyKSxcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlVVJMKClcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cbi8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmZldGNoO1xufS5jYWxsKGdsb2JhbCkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vaW1wb3J0cy1sb2FkZXI/dGhpcz0+Z2xvYmFsIS4uL34vZXhwb3J0cy1sb2FkZXI/Z2xvYmFsLmZldGNoIS4uL34vd2hhdHdnLWZldGNoL2ZldGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fV2Vha01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hcnJheVNvbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlRm9yT3duLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDIzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlUGlja0J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgbWV0YU1hcCA9IHJlcXVpcmUoJy4vX21ldGFNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gIHJldHVybiBmdW5jO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0RGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlU2V0RGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgfVxuICB9XG4gIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9zZUFyZ3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY29tcG9zZUFyZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gIH1cbiAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvc2VBcmdzUmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY29tcG9zZUFyZ3NSaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjb21wb3NlQXJncyA9IHJlcXVpcmUoJy4vX2NvbXBvc2VBcmdzJyksXG4gICAgY29tcG9zZUFyZ3NSaWdodCA9IHJlcXVpcmUoJy4vX2NvbXBvc2VBcmdzUmlnaHQnKSxcbiAgICBjb3VudEhvbGRlcnMgPSByZXF1aXJlKCcuL19jb3VudEhvbGRlcnMnKSxcbiAgICBjcmVhdGVDdG9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQ3RvcicpLFxuICAgIGNyZWF0ZVJlY3VycnkgPSByZXF1aXJlKCcuL19jcmVhdGVSZWN1cnJ5JyksXG4gICAgZ2V0SG9sZGVyID0gcmVxdWlyZSgnLi9fZ2V0SG9sZGVyJyksXG4gICAgcmVvcmRlciA9IHJlcXVpcmUoJy4vX3Jlb3JkZXInKSxcbiAgICByZXBsYWNlSG9sZGVycyA9IHJlcXVpcmUoJy4vX3JlcGxhY2VIb2xkZXJzJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgfVxuICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChhcmdQb3MpIHtcbiAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgIH1cbiAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHlicmlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NyZWF0ZUh5YnJpZC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzTGF6aWFibGUgPSByZXF1aXJlKCcuL19pc0xhemlhYmxlJyksXG4gICAgc2V0RGF0YSA9IHJlcXVpcmUoJy4vX3NldERhdGEnKSxcbiAgICBzZXRXcmFwVG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRXcmFwVG9TdHJpbmcnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICB9XG4gIHZhciBuZXdEYXRhID0gW1xuICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gIF07XG5cbiAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICB9XG4gIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVjdXJyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jcmVhdGVSZWN1cnJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19lcXVhbEFycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19nZXRBbGxLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcmVhbE5hbWVzID0gcmVxdWlyZSgnLi9fcmVhbE5hbWVzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZ1bmNOYW1lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldEZ1bmNOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gIHZhciBvYmplY3QgPSBmdW5jO1xuICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvbGRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19nZXRIb2xkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIExhenlXcmFwcGVyID0gcmVxdWlyZSgnLi9fTGF6eVdyYXBwZXInKSxcbiAgICBnZXREYXRhID0gcmVxdWlyZSgnLi9fZ2V0RGF0YScpLFxuICAgIGdldEZ1bmNOYW1lID0gcmVxdWlyZSgnLi9fZ2V0RnVuY05hbWUnKSxcbiAgICBsb2Rhc2ggPSByZXF1aXJlKCcuL3dyYXBwZXJMb2Rhc2gnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGF6aWFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faXNMYXppYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKTtcblxuLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0YU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19tZXRhTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX292ZXJBcmcuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fb3ZlclJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlU2V0RGF0YSA9IHJlcXVpcmUoJy4vX2Jhc2VTZXREYXRhJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXREYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3NldERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnZXRXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX2dldFdyYXBEZXRhaWxzJyksXG4gICAgaW5zZXJ0V3JhcERldGFpbHMgPSByZXF1aXJlKCcuL19pbnNlcnRXcmFwRGV0YWlscycpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKSxcbiAgICB1cGRhdGVXcmFwRGV0YWlscyA9IHJlcXVpcmUoJy4vX3VwZGF0ZVdyYXBEZXRhaWxzJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAqL1xuZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRXcmFwVG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc2V0V3JhcFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc2hvcnRPdXQuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL190b1NvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9kZWJvdW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2ZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvZm9yRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2hhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL21lbW9pemUuanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvc3R1YkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3RvTnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3RvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsdXggZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvLyBDYWxsIGhhbmRsZXJzIHdpdGggc3BlY2lmaWVkIHBhdGggdmFsdWVzXG4gIC8vIGlmIHRoZXkgaGF2ZSBjaGFuZ2VkXG4gIHVwZGF0ZXIob2xkU3RhdGUsIHN0YXRlLCBydWxlcykge1xuICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICBsZXQgcnVsZU9iaiA9IHJ1bGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlKSkge1xuICAgICAgICBydWxlT2JqID0ge1xuICAgICAgICAgIHBhdGg6IHJ1bGVbMF0sXG4gICAgICAgICAgaGFuZGxlcjogcnVsZVsxXSxcbiAgICAgICAgICBjb21wYXJlOiBydWxlWzJdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcnVsZU9iai5jb21wYXJlID0gcnVsZU9iai5jb21wYXJlIHx8IGlzRXF1YWw7XG5cbiAgICAgIGlmIChydWxlT2JqLnBhdGgpIHsgLy8gKGZhbHN5IHBhdGhzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBjb25kaXRpb25hbCBydWxlcylcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQoc3RhdGUsIHJ1bGVPYmoucGF0aCk7XG4gICAgICAgIGlmICghb2xkU3RhdGUpIHJ1bGVPYmouaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0KG9sZFN0YXRlLCBydWxlT2JqLnBhdGgpO1xuICAgICAgICAgIGlmICghcnVsZU9iai5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJ1bGVPYmouaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkaXNwYXRjaChjb250ZXh0LCBhY3Rpb25OYW1lLCAuLi5hY3Rpb25BcmdzKSB7XG4gICAgaWYgKGNvbnRleHQubmFtZSAhPT0gdGhpcy5vd25Db250ZXh0TmFtZSkge1xuICAgICAgdGhpcy5jYWxsUmVtb3RlQWN0aW9uKGNvbnRleHQsIGFjdGlvbk5hbWUsIGFjdGlvbkFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkaXJlY3RcbiAgICAgIHRoaXMuY2FsbExvY2FsQWN0aW9uKGFjdGlvbk5hbWUsIGFjdGlvbkFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxSZW1vdGVBY3Rpb24oY29udGV4dCwgYWN0aW9uTmFtZSwgYWN0aW9uQXJncykge1xuICAgIHRoaXMuc2VuZFRvQ29udGV4dChjb250ZXh0LCB7XG4gICAgICB0b3BpYzogJ2Rpc3BhdGNoQWN0aW9uJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uTmFtZSxcbiAgICAgICAgYWN0aW9uQXJncyxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRUb0NvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc2VzIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QnKTtcbiAgfVxuXG4gIGNhbGxMb2NhbEFjdGlvbihhY3Rpb25OYW1lLCBhY3Rpb25BcmdzKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5fYWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb24gbm90IGZvdW5kOiAnICsgYWN0aW9uTmFtZSk7XG4gICAgfVxuICAgIGFjdGlvbiguLi5hY3Rpb25BcmdzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vRmx1eC5qcyIsImNvbnN0IGF1dGhGZXRjaCA9ICh1cmwsIG9wdHMgPSB7fSkgPT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7IGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsIC4uLm9wdHMgfSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgYXV0aEZldGNoO1xuXG5leHBvcnQgY29uc3QgYXBpRmV0Y2ggPSAocHJvY2Vzcy5lbnYuQlJPV1NFUiA9PT0gJ2VtYmVkJykgPyBmZXRjaCA6IGF1dGhGZXRjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2F1dGhGZXRjaC5qcyIsImltcG9ydCB7Z2V0Wm9vbX0gZnJvbSAnYmFzZS9jb250ZW50L3pvb20vem9vbUZyYW1lTm9kZSc7XG5pbXBvcnQgd2FpdEZvckluaXQgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvd2FpdEZvckluaXQnO1xuaW1wb3J0IHsgYWRkV2luZG93TGlzdGVuZXIgfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy93aW5kb3dFdmVudHMnO1xuaW1wb3J0ICogYXMgZnJhbWVNZXNzYWdlcyBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9mcmFtZU1lc3NhZ2VzJztcblxuaW1wb3J0IG1hcFZhbHVlcyBmcm9tICdsb2Rhc2gvbWFwVmFsdWVzJztcbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuLy8gT2Zmc2V0cyBiZXR3ZWVuIHRoZSBvcmlnaW4gb2YgdGhlIHNjcmVlbiBjb29yZGluYXRlIHN5c3RlbSBhbmQgdGhlXG4vLyBjb250ZW50IGNvb3JkaW5hdGUgc3lzdGVtLiBXZSBzdGFydCBvZiB3aXRoIGFuIGVkdWNhdGVkIGd1ZXNzIGJ1dFxuLy8gdGhlIGZpcnN0IHRpbWUgd2Ugc2VlIGEgbW91c2UgZXZlbnQgd2UnbGwgYmUgZ2l2ZW4gYm90aCBjbGllbnQgYW5kXG4vLyBzY3JlZW4gY29vcmRpbmF0ZXMgYW5kIGNhbiBhY3R1YWxseSBnZXQgdGhlIHJlYWwgbnVtYmVyc1xuLy8gSU5JVElBTCBHVUVTUyBWQUxVRVMhXG5jb25zdCBpc1RvcCA9IHdpbmRvdyA9PT0gd2luZG93LnRvcDtcbmxldCBjb250ZW50U2NyZWVuT2Zmc2V0WCA9IHdpbmRvdy5zY3JlZW5YICsgKGlzVG9wID8gKCh3aW5kb3cub3V0ZXJXaWR0aCAtIHdpbmRvdy5pbm5lcldpZHRoKSAvIDIpIDogMCk7XG5sZXQgY29udGVudFNjcmVlbk9mZnNldFkgPSB3aW5kb3cuc2NyZWVuWSArIChpc1RvcCA/ICh3aW5kb3cub3V0ZXJIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBjb250ZW50U2NyZWVuT2Zmc2V0WCkgOiAwKTtcbmxldCBpc1RydXN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gYnJvYWRjYXN0RG93bigpIHtcbiAgY29uc3QgaWZyYW1lcyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIikpXG4gIGlmcmFtZXMuZm9yRWFjaChpZnJhbWUgPT4ge1xuICAgIGNvbnN0IHNjcmVlbkJvdW5kcyA9IHBhZ2Uyc2NyZWVuKGlmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgZnJhbWVNZXNzYWdlcy5zZW5kKGlmcmFtZS5jb250ZW50V2luZG93LCAnY29vcmRpbmF0ZXM6aW5pdGlhbFZhbHVlcycsIHtcbiAgICAgIGNvbnRlbnRTY3JlZW5PZmZzZXRYOiBzY3JlZW5Cb3VuZHMubGVmdCxcbiAgICAgIGNvbnRlbnRTY3JlZW5PZmZzZXRZOiBzY3JlZW5Cb3VuZHMudG9wLFxuICAgICAgaXNUcnVzdGVkLFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2V0cyh2YWx1ZXMpIHtcbiAgY29uc3QgY2hhbmdlZCA9IHZhbHVlcy5jb250ZW50U2NyZWVuT2Zmc2V0WCAhPT0gY29udGVudFNjcmVlbk9mZnNldFggfHxcbiAgICB2YWx1ZXMuY29udGVudFNjcmVlbk9mZnNldFkgIT09IGNvbnRlbnRTY3JlZW5PZmZzZXRZIHx8XG4gICAgdmFsdWVzLmlzVHJ1c3RlZCAhPT0gaXNUcnVzdGVkO1xuXG4gIGlmIChjaGFuZ2VkKSB7XG4gICAgKHsgY29udGVudFNjcmVlbk9mZnNldFgsIGNvbnRlbnRTY3JlZW5PZmZzZXRZLCBpc1RydXN0ZWQgfSA9IHZhbHVlcyk7XG4gICAgYnJvYWRjYXN0RG93bigpO1xuICAgIC8vY29uc29sZS5sb2coJ3VwZGF0ZU9mZnNldHMnLCBjb250ZW50U2NyZWVuT2Zmc2V0WSwgbW91c2VFdmVudC5zY3JlZW5ZLCBtb3VzZUV2ZW50LmNsaWVudFksIHJhdGlvKTtcbiAgfVxufVxuXG5pZiAoIWlzVG9wKSB7XG4gIGZyYW1lTWVzc2FnZXMub25NZXNzYWdlKCdjb29yZGluYXRlczppbml0aWFsVmFsdWVzJywgKHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgaWYgKGlzVHJ1c3RlZCAmJiAhcGF5bG9hZC50cnVzdGVkKSByZXR1cm47XG4gICAgdXBkYXRlT2Zmc2V0cyhwYXlsb2FkKTtcbiAgfSk7XG4gIGZyYW1lTWVzc2FnZXMuc2VuZChmcmFtZU1lc3NhZ2VzLlBBUkVOVCwgJ2Nvb3JkaW5hdGVzOmdldEluaXRpYWxWYWx1ZXMnKTtcbn1cbmZyYW1lTWVzc2FnZXMub25NZXNzYWdlKCdjb29yZGluYXRlczpnZXRJbml0aWFsVmFsdWVzJywgKCkgPT4ge1xuICBicm9hZGNhc3REb3duKCk7XG59KTtcblxuZnVuY3Rpb24gaGFuZGxlRXZlbnQobW91c2VFdmVudCkge1xuICBpZiAoIWRvY3VtZW50LmJvZHkpIHJldHVybjsgLy8gdG9vIGVhcmx5XG4gIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgbW91c2VFdmVudC5zY3JlZW5YID09PSAwICYmIG1vdXNlRXZlbnQuc2NyZWVuWSA9PT0gMCkgcmV0dXJuOyAvLyBpZ25vcmUgZmFrZSBldmVudCAoc2VlIDk0NiNpc3N1ZWNvbW1lbnQtMzM5NjU4OTQyKVxuICBjb25zdCByYXRpbyA9IHByb2Nlc3MuZW52LkJST1dTRVIgPT09ICdlZGdlJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogZ2V0Wm9vbSgpO1xuICB1cGRhdGVPZmZzZXRzKHtcbiAgICBjb250ZW50U2NyZWVuT2Zmc2V0WDogbW91c2VFdmVudC5zY3JlZW5YIC0gKG1vdXNlRXZlbnQuY2xpZW50WCAqIHJhdGlvKSxcbiAgICBjb250ZW50U2NyZWVuT2Zmc2V0WTogbW91c2VFdmVudC5zY3JlZW5ZIC0gKG1vdXNlRXZlbnQuY2xpZW50WSAqIHJhdGlvKSxcbiAgICBpc1RydXN0ZWQ6IHRydWUsXG4gIH0pO1xufVxud2FpdEZvckluaXQoKCkgPT4ge1xuICBhZGRXaW5kb3dMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVFdmVudCwgdHJ1ZSk7XG4gIGFkZFdpbmRvd0xpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVFdmVudCwgdHJ1ZSk7XG4gIGFkZFdpbmRvd0xpc3RlbmVyKCdtb3VzZW92ZXInLCBoYW5kbGVFdmVudCwgdHJ1ZSk7IC8vIG5lZWRlZCBpbiBjYXNlIG9mIDEwMCUgc2l6ZSBpZnJhbWVzICgjODE3KVxufSk7XG5cbmZ1bmN0aW9uIG1hcEJvdW5kc1Bvc2l0aW9uKGJvdW5kc1Bvc2l0aW9uLCBob3Jpem9udGFsRm4sIHZlcnRpY2FsRm4pIHtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IG1hcFZhbHVlcyhwaWNrKGJvdW5kc1Bvc2l0aW9uLCBbJ3gnLCAnbGVmdCcsICdyaWdodCddKSwgaCA9PlxuICAgIGhvcml6b250YWxGbihoKVxuICApO1xuXG4gIGNvbnN0IHZlcnRpY2FsID0gbWFwVmFsdWVzKHBpY2soYm91bmRzUG9zaXRpb24sIFsneScsICd0b3AnLCAnYm90dG9tJ10pLCB2ID0+XG4gICAgdmVydGljYWxGbih2KVxuICApO1xuXG4gIHJldHVybiB7IC4uLmhvcml6b250YWwsIC4uLnZlcnRpY2FsIH07XG59XG5cbmZ1bmN0aW9uIHBhZ2Uyc2NyZWVuKGJvdW5kc1Bvc2l0aW9uLCBvZmZzZXQ9bnVsbCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfHwge3g6IGNvbnRlbnRTY3JlZW5PZmZzZXRYLCB5OiBjb250ZW50U2NyZWVuT2Zmc2V0WX07XG4gIGNvbnN0IHJhdGlvID0gZ2V0Wm9vbSgpO1xuXG4gIHJldHVybiBtYXBCb3VuZHNQb3NpdGlvbihcbiAgICBib3VuZHNQb3NpdGlvbixcbiAgICBoID0+IE1hdGgucm91bmQoKGggKiByYXRpbykgKyBvZmZzZXQueCksXG4gICAgdiA9PiBNYXRoLnJvdW5kKCh2ICogcmF0aW8pICsgb2Zmc2V0LnkpLFxuICApO1xufVxuXG4vLyBVc2VkIGJ5IHRlc3RQYWdlLmpzIGFuZCBzY3JlZW5ib3VuZHMycGFnZSAod2hpY2ggaXMgb25seSB1c2VkIGJ5IHRlc3RQYWdlLmpzKVxuZXhwb3J0IGZ1bmN0aW9uIHNjcmVlbjJwYWdlKGJvdW5kc1Bvc2l0aW9uKSB7XG4gIGNvbnN0IHJhdGlvID0gZ2V0Wm9vbSgpO1xuXG4gIHJldHVybiBtYXBCb3VuZHNQb3NpdGlvbihcbiAgICBib3VuZHNQb3NpdGlvbixcbiAgICBoID0+ICgoaCAtIGNvbnRlbnRTY3JlZW5PZmZzZXRYKSAvIHJhdGlvKSxcbiAgICB2ID0+ICgodiAtIGNvbnRlbnRTY3JlZW5PZmZzZXRZKSAvIHJhdGlvKVxuICApO1xufVxuXG5mdW5jdGlvbiBzY3JlZW4ydGFiKGJvdW5kc1Bvc2l0aW9uKSB7XG4gIHJldHVybiBtYXBCb3VuZHNQb3NpdGlvbihcbiAgICBib3VuZHNQb3NpdGlvbixcbiAgICBoID0+IGggLSBjb250ZW50U2NyZWVuT2Zmc2V0WCxcbiAgICB2ID0+IHYgLSBjb250ZW50U2NyZWVuT2Zmc2V0WVxuICApO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYWdlYm91bmRzMnNjcmVlbihib3VuZHMsIG9mZnNldD1udWxsKSB7XG4gIGNvbnN0IHJhdGlvID0gZ2V0Wm9vbSgpO1xuICBjb25zdCBib3VuZHNQb3NpdGlvbiA9IHBpY2soYm91bmRzLCBbJ3gnLCAneScsICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wYWdlMnNjcmVlbihib3VuZHNQb3NpdGlvbiwgb2Zmc2V0KSxcbiAgICB3aWR0aDogTWF0aC5yb3VuZChib3VuZHMud2lkdGggKiByYXRpbyksXG4gICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kcy5oZWlnaHQgKiByYXRpbyksXG4gIH07XG59XG5cbi8vIE9ubHkgdXNlZCBpbiB0ZXN0UGFnZS5qcyBjdXJyZW50bHlcbmV4cG9ydCBmdW5jdGlvbiBzY3JlZW5ib3VuZHMycGFnZShib3VuZHMpIHtcbiAgY29uc3QgcmF0aW8gPSBnZXRab29tKCk7XG4gIGNvbnN0IGJvdW5kc1Bvc2l0aW9uID0gcGljayhib3VuZHMsIFsneCcsICd5JywgJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnNjcmVlbjJwYWdlKGJvdW5kc1Bvc2l0aW9uKSxcbiAgICB3aWR0aDogYm91bmRzLndpZHRoIC8gcmF0aW8sXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0IC8gcmF0aW8sXG4gIH07XG59XG5cbi8vIE5vdGU6IG9ubHkgd29ya3MgaW4gdG9wIGZyYW1lIVxuZXhwb3J0IGZ1bmN0aW9uIHNjcmVlbmJvdW5kczJ0YWIoYm91bmRzKSB7XG4gIGNvbnN0IGJvdW5kc1Bvc2l0aW9uID0gcGljayhib3VuZHMsIFsneCcsICd5JywgJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnNjcmVlbjJ0YWIoYm91bmRzUG9zaXRpb24pLFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICB9O1xufVxuXG4vLyBOb3RlOiBzY3JlZW4gYW5kIHRhYiBib3VuZHMgYWxyZWFkeSBpbmNsdWRlIHpvb20sXG4vLyB0aHVzIHRoaXMgbWlnaHQgb25seSBiZSB1c2VmdWwgZm9yIHBhZ2UgYm91bmRzLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Wm9vbTJib3VuZHMoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0sIHpvb20pIHtcbiAgbG9nZ2VyLmRlYnVnKCdCZWZvcmUgem9vbScsIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KTtcblxuICB4ID0gTWF0aC5yb3VuZCh4ICogem9vbSk7XG4gIHkgPSBNYXRoLnJvdW5kKHkgKiB6b29tKTtcbiAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogem9vbSk7XG4gIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogem9vbSk7XG5cbiAgbG9nZ2VyLmRlYnVnKCdBZnRlciB6b29tJywgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9jb29yZGluYXRlcy5qcyIsImV4cG9ydCBjb25zdCB3aXRoRGVmYXVsdFByZXZlbnRlZCA9IChmbikgPT4ge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGZuKGUpO1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNsb3Nlc3QgPSAoZWwsIGZuKSA9PiB7XG4gIGxldCBjdXJyZW50RWwgPSBlbDtcbiAgd2hpbGUgKGN1cnJlbnRFbCkge1xuICAgIGlmIChmbihjdXJyZW50RWwpKSByZXR1cm4gY3VycmVudEVsO1xuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnRFbGVtZW50O1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvZG9tLmpzIiwiZnVuY3Rpb24gbm9ybWFsaXplZFVybFdpdGhvdXRPcmlnaW4ocGFyc2VkVXJsKSB7XG4gIC8vIEFkZCBldmVudHVhbCBlbmRpbmcgJy8nIHRvIHBhdGhuYW1lXG4gIC8vIE5vdGU6IHRoaXMgaXMgbmVlZGVkIGZvciB1cmxzIHN1Y2ggYXMgXCJBOiBodHRwczovL3NpdGUuY29tL3NvbWVcIiwgXCJCOiBodHRwczovL3NpdGUuY29tL3NvbWUvXCJcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lID09PSAnJyA/ICcvJyA6IHBhcnNlZFVybC5wYXRobmFtZTtcblxuICAvLyBpZ25vcmUgb3V0IGN1c3RvbSBcImlvcmFkTGl2ZUlkXCIgcXVlcnkgcGFyYW1ldGVyLCBzaW5jZSBpdCBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1c2VyIHBhZ2UuXG4gIC8vIGl0IGFsc28gZG9lcyBvdGhlciBjbGVhbmluZyBvbiB0aGUgc2VhcmNoLlxuICBsZXQgbm9ybWFsaXplZFNlYXJjaCA9IHBhcnNlZFVybC5zZWFyY2gubWF0Y2goL1s/Jl1pb3JhZExpdmVJZD1cXGQrLykgP1xuICAgIHBhcnNlZFVybC5zZWFyY2gucmVwbGFjZSgvWz8mXWlvcmFkTGl2ZUlkPVxcZCsvLCAnJykgOiBwYXJzZWRVcmwuc2VhcmNoO1xuICBub3JtYWxpemVkU2VhcmNoID0gbm9ybWFsaXplZFNlYXJjaC5zdGFydHNXaXRoKCcmJykgPyBub3JtYWxpemVkU2VhcmNoID0gJz8nICsgbm9ybWFsaXplZFNlYXJjaC5zbGljZSgxKSA6IG5vcm1hbGl6ZWRTZWFyY2g7XG4gIG5vcm1hbGl6ZWRTZWFyY2ggPSBub3JtYWxpemVkU2VhcmNoID09PSAnPycgPyAnJyA6IG5vcm1hbGl6ZWRTZWFyY2g7XG5cbiAgY29uc3Qgbm9ybWFsaXplZEhhc2ggPSBwYXJzZWRVcmwuaGFzaCA9PT0gJyMnID8gJycgOiBwYXJzZWRVcmwuaGFzaDtcblxuICByZXR1cm4gbm9ybWFsaXplZFBhdGhuYW1lICsgbm9ybWFsaXplZFNlYXJjaCArIG5vcm1hbGl6ZWRIYXNoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVkaXJlY3Qoc3RlcFVybFN0cmluZywgY3VycmVudFVybFN0cmluZywgZm9yY2UpIHtcbiAgaWYgKCFzdGVwVXJsU3RyaW5nKSByZXR1cm4gbnVsbDtcbiAgY29uc3Qgc3RlcFVybCA9IG5ldyBVUkwoc3RlcFVybFN0cmluZyk7XG4gIGNvbnN0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKGN1cnJlbnRVcmxTdHJpbmcpO1xuXG4gIGlmIChmb3JjZSkge1xuICAgIHJldHVybiBzdGVwVXJsLmhyZWY7XG4gIH1cblxuICBjb25zdCB3aGl0ZWxpc3RlZCA9IChcbiAgICBzdGVwVXJsLmhvc3RuYW1lLmVuZHNXaXRoKFwiLnplbmRlc2suY29tXCIpIHx8XG4gICAgc3RlcFVybC5ob3N0bmFtZS5lbmRzV2l0aChcIi5pb3JhZC5jb21cIikgfHxcbiAgICBzdGVwVXJsLmhvc3RuYW1lLmVuZHNXaXRoKFwiLmlvcmFkLmRldlwiKVxuICApO1xuICBpZiAoIXdoaXRlbGlzdGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEb24ndCBzd2l0Y2ggdG8gdXJscyB3aXRoIG51bWVyaWMgcGF0aCBzZWdtZW50cy4gVGhpcyBpcyBhIHZlcnkgdmVyeVxuICAvLyByb3VnaCBoZXVyaXN0aWMgZm9yIGEgdXJsIHRoYXQgY2hhbmdlcyBkZXBlbmRpbmcgb24gdGhlIHVzZXJcbiAgaWYgKC9cXC9cXGQrKCR8XFwvKS8uZXhlYyhzdGVwVXJsLnBhdGhuYW1lKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB6ZW5kZXNrIHNvIHdlIGNhbiBhcHBseSB1cmxzIHRvIHRoZSB1c2VyJ3MgY3VycmVudFxuICAvLyBhY2NvdW50LiBTZWUgIzYxOVxuICAvLyBRVUVTVElPTjogV291bGQgdGhpcyBtYWtlIHNlbnNlIGluIGdlbmVyYWwgZm9yIHN1Yi1kb21haW5zP1xuICBjb25zdCBpc1plbmRlc2tTdWJkb21haW4gPSBzdGVwVXJsLmhvc3RuYW1lLmVuZHNXaXRoKFwiLnplbmRlc2suY29tXCIpICYmXG4gICAgKGN1cnJlbnRVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuemVuZGVzay5jb21cIikgfHwgd2luZG93LlplbmRlc2spICYmXG4gICAgY3VycmVudFVybC5ob3N0bmFtZSAhPT0gXCJ3d3cuemVuZGVzay5jb21cIiAmJlxuICAgIHN0ZXBVcmwuaG9zdG5hbWUgIT09IFwid3d3LnplbmRlc2suY29tXCI7XG4gIGlmIChpc1plbmRlc2tTdWJkb21haW4pIHtcbiAgICBzdGVwVXJsLmhvc3RuYW1lID0gY3VycmVudFVybC5ob3N0bmFtZTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1cmxzIGFyZSB0aGUgc2FtZSBleGNlcHQgdGhlIHBhcnRzIGFmdGVyIHRoZSBsYXN0ICcvJyxcbiAgLy8gdGhlbiB3ZSBjYW4gYXNzdW1lIGl0IGlzIHNhZmUgdG8gcmVkaXJlY3QuXG4gIC8vIE5vdGU6IHRoZSBcIi9cIiBjb3VsZCBhbHNvIGJlIGluc2lkZSB0aGUgc2VhcmNoIG9yIHRoZSBoYXNoIChlLmcuIFwiLyMvXCIgdnMgXCIvIy9RdW9yYVwiKVxuICBpZiAoc3RlcFVybC5ob3N0bmFtZSA9PT0gY3VycmVudFVybC5ob3N0bmFtZSkge1xuICAgIGNvbnN0IHN0ZXBVcmxQYXJ0cyA9IG5vcm1hbGl6ZWRVcmxXaXRob3V0T3JpZ2luKHN0ZXBVcmwpLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgY3VycmVudFVybFBhcnRzID0gbm9ybWFsaXplZFVybFdpdGhvdXRPcmlnaW4oY3VycmVudFVybCkuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBzYW1lSW5pdGlhbFVybCA9IHN0ZXBVcmxQYXJ0cy5zbGljZSgwLCAtMSkuam9pbignLycpID09PSBjdXJyZW50VXJsUGFydHMuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICBjb25zdCBzYW1lRmluYWxVcmwgPSBzdGVwVXJsUGFydHMuc2xpY2UoLTEpLmpvaW4oJy8nKSA9PT0gY3VycmVudFVybFBhcnRzLnNsaWNlKC0xKS5qb2luKCcvJyk7XG4gICAgaWYgKHNhbWVJbml0aWFsVXJsICYmICFzYW1lRmluYWxVcmwpIHtcbiAgICAgIHJldHVybiBzdGVwVXJsLmhyZWY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWRpcmVjdElmTmVlZGVkKHN0ZXBVcmxTdHJpbmcsIGZvcmNlKSB7XG4gIGNvbnN0IHJlZGlyZWN0VXJsID0gZ2V0UmVkaXJlY3Qoc3RlcFVybFN0cmluZywgd2luZG93LmxvY2F0aW9uLmhyZWYsIGZvcmNlKTtcbiAgaWYgKHJlZGlyZWN0VXJsICYmIHJlZGlyZWN0VXJsICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcmVkaXJlY3RVcmw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBCcm93c2VyIHdvbid0IHJlbG9hZCB0aGUgcGFnZSBpZiBvbmx5IHRoZSBoYXNoIGhhcyBjaGFuZ2VkXG5leHBvcnQgZnVuY3Rpb24gd2lsbEJyb3dzZXJSZWxvYWQob2xkVXJsU3RyaW5nLCBuZXdVcmxTdHJpbmcpIHtcbiAgaWYgKG9sZFVybFN0cmluZyA9PT0gbmV3VXJsU3RyaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qgb2xkVXJsUGFyc2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBvbGRVcmxQYXJzZXIuaHJlZiA9IG9sZFVybFN0cmluZztcblxuICBjb25zdCBuZXdVcmxQYXJzZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIG5ld1VybFBhcnNlci5ocmVmID0gbmV3VXJsU3RyaW5nO1xuXG4gIHJldHVybiBvbGRVcmxQYXJzZXIub3JpZ2luICsgb2xkVXJsUGFyc2VyLnBhdGhuYW1lICsgb2xkVXJsUGFyc2VyLnNlYXJjaCAhPT0gbmV3VXJsUGFyc2VyLm9yaWdpbiArIG5ld1VybFBhcnNlci5wYXRobmFtZSArIG5ld1VybFBhcnNlci5zZWFyY2g7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9wbGF5ZXIuanMiLCIvLyBvbiB0aGUgcGFnZS4gT2YgY291cnNlIHRoaXMgd2lsbCBhbHdheXMgYmUgYSBoZXVyaXN0aWMsIG5vdFxuLy8gcG9zc2libGUgdG8gZG8gaXQgcGVyZmVjdGx5LlxuaW1wb3J0IENTU0VzY2FwZSBmcm9tICdjc3MuZXNjYXBlJztcbmltcG9ydCB7IGRldGVjdE5hbWUgfSBmcm9tICcuL2VsZW1lbnRJbmZvJztcblxuaW1wb3J0IGNvbXBhY3QgZnJvbSAnbG9kYXNoL2NvbXBhY3QnO1xuaW1wb3J0IGZpbHRlciBmcm9tICdsb2Rhc2gvZmlsdGVyJztcbmltcG9ydCBpbnRlcnNlY3Rpb24gZnJvbSAnbG9kYXNoL2ludGVyc2VjdGlvbic7XG5pbXBvcnQgbGFzdCBmcm9tICdsb2Rhc2gvbGFzdCc7XG5pbXBvcnQgbWFwIGZyb20gJ2xvZGFzaC9tYXAnO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSAnbG9kYXNoL3RvQXJyYXknO1xuaW1wb3J0IHVuaW9uIGZyb20gJ2xvZGFzaC91bmlvbic7XG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gvdW5pcSc7XG5pbXBvcnQgZXZlcnkgZnJvbSAnbG9kYXNoL2V2ZXJ5JztcbmltcG9ydCBmbGF0dGVuIGZyb20gJ2xvZGFzaC9mbGF0dGVuJztcbmltcG9ydCBkaWZmZXJlbmNlIGZyb20gJ2xvZGFzaC9kaWZmZXJlbmNlJztcbmltcG9ydCB1bmlxV2l0aCBmcm9tICdsb2Rhc2gvdW5pcVdpdGgnO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSAnbG9kYXNoL2lzRW1wdHknO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5mdW5jdGlvbiBxdWVyeUZpbmQoZG9jdW1lbnQsIHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgaWYgKCFxdWVyeSB8fCBxdWVyeS50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgbGV0IGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuXG4gICAgLy8gaWdub3JlIGludmlzaWJsZSBlbGVtZW50c1xuICAgIC8vIFRPRE86IHRoaXMgY291bGQgbm90IHdvcmsgd2l0aCBmaXhlZCBlbGVtZW50cywgbmVlZHMgaW1wcm92ZW1lbnRcbiAgICAvKmVscyA9IFsuLi5lbHNdLmZpbHRlcihlbCA9PlxuICAgICAgZWwub2Zmc2V0UGFyZW50ICE9PSBudWxsIHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICApOyovXG5cbiAgICByZXR1cm4gZWxzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBsb29raW5nIGZvciBzZWxlY3RvciBcIicgKyBxdWVyeSArICdcIiwgZ290IGVycm9yOiAnLCBlLCAnXFxuJywgZS5zdGFjayk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckJ5VGV4dChlbHMsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICBmdW5jdGlvbiBzaW1wbGlmeVRleHQoYVRleHQpIHtcbiAgICAgIC8vIHJlbW92ZSBudW1iZXJzIHNpbmNlIHRoZXkgb2Z0ZW4gY2hhbmdlXG4gICAgICAvLyBhbW9uZyBkaWZmZXJlbnQgcGxheWJhY2tzXG4gICAgICByZXR1cm4gYVRleHQucmVwbGFjZSgvXFxkKy9nLCAnJykudHJpbSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHQoZSkge1xuICAgICAgaWYgKCFlLmNsYXNzTGlzdCkgcmV0dXJuICcnO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gZSAmJiBlLnRleHRDb250ZW50O1xuICAgICAgaWYgKGUuaGFzQXR0cmlidXRlKCdhbHQnKSkge1xuICAgICAgICB0ZXh0Q29udGVudCA9IGUuZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodGV4dENvbnRlbnQgfHwgJycpO1xuICAgIH1cblxuICAgIGVscyA9IGZpbHRlcihlbHMsIGUgPT4gc2ltcGxpZnlUZXh0KGdldFRleHQoZSkpID09PSBzaW1wbGlmeVRleHQodGV4dCkpO1xuICB9XG4gIHJldHVybiBlbHM7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckJ5RGV0ZWN0ZWROYW1lKGVscywgbmFtZSkge1xuICBpZiAobmFtZSkge1xuICAgIGZ1bmN0aW9uIHNpbXBsaWZ5TmFtZShhTmFtZSkge1xuICAgICAgLy8gcmVtb3ZlIG51bWJlcnMgc2luY2UgdGhleSBvZnRlbiBjaGFuZ2VcbiAgICAgIC8vIGFtb25nIGRpZmZlcmVudCBwbGF5YmFja3NcbiAgICAgIHJldHVybiBhTmFtZS5yZXBsYWNlKC9cXGQrL2csICcnKS50cmltKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShlKSB7XG4gICAgICByZXR1cm4gZGV0ZWN0TmFtZShlKSB8fCAnJztcbiAgICB9XG5cbiAgICBlbHMgPSBmaWx0ZXIoZWxzLCBlID0+IHNpbXBsaWZ5TmFtZShnZXROYW1lKGUpKSA9PT0gc2ltcGxpZnlOYW1lKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gZWxzO1xufVxuXG5mdW5jdGlvbiBhcmVFbGVtZW50c1NpYmxpbmdzKGVscykge1xuICBpZiAoZWxzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZmlyc3RQYXJlbnQgPSBlbHNbMF0ucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFsuLi5lbHNdLmZpbHRlcihlbCA9PiBlbC5wYXJlbnROb2RlICE9PSBmaXJzdFBhcmVudCkubGVuZ3RoID09PSAwO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKGVsKSB7XG4gIGlmICghZWwuYXR0cmlidXRlcykgcmV0dXJuIFtdOyAvLyBlLmcuIHdpbmRvd1xuXG4gIHJldHVybiAoIC8vIG1ha2UgYW4gb2JqZWN0IHthdHRyTmFtZTogYXR0clZhbHVlfVxuICAgIEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykucmVkdWNlKChhdHRycywgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIHsuLi5hdHRycywgW25vZGUubm9kZU5hbWVdOiBub2RlLm5vZGVWYWx1ZX07XG4gICAgfSwge30pXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldE5lc3RlZGluZm8oZWwsIGNvbnRleHRQcm9wLCBpbmZvUHJvcE5hbWUsIG5lc3RpbmdMZXZlbCkge1xuICBjb25zdCBjb250ZXh0Tm9kZSA9IGVsW2NvbnRleHRQcm9wXTtcbiAgaWYgKCFjb250ZXh0Tm9kZSB8fCBuZXN0aW5nTGV2ZWwgPD0gMCkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgaW5mbyA9IGVsZW1lbnRJbmZvKGNvbnRleHROb2RlLCBmYWxzZSk7XG4gIGluZm9baW5mb1Byb3BOYW1lXSA9IGdldE5lc3RlZGluZm8oXG4gICAgZWwsIGNvbnRleHRQcm9wLCBpbmZvUHJvcE5hbWUsIG5lc3RpbmdMZXZlbCAtIDEsXG4gICk7XG4gIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50cyhlbCwgbGltaXQgPSAxMCkge1xuICBjb25zdCBpbmZvID0gIGdldE5lc3RlZGluZm8oZWwsICdwYXJlbnROb2RlJywgJ3BhcmVudCcsIGxpbWl0KTtcbiAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBnZXRQcmV2U2libGluZ3MoZWwsIGxpbWl0ID0gMTApIHtcbiAgcmV0dXJuIGdldE5lc3RlZGluZm8oZWwsICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJywgJ3ByZXZTaWJsaW5nJywgbGltaXQpO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmdzKGVsLCBsaW1pdCA9IDEwKSB7XG4gIHJldHVybiBnZXROZXN0ZWRpbmZvKGVsLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ25leHRTaWJsaW5nJywgbGltaXQpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dEluZm8oZWwpIHtcbiAgcmV0dXJuIHtcbiAgICBwYXJlbnQ6IGdldFBhcmVudHMoZWwpLFxuICAgIHByZXZTaWJsaW5nOiBnZXRQcmV2U2libGluZ3MoZWwpLFxuICAgIG5leHRTaWJsaW5nOiBnZXROZXh0U2libGluZ3MoZWwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50SW5mbyhlbCwgd2l0aENvbnRleHQgPSBmYWxzZSkge1xuICBjb25zdCB7IHRhZ05hbWUsIGNsYXNzTGlzdCB9ID0gZWw7XG4gIGNvbnN0IGlkID0gKGVsLmNsYXNzTGlzdCAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IHVuZGVmaW5lZDtcbiAgY29uc3QgbmFtZSA9IChlbC5jbGFzc0xpc3QgJiYgZWwuZ2V0QXR0cmlidXRlKCduYW1lJykpIHx8IHVuZGVmaW5lZDtcbiAgY29uc3QgZGV0ZWN0ZWROYW1lID0gKFsnSU5QVVQnLCAnVEVYVEFSRUEnXS5pbmRleE9mKGVsLnRhZ05hbWUpICE9PSAtMSAmJiBkZXRlY3ROYW1lKGVsKSkgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IChlbC5jbGFzc0xpc3QgJiYgZWwuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpKSB8fCB1bmRlZmluZWQ7XG4gIGNvbnN0IGhyZWYgPSAoZWwuY2xhc3NMaXN0ICYmIGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCB1bmRlZmluZWQ7XG4gIGNvbnN0IHNyYyA9IChlbC5jbGFzc0xpc3QgJiYgZWwuZ2V0QXR0cmlidXRlKCdzcmMnKSkgfHwgdW5kZWZpbmVkO1xuICBjb25zdCBjaGlsZEluZGV4ID0gKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5jaGlsZHJlbikgPyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGVsLnBhcmVudE5vZGUuY2hpbGRyZW4sIGVsKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBlbC5jbGFzc0xpc3QgPyAoZWwudGV4dENvbnRlbnQudHJpbSgpIHx8IGVsLmdldEF0dHJpYnV0ZSgnYWx0JykpIDogdW5kZWZpbmVkO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhlbCk7XG4gIGNvbnN0IGNvbnRleHRJbmZvID0gd2l0aENvbnRleHQgPyBnZXRDb250ZXh0SW5mbyhlbCkgOiB7fTtcbiAgY29uc3QgYXJpYUxhYmVsID0gKGVsLmNsYXNzTGlzdCAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkgfHwgdW5kZWZpbmVkO1xuXG4gIHJldHVybiB7XG4gICAgdGFnTmFtZSxcbiAgICBpZCxcbiAgICBjbGFzc2VzOiAoY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5sZW5ndGggPiAwKSA/IHRvQXJyYXkoY2xhc3NMaXN0KSA6IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiAodGV4dENvbnRlbnQgJiYgKHRleHRDb250ZW50Lmxlbmd0aCA8IDUwKSkgPyB0ZXh0Q29udGVudCA6IHVuZGVmaW5lZCxcbiAgICBwbGFjZWhvbGRlcixcbiAgICBhcmlhTGFiZWwsXG4gICAgbmFtZSxcbiAgICBkZXRlY3RlZE5hbWUsXG4gICAgaHJlZixcbiAgICBzcmMsXG4gICAgY2hpbGRJbmRleCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIC4uLmNvbnRleHRJbmZvLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRvcihlbCkge1xuICBjb25zdCBsb2NhdG9yID0gW107XG5cbiAgY29uc3QgTUFYX0xFVkVMID0gMTA7XG4gIGxldCBjdXJyZW50RWwgPSBlbDtcbiAgd2hpbGUgKGN1cnJlbnRFbCAhPT0gbnVsbCAmJiBsb2NhdG9yLmxlbmd0aCA8IE1BWF9MRVZFTCkge1xuICAgIGNvbnN0IGluZm8gPSBlbGVtZW50SW5mbyhjdXJyZW50RWwpO1xuICAgIGxvY2F0b3IudW5zaGlmdChpbmZvKTtcblxuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gbG9jYXRvcjtcbn1cblxuY29uc3QgSU1QT1JUQU5UX0lORk9fUFJPUFMgPSBbJ3RhZ05hbWUnLCAnaWQnLCAnbmFtZScsICdkZXRlY3RlZE5hbWUnLCAnaHJlZicsICdzcmMnLCAncGxhY2Vob2xkZXInLCAnYXJpYUxhYmVsJyxdO1xuY29uc3QgaW1wb3J0YW50QXR0cmlidXRlcyA9IFsnaWQnLCAnY2xhc3MnLCAnbmFtZScsICdocmVmJywgJ3NyYycsICdwbGFjZWhvbGRlcicsICdhcmlhLWxhYmVsJ107XG5cbmZ1bmN0aW9uIG1ha2VRdWVyeShpbmZvKSB7XG4gIGxldCBxdWVyeSA9ICcnO1xuICBpZiAoaW5mby50YWdOYW1lKSBxdWVyeSArPSBgJHtDU1NFc2NhcGUoaW5mby50YWdOYW1lKX1gO1xuICBpZiAoaW5mby5pZCkge1xuICAgIHF1ZXJ5ICs9IGAjJHtDU1NFc2NhcGUoaW5mby5pZCl9YDtcbiAgfVxuICBxdWVyeSArPSBtYXAoaW5mby5jbGFzc2VzLCBjbHMgPT4gYC4ke0NTU0VzY2FwZShjbHMpfWApLmpvaW4oJycpO1xuICBpZiAoaW5mby5uYW1lKSB7XG4gICAgcXVlcnkgKz0gYFtuYW1lPVwiJHtDU1NFc2NhcGUoaW5mby5uYW1lKX1cIl1gO1xuICB9XG4gIGlmIChpbmZvLmhyZWYpIHtcbiAgICBxdWVyeSArPSBgW2hyZWY9XCIke0NTU0VzY2FwZShpbmZvLmhyZWYpfVwiXWA7XG4gIH1cbiAgaWYgKGluZm8uaHJlZlN1ZmZpeCkge1xuICAgIHF1ZXJ5ICs9IGBbaHJlZiQ9XCIke0NTU0VzY2FwZShpbmZvLmhyZWZTdWZmaXgpfVwiXWA7XG4gIH1cbiAgaWYgKGluZm8uc3JjKSB7XG4gICAgcXVlcnkgKz0gYFtzcmM9XCIke0NTU0VzY2FwZShpbmZvLnNyYyl9XCJdYDtcbiAgfVxuICBpZiAoaW5mby5jaGlsZEluZGV4ICE9IG51bGwpIHtcbiAgICBxdWVyeSArPSBgOm50aC1jaGlsZCgke2luZm8uY2hpbGRJbmRleCArIDF9KWA7XG4gIH1cbiAgaWYgKGluZm8ucGxhY2Vob2xkZXIpIHtcbiAgICBxdWVyeSArPSBgW3BsYWNlaG9sZGVyPVwiJHtDU1NFc2NhcGUoaW5mby5wbGFjZWhvbGRlcil9XCJdYDtcbiAgfVxuICBpZiAoaW5mby5hcmlhTGFiZWwpIHtcbiAgICBxdWVyeSArPSBgW2FyaWEtbGFiZWw9XCIke0NTU0VzY2FwZShpbmZvLmFyaWFMYWJlbCl9XCJdYDtcbiAgfVxuICBpZiAoaW5mby5hdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG9taXQoaW5mby5hdHRyaWJ1dGVzLCBpbXBvcnRhbnRBdHRyaWJ1dGVzKTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgb2YgT2JqZWN0LmtleXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIGNvbnRpbnVlOyAvLyBJIGhhdmUgbm8gaWRlYSBob3cgdG8gZG8gYSBDU1Mgc2VsZWN0b3IgbmFtZXNwYWNlcyBhdHRyaWJ1dGVzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBxdWVyeSArPSBgWyR7YXR0cmlidXRlTmFtZX09XCIke0NTU0VzY2FwZShhdHRyaWJ1dGVWYWx1ZSl9XCJdYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG5mdW5jdGlvbiBxdWVyeUxvY2F0b3IoZG9jdW1lbnQsIGxvY2F0b3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxvY2F0b3IpKSB7XG4gICAgbG9jYXRvciA9IFtsb2NhdG9yXTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJpZXMgPSBsb2NhdG9yLm1hcChtYWtlUXVlcnkpO1xuICBsZXQgcXVlcnkgPSAocXVlcmllc1swXSB8fCAnJykudHJpbSgpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50UXVlcnkgPSBxdWVyaWVzW2ldLnRyaW0oKTtcbiAgICBjb25zdCBxdWVyeVNlcGFyYXRvciA9ICghcXVlcnkgfHwgIWN1cnJlbnRRdWVyeSkgPyAnJyA6IGxvY2F0b3JbaV0uZGlyZWN0Q2hpbGQgPyAnID4gJyA6ICcgJztcbiAgICBxdWVyeSArPSBxdWVyeVNlcGFyYXRvciArIGN1cnJlbnRRdWVyeTtcbiAgfVxuXG4gIGxldCBlbHMgPSBxdWVyeUZpbmQoZG9jdW1lbnQsIHF1ZXJ5KTtcblxuICBpZiAobGFzdChsb2NhdG9yKS50ZXh0KSB7XG4gICAgZWxzID0gZmlsdGVyQnlUZXh0KGVscywgbGFzdChsb2NhdG9yKS50ZXh0KTtcbiAgfVxuXG4gIGlmIChsYXN0KGxvY2F0b3IpLmRldGVjdGVkTmFtZSkge1xuICAgIGVscyA9IGZpbHRlckJ5RGV0ZWN0ZWROYW1lKGVscywgbGFzdChsb2NhdG9yKS5kZXRlY3RlZE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHsgcXVlcnksIGVscyB9O1xufVxuXG5mdW5jdGlvbiBjb3VudExvY2F0b3IoZG9jdW1lbnQsIGxvY2F0b3IpIHtcbiAgcmV0dXJuIHF1ZXJ5TG9jYXRvcihkb2N1bWVudCwgbG9jYXRvcikuZWxzLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUluZm9TY29yZShpbmZvKSB7XG4gIGNvbnN0IGltcG9ydGFudFByb3BzU2NvcmUgPSAxMDtcbiAgY29uc3QgdGV4dFNjb3JlID0gMTA7XG4gIGNvbnN0IGFDbGFzc1Njb3JlID0gNDtcbiAgY29uc3QgYW5BdHRyaWJ1dGVTY29yZSA9IDQ7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGluZm8pLnJlZHVjZSgoY3VycmVudFNjb3JlLCBpbmZvUHJvcCkgPT4ge1xuICAgIGxldCBwcm9wU2NvcmUgPSAwO1xuICAgIGlmIChJTVBPUlRBTlRfSU5GT19QUk9QUy5pbmRleE9mKGluZm9Qcm9wKSAhPT0gLTEpIHtcbiAgICAgIHByb3BTY29yZSA9IGltcG9ydGFudFByb3BzU2NvcmU7XG4gICAgfSBpZiAoaW5mb1Byb3AgPT09ICd0ZXh0Jykge1xuICAgICAgcHJvcFNjb3JlID0gdGV4dFNjb3JlO1xuICAgIH0gZWxzZSBpZiAoaW5mb1Byb3AgPT09ICdjbGFzc2VzJyAmJiBpbmZvLmNsYXNzZXMpIHtcbiAgICAgIHByb3BTY29yZSA9IGluZm8uY2xhc3Nlcy5sZW5ndGggKiBhQ2xhc3NTY29yZTtcbiAgICB9IGVsc2UgaWYgKGluZm9Qcm9wID09PSAnYXR0cmlidXRlcycgJiYgaW5mby5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKG9taXQoaW5mby5hdHRyaWJ1dGVzLCBbJ2NsYXNzJywgLi4uSU1QT1JUQU5UX0lORk9fUFJPUFNdKSk7XG4gICAgICBwcm9wU2NvcmUgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGggKiBhbkF0dHJpYnV0ZVNjb3JlO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFNjb3JlICsgcHJvcFNjb3JlO1xuICB9LCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxvY2F0b3JTY29yZShsb2NhdG9yKSB7XG4gIHJldHVybiBsb2NhdG9yLnJlZHVjZSgoY3VycmVudFNjb3JlLCBpbmZvKSA9PiBjdXJyZW50U2NvcmUgKyBjYWxjdWxhdGVJbmZvU2NvcmUoaW5mbyksIDApO1xufVxuXG5cbi8vIE5vdGU6IHRoaXMgaXMgYmVzdCBzdWl0ZWQgZm9yIGNvbXBhcmluZyBzaWJsaW5ncy5cblxuLy8gTk9URTogVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBtaWNyby1vcHRpbWlzZWQsIHdlIGNhbGwgaXQgYSAqbG90KlxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVsZW1lbnRzU2ltaWxhcihlbGVtZW50cywgbWluRXF1YWxDbGFzc2VzLCB0aHJlc2hvbGQpIHtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gZWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcblxuICAvLyBUT08gSElHSDogZG9lc24ndCBjYXRjaCBzaW1pbGFyIGVsZW1lbnRzXG4gIC8vIFRPTyBMT1c6IGNhdGNoZXMgZWxlbWVudHMgdGhhdCBhcmVuJ3Qgc2ltaWxhclxuICBpZiAodHlwZW9mIG1pbkVxdWFsQ2xhc3NlcyA9PT0gJ3VuZGVmaW5lZCcpIG1pbkVxdWFsQ2xhc3NlcyA9IDE7XG4gIC8vIHBhcnQgb2Ygbm90IHNpbWlsYXIgZWxlbWVudHMgYWxsb3dlZFxuICBpZiAodHlwZW9mIHRocmVzaG9sZCA9PT0gJ3VuZGVmaW5lZCcpIHRocmVzaG9sZCA9IDAuMjsgLy8gMjAlXG5cbiAgLy8gTXVzdCBhbGwgYmUgdGhlIHNhbWUgdGFnIHR5cGVcbiAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnRzWzBdLnRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZWxlbWVudHNbaV0udGFnTmFtZSB8fCBlbGVtZW50c1tpXS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09IHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGV5IG11c3QgYWxsIGhhdmUgdGhlIHNhbWUgdGFnIG5hbWVcbiAgLy8gbGlzdC90YWJsZSBlbGVtZW50cyBhcmUgc2ltaWxhciByZWdhcmRsZXNzIG9mIGV2ZXJ5dGhpbmcgZWxzZVxuICBjb25zdCBhcmVMaXN0VGFibGVFbGVtZW50cyA9ICh0YWdOYW1lID09PSAnTEknIHx8IHRhZ05hbWUgPT09ICdUUicgfHwgdGFnTmFtZSA9PT0gJ1REJyk7XG4gIGlmIChhcmVMaXN0VGFibGVFbGVtZW50cykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIG9yIHRoZXkgbXVzdCBhbGwgaGF2ZSBhdCBsZWFzdCBYIGVxdWFsIGNsYXNzZXMgKG9yIG5vIGNsYXNzIGF0IGFsbClcblxuICBjb25zdCBzZWVuQ2xhc3NlcyA9IHt9O1xuICBsZXQgc2hhcmVkQ2xhc3NlcyA9IDAsIHRvdGFsQ2xhc3NlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbCA9IGVsZW1lbnRzW2ldLmNsYXNzTGlzdDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBjID0gY2xbal07XG4gICAgICBjb25zdCB2YWwgPSAoc2VlbkNsYXNzZXNbY10gfHwgMCkgKyAxO1xuICAgICAgc2VlbkNsYXNzZXNbY10gPSB2YWw7XG4gICAgICBpZiAodmFsID49IGVsZW1lbnRzLmxlbmd0aCAqICgxIC0gdGhyZXNob2xkKSkge1xuICAgICAgICBzaGFyZWRDbGFzc2VzKys7XG4gICAgICAgIGlmIChzaGFyZWRDbGFzc2VzID49IG1pbkVxdWFsQ2xhc3Nlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3RhbENsYXNzZXMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgaGF2ZU5vQ2xhc3NlcyA9IHRvdGFsQ2xhc3NlcyA9PT0gMDtcbiAgaWYgKGhhdmVOb0NsYXNzZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gTm90ZTogdXNlcyBkZXB0aC1maXJzdCBzZWFyY2guXG5leHBvcnQgZnVuY3Rpb24gZmluZFNpbWlsYXJCb3R0b21EZXNjZW5kYW50cyhlbCwgZGVzY2VuZGFudHMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZ2luYWxEZXNjZW5kYW50c0xlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBvcmlnaW5hbERlc2NlbmRhbnRzTGVuZ3RoOiBkZXNjZW5kYW50cy5sZW5ndGggfTtcbiAgfVxuXG4gIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDApIHJldHVybiBbZWxdOyAvLyBlbmQgb2YgcmVjdXJzaW9uXG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG5cbiAgY29uc3Qgc2ltaWxhclRvcERlc2NlbmRhbnRzID0gY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IHtcbiAgICByZXR1cm4gYXJlRWxlbWVudHNTaW1pbGFyKFtjaGlsZCwgZGVzY2VuZGFudHNbMF1dLFxuICAgICAgLy8gYmUgbGVzcyByZXN0cmljdGl2ZSB3aXRoIG5vbi1ib3R0b20gZGVzY2VuZGFudHNcbiAgICAgIChkZXNjZW5kYW50cy5sZW5ndGggPiAxKSA/IDEgOiBvcHRpb25zLm1pbkVxdWFsQ2xhc3NlcyxcbiAgICApO1xuICB9KTtcbiAgZm9yIChjb25zdCBzaW1pbGFyVG9wRGVzY2VuZGFudCBvZiBzaW1pbGFyVG9wRGVzY2VuZGFudHMpIHtcbiAgICBjb25zdCBzaW1pbGFyQm90dG9tRGVzY2VuZGFudHMgPSBmaW5kU2ltaWxhckJvdHRvbURlc2NlbmRhbnRzKHNpbWlsYXJUb3BEZXNjZW5kYW50LCBkZXNjZW5kYW50cy5zbGljZSgxKSwgb3B0aW9ucyk7XG4gICAgcmVzdWx0LnB1c2goLi4uc2ltaWxhckJvdHRvbURlc2NlbmRhbnRzKTtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgc2ltaWxhclRvcERlc2NlbmRhbnRzLmxlbmd0aCAhPT0gY2hpbGRyZW4ubGVuZ3RoICYmIG9wdGlvbnMub3JpZ2luYWxEZXNjZW5kYW50c0xlbmd0aCA+IDEgJiYgIW9wdGlvbnMuc2tpcHBlZE9uZSkge1xuICAgIC8vIHJldHJ5IGJ5IHNraXBwaW5nIG9uZSBkZXNjZW5kYW50XG4gICAgLy8gTk9URTogdGhpcyBpcyBuZWVkZWQgaW4gY2FzZSB0aGUgb3JpZ2luYWwgZWxlbWVudCBoYXMgYSB3cmFwcGVyIHRoYXQgZG9lc24ndCBleGlzdCBpbiBhIHNpbWlsYXIgZWxlbWVudCAoZS5nLiBnbWFpbCAjNjU4KVxuICAgIGNvbnN0IHNpbWlsYXJCb3R0b21EZXNjZW5kYW50cyA9IGZpbmRTaW1pbGFyQm90dG9tRGVzY2VuZGFudHMoZWwsIGRlc2NlbmRhbnRzLnNsaWNlKDEpLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc2tpcHBlZE9uZTogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXN1bHQucHVzaCguLi5zaW1pbGFyQm90dG9tRGVzY2VuZGFudHMpO1xuXG4gICAgLy8gTm90ZTogdGhpcyBpcyBuZWVkZWQgaW4gY2FzZSB0aGUgc2ltaWxhciBlbGVtZW50IGhhcyBhIHdyYXBwZXIgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBlbGVtZW50IChlLmcuIGdtYWlsICM2OTApXG4gICAgLy8gKGkuZS4gaXMgdGhlIHNwZWN1bGFyIGNhc2Ugb2YgdGhlIHByZXZpb3VzIG9uZSlcbiAgICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtb3JlU2ltaWxhckJvdHRvbURlc2NlbmRhbnRzID0gZmluZFNpbWlsYXJCb3R0b21EZXNjZW5kYW50cyhlbC5jaGlsZHJlblswXSwgZGVzY2VuZGFudHMsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2tpcHBlZE9uZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LnB1c2goLi4ubW9yZVNpbWlsYXJCb3R0b21EZXNjZW5kYW50cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBGaW5kIGNsb3Nlc3QgYW5jZXN0b3Igd2l0aCBzaW1pbWlsYXIgZGVzY2VuZGFudHMuXG4vLyBUaGUgYm90dG9tIGRlc2NlbmRhbnRzIHdpbGwgYmUgdGhlIHNpbWlsYXIgZWxlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gZmluZFNpbWlsYXJFbGVtZW50cyhlbCkge1xuICBsZXQgcmVzdWx0ID0gW2VsXTtcblxuICBjb25zdCBkZXNjZW5kYW50cyA9IFtdO1xuICBsZXQgY3VycmVudEVsID0gZWw7XG4gIHdoaWxlIChjdXJyZW50RWwgJiYgY3VycmVudEVsLnBhcmVudE5vZGUgJiYgY3VycmVudEVsLnBhcmVudE5vZGUuY2xhc3NMaXN0KSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBjdXJyZW50RWwucGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBNSU5fU0lCTElOR1MgPSAxO1xuICAgIGlmIChzaWJsaW5ncy5sZW5ndGggPj0gTUlOX1NJQkxJTkdTICYmIGFyZUVsZW1lbnRzU2ltaWxhcihzaWJsaW5ncykpIHtcbiAgICAgIC8vIGZpbmQgc2ltaWxhciBkZXNjZW5kYW50cyBkb3dud2FyZHMhXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmZpbmRTaW1pbGFyQm90dG9tRGVzY2VuZGFudHMoc2libGluZ3NbaV0sIGRlc2NlbmRhbnRzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVzY2VuZGFudHMudW5zaGlmdChjdXJyZW50RWwpO1xuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmVzdWx0ID0gdW5pcShyZXN1bHQpO1xuICBjb25zdCBNSU5fTEVOR1RIID0gMjtcbiAgaWYgKHJlc3VsdC5sZW5ndGggPiBNSU5fTEVOR1RIKSB7XG4gICAgcmVzdWx0ID0gcmVkdWNlQnlUYWdOYW1lKGVsLCByZXN1bHQpO1xuICB9XG4gIGlmIChyZXN1bHQubGVuZ3RoID4gTUlOX0xFTkdUSCkge1xuICAgIHJlc3VsdCA9IHJlZHVjZUJ5U2hhcmVkQ2xhc3NlcyhlbCwgcmVzdWx0LCBNSU5fTEVOR1RIKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWR1Y2VCeVRhZ05hbWUoZWwsIHNlbHMpIHtcbiAgcmV0dXJuIHNlbHMuZmlsdGVyKHNlbCA9PiBzZWwudGFnTmFtZSA9PT0gZWwudGFnTmFtZSk7XG59XG5cbmNvbnN0IGhhc0NsYXNzZXNSZXF1aXJlZCA9IChsZW5ndGgsIGNsYXNzTGlzdCkgPT4gKHNlbCkgPT5cbiAgaW50ZXJzZWN0aW9uKHNlbC5jbGFzc0xpc3QsIGNsYXNzTGlzdCkubGVuZ3RoID49IGxlbmd0aDtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUJ5U2hhcmVkQ2xhc3NlcyhlbCwgc2VscywgbWluTGVuZ3RoKSB7XG4gIGxldCByZWR1Y2VkTGlzdCA9IFtdO1xuICBjb25zdCBjbCA9IGVsLmNsYXNzTGlzdDtcblxuICBmb3IgKFxuICAgIGxldCBsZW5ndGhSZXF1aXJlZCA9IGNsLmxlbmd0aDtcbiAgICByZWR1Y2VkTGlzdC5sZW5ndGggPCBtaW5MZW5ndGggJiYgbGVuZ3RoUmVxdWlyZWQgPiAwO1xuICAgIGxlbmd0aFJlcXVpcmVkLS1cbiAgKSB7XG4gICAgcmVkdWNlZExpc3QgPSBzZWxzLmZpbHRlcihoYXNDbGFzc2VzUmVxdWlyZWQobGVuZ3RoUmVxdWlyZWQsIGNsKSk7XG4gIH1cbiAgcmV0dXJuIHJlZHVjZWRMaXN0Lmxlbmd0aCA8IG1pbkxlbmd0aCA/IHNlbHMgOiByZWR1Y2VkTGlzdDtcbn1cblxuXG5cbi8vIE5hcnJvdyBhIHNlbGVjdG9yIHBhcnQgKGdpdmVuIHRoZSBmdWxsIG9yaWdpbmFsIHZlcnNpb24pXG5mdW5jdGlvbiAqbmFycm93UGFydChpbmZvLCBvcmlnaW5hbEluZm8sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IG9ubHlJbXBvcnRhbnQgPSBmYWxzZSwgaW5jbHVkZVRleHQgPSBmYWxzZSwgaW5jbHVkZURpcmVjdENoaWxkID0gZmFsc2UgfSA9IG9wdGlvbnM7XG5cbiAgZm9yIChsZXQgcHJvcCBvZiBJTVBPUlRBTlRfSU5GT19QUk9QUykge1xuICAgIC8vIE11c3QgYm90aCBiZSBpbiBvcmlnaW5hbEluZm8gQU5EIGJlIG5vbi1mYWxzeVxuICAgIGlmICghKHByb3AgaW4gaW5mbykgJiYgb3JpZ2luYWxJbmZvW3Byb3BdKSB7XG4gICAgICB5aWVsZCB7Li4uaW5mbywgW3Byb3BdOiBvcmlnaW5hbEluZm9bcHJvcF19O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlVGV4dCkge1xuICAgIGlmIChvcmlnaW5hbEluZm8udGV4dCkge1xuICAgICAgY29uc3QgdGV4dCA9IG9yaWdpbmFsSW5mby50ZXh0O1xuXG4gICAgICBpZiAodHlwZW9mIGluZm8udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgeWllbGQgKHtcbiAgICAgICAgICAuLi5pbmZvLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcmlnaW5hbEluZm8uY2xhc3Nlcykge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBvcmlnaW5hbEluZm8uY2xhc3NlcztcblxuICAgIGZvciAoY29uc3QgYUNsYXNzIG9mIGNsYXNzZXMpIHtcbiAgICAgIGlmICghaW5mby5jbGFzc2VzIHx8IGluZm8uY2xhc3Nlcy5pbmRleE9mKGFDbGFzcykgPT09IC0xKSB7XG4gICAgICAgIC8vIHJlc3RyaWN0IHdpdGggY2xhc3NcbiAgICAgICAgeWllbGQgKHtcbiAgICAgICAgICAuLi5pbmZvLFxuICAgICAgICAgIGNsYXNzZXM6IFtcbiAgICAgICAgICAgIC4uLihpbmZvLmNsYXNzZXMgfHwgW10pLFxuICAgICAgICAgICAgYUNsYXNzLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcmlnaW5hbEluZm8uYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBvbWl0KG9yaWdpbmFsSW5mby5hdHRyaWJ1dGVzLCBpbXBvcnRhbnRBdHRyaWJ1dGVzKTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBvZiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKCFpbmZvLmF0dHJpYnV0ZXMgfHwgdHlwZW9mIGluZm8uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gcmVzdHJpY3Qgd2l0aCBhdHRyaWJ1dGVcbiAgICAgICAgeWllbGQgKHtcbiAgICAgICAgICAuLi5pbmZvLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIC4uLmluZm8uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIFthdHRyaWJ1dGVOYW1lXTogYXR0cmlidXRlVmFsdWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvbmx5SW1wb3J0YW50KSB7XG4gICAgaWYgKG9yaWdpbmFsSW5mby5jaGlsZEluZGV4ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBvcmlnaW5hbEluZm8uY2hpbGRJbmRleDtcblxuICAgICAgaWYgKHR5cGVvZiBpbmZvLmNoaWxkSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHlpZWxkICh7XG4gICAgICAgICAgICAuLi5pbmZvLFxuICAgICAgICAgIGNoaWxkSW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmNsdWRlRGlyZWN0Q2hpbGQpIHtcbiAgICBpZiAoIWluZm8uZGlyZWN0Q2hpbGQpIHtcbiAgICAgIHlpZWxkICh7XG4gICAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgZGlyZWN0Q2hpbGQ6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHJlcGxhY2VJbmRleChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gIHJldHVybiBbLi4uYXJyYXkuc2xpY2UoMCwgaW5kZXgpLCB2YWx1ZSwgLi4uYXJyYXkuc2xpY2UoaW5kZXgrMSldO1xufVxuXG5mdW5jdGlvbiBtYXhpbWl6ZU5hcnJvd2luZ0luZGV4KGRvY3VtZW50LCBsb2NhdG9yLCBmdWxsTG9jYXRvciwgaSkge1xuICBmb3IgKGNvbnN0IG5hcnJvd2VkUGFydCBvZiBuYXJyb3dQYXJ0KGxvY2F0b3JbaV0sIGZ1bGxMb2NhdG9yW2ldLCB7XG4gICAgb25seUltcG9ydGFudDogZmFsc2UsXG4gICAgaW5jbHVkZVRleHQ6IGkgPT09IGxvY2F0b3IubGVuZ3RoIC0gMSxcbiAgICBpbmNsdWRlRGlyZWN0Q2hpbGQ6IGkgPiAwICYmICFpc0VtcHR5KGxvY2F0b3JbaSAtIDFdKSxcbiAgfSkpIHtcbiAgICBjb25zdCBuYXJyb3dlZExvY2F0b3IgPSByZXBsYWNlSW5kZXgobG9jYXRvciwgaSwgbmFycm93ZWRQYXJ0KTtcbiAgICBjb25zdCBuYXJyb3dlZENvdW50ID0gY291bnRMb2NhdG9yKGRvY3VtZW50LCBuYXJyb3dlZExvY2F0b3IpO1xuICAgIGlmIChuYXJyb3dlZENvdW50ICE9PSAwKSB7XG4gICAgICAvLyB0aGUgbmFycm93ZWQgbG9jYXRvciBjYW4gb25seSBiZSBiZXR0ZXIgaW4gdGVybSBvZiBjb3VudCAoc2luY2UgaXMgYSByZXN0cmljdGlvbilcbiAgICAgIHJldHVybiBtYXhpbWl6ZU5hcnJvd2luZ0luZGV4KGRvY3VtZW50LCBuYXJyb3dlZExvY2F0b3IsIGZ1bGxMb2NhdG9yLCBpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRvcjtcbn1cblxuLy8gTmFycm93cyB0aGUgbG9jYXRvciBhcyBtdWNoIGFzIHBvc3NpYmxlLCBzbyB0byBtYXhpbWl6ZSBpdHMgc2NvcmVcbi8vIChhIE1VU1QgaW4gbXVsdGktZnJhbWUgc2NlbmFyaW9zKVxuZnVuY3Rpb24gbWF4aW1pemVOYXJyb3dpbmcoZG9jdW1lbnQsIGxvY2F0b3IsIGZ1bGxMb2NhdG9yKSB7XG4gIGZvciAobGV0IGkgPSBsb2NhdG9yLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbG9jYXRvciA9IG1heGltaXplTmFycm93aW5nSW5kZXgoZG9jdW1lbnQsIGxvY2F0b3IsIGZ1bGxMb2NhdG9yLCBpKTtcbiAgfVxuXG4gIHJldHVybiBsb2NhdG9yO1xufVxuXG4vLyBUaGUgYWJzb2x1dGUgbWluaW1hbCB2ZXJzaW9uIG9mIGEgbG9jYXRvciB3ZSBkZW1hbmQgbWF0Y2hlcyAodGhpcyBmdW5jdGlvblxuLy8ganVzdCBwcm9kdWNlcyB0aGUgbWluaW1hbCB2ZXJzaW9uLCBpdCBET0VTIE5PVCB0ZXN0IGl0KVxuZnVuY3Rpb24gbWluaW1hbExvY2F0b3IoZnVsbExvY2F0b3IsIGxvb3NlID0gZmFsc2UpIHtcbiAgLy8gUVVFU1RJT046IGlzIHRoaXMgbWluaW1hbCBlbm91Z2g/IFNob3VsZCB3ZSBhY2NlcHQgY2hhaW5zIGluIHdoaWNoIHRoZSB0YWdcbiAgLy8gbmFtZXMgZG9uJ3QgYWxsIG1hdGNoPyBNYXliZSB3ZSBzaG91bGQganVzdCBpbnNpc3Qgb24gY2VydGFpbiB0YWdzIChURCBhbmRcbiAgLy8gVEggd291bGQgYmUgZ29vZCBjYW5kaWRhdGVzIGZvciB0aGlzKT9cbiAgcmV0dXJuIGZ1bGxMb2NhdG9yLm1hcCgobCwgaSkgPT4ge1xuICAgIGlmIChsb29zZSAmJiAoaSAhPT0gZnVsbExvY2F0b3IubGVuZ3RoIC0gMSkgJiYgbC50YWdOYW1lID09PSAnRElWJykgcmV0dXJuIHt9OyAvLyB0b28gZ2VuZXJpYywgZXZlbiBhIHNpbmdsZSB3cmFwcGVyIERJViB3b3VsZCBicmVhayB0aGUgbG9jYXRvciAoc2VlICM5MTgpXG5cbiAgICBjb25zdCBzZWdtZW50ID0ge1xuICAgICAgdGFnTmFtZTogbC50YWdOYW1lXG4gICAgfTtcbiAgICAvLyBEZW1hbmQgdGhhdCBpZiBhIHRhZyBpcyBJTlBVVCBpdCBzaG91bGQgYmUgdGhlIHJpZ2h0ICp0eXBlKiBvZiBpbnB1dFxuICAgIGlmIChsLnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgbC5hdHRyaWJ1dGVzICYmIGwuYXR0cmlidXRlcy50eXBlKSB7XG4gICAgICBzZWdtZW50LmF0dHJpYnV0ZXMgPSB7dHlwZTogbC5hdHRyaWJ1dGVzLnR5cGV9O1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudDtcbiAgfSk7XG59XG5cbi8vIHJlc3RyaWN0aW9uOiBzaG91bGRuJ3QgbWF0Y2ggYnkganVzdCB1c2luZyB0YWdOYW1lIGFuZC9vciBwb3NpdGlvblxuLy8gKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBsb2NhdG9ycyBjb21wb3NlZCBvZiBqdXN0IEhUTUwgYW5kIEJPRFkgZWxlbWVudHMpXG5mdW5jdGlvbiBpc0ludmFsaWRMb2NhdG9yKGxvY2F0b3IpIHtcbiAgY29uc3Qgbm9uVHJpdmlhbExvY2F0b3IgPSBsb2NhdG9yLmZpbHRlcihsID0+IFsnSFRNTCcsICdCT0RZJywgdW5kZWZpbmVkXS5pbmRleE9mKGwudGFnTmFtZSkgPT09IC0xKTtcbiAgcmV0dXJuIG5vblRyaXZpYWxMb2NhdG9yLmxlbmd0aCAhPT0gMCAmJiBldmVyeShub25Ucml2aWFsTG9jYXRvciwgbCA9PlxuICAgIGV2ZXJ5KE9iamVjdC5rZXlzKGwpLCBrZXkgPT4gWyd0YWdOYW1lJywgJ2NoaWxkSW5kZXgnLCAnZGlyZWN0Q2hpbGQnXS5pbmRleE9mKGtleSkgPj0gMClcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hMb2NhdG9yKGRvY3VtZW50LCBmdWxsTG9jYXRvciwgYWxsb3dNdWx0aXBsZT1mYWxzZSkge1xuICAvLyBXaGF0ZXZlciBoYXBwZW5zIHdlIGFsd2F5cyBleHBlY3QgdG8gZmluZCB0aGUgY29ycmVjdCBzZXF1ZW5jZSBvZiB0YWcgbmFtZXNcblxuICBsZXQgbWluTG9jYXRvciA9IG1pbmltYWxMb2NhdG9yKGZ1bGxMb2NhdG9yKTtcbiAgbGV0IG1pbkNvdW50ID0gY291bnRMb2NhdG9yKGRvY3VtZW50LCBtaW5Mb2NhdG9yKTtcbiAgaWYgKG1pbkNvdW50ID09PSAwKSB7XG4gICAgLy8gdHJ5IGJlaW5nIGxlc3Mgc3RyaWN0XG4gICAgbWluTG9jYXRvciA9IG1pbmltYWxMb2NhdG9yKGZ1bGxMb2NhdG9yLCB0cnVlKTtcbiAgICBtaW5Db3VudCA9IGNvdW50TG9jYXRvcihkb2N1bWVudCwgbWluTG9jYXRvcik7XG4gICAgaWYgKG1pbkNvdW50ID09PSAwKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJFdmVuIHRoZSBsb29zZSBtaW5pbWFsIGxvY2F0b3IgZGlkbid0IG1hdGNoLCBubyBwb2ludCBnb2luZyBmdXJ0aGVyXCIsIGZ1bGxMb2NhdG9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hcnJvd2VkTG9jYXRvciA9IG1heGltaXplTmFycm93aW5nKGRvY3VtZW50LCBtaW5Mb2NhdG9yLCBmdWxsTG9jYXRvcik7XG4gIGNvbnN0IG5hcnJvd2VkQ291bnQgPSBjb3VudExvY2F0b3IoZG9jdW1lbnQsIG5hcnJvd2VkTG9jYXRvcik7XG4gIGxvZ2dlci5kZWJ1ZygnRm91bmQgc28gZmFyJywgbmFycm93ZWRMb2NhdG9yLCBuYXJyb3dlZENvdW50KTtcblxuICBpZiAobmFycm93ZWRDb3VudCA9PT0gMSB8fCBhbGxvd011bHRpcGxlKSB7XG4gICAgaWYgKGlzSW52YWxpZExvY2F0b3IobmFycm93ZWRMb2NhdG9yKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5hcnJvd2VkTG9jYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYXRlRWxlbWVudChsb2NhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFsb2NhdG9yKSByZXR1cm4geyBlbDogbnVsbCwgcXVlcnk6IG51bGwsIHNjb3JlOiAwIH07XG4gIGlmICghQXJyYXkuaXNBcnJheShsb2NhdG9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxvY2F0b3IgdG8gYmUgYW4gYXJyYXk6IFwiICsgSlNPTi5zdHJpbmdpZnkobG9jYXRvcikpO1xuICB9XG4gIGNvbnN0IGRvY3VtZW50ID0gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgbG9nZ2VyLmRlYnVnKCdMb2NhdGluZycsIGxvY2F0b3IpO1xuXG4gIGNvbnN0IG1hdGNoaW5nTG9jYXRvciA9IG1hdGNoTG9jYXRvcihkb2N1bWVudCwgbG9jYXRvciwgb3B0aW9ucy5tdWx0aXBsZU1hdGNoZXMpO1xuXG4gIGlmIChtYXRjaGluZ0xvY2F0b3IpIHtcbiAgICBsZXQgeyBxdWVyeSwgZWxzIH0gPSBxdWVyeUxvY2F0b3IoZG9jdW1lbnQsIG1hdGNoaW5nTG9jYXRvcik7XG5cbiAgICBpZiAob3B0aW9ucy5tdWx0aXBsZU1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRWxzID0gZWxzO1xuICAgICAgLy8gZmluZCBhbGwgdGhlIHNpbWlsYXIgZWxlbWVudHNcblxuICAgICAgLy8gV2UgdXNlZCB0byBmaW5kU2ltaWxhckVsZW1lbnRzIGZyb20gYWxsIG9mIHRoZSBjdXJyZW50IGVsZW1lbnRzIGxpa2UgdGhpcy4uLlxuICAgICAgLy8gZWxzID0gW10uY29uY2F0KC4uLm9yaWdpbmFsRWxzLm1hcChlbCA9PiBmaW5kU2ltaWxhckVsZW1lbnRzKGVsKSkpO1xuICAgICAgLy8gLi4uYnV0IHRoYXQgd2FzIHZlcnkgc2xvdyBpbiBzb21lIHNpdHVhdGlvbnMgc28gbm93IHdlIGp1c3QgbG9vayBhdCB0aGUgZmlyc3QgbGlrZSB0aGlzLi4uXG4gICAgICBpZiAoZWxzLmxlbmd0aCkge1xuICAgICAgICBlbHMgPSBlbHMuY29uY2F0KGZpbmRTaW1pbGFyRWxlbWVudHMoZWxzWzBdKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIGR1cGxpY2F0ZSByZXN1bHRzIHdlIG5lZWQgdG8gcmVtb3ZlXG4gICAgICAvLyBtb3Jlb3ZlciwgdGhlcmUgbWlnaHQgYmUgZWxlbWVudHMgdGhhdCBhcmUgYW5jZXN0b3JzIG9mIG90aGVyIGVsZW1lbnRzXG4gICAgICAvLyAod2Ugd2FudCB0byBrZWVwIHRoZSBkZXNjZW5kYW50cylcbiAgICAgIGVscyA9IHVuaXFXaXRoKGVscywgKGVsQSwgZWxCKSA9PiBlbEEgPT09IGVsQiB8fCBlbEEuY29udGFpbnMoZWxCKSk7XG4gICAgICByZXR1cm4geyBxdWVyeSwgZWw6IGVscywgc2NvcmU6IGNhbGN1bGF0ZUxvY2F0b3JTY29yZShtYXRjaGluZ0xvY2F0b3IpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHF1ZXJ5LCBlbDogZWxzWzBdLCBzY29yZTogY2FsY3VsYXRlTG9jYXRvclNjb3JlKG1hdGNoaW5nTG9jYXRvcikgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBlbDogbnVsbCwgcXVlcnk6IFwiXCIsIHNjb3JlOiAwIH07XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9lbGVtZW50TG9jYXRvci5qcyIsImltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL2RlZmF1bHRzJztcbmltcG9ydCBmb3JFYWNoIGZyb20gJ2xvZGFzaC9mb3JFYWNoJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaXNFbXB0eSBmcm9tICdsb2Rhc2gvaXNFbXB0eSc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgb21pdCBmcm9tICdsb2Rhc2gvb21pdCc7XG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9zZXQnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHNoYXJlZEVtaXR0ZXIgZnJvbSAnLi9zaGFyZWRFbWl0dGVyJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuLy8gV2UgdXNlIGFuIGV4dGVybmFsIGVtaXR0ZXIgc28gdGhhdCB0aGUgYmFja2dyb3VuZCBzdG9yYWdlIGluc3RhbmNlXG4vLyBjYW4gbGlzdGVuIHRvIHRoZSBldmVudHMgb2YgdGhlIGNvbnRlbnQgc3RvcmFnZSBpbnN0YW5jZSwgYW5kIHZpY2V2ZXJzYVxuLy8gKHNpbmNlIHRoZXkgcnVuIGluIHRoZSBzYW1lIGNvbnRleHQpLlxuY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0U3RvcmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihrZXksIHBlcm1pc3Npb24pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5wZXJtaXNzaW9uID0gcGVybWlzc2lvbjtcblxuICAgIHRoaXMuX2xpc3RlbkZvckNoYW5nZXMoKTtcbiAgfVxuXG4gIF9saXN0ZW5Gb3JDaGFuZ2VzKCkge1xuICAgIC8vIE5vdGU6IHRoZSB3aW5kb3cgJ3N0b3JhZ2UnIGV2ZW50IGlzIG5vdCBmaXJlZCBvbiB0aGUgc2FtZSBwYWdlIChmcmFtZT8pIHRoYXQgaXMgbWFraW5nIHRoZSBjaGFuZ2VzXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICBjb25zdCBjaGFuZ2VJbmZvID0ge1xuICAgICAgICAgIG9sZFZhbHVlOiBlLm9sZFZhbHVlICYmIEpTT04ucGFyc2UoZS5vbGRWYWx1ZSksXG4gICAgICAgICAgbmV3VmFsdWU6IGUubmV3VmFsdWUgJiYgSlNPTi5wYXJzZShlLm5ld1ZhbHVlKSxcbiAgICAgICAgICBjaGFuZ2VUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIGNoYW5nZUluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZW1pdHRlci5vbignY2hhbmdlJywgKGtleSwgLi4ucmVzdCkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gdGhpcy5rZXkpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCAuLi5yZXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3N0b3JhZ2UjdHlwZS1TdG9yYWdlQXJlYVxuICAvLyBAcGFyYW0ga2V5cyBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nIG9yIG9iamVjdFxuICAvLyBBIHNpbmdsZSBrZXkgdG8gZ2V0LCBsaXN0IG9mIGtleXMgdG8gZ2V0LCBvciBhIGRpY3Rpb25hcnkgc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlcyAoc2VlIGRlc2NyaXB0aW9uIG9mIHRoZSBvYmplY3QpLlxuICAvLyBBbiBlbXB0eSBsaXN0IG9yIG9iamVjdCB3aWxsIHJldHVybiBhbiBlbXB0eSByZXN1bHQgb2JqZWN0LiBQYXNzIGluIG51bGwgdG8gZ2V0IHRoZSBlbnRpcmUgY29udGVudHMgb2Ygc3RvcmFnZS5cbiAgZ2V0KGtleXMpIHtcbiAgICAvL2xvZ2dlci5kZWJ1ZygnZ2V0Jywga2V5cyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgbGV0IG1haW5PYmplY3QgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSk7XG5cbiAgICAgIGlmICghbWFpbk9iamVjdCkgbWFpbk9iamVjdCA9IHt9O1xuICAgICAgZWxzZSBtYWluT2JqZWN0ID0gSlNPTi5wYXJzZShtYWluT2JqZWN0KTtcblxuICAgICAgaWYgKGtleXMgPT09IG51bGwgfHwgdHlwZW9mIGtleXMgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbWFpbk9iamVjdDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSByZXR1cm4gcGljayhtYWluT2JqZWN0LCBrZXlzKTtcbiAgICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGljayhtYWluT2JqZWN0LCBPYmplY3Qua2V5cyhrZXlzKSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cyhyZXN1bHQsIGtleXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1haW5PYmplY3Rba2V5c107XG4gICAgfSk7XG4gIH1cblxuICAvLyBOb3RlOiBmbiBzaG91bGQgcmV0dXJuIHRoZSB2YWx1ZSBpbW1lZGlhdGVseSwgcHJvbWlzZXMgYXJlbid0IGFsbG93ZWRcbiAgLy8gKHRoZSBjaGFuZ2UgbXVzdCBiZSBhdG9taWMgdG8gcHJldmVudCBjb25jdXJyZW5jeSBpc3N1ZXMpIVxuICBzZXRCeUZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHRoaXMucGVybWlzc2lvbiAhPT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHRocm93ICdBY2Nlc3MgZGVuaWVkOiBubyByZWFkd3JpdGUgcGVybWlzc2lvbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgbGV0IG1haW5PYmplY3QgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSk7XG5cbiAgICAgIGxldCBvbGRWYWx1ZTtcbiAgICAgIGlmICghbWFpbk9iamVjdCkge1xuICAgICAgICBtYWluT2JqZWN0ID0ge307XG4gICAgICAgIG9sZFZhbHVlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5PYmplY3QgPSBKU09OLnBhcnNlKG1haW5PYmplY3QpO1xuICAgICAgICBvbGRWYWx1ZSA9IGNsb25lRGVlcChtYWluT2JqZWN0KTsgLy8gZGVlcCBjbG9uZWQgc2luY2UgbWFpbk9iamVjdCBjb3VsZCBiZSBtdXRhdGVkIGR1cmluZyBmbiBjYWxsXG4gICAgICB9XG5cbiAgICAgIG1haW5PYmplY3QgPSBmbihtYWluT2JqZWN0KTtcblxuICAgICAgaWYgKCFpc0VxdWFsKG1haW5PYmplY3QsIG9sZFZhbHVlKSkgeyAvLyBwcmV2ZW50IHVuLW5lZWRlZCBjaGFuZ2VcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5rZXksIEpTT04uc3RyaW5naWZ5KG1haW5PYmplY3QpKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGV2ZW50IGlzIGFsc28gZW1pdHRlZCBvbiB0aGUgc2FtZSBmcmFtZVxuICAgICAgICBjb25zdCBjaGFuZ2VJbmZvID0geyBvbGRWYWx1ZSwgbmV3VmFsdWU6IG1haW5PYmplY3QsIGNoYW5nZVRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB0aGlzLmtleSwgY2hhbmdlSW5mbyk7XG4gICAgICAgIC8vIGFsc28gcm91dGUgdGhlIGNoYW5nZSB0byB0aGUgc2hhcmVkRW1pdHRlcixcbiAgICAgICAgLy8gc2luY2UgaXQgd29uJ3QgYmUgYWJsZSB0byBnZXQgaXQgZnJvbSB0aGUgd2luZG93ICdzdG9yYWdlJyBldmVudFxuICAgICAgICBzaGFyZWRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHRoaXMua2V5LCBjaGFuZ2VJbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3N0b3JhZ2UjdHlwZS1TdG9yYWdlQXJlYVxuICAvLyBAcGFyYW0gaXRlbXNcbiAgLy8gQW4gb2JqZWN0IHdoaWNoIGdpdmVzIGVhY2gga2V5L3ZhbHVlIHBhaXIgdG8gdXBkYXRlIHN0b3JhZ2Ugd2l0aC4gQW55IG90aGVyIGtleS92YWx1ZSBwYWlycyBpbiBzdG9yYWdlIHdpbGwgbm90IGJlIGFmZmVjdGVkLlxuICAvLyBQcmltaXRpdmUgdmFsdWVzIHN1Y2ggYXMgbnVtYmVycyB3aWxsIHNlcmlhbGl6ZSBhcyBleHBlY3RlZC4gVmFsdWVzIHdpdGggYSB0eXBlb2YgXCJvYmplY3RcIiBhbmQgXCJmdW5jdGlvblwiXG4gIC8vIHdpbGwgdHlwaWNhbGx5IHNlcmlhbGl6ZSB0byB7fSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIEFycmF5IChzZXJpYWxpemVzIGFzIGV4cGVjdGVkKSxcbiAgLy8gRGF0ZSwgYW5kIFJlZ2V4IChzZXJpYWxpemUgdXNpbmcgdGhlaXIgU3RyaW5nIHJlcHJlc2VudGF0aW9uKS5cbiAgc2V0KGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMucGVybWlzc2lvbiAhPT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHRocm93ICdBY2Nlc3MgZGVuaWVkOiBubyByZWFkd3JpdGUgcGVybWlzc2lvbic7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKCdzZXQnLCBpdGVtcyk7XG4gICAgcmV0dXJuIHRoaXMuc2V0QnlGdW5jdGlvbihtYWluT2JqZWN0ID0+IE9iamVjdC5hc3NpZ24oe30sIG1haW5PYmplY3QsIGl0ZW1zKSk7XG4gIH1cblxuICBzZXRCeVBhdGgoaXRlbXMpIHtcbiAgICBpZiAodGhpcy5wZXJtaXNzaW9uICE9PSAncmVhZHdyaXRlJykge1xuICAgICAgdGhyb3cgJ0FjY2VzcyBkZW5pZWQ6IG5vIHJlYWR3cml0ZSBwZXJtaXNzaW9uJztcbiAgICB9XG5cbiAgICBpZiAoIWl0ZW1zIHx8IGlzRW1wdHkoaXRlbXMpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbG9nZ2VyLmRlYnVnKCdzZXRCeVBhdGgnLCBpdGVtcyk7XG4gICAgcmV0dXJuIHRoaXMuc2V0QnlGdW5jdGlvbihtYWluT2JqZWN0ID0+IHtcbiAgICAgIGZvckVhY2goaXRlbXMsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsY3VsYXRlZFZhbHVlID0gdmFsdWUoZ2V0KG1haW5PYmplY3QsIHBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxjdWxhdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1haW5PYmplY3QgPSBzZXQobWFpbk9iamVjdCwgcGF0aCwgY2FsY3VsYXRlZFZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1haW5PYmplY3Q7XG4gICAgfSk7XG4gIH1cblxuICBleHRlbmRCeVBhdGgocGF0aCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5wZXJtaXNzaW9uICE9PSAncmVhZHdyaXRlJykge1xuICAgICAgdGhyb3cgJ0FjY2VzcyBkZW5pZWQ6IG5vIHJlYWR3cml0ZSBwZXJtaXNzaW9uJztcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoJ2V4dGVuZEJ5UGF0aCcsIHBhdGgsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5zZXRCeUZ1bmN0aW9uKG1haW5PYmplY3QgPT4ge1xuICAgICAgbGV0IGNhbGN1bGF0ZWRWYWx1ZTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsY3VsYXRlZFZhbHVlID0gdmFsdWUoZ2V0KG1haW5PYmplY3QsIHBhdGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBkb24ndCBjcmVhdGUgZW1wdHkgcGF0aCBpZiBubyB2YWx1ZSBpcyByZXR1cm5lZFxuICAgICAgaWYgKHR5cGVvZiBjYWxjdWxhdGVkVmFsdWUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbWFpbk9iamVjdDtcblxuICAgICAgcmV0dXJuIHNldChtYWluT2JqZWN0LCBwYXRoLCBPYmplY3QuYXNzaWduKHt9LCBnZXQobWFpbk9iamVjdCwgcGF0aCwge30pLCBjYWxjdWxhdGVkVmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLnBlcm1pc3Npb24gIT09ICdyZWFkd3JpdGUnKSB7XG4gICAgICB0aHJvdyAnQWNjZXNzIGRlbmllZDogbm8gcmVhZHdyaXRlIHBlcm1pc3Npb24nO1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZygnY2xlYXInKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBsZXQgbWFpbk9iamVjdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMua2V5KTtcbiAgICAgIGlmICghbWFpbk9iamVjdCkgbWFpbk9iamVjdCA9IHt9O1xuICAgICAgZWxzZSBtYWluT2JqZWN0ID0gSlNPTi5wYXJzZShtYWluT2JqZWN0KTtcblxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5rZXkpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGV2ZW50IGlzIGFsc28gZW1pdHRlZCBvbiB0aGUgc2FtZSBmcmFtZVxuICAgICAgY29uc3QgY2hhbmdlSW5mbyA9IHsgb2xkVmFsdWU6IG1haW5PYmplY3QsIG5ld1ZhbHVlOiBudWxsLCBjaGFuZ2VUaW1lOiBEYXRlLm5vdygpIH07XG4gICAgICBlbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHRoaXMua2V5LCBjaGFuZ2VJbmZvKTtcbiAgICAgIC8vIGFsc28gcm91dGUgdGhlIGNoYW5nZSB0byB0aGUgc2hhcmVkRW1pdHRlcixcbiAgICAgIC8vIHNpbmNlIGl0IHdvbid0IGJlIGFibGUgdG8gZ2V0IGl0IGZyb20gdGhlIHdpbmRvdyAnc3RvcmFnZScgZXZlbnRcbiAgICAgIHNoYXJlZEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgdGhpcy5rZXksIGNoYW5nZUluZm8pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0QnlQYXRoKHBhdGgpIHtcbiAgICAvL2xvZ2dlci5kZWJ1ZygnZ2V0QnlQYXRoJywgcGF0aCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgbGV0IG1haW5PYmplY3QgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSk7XG5cbiAgICAgIGlmICghbWFpbk9iamVjdCkgbWFpbk9iamVjdCA9IHt9O1xuICAgICAgZWxzZSBtYWluT2JqZWN0ID0gSlNPTi5wYXJzZShtYWluT2JqZWN0KTtcblxuICAgICAgcmV0dXJuIGdldChtYWluT2JqZWN0LCBwYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUJ5UGF0aChwYXRoKSB7XG4gICAgaWYgKHRoaXMucGVybWlzc2lvbiAhPT0gJ3JlYWR3cml0ZScpIHtcbiAgICAgIHRocm93ICdBY2Nlc3MgZGVuaWVkOiBubyByZWFkd3JpdGUgcGVybWlzc2lvbic7XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSBwYXRoID0gW3BhdGhdO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGxvZ2dlci5kZWJ1ZygncmVtb3ZlQnlQYXRoJywgcGF0aCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0QnlGdW5jdGlvbihtYWluT2JqZWN0ID0+IG9taXQobWFpbk9iamVjdCwgcGF0aCkpO1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvT2JqZWN0U3RvcmUuanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VDbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VGb3IuanNcbi8vIG1vZHVsZSBpZCA9IDI4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUluZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDI5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY2FzdEZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jbG9uZUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpLFxuICAgIGdldERhdGEgPSByZXF1aXJlKCcuL19nZXREYXRhJyksXG4gICAgZ2V0RnVuY05hbWUgPSByZXF1aXJlKCcuL19nZXRGdW5jTmFtZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0xhemlhYmxlID0gcmVxdWlyZSgnLi9faXNMYXppYWJsZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICApIHtcbiAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZsb3c7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlRmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faGFzUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19oYXNVbmljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gKi9cbnZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbkluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvYXNzaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDI5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2Nsb25lRGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFycmF5RXZlcnkgPSByZXF1aXJlKCcuL19hcnJheUV2ZXJ5JyksXG4gICAgYmFzZUV2ZXJ5ID0gcmVxdWlyZSgnLi9fYmFzZUV2ZXJ5JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlcnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9ldmVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc0VtcHR5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAqIEBzZWUgXy5tYXBLZXlzXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gKiB9O1xuICpcbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVmFsdWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvbWFwVmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gJy4vbmFtZXNwYWNlJztcbmltcG9ydCB7IGFkZFdpbmRvd0xpc3RlbmVyIH0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvd2luZG93RXZlbnRzJztcblxuZXhwb3J0IGNvbnN0IHNlbmRUb0V4dGVuc2lvbiA9ICh0b3BpYywgZGF0YSkgPT4ge1xuICBjb25zdCBtZXNzYWdlID0ge1xuICAgIHRvcGljLCBkYXRhLCBmcm9tOiBuYW1lc3BhY2UoJ3ByYWN0aWNlJyksIHRvOiBuYW1lc3BhY2UoJ2NvbnRlbnQnKVxuICB9O1xuICB3aW5kb3cudG9wLnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XG59O1xuXG5leHBvcnQgY29uc3QgbGlzdGVuVG9QcmFjdGljZU1lc3NhZ2UgPSAoaGFuZGxlcikgPT4ge1xuICBhZGRXaW5kb3dMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChcbiAgICAgIG1lc3NhZ2UuZnJvbSAhPT0gbmFtZXNwYWNlKCdwcmFjdGljZScpIHx8XG4gICAgICBtZXNzYWdlLnRvICE9PSBuYW1lc3BhY2UoJ2NvbnRlbnQnKVxuICAgICkgcmV0dXJuO1xuXG4gICAgY29uc3QgaXNUb3BGcmFtZSA9ICh3aW5kb3cucGFyZW50ID09PSB3aW5kb3cpO1xuICAgIGlmICghaXNUb3BGcmFtZSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlcihtZXNzYWdlKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvcHJhY3RpY2VQbGF5ZXIuanMiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvZXM2L3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQWJzdHJhY3QgY2xhc3NcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3J0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvcihfcG9ydCA9IG51bGwsIG5hbWUgPSAnJywgZXh0ZW5zaW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgICB0aGlzLl9wb3J0ID0gX3BvcnQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9iaW5kSGFuZGxlcnMoKTtcbiAgfVxuXG4gIHN0YXRpYyBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAvLyBuby1vcFxuICB9XG5cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLl9iaW5kSGFuZGxlcnMoKTtcbiAgfVxuXG4gIF9iaW5kSGFuZGxlcnMoKSB7XG4gICAgLy8gbm8tb3BcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgLy8gbm8tb3BcbiAgfVxuXG4gIF91bmJpbmRIYW5kbGVycygpIHtcbiAgICAvLyBuby1vcFxuICB9XG5cbiAgc2VuZChtZXNzYWdlLCByZXNwb25zZUhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIG5vLW9wXG4gIH1cblxuICBfb25Db25uZWN0ZWQoKSB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnKTtcbiAgfVxuXG4gIF9vbkRpc2Nvbm5lY3RlZChlcnJvcikge1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJywgZXJyb3IpO1xuICB9XG5cbiAgX3dhaXRFeHRlbnNpb25SZWFkeSgpIHtcbiAgICBpZiAodGhpcy5fd2FpdEV4dGVuc2lvblJlYWR5UHJvbWlzZSkgcmV0dXJuIHRoaXMuX3dhaXRFeHRlbnNpb25SZWFkeVByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuX3dhaXRFeHRlbnNpb25SZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9uLmlzUmVhZHkpIHJlc29sdmUoKTtcbiAgICAgIGVsc2UgdGhpcy5leHRlbnNpb24ub25jZSgncmVhZHknLCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9vbk1lc3NhZ2VSZWNlaXZlZChtZXNzYWdlLCByZXNwb25kKSB7XG4gICAgLy8gZG9uJ3QgZW1pdCB0aGUgZXZlbnQgYmVmb3JlIHRoZSBleHRlbnNpb25cbiAgICAvLyBpcyBmdWxseSBjcmVhdGVkIGFuZCBpbml0aWFsaXplZFxuICAgIC8vIChzbyB0aGF0IHRoZSBtZXNzYWdlIGNhbiBiZSBoYW5kbGVkKVxuICAgIHRoaXMuX3dhaXRFeHRlbnNpb25SZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSwgcmVzcG9uZCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vUG9ydC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5lbnYuTkFNRTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL2Vudi5qcyIsIi8vIGNvbnN0IGRldmVsb3BtZW50ID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzEwMCc7XG5jb25zdCBkZXZlbG9wbWVudCA9ICdodHRwczovL3Rlc3QuaW9yYWQuY29tJztcbmNvbnN0IHRlc3RJb3JhZENvbSA9ICdodHRwczovL3Rlc3QuaW9yYWQuY29tJztcbmNvbnN0IHByb2R1Y3Rpb24gPSAnaHR0cHM6Ly93d3cuaW9yYWQuY29tJztcblxuY29uc3Qgbm9kZUFwaSA9ICdodHRwOi8vZGV2LmlvcmFkLmRldi9hcGknO1xuLy8gY29uc3Qgbm9kZUFwaSA9ICdodHRwczovL2xvY2FsLmlvcmFkLmNvbTo4NDQzL2FwaSc7XG5jb25zdCBub2RlQXBwUHJlZml4ID0gJ2h0dHA6Ly9kZXYuaW9yYWQuZGV2JztcblxuY29uc3QgcmVsYXRpdmVQYXRoID0gKHBhdGgsIHByb3BOYW1lID0gJ3VybCcpID0+ICh7XG4gIGRldmVsb3BtZW50OiB7IFtwcm9wTmFtZV06IGRldmVsb3BtZW50ICsgJy9hcGknICsgcGF0aCB9LFxuICB2YWdyYW50OiB7IFtwcm9wTmFtZV06IG5vZGVBcGkgKyBwYXRoIH0sXG4gICd0ZXN0LmlvcmFkLmNvbSc6IHsgW3Byb3BOYW1lXTogdGVzdElvcmFkQ29tICsgJy9hcGknICsgcGF0aCB9LFxuICBwcm9kdWN0aW9uOiB7IFtwcm9wTmFtZV06IHByb2R1Y3Rpb24gKyAnL2FwaScgKyBwYXRoIH0sXG59KTtcbmNvbnN0IHJlbGF0aXZlUGFnZSA9IChwYXRoLCBwcm9wTmFtZSA9ICd1cmwnKSA9PiAoe1xuICBkZXZlbG9wbWVudDogeyBbcHJvcE5hbWVdOiBkZXZlbG9wbWVudCArIHBhdGggfSxcbiAgdmFncmFudDogeyBbcHJvcE5hbWVdOiBub2RlQXBwUHJlZml4ICsgcGF0aCB9LFxuICAndGVzdC5pb3JhZC5jb20nOiB7IFtwcm9wTmFtZV06IHRlc3RJb3JhZENvbSArIHBhdGggfSxcbiAgcHJvZHVjdGlvbjogeyBbcHJvcE5hbWVdOiBwcm9kdWN0aW9uICsgcGF0aCB9LFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8ga2VlcCBzdXJlIHRvIHNwZWNpZnkgYmVsb3cgYWxsIHRoZSBwb3NzaWJsZSBlbnZzIVxuICBlbnZzOiBbJ2RldmVsb3BtZW50JywgJ3ZhZ3JhbnQnLCAndGVzdC5pb3JhZC5jb20nLCAncHJvZHVjdGlvbiddLFxuXG4gIHZhbHVlczoge1xuXG4gICAgJ2RlYnVnJzoge1xuICAgICAgZGV2ZWxvcG1lbnQ6IHtcbiAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgdmFncmFudDoge1xuICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICAndGVzdC5pb3JhZC5jb20nOiB7XG4gICAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHByb2R1Y3Rpb246IHtcbiAgICAgICAgaXNEaXNhYmxlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSxcblxuICAgICdkZWZhdWx0Q29sb3JzJzoge1xuICAgICAgJyonOiB7XG4gICAgICAgIG1haW46ICcjMWQxZjIzJyxcbiAgICAgICAgbmF2QmFyOiAnIzFkMWYyMycsXG4gICAgICAgIGFjdGlvbkJ1dHRvbjogJyMwMDkwZTInLFxuICAgICAgICBoaWdobGlnaHQ6ICcjMDA5MGUyJyxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2V4dGVuc2lvbic6IHtcbiAgICAgICdjaHJvbWUnOiB7XG4gICAgICAgICdpZHMnOiB7XG4gICAgICAgICAgJ2tqZm1lZGJnYW5hbHBrb2hrZWdoaHBwcGljb2lnZGFsJzoge1xuICAgICAgICAgICAgJ2J1aWxkJzogJ3N0YW5kYXJkJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgICdmaGVnaG1vZ25jY21ia2xqZmxvYmhrY2ZraWFqbGxpcCc6IHtcbiAgICAgICAgICAgIGJ1aWxkOiAnY2knLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBXQVJOSU5HOiBiYXNlUGF0aCBzZXR0aW5nIGlzIGlnbm9yZWQgaWYgaXQgY2FuIGdldCB0aGUgYmFzZSB1cmwgZnJvbSB0aGUgc2NyaXB0IHRhZ1xuICAgICAgJ2VtYmVkJzoge1xuICAgICAgICAnZGV2ZWxvcG1lbnQnOiB7XG4gICAgICAgICAgYmFzZVBhdGg6ICdjaHJvbWUtZXh0ZW5zaW9uOi8vbmVhY2ZhZmhhZGZvZHBvYWdnZWFoamdnaGpvZm1lbHAnLFxuICAgICAgICB9LFxuICAgICAgICAndmFncmFudCc6IHtcbiAgICAgICAgICAnYmFzZVBhdGgnOiAnL2Rpc3QvZW1iZWQnLFxuICAgICAgICB9LFxuICAgICAgICAndGVzdC5pb3JhZC5jb20nOiB7XG4gICAgICAgICAgJ2Jhc2VQYXRoJzogJ2h0dHBzOi8vdGVzdC5pb3JhZC5jb20vc2VydmVyL2Fzc2V0cy9lbWJlZCcsXG4gICAgICAgIH0sXG4gICAgICAgICdwcm9kdWN0aW9uJzoge1xuICAgICAgICAgICdiYXNlUGF0aCc6ICdodHRwczovL3d3dy5pb3JhZC5jb20vc2VydmVyL2Fzc2V0cy9lbWJlZCcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcblxuICAgIHBhZ2VzOiB7XG4gICAgICBjcmVhdGVOZXdCcm93c2VyVHV0b3JpYWxVcmw6IHtcbiAgICAgICAgZGV2ZWxvcG1lbnQ6IHtcbiAgICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWwuaW9yYWQuY29tOjkwMDAvZWRpdG9yLmh0bWw/bW9kdWxlPURFViZ1aWQ9REVWI2NhcHR1cmUvbGF1bmNoL2Jyb3dzZXInXG4gICAgICAgIH0sXG4gICAgICAgIHZhZ3JhbnQ6IHtcbiAgICAgICAgICB1cmw6IGAke25vZGVBcHBQcmVmaXh9L2NyZWF0ZU5ld0Jyb3dzZXJUdXRvcmlhbC8/cmVmZXJyZXI9ZXh0ZW5zaW9uYFxuICAgICAgICB9LFxuICAgICAgICAndGVzdC5pb3JhZC5jb20nOiB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly90ZXN0LmlvcmFkLmNvbS9jcmVhdGVOZXdCcm93c2VyVHV0b3JpYWwvP3JlZmVycmVyPWV4dGVuc2lvbidcbiAgICAgICAgfSxcbiAgICAgICAgcHJvZHVjdGlvbjoge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3LmlvcmFkLmNvbS9jcmVhdGVOZXdCcm93c2VyVHV0b3JpYWwvP3JlZmVycmVyPWV4dGVuc2lvbidcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZU5ld0Rlc2t0b3BUdXRvcmlhbFVybDoge1xuICAgICAgICBkZXZlbG9wbWVudDoge1xuICAgICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbC5pb3JhZC5jb206OTAwMC9lZGl0b3IuaHRtbD9tb2R1bGU9REVWJnVpZD1ERVYjY2FwdHVyZS9sYXVuY2gvYXBwJ1xuICAgICAgICB9LFxuICAgICAgICB2YWdyYW50OiB7XG4gICAgICAgICAgdXJsOiBgJHtub2RlQXBwUHJlZml4fS9jcmVhdGVOZXdEZXNrdG9wVHV0b3JpYWwvP3JlZmVycmVyPWV4dGVuc2lvbmBcbiAgICAgICAgfSxcbiAgICAgICAgJ3Rlc3QuaW9yYWQuY29tJzoge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vdGVzdC5pb3JhZC5jb20vY3JlYXRlTmV3RGVza3RvcFR1dG9yaWFsLz9yZWZlcnJlcj1leHRlbnNpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHByb2R1Y3Rpb246IHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5pb3JhZC5jb20vY3JlYXRlTmV3RGVza3RvcFR1dG9yaWFsLz9yZWZlcnJlcj1leHRlbnNpb24nXG4gICAgICAgIH0sXG4gICAgICB9LFxuXG4gICAgICAnbXl0dXRvcmlhbHMnOiB7XG4gICAgICAgICdwcm9kdWN0aW9uJzoge1xuICAgICAgICAgICd1cmwnOiAnaHR0cDovL3d3dy5pb3JhZC5jb20vdHV0b3JpYWxzJ1xuICAgICAgICB9LFxuICAgICAgICB2YWdyYW50OiB7XG4gICAgICAgICAgJ3VybCc6IGAke25vZGVBcHBQcmVmaXh9L3R1dG9yaWFsc2BcbiAgICAgICAgfSxcbiAgICAgICAgJyonOiB7XG4gICAgICAgICAgJ3VybCc6ICdodHRwczovL3Rlc3QuaW9yYWQuY29tL3R1dG9yaWFscydcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgJ215YWNjb3VudCc6IHtcbiAgICAgICAgJ3Byb2R1Y3Rpb24nOiB7XG4gICAgICAgICAgJ3VybCc6ICdodHRwOi8vd3d3LmlvcmFkLmNvbS9hY2NvdW50J1xuICAgICAgICB9LFxuICAgICAgICB2YWdyYW50OiB7XG4gICAgICAgICAgJ3VybCc6IGAke25vZGVBcHBQcmVmaXh9L2FjY291bnRgXG4gICAgICAgIH0sXG4gICAgICAgICcqJzoge1xuICAgICAgICAgICd1cmwnOiAnaHR0cHM6Ly90ZXN0LmlvcmFkLmNvbS9hY2NvdW50J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHV0b3JpYWxQbGF5ZXI6IHtcbiAgICAgICAgZGV2ZWxvcG1lbnQ6IHtcbiAgICAgICAgICB1cmw6ICdodHRwOi8vbG9jYWwuaW9yYWQuY29tOjkwMDAvJWF1dGhvcklEJS8ldHV0b3JpYWxJRCUvJXRpdGxlJSdcbiAgICAgICAgfSxcbiAgICAgICAgdmFncmFudDoge1xuICAgICAgICAgIHVybDogYCR7bm9kZUFwcFByZWZpeH0vcGxheWVyLyV0dXRvcmlhbElEJS8ldGl0bGUlYFxuICAgICAgICB9LFxuICAgICAgICAndGVzdC5pb3JhZC5jb20nOiB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly90ZXN0LmlvcmFkLmNvbS9wbGF5ZXIvJXR1dG9yaWFsSUQlLyV0aXRsZSUnXG4gICAgICAgIH0sXG4gICAgICAgIHByb2R1Y3Rpb246IHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5pb3JhZC5jb20vcGxheWVyLyV0dXRvcmlhbElEJS8ldGl0bGUlJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGhlbHA6IHtcbiAgICAgICAgJyonOiB7XG4gICAgICAgICAgdXJsOiAnaHR0cDovL2hlbHAuaW9yYWQuY29tLydcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0ZXJtczoge1xuICAgICAgICBkZXZlbG9wbWVudDoge1xuICAgICAgICAgIHVybDogJ2h0dHA6Ly9sb2NhbC5pb3JhZC5jb206OTAwMC90ZXJtcydcbiAgICAgICAgfSxcbiAgICAgICAgdmFncmFudDoge1xuICAgICAgICAgIHVybDogYCR7bm9kZUFwcFByZWZpeH0vdGVybXNgXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXN0LmlvcmFkLmNvbSc6IHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3Rlc3QuaW9yYWQuY29tL3Rlcm1zJ1xuICAgICAgICB9LFxuICAgICAgICBwcm9kdWN0aW9uOiB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cuaW9yYWQuY29tL3Rlcm1zJ1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHByaWNpbmc6IHJlbGF0aXZlUGFnZSgnL3ByaWNpbmcnKSxcblxuICAgICAgZXh0ZW5zaW9uSW5zdGFsbGVkOiB7XG4gICAgICAgICcqJzoge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vc3RhcnQuaW9yYWQuY29tL2luc3RhbGxlZCdcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcblxuICAgICdjYXB0dXJlJzoge1xuICAgICAgJ2Rlc2t0b3AnOiB7XG4gICAgICAgICdwcm9kdWN0aW9uJzoge1xuICAgICAgICAgICdsb2NhdGlvbic6IHtcbiAgICAgICAgICAgICd2YW5pbGxhJzoge1xuICAgICAgICAgICAgICAnd2luZG93cyc6ICdodHRwczovL3d3dy5pb3JhZC5jb20vc2VydmVyL3dlYnN0YXJ0L2lvcmFkLWNhcHR1cmUuZXhlJyxcbiAgICAgICAgICAgICAgJ21hYyc6ICdodHRwczovL3d3dy5pb3JhZC5jb20vc2VydmVyL3dlYnN0YXJ0L2lvcmFkLWNhcHR1cmUucGtnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdidW5kbGVkJzoge1xuICAgICAgICAgICAgICAnd2luZG93cyc6ICdodHRwczovL3d3dy5pb3JhZC5jb20vc2VydmVyL3dlYnN0YXJ0L2lvcmFkLWNhcHR1cmUtSlZNLmV4ZScsXG4gICAgICAgICAgICAgICdtYWMnOiAnaHR0cHM6Ly93d3cuaW9yYWQuY29tL3NlcnZlci93ZWJzdGFydC9pb3JhZC1jYXB0dXJlLUpWTS5wa2cnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnKic6IHtcbiAgICAgICAgICAnbG9jYXRpb24nOiB7XG4gICAgICAgICAgICAndmFuaWxsYSc6IHtcbiAgICAgICAgICAgICAgJ3dpbmRvd3MnOiAnaHR0cHM6Ly90ZXN0LmlvcmFkLmNvbS9zZXJ2ZXIvd2Vic3RhcnQvaW9yYWQtY2FwdHVyZS5leGUnLFxuICAgICAgICAgICAgICAnbWFjJzogJ2h0dHBzOi8vdGVzdC5pb3JhZC5jb20vc2VydmVyL3dlYnN0YXJ0L2lvcmFkLWNhcHR1cmUucGtnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdidW5kbGVkJzoge1xuICAgICAgICAgICAgICAnd2luZG93cyc6ICdodHRwczovL3Rlc3QuaW9yYWQuY29tL3NlcnZlci93ZWJzdGFydC9pb3JhZC1jYXB0dXJlLUpWTS5leGUnLFxuICAgICAgICAgICAgICAnbWFjJzogJ2h0dHBzOi8vdGVzdC5pb3JhZC5jb20vc2VydmVyL3dlYnN0YXJ0L2lvcmFkLWNhcHR1cmUtSlZNLnBrZydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VydmVyOiB7XG4gICAgICBzZWFyY2hUdXRvcmlhbHM6IHJlbGF0aXZlUGF0aChcbiAgICAgICAgJy90dXRvcmlhbC9zZWFyY2g/dXJscz0ldXJscyUmc2s9JXRleHQlJnN0PXRhZyxuYW1lLGRlc2Mmb25seUxpdmU9JW9ubHlMaXZlJSZsaXZlRW1iZWRGb3JVc2VyPSVsaXZlRW1iZWRGb3IlJ1xuICAgICAgKSxcbiAgICAgIHR1dG9yaWFsTGl2ZUxpc3Q6IHJlbGF0aXZlUGF0aChcbiAgICAgICAgJy90dXRvcmlhbC9saXZlTGlzdD91cmxzPSV1cmxzJSZzZWFyY2hLZXk9JXNlYXJjaEtleSUmZW1iZWQ9JWVtYmVkJSZtb2JpbGVNb2RlPSVtb2JpbGVNb2RlJSdcbiAgICAgICksXG4gICAgICBnZXRUdXRvcmlhbDogcmVsYXRpdmVQYXRoKCcvdHV0b3JpYWwvZ2V0P3R1dG9yaWFsX2lkPSV0dXRvcmlhbF9pZCUnKSxcbiAgICAgIGdldE5vdGlmaWNhdGlvbnM6IHJlbGF0aXZlUGF0aCgnL25vdGlmaWNhdGlvbi9maW5kQWxsJyksXG4gICAgICB0dXRvcmlhbFNhdmVTdGF0aXN0aWNzOiByZWxhdGl2ZVBhdGgoJy90dXRvcmlhbC9zYXZlU3RhdGlzdGljcycpLFxuXG4gICAgICBzaWdudXA6IHJlbGF0aXZlUGF0aCgnL3NpZ251cCcpLFxuICAgICAgZ29vZ2xlQXV0aDogcmVsYXRpdmVQYXRoKCcvZ29vZ2xlQXV0aCcpLFxuICAgICAgbG9naW46IHJlbGF0aXZlUGF0aCgnL2xvZ2luJyksXG4gICAgICBzYW1sTG9naW5VUkw6IHJlbGF0aXZlUGF0aCgnL3NldHRpbmdzL3NhbWxMb2dpblVSTCcpLFxuICAgICAgcmVzZXRQYXNzd29yZDogcmVsYXRpdmVQYXRoKCcvcmVzZXRQYXNzd29yZCcpLFxuICAgICAgcmVzZW5kQWN0aXZhdGlvbjogcmVsYXRpdmVQYXRoKCcvcmVzZW5kQWN0aXZhdGlvbicpLFxuICAgICAgbG9nb3V0OiByZWxhdGl2ZVBhdGgoJy9sb2dvdXQnKSxcbiAgICAgIGxvYWRBdXRoOiByZWxhdGl2ZVBhdGgoJy9sb2FkQXV0aCcpLFxuICAgICAgbWU6IHJlbGF0aXZlUGF0aCgnL21lP2FjY291bnRJbmZvPSVhY2NvdW50SW5mbyUnKSxcblxuICAgICAgaW1hZ2VSZW1vdGVQYXRoOiB7XG4gICAgICAgIGRldmVsb3BtZW50OiB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly90ZXN0LmlvcmFkLmNvbS9jYXB0dXJlL3R1dG9yaWFscy8ldXNlcl9pZCUvJXR1dG9yaWFsX2lkJS8laW1hZ2VfaWQlLnBuZz9ub2NhY2hlPSVub2NhY2hlJSdcbiAgICAgICAgfSxcbiAgICAgICAgdmFncmFudDoge1xuICAgICAgICAgIHVybDogYCR7bm9kZUFwcFByZWZpeH0vY2FwdHVyZS90dXRvcmlhbHMvJXVzZXJfaWQlLyV0dXRvcmlhbF9pZCUvJWltYWdlX2lkJS5wbmc/bm9jYWNoZT0lbm9jYWNoZSVgXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXN0LmlvcmFkLmNvbSc6IHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3Rlc3QuaW9yYWQuY29tL2NhcHR1cmUvdHV0b3JpYWxzLyV1c2VyX2lkJS8ldHV0b3JpYWxfaWQlLyVpbWFnZV9pZCUucG5nP25vY2FjaGU9JW5vY2FjaGUlJ1xuICAgICAgICB9LFxuICAgICAgICBwcm9kdWN0aW9uOiB7XG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9zMy5pb3JhZC5jb20vY2FwdHVyZS90dXRvcmlhbHMvJXVzZXJfaWQlLyV0dXRvcmlhbF9pZCUvJWltYWdlX2lkJS5wbmc/bm9jYWNoZT0lbm9jYWNoZSUnXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGF1ZGlvUmVtb3RlUGF0aDoge1xuICAgICAgICBkZXZlbG9wbWVudDoge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vdGVzdC5pb3JhZC5jb20vY2FwdHVyZS90dXRvcmlhbHMvJXVzZXJfaWQlLyV0dXRvcmlhbF9pZCUvJWF1ZGlvX2lkJS4lYXVkaW9fZXh0JT9jYWNoZT0lY2FjaGUlJ1xuICAgICAgICB9LFxuICAgICAgICB2YWdyYW50OiB7XG4gICAgICAgICAgdXJsOiBgJHtub2RlQXBwUHJlZml4fS9jYXB0dXJlL3R1dG9yaWFscy8ldXNlcl9pZCUvJXR1dG9yaWFsX2lkJS8lYXVkaW9faWQlLiVhdWRpb19leHQlP2NhY2hlPSVjYWNoZSVgXG4gICAgICAgIH0sXG4gICAgICAgICd0ZXN0LmlvcmFkLmNvbSc6IHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3Rlc3QuaW9yYWQuY29tL2NhcHR1cmUvdHV0b3JpYWxzLyV1c2VyX2lkJS8ldHV0b3JpYWxfaWQlLyVhdWRpb19pZCUuJWF1ZGlvX2V4dCU/Y2FjaGU9JWNhY2hlJSdcbiAgICAgICAgfSxcbiAgICAgICAgcHJvZHVjdGlvbjoge1xuICAgICAgICAgIHVybDogJ2h0dHBzOi8vczMuaW9yYWQuY29tL2NhcHR1cmUvdHV0b3JpYWxzLyV1c2VyX2lkJS8ldHV0b3JpYWxfaWQlLyVhdWRpb19pZCUuJWF1ZGlvX2V4dCU/Y2FjaGU9JWNhY2hlJSdcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYXZhdGFyOiByZWxhdGl2ZVBhdGgoJy91c2VyL2F2YXRhcj91c2VyaWQ9JXVzZXJfaWQlJyksXG4gICAgfVxuICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3NldHRpbmdzLmNvbmZpZy5qcyIsIi8vIFRoaXMgaXMganVzdCBhIHN0dWIsIHdlIGFjdHVhbGx5IG9ubHkgbmVlZCBTaGFyZWRNZW1vcnkgaW4gZW1iZWRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXJlZE1lbW9yeSB7XG4gIHN0YXJ0KGV4dGVuc2lvbikge1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5LmpzIiwiLy8gVXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBzb2xlbHkgcmVseWluZyBvbiBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbi8vIHNpbmNlIGl0IGRvZXNuJ3Qgd29yayBpbiBGaXJlZm94XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTkzNTQ1NC8xNDE4MDQ5LCAjNDQwXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWlnaHQoKSB7XG4gIGNvbnN0IEQgPSBkb2N1bWVudDtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIE1hdGgubWF4KEQuYm9keSA/IEQuYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBELmRvY3VtZW50RWxlbWVudCA/IEQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IDApLFxuICAgIE1hdGgubWF4KEQuYm9keSA/IEQuYm9keS5vZmZzZXRIZWlnaHQgOiAwLCBELmRvY3VtZW50RWxlbWVudCA/IEQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCA6IDApLFxuICAgIE1hdGgubWF4KEQuYm9keSA/IEQuYm9keS5jbGllbnRIZWlnaHQgOiAwLCBELmRvY3VtZW50RWxlbWVudCA/IEQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IDApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudFdpZHRoKCkge1xuICBjb25zdCBEID0gZG9jdW1lbnQ7XG4gIHJldHVybiBNYXRoLm1heChcbiAgICBNYXRoLm1heChELmJvZHkgPyBELmJvZHkuc2Nyb2xsV2lkdGggOiAwLCBELmRvY3VtZW50RWxlbWVudCA/IEQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDogMCksXG4gICAgTWF0aC5tYXgoRC5ib2R5ID8gRC5ib2R5Lm9mZnNldFdpZHRoIDogMCwgRC5kb2N1bWVudEVsZW1lbnQgPyBELmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCA6IDApLFxuICAgIE1hdGgubWF4KEQuYm9keSA/IEQuYm9keS5jbGllbnRXaWR0aCA6IDAsIEQuZG9jdW1lbnRFbGVtZW50ID8gRC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiAwKVxuICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvZG9jdW1lbnRTaXplLmpzIiwiLy8gZXhwYW5kIG1hcmtlciBzaXplIHdpdGhvdXQgZXhjZWVkaW5nIGxpbWl0c1xuZXhwb3J0IGRlZmF1bHQgKGFtb3VudCwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWFya2VyQm91bmRzKSA9PiB7XG4gIGNvbnN0IHggPSBNYXRoLm1heCgwLCBtYXJrZXJCb3VuZHMueCAtIGFtb3VudCk7XG4gIGNvbnN0IHkgPSBNYXRoLm1heCgwLCBtYXJrZXJCb3VuZHMueSAtIGFtb3VudCk7XG5cbiAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihcbiAgICBtYXhXaWR0aCxcbiAgICBtYXJrZXJCb3VuZHMueCAtIHggKyBtYXJrZXJCb3VuZHMud2lkdGggKyBhbW91bnRcbiAgKTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgbWF4SGVpZ2h0LFxuICAgIG1hcmtlckJvdW5kcy55IC0geSArIG1hcmtlckJvdW5kcy5oZWlnaHQgKyBhbW91bnRcbiAgKTtcbiAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2V4cGFuZE1hcmtlci5qcyIsIi8vIFJldHVybiB0cnVlIGlmIHRoZSB0d28gdXJscyBhcmUgcHJvYmFibHkgcm91Z2hseSB0aGUgc2FtZSBwYWdlLiBXZSBpZ25vcmVcbi8vIHN1YmRvbWFpbnMsIG51bWVyaWMgc2VnbWVudHMgb2YgdGhlIHBhdGguIFNlZSAjNjE4XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdXp6eU1hdGNoVXJsKHVybGEsIHVybGIpIHtcbiAgY29uc3Qgbm9ybWFsaXplID0gKHVybCkgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgICBwYXJzZWQuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWUuc3BsaXQoJy4nKS5zbGljZSgtMikuam9pbignLicpO1xuICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZS5yZXBsYWNlKC9cXC9cXGQrKCR8XFwvKS9nLCAnL3tOVU1CRVJ9JDEnKVxuICAgIHBhcnNlZC5zZWFyY2ggPSBwYXJzZWQuc2VhcmNoLnJlcGxhY2UoLz1cXGQrKCR8JikvZywgJz17TlVNQkVSfSQxJylcbiAgICByZXR1cm4gcGFyc2VkLmhyZWY7XG4gIH07XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZSh1cmxhKSA9PT0gbm9ybWFsaXplKHVybGIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvZnV6enlNYXRjaFVybC5qcyIsImltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcblxuZXhwb3J0IGRlZmF1bHQgKGVsKSA9PiB7XG4gIHJldHVybiBwaWNrKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBbXG4gICAgJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnLFxuICBdKTsgLy8gbWFrZSBpdCBlbnVtZXJhYmxlXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvZ2V0Qm91bmRzLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50UG9wdXAoZWwpIHtcbiAgbGV0IHBhcmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHBhcmVudEVsICYmIHBhcmVudEVsLmNsYXNzTGlzdCAmJiBwYXJlbnRFbCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudEVsKTtcbiAgICBjb25zdCBib3VuZHMgPSBwYXJlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGNvbnN0IGlzRHJvcGRvd24gPSBzdHlsZXMucG9zaXRpb24gPT09ICdhYnNvbHV0ZScgJiZcbiAgICAgIGJvdW5kcy53aWR0aCA8PSA0MDAgJiZcbiAgICAgIGJvdW5kcy5oZWlnaHQgPD0gNDAwICYmXG4gICAgICBib3VuZHMud2lkdGggPj0gMTAwICYmXG4gICAgICBib3VuZHMuaGVpZ2h0ID49IDEwMDtcbiAgICBpZiAoaXNEcm9wZG93bikge1xuICAgICAgcmV0dXJuIHBhcmVudEVsO1xuICAgIH1cblxuICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2dldFBhcmVudFBvcHVwLmpzIiwiLy8gTm90ZTogcmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHN0ZXAgZG9lc24ndCBoYXZlIHRoaXMgaW5mb1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTdGVwTG9nZ2VkSW4oc3RlcCkge1xuICBpZiAoc3RlcC53aW5kb3cgJiYgdHlwZW9mIHN0ZXAud2luZG93LmxvZ2dlZEluICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzdGVwLndpbmRvdy5sb2dnZWRJbjtcbiAgfVxuICAvLyBsZWdhY3kgdHV0b3JpYWxzXG4gIHJldHVybiBzdGVwLmV2ZW50ICYmIHN0ZXAuZXZlbnQubG9nZ2VkSW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGVwTG9nZ2VkSW5UeXBlKHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAud2luZG93LmxvZ2dlZEluVHlwZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2lzU3RlcExvZ2dlZEluLmpzIiwiLy8gYmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE0NTUyNVxuLy8gQSByZXBsYWNlIGFsbCBmdW5jdGlvbiB3aXRob3V0IHVzaW5nIHJlZ2V4ICh0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZClcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcGxhY2VBbGwodGFyZ2V0LCBzZWFyY2gsIHJlcGxhY2VtZW50ID0gJycpIHtcbiAgcmV0dXJuIHRhcmdldC5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZW1lbnQpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvcmVwbGFjZUFsbC5qcyIsIi8vIHJldHVybiB0cnVlIGlmIGN1cnJlbnRVcmwgbWF0Y2hlcyB0aGUgYmFzZSBkb21haW4gb2YgYXQgbGVhc3Qgb25lIHN0ZXBcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHR1dG9yaWFsTWF0Y2hVcmwodHV0b3JpYWxEYXRhLCBjdXJyZW50VXJsKSB7XG4gIGlmICghdHV0b3JpYWxEYXRhIHx8ICF0dXRvcmlhbERhdGEuc3RlcHMgfHwgIWN1cnJlbnRVcmwpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcGFnZUJhc2VEb21haW4gPSAobmV3IFVSTChjdXJyZW50VXJsKSkuaG9zdG5hbWUuc3BsaXQoJy4nKS5zbGljZSgtMikuam9pbignLicpO1xuICBjb25zdCBzdGVwQmFzZURvbWFpbnMgPSB0dXRvcmlhbERhdGEuc3RlcHMubWFwKHMgPT5cbiAgICAobmV3IFVSTChzLndpbmRvdy51cmwpKS5ob3N0bmFtZS5zcGxpdCgnLicpLnNsaWNlKC0yKS5qb2luKCcuJylcbiAgKTtcbiAgcmV0dXJuIHN0ZXBCYXNlRG9tYWlucy5pbmRleE9mKHBhZ2VCYXNlRG9tYWluKSAhPT0gLTE7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy90dXRvcmlhbE1hdGNoVXJsLmpzIiwiaW1wb3J0IHdhaXRGb3IgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvd2FpdEZvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhaXRGb3JJbml0KGNhbGxiYWNrLCB0aW1lKSB7XG4gIGlmICh3aW5kb3cgIT09IHdpbmRvdy50b3AgJiYgZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJykge1xuICAgIC8vIE5vdGU6IHdpdGhvdXQgd2FpdEZvciB0aGUgd2luZG93L2RvY3VtZW50IGxpc3RlbmVycyB3b24ndCBiZSBjYWxsZWQgaW4gaWZyYW1lcyBjcmVhdGVkIHdpdGggZG9jdW1lbnQud3JpdGVcbiAgICAvLyAoZS5nLiBpb3JhZCBlZGl0b3IsIHNlZSAjMzk1KVxuICAgIC8vIFRPRE86IHVuZGVyc3RhbmQgd2h5IGl0IGhhcHBlbnNcbiAgICB3YWl0Rm9yKCgpID0+ICEhZG9jdW1lbnQuaGVhZCwgY2FsbGJhY2ssIHRpbWUpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL3dhaXRGb3JJbml0LmpzIiwiLy8gRnVuY3Rpb24gdG8gZ2V0IHRoZSBvZmZzZXQgdG8gYWRqdXN0IHBvc2l0aW9ucyB0byBnbyBmcm9tIHBvcnRhbC1yZWxhdGl2ZSB0b1xuLy8gcGFnZS1jb250ZW50IHJlbGF0aXZlIGluIHRoZSBjdXJyZW50IHBhZ2UvZnJhbWVcblxuZnVuY3Rpb24gcGFyc2VOdW1iZXIobikge1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KG4sIDEwKTtcbiAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIDA7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc3VtQ1NTUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLnJlZHVjZSgoY291bnQsIHByb3ApID0+IHtcbiAgICByZXR1cm4gY291bnQgKyBwYXJzZU51bWJlcihjb21wdXRlZFN0eWxlW3Byb3BdKTtcbiAgfSwgMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbE9mZnNldCgpIHtcbiAgbGV0IHRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgbGV0IGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gIGNvbnN0IGJvZHlDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gIGlmIChib2R5Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ3JlbGF0aXZlJykge1xuICAgIHRvcCAtPSBzdW1DU1NQcm9wZXJ0aWVzKFsndG9wJywgJ21hcmdpblRvcCcsICdib3JkZXJUb3BXaWR0aCddLCBib2R5Q29tcHV0ZWRTdHlsZSk7XG4gICAgbGVmdCAtPSBzdW1DU1NQcm9wZXJ0aWVzKFsnbGVmdCcsICdtYXJnaW5MZWZ0JywgJ2JvcmRlckxlZnRXaWR0aCddLCBib2R5Q29tcHV0ZWRTdHlsZSk7XG4gIH1cbiAgcmV0dXJuIHt4OiBsZWZ0LCB5OiB0b3B9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L2dldFdpbmRvd1Njcm9sbE9mZnNldC5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDMzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDMzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IDM0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDM1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanNcbi8vIG1vZHVsZSBpZCA9IDM1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9oID09IDEpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZWFjdGlvbjtcbiAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYgKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKSByZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAzNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDM2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2JhYmVsLXJ1bnRpbWUvfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYmFiZWwtcnVudGltZS9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDM2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcbi8vIG1vZHVsZSBpZCA9IDM2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gMzc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDM4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAzODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMzg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19EYXRhVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMzg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMzkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRNYXBFbnRyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hZGRNYXBFbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNldEVudHJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2FkZFNldEVudHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpVG9BcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hc2NpaVRvQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDM5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMzk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlQXNzaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDM5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaXRlcmF0ZWUpIHtcbiAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZURpZmZlcmVuY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZURpZmZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDM5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMzk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gNDAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlSXNOYU4uanNcbi8vIG1vZHVsZSBpZCA9IDQwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUtleXNJbi5qc1xuLy8gbW9kdWxlIGlkID0gNDA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDQwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBiYXNlU29ydEJ5ID0gcmVxdWlyZSgnLi9fYmFzZVNvcnRCeScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNvbXBhcmVNdWx0aXBsZSA9IHJlcXVpcmUoJy4vX2NvbXBhcmVNdWx0aXBsZScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlT3JkZXJCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlT3JkZXJCeS5qc1xuLy8gbW9kdWxlIGlkID0gNDA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlUGljay5qc1xuLy8gbW9kdWxlIGlkID0gNDA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gNDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTbGljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlU2xpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0O1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiAhcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuICEhcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb21lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VTb21lLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0Qnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZVNvcnRCeS5qc1xuLy8gbW9kdWxlIGlkID0gNDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlVW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gNDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZVZhbHVlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA0MThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Nsb25lTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0MTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Nsb25lU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jbG9uZVN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFzY2VuZGluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29tcGFyZUFzY2VuZGluZyA9IHJlcXVpcmUoJy4vX2NvbXBhcmVBc2NlbmRpbmcnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTXVsdGlwbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY29weVN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDQyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gKi9cbmZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IDA7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3VudEhvbGRlcnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY291bnRIb2xkZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA0Mjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDQyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gNDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNyZWF0ZUN0b3IgPSByZXF1aXJlKCcuL19jcmVhdGVDdG9yJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJpbmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQmluZC5qc1xuLy8gbW9kdWxlIGlkID0gNDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBjcmVhdGVDdG9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQ3RvcicpLFxuICAgIGNyZWF0ZUh5YnJpZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUh5YnJpZCcpLFxuICAgIGNyZWF0ZVJlY3VycnkgPSByZXF1aXJlKCcuL19jcmVhdGVSZWN1cnJ5JyksXG4gICAgZ2V0SG9sZGVyID0gcmVxdWlyZSgnLi9fZ2V0SG9sZGVyJyksXG4gICAgcmVwbGFjZUhvbGRlcnMgPSByZXF1aXJlKCcuL19yZXBsYWNlSG9sZGVycycpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgID8gW11cbiAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ3Vycnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3JlYXRlQ3VycnkuanNcbi8vIG1vZHVsZSBpZCA9IDQzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVGaW5kO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NyZWF0ZUZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgY3JlYXRlQ3RvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUN0b3InKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgfVxuICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGFydGlhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jcmVhdGVQYXJ0aWFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVNldERhdGEgPSByZXF1aXJlKCcuL19iYXNlU2V0RGF0YScpLFxuICAgIGNyZWF0ZUJpbmQgPSByZXF1aXJlKCcuL19jcmVhdGVCaW5kJyksXG4gICAgY3JlYXRlQ3VycnkgPSByZXF1aXJlKCcuL19jcmVhdGVDdXJyeScpLFxuICAgIGNyZWF0ZUh5YnJpZCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUh5YnJpZCcpLFxuICAgIGNyZWF0ZVBhcnRpYWwgPSByZXF1aXJlKCcuL19jcmVhdGVQYXJ0aWFsJyksXG4gICAgZ2V0RGF0YSA9IHJlcXVpcmUoJy4vX2dldERhdGEnKSxcbiAgICBtZXJnZURhdGEgPSByZXF1aXJlKCcuL19tZXJnZURhdGEnKSxcbiAgICBzZXREYXRhID0gcmVxdWlyZSgnLi9fc2V0RGF0YScpLFxuICAgIHNldFdyYXBUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFdyYXBUb1N0cmluZycpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAgIDEgLSBgXy5iaW5kYFxuICogICAgMiAtIGBfLmJpbmRLZXlgXG4gKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAqICAgIDggLSBgXy5jdXJyeWBcbiAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICogICAzMiAtIGBfLnBhcnRpYWxgXG4gKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICogIDEyOCAtIGBfLnJlYXJnYFxuICogIDI1NiAtIGBfLmFyeWBcbiAqICA1MTIgLSBgXy5mbGlwYFxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICB2YXIgbmV3RGF0YSA9IFtcbiAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICBdO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICB9XG4gIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICB9XG4gIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXcmFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NyZWF0ZVdyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDQzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19lcXVhbEJ5VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA0MzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gNDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gNDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDQ0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xudmFyIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFdyYXBEZXRhaWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2dldFdyYXBEZXRhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19oYXNoQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19oYXNoRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2hhc2hHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faGFzaEhhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2hhc2hTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faW5pdENsb25lQnlUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDQ0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xudmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vO1xuXG4vKipcbiAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICovXG5mdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFdyYXBEZXRhaWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2luc2VydFdyYXBEZXRhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19pc01hc2tlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gNDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gNDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX21hcENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19tYXBDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19tYXBDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gNDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qc1xuLy8gbW9kdWxlIGlkID0gNDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGNvbXBvc2VBcmdzID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3MnKSxcbiAgICBjb21wb3NlQXJnc1JpZ2h0ID0gcmVxdWlyZSgnLi9fY29tcG9zZUFyZ3NSaWdodCcpLFxuICAgIHJlcGxhY2VIb2xkZXJzID0gcmVxdWlyZSgnLi9fcmVwbGFjZUhvbGRlcnMnKTtcblxuLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xudmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICpcbiAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gIHZhciBpc0NvbWJvID1cbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICBpZiAodmFsdWUpIHtcbiAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgfVxuICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZGF0YVs3XSA9IHZhbHVlO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gIH1cbiAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICBkYXRhWzldID0gc291cmNlWzldO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX21lcmdlRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fbm9kZVV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbnZhciByZWFsTmFtZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWFsTmFtZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fcmVhbE5hbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0Njlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVvcmRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19yZW9yZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zZXRDYWNoZUFkZC5qc1xuLy8gbW9kdWxlIGlkID0gNDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3NldENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zdGFja0NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zdGFja0dldC5qc1xuLy8gbW9kdWxlIGlkID0gNDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zdGFja0hhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc3RhY2tTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDQ3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhc2NpaVRvQXJyYXkgPSByZXF1aXJlKCcuL19hc2NpaVRvQXJyYXknKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVUb0FycmF5ID0gcmVxdWlyZSgnLi9fdW5pY29kZVRvQXJyYXknKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9BcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0Nzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19zdHJpbmdUb1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQ4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3VuaWNvZGVUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA0ODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbi8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG52YXIgd3JhcEZsYWdzID0gW1xuICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG5dO1xuXG4vKipcbiAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXBkYXRlV3JhcERldGFpbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fdXBkYXRlV3JhcERldGFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBMYXp5V3JhcHBlciA9IHJlcXVpcmUoJy4vX0xhenlXcmFwcGVyJyksXG4gICAgTG9kYXNoV3JhcHBlciA9IHJlcXVpcmUoJy4vX0xvZGFzaFdyYXBwZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICovXG5mdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZXJDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL193cmFwcGVyQ2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvY29uc3RhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5JyksXG4gICAgYXNzaWduSW5XaXRoID0gcmVxdWlyZSgnLi9hc3NpZ25JbldpdGgnKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2N1c3RvbURlZmF1bHRzQXNzaWduSW4nKTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuICByZXR1cm4gYXBwbHkoYXNzaWduSW5XaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9kZWZhdWx0cy5qc1xuLy8gbW9kdWxlIGlkID0gNDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9lYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXNzaWduSW4nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2V4dGVuZC5qc1xuLy8gbW9kdWxlIGlkID0gNDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9fYmFzZUZpbHRlcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0ODhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9maW5kSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlSGFzID0gcmVxdWlyZSgnLi9fYmFzZUhhcycpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoJy4vX2Jhc2VJbnRlcnNlY3Rpb24nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgY2FzdEFycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vX2Nhc3RBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAqIC8vID0+IFsyXVxuICovXG52YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICA6IFtdO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJzZWN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvaW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2xhc3QuanNcbi8vIG1vZHVsZSBpZCA9IDQ5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDQ5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIFtwcm9wXTtcbiAgfSk7XG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpO1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrQnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9waWNrQnkuanNcbi8vIG1vZHVsZSBpZCA9IDQ5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0OTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3NldC5qc1xuLy8gbW9kdWxlIGlkID0gNDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VTb21lID0gcmVxdWlyZSgnLi9fYmFzZVNvbWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvc29tZS5qc1xuLy8gbW9kdWxlIGlkID0gNDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3N0dWJGYWxzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL3RvRmluaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgTGF6eVdyYXBwZXIgPSByZXF1aXJlKCcuL19MYXp5V3JhcHBlcicpLFxuICAgIExvZGFzaFdyYXBwZXIgPSByZXF1aXJlKCcuL19Mb2Rhc2hXcmFwcGVyJyksXG4gICAgYmFzZUxvZGFzaCA9IHJlcXVpcmUoJy4vX2Jhc2VMb2Rhc2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKSxcbiAgICB3cmFwcGVyQ2xvbmUgPSByZXF1aXJlKCcuL193cmFwcGVyQ2xvbmUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAqIHdpdGggYF8jdmFsdWVgLlxuICpcbiAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gKlxuICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gKlxuICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqXG4gKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICpcbiAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gKlxuICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICpcbiAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gKlxuICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gKlxuICogQG5hbWUgX1xuICogQGNvbnN0cnVjdG9yXG4gKiBAY2F0ZWdvcnkgU2VxXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICpcbiAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICogLy8gPT4gNlxuICpcbiAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICpcbiAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbn1cblxuLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxubG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xubG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC93cmFwcGVyTG9kYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1MDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgQ09NUExFVEUgPSAnY29tcGxldGUnLFxuICAgIENBTkNFTEVEID0gJ2NhbmNlbGVkJztcblxuZnVuY3Rpb24gcmFmKHRhc2spe1xuICAgIGlmKCdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIGluIHdpbmRvdyl7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRhc2spO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQodGFzaywgMTYpO1xufVxuXG5mdW5jdGlvbiBzZXRFbGVtZW50U2Nyb2xsKGVsZW1lbnQsIHgsIHkpe1xuICAgIGlmKGVsZW1lbnQuc2VsZiA9PT0gZWxlbWVudCl7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG8oeCwgeSk7XG4gICAgfWVsc2V7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0geTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldFNjcm9sbExvY2F0aW9uKHRhcmdldCwgcGFyZW50LCBhbGlnbil7XG4gICAgdmFyIHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBwYXJlbnRQb3NpdGlvbixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZGlmZmVyZW5jZVgsXG4gICAgICAgIGRpZmZlcmVuY2VZLFxuICAgICAgICB0YXJnZXRXaWR0aCxcbiAgICAgICAgdGFyZ2V0SGVpZ2h0LFxuICAgICAgICBsZWZ0QWxpZ24gPSBhbGlnbiAmJiBhbGlnbi5sZWZ0ICE9IG51bGwgPyBhbGlnbi5sZWZ0IDogMC41LFxuICAgICAgICB0b3BBbGlnbiA9IGFsaWduICYmIGFsaWduLnRvcCAhPSBudWxsID8gYWxpZ24udG9wIDogMC41LFxuICAgICAgICBsZWZ0T2Zmc2V0ID0gYWxpZ24gJiYgYWxpZ24ubGVmdE9mZnNldCAhPSBudWxsID8gYWxpZ24ubGVmdE9mZnNldCA6IDAsXG4gICAgICAgIHRvcE9mZnNldCA9IGFsaWduICYmIGFsaWduLnRvcE9mZnNldCAhPSBudWxsID8gYWxpZ24udG9wT2Zmc2V0IDogMCxcbiAgICAgICAgbGVmdFNjYWxhciA9IGxlZnRBbGlnbixcbiAgICAgICAgdG9wU2NhbGFyID0gdG9wQWxpZ247XG5cbiAgICBpZihwYXJlbnQuc2VsZiA9PT0gcGFyZW50KXtcbiAgICAgICAgdGFyZ2V0V2lkdGggPSBNYXRoLm1pbih0YXJnZXRQb3NpdGlvbi53aWR0aCwgcGFyZW50LmlubmVyV2lkdGgpO1xuICAgICAgICB0YXJnZXRIZWlnaHQgPSBNYXRoLm1pbih0YXJnZXRQb3NpdGlvbi5oZWlnaHQsIHBhcmVudC5pbm5lckhlaWdodCk7XG4gICAgICAgIHggPSB0YXJnZXRQb3NpdGlvbi5sZWZ0ICsgcGFyZW50LnBhZ2VYT2Zmc2V0IC0gcGFyZW50LmlubmVyV2lkdGggKiBsZWZ0U2NhbGFyICsgdGFyZ2V0V2lkdGggKiBsZWZ0U2NhbGFyO1xuICAgICAgICB5ID0gdGFyZ2V0UG9zaXRpb24udG9wICsgcGFyZW50LnBhZ2VZT2Zmc2V0IC0gcGFyZW50LmlubmVySGVpZ2h0ICogdG9wU2NhbGFyICsgdGFyZ2V0SGVpZ2h0ICogdG9wU2NhbGFyO1xuICAgICAgICB4IC09IGxlZnRPZmZzZXQ7XG4gICAgICAgIHkgLT0gdG9wT2Zmc2V0O1xuICAgICAgICBkaWZmZXJlbmNlWCA9IHggLSBwYXJlbnQucGFnZVhPZmZzZXQ7XG4gICAgICAgIGRpZmZlcmVuY2VZID0geSAtIHBhcmVudC5wYWdlWU9mZnNldDtcbiAgICB9ZWxzZXtcbiAgICAgICAgdGFyZ2V0V2lkdGggPSB0YXJnZXRQb3NpdGlvbi53aWR0aDtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0UG9zaXRpb24uaGVpZ2h0O1xuICAgICAgICBwYXJlbnRQb3NpdGlvbiA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSB0YXJnZXRQb3NpdGlvbi5sZWZ0IC0gKHBhcmVudFBvc2l0aW9uLmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdCk7XG4gICAgICAgIHZhciBvZmZzZXRUb3AgPSB0YXJnZXRQb3NpdGlvbi50b3AgLSAocGFyZW50UG9zaXRpb24udG9wIC0gcGFyZW50LnNjcm9sbFRvcCk7XG4gICAgICAgIHggPSBvZmZzZXRMZWZ0ICsgKHRhcmdldFdpZHRoICogbGVmdFNjYWxhcikgLSBwYXJlbnQuY2xpZW50V2lkdGggKiBsZWZ0U2NhbGFyO1xuICAgICAgICB5ID0gb2Zmc2V0VG9wICsgKHRhcmdldEhlaWdodCAqIHRvcFNjYWxhcikgLSBwYXJlbnQuY2xpZW50SGVpZ2h0ICogdG9wU2NhbGFyO1xuICAgICAgICB4ID0gTWF0aC5tYXgoTWF0aC5taW4oeCwgcGFyZW50LnNjcm9sbFdpZHRoIC0gcGFyZW50LmNsaWVudFdpZHRoKSwgMCk7XG4gICAgICAgIHkgPSBNYXRoLm1heChNYXRoLm1pbih5LCBwYXJlbnQuc2Nyb2xsSGVpZ2h0IC0gcGFyZW50LmNsaWVudEhlaWdodCksIDApO1xuICAgICAgICB4IC09IGxlZnRPZmZzZXQ7XG4gICAgICAgIHkgLT0gdG9wT2Zmc2V0O1xuICAgICAgICBkaWZmZXJlbmNlWCA9IHggLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgZGlmZmVyZW5jZVkgPSB5IC0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBkaWZmZXJlbmNlWDogZGlmZmVyZW5jZVgsXG4gICAgICAgIGRpZmZlcmVuY2VZOiBkaWZmZXJlbmNlWVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGUocGFyZW50KXtcbiAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNjcm9sbFNldHRpbmdzID0gcGFyZW50Ll9zY3JvbGxTZXR0aW5ncztcbiAgICAgICAgaWYoIXNjcm9sbFNldHRpbmdzKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdldFRhcmdldFNjcm9sbExvY2F0aW9uKHNjcm9sbFNldHRpbmdzLnRhcmdldCwgcGFyZW50LCBzY3JvbGxTZXR0aW5ncy5hbGlnbiksXG4gICAgICAgICAgICB0aW1lID0gRGF0ZS5ub3coKSAtIHNjcm9sbFNldHRpbmdzLnN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRpbWVWYWx1ZSA9IE1hdGgubWluKDEgLyBzY3JvbGxTZXR0aW5ncy50aW1lICogdGltZSwgMSk7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgICB0aW1lID4gc2Nyb2xsU2V0dGluZ3MudGltZSArIDIwXG4gICAgICAgICl7XG4gICAgICAgICAgICBzZXRFbGVtZW50U2Nyb2xsKHBhcmVudCwgbG9jYXRpb24ueCwgbG9jYXRpb24ueSk7XG4gICAgICAgICAgICBwYXJlbnQuX3Njcm9sbFNldHRpbmdzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY3JvbGxTZXR0aW5ncy5lbmQoQ09NUExFVEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVhc2VWYWx1ZSA9IDEgLSBzY3JvbGxTZXR0aW5ncy5lYXNlKHRpbWVWYWx1ZSk7XG5cbiAgICAgICAgc2V0RWxlbWVudFNjcm9sbChwYXJlbnQsXG4gICAgICAgICAgICBsb2NhdGlvbi54IC0gbG9jYXRpb24uZGlmZmVyZW5jZVggKiBlYXNlVmFsdWUsXG4gICAgICAgICAgICBsb2NhdGlvbi55IC0gbG9jYXRpb24uZGlmZmVyZW5jZVkgKiBlYXNlVmFsdWVcbiAgICAgICAgKTtcblxuICAgICAgICBhbmltYXRlKHBhcmVudCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uU2Nyb2xsVG8odGFyZ2V0LCBwYXJlbnQsIHNldHRpbmdzLCBjYWxsYmFjayl7XG4gICAgdmFyIGlkbGUgPSAhcGFyZW50Ll9zY3JvbGxTZXR0aW5ncyxcbiAgICAgICAgbGFzdFNldHRpbmdzID0gcGFyZW50Ll9zY3JvbGxTZXR0aW5ncyxcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgZW5kSGFuZGxlcjtcblxuICAgIGlmKGxhc3RTZXR0aW5ncyl7XG4gICAgICAgIGxhc3RTZXR0aW5ncy5lbmQoQ0FOQ0VMRUQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZChlbmRUeXBlKXtcbiAgICAgICAgcGFyZW50Ll9zY3JvbGxTZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIGlmKHBhcmVudC5wYXJlbnRFbGVtZW50ICYmIHBhcmVudC5wYXJlbnRFbGVtZW50Ll9zY3JvbGxTZXR0aW5ncyl7XG4gICAgICAgICAgICBwYXJlbnQucGFyZW50RWxlbWVudC5fc2Nyb2xsU2V0dGluZ3MuZW5kKGVuZFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVuZFR5cGUpO1xuICAgICAgICBwYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGVuZEhhbmRsZXIpO1xuICAgIH1cblxuICAgIHBhcmVudC5fc2Nyb2xsU2V0dGluZ3MgPSB7XG4gICAgICAgIHN0YXJ0VGltZTogbGFzdFNldHRpbmdzID8gbGFzdFNldHRpbmdzLnN0YXJ0VGltZSA6IERhdGUubm93KCksXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICB0aW1lOiBzZXR0aW5ncy50aW1lICsgKGxhc3RTZXR0aW5ncyA/IG5vdyAtIGxhc3RTZXR0aW5ncy5zdGFydFRpbWUgOiAwKSxcbiAgICAgICAgZWFzZTogc2V0dGluZ3MuZWFzZSxcbiAgICAgICAgYWxpZ246IHNldHRpbmdzLmFsaWduLFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG5cbiAgICBlbmRIYW5kbGVyID0gZW5kLmJpbmQobnVsbCwgQ0FOQ0VMRUQpO1xuICAgIHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZW5kSGFuZGxlcik7XG5cbiAgICBpZihpZGxlKXtcbiAgICAgICAgYW5pbWF0ZShwYXJlbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdElzU2Nyb2xsYWJsZShlbGVtZW50KXtcbiAgICByZXR1cm4gKFxuICAgICAgICAncGFnZVhPZmZzZXQnIGluIGVsZW1lbnQgfHxcbiAgICAgICAgKFxuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxIZWlnaHQgIT09IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFdpZHRoICE9PSBlbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICkgJiZcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5vdmVyZmxvdyAhPT0gJ2hpZGRlbidcbiAgICApO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VmFsaWRUYXJnZXQoKXtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzLCBjYWxsYmFjayl7XG4gICAgaWYoIXRhcmdldCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih0eXBlb2Ygc2V0dGluZ3MgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICBjYWxsYmFjayA9IHNldHRpbmdzO1xuICAgICAgICBzZXR0aW5ncyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYoIXNldHRpbmdzKXtcbiAgICAgICAgc2V0dGluZ3MgPSB7fTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncy50aW1lID0gaXNOYU4oc2V0dGluZ3MudGltZSkgPyAxMDAwIDogc2V0dGluZ3MudGltZTtcbiAgICBzZXR0aW5ncy5lYXNlID0gc2V0dGluZ3MuZWFzZSB8fCBmdW5jdGlvbih2KXtyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB2LCB2IC8gMik7fTtcblxuICAgIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50RWxlbWVudCxcbiAgICAgICAgcGFyZW50cyA9IDA7XG5cbiAgICBmdW5jdGlvbiBkb25lKGVuZFR5cGUpe1xuICAgICAgICBwYXJlbnRzLS07XG4gICAgICAgIGlmKCFwYXJlbnRzKXtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVuZFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkVGFyZ2V0ID0gc2V0dGluZ3MudmFsaWRUYXJnZXQgfHwgZGVmYXVsdFZhbGlkVGFyZ2V0O1xuICAgIHZhciBpc1Njcm9sbGFibGUgPSBzZXR0aW5ncy5pc1Njcm9sbGFibGU7XG5cbiAgICB3aGlsZShwYXJlbnQpe1xuICAgICAgICBpZih2YWxpZFRhcmdldChwYXJlbnQsIHBhcmVudHMpICYmIChpc1Njcm9sbGFibGUgPyBpc1Njcm9sbGFibGUocGFyZW50LCBkZWZhdWx0SXNTY3JvbGxhYmxlKSA6IGRlZmF1bHRJc1Njcm9sbGFibGUocGFyZW50KSkpe1xuICAgICAgICAgICAgcGFyZW50cysrO1xuICAgICAgICAgICAgdHJhbnNpdGlvblNjcm9sbFRvKHRhcmdldCwgcGFyZW50LCBzZXR0aW5ncywgZG9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgICBpZighcGFyZW50KXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBhcmVudC50YWdOYW1lID09PSAnQk9EWScpe1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZGVmYXVsdFZpZXcgfHwgcGFyZW50Lm93bmVyV2luZG93O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vc2Nyb2xsLWludG8tdmlldy9zY3JvbGxJbnRvVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IENvbW1vbkZsdXggZnJvbSAnYmFzZS9jb21tb24vRmx1eCc7XG5pbXBvcnQgU3RhdGVNYW5hZ2VyIGZyb20gJ2Jhc2UvY29tbW9uL1N0YXRlTWFuYWdlcic7XG5pbXBvcnQgYWN0aW9uRmFjdG9yeSBmcm9tICcuL2FjdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbHV4IGV4dGVuZHMgQ29tbW9uRmx1eCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMub3duQ29udGV4dE5hbWUgPSAnYmFja2dyb3VuZCc7XG5cbiAgICB0aGlzLm9sZEJhY2tncm91bmRTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5iYWNrZ3JvdW5kU3RhdGUgPSB7fTtcblxuICAgIC8vIFRPRE86IGNsZWFudXAgb24gdGFiIGNsb3NlIChpbmNsdWRpbmcgZW1iZWQgY2FjaGUpXG4gICAgdGhpcy5wYW5lbFN0YXRlcyA9IHt9OyAvLyA8dGFiIGlkLCBzdGF0ZT5cbiAgICB0aGlzLm9sZFBhbmVsU3RhdGVzID0ge307IC8vIDx0YWIgaWQsIHN0YXRlPlxuICAgIHRoaXMuY29udGVudFN0YXRlcyA9IHt9OyAvLyA8dGFiIGlkLCBzdGF0ZT5cbiAgICB0aGlzLm9sZENvbnRlbnRTdGF0ZXMgPSB7fTsgLy8gPHRhYiBpZCwgc3RhdGU+XG4gIH1cblxuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgICB0aGlzLmRvY3VtZW50c1BvcnQgPSB0aGlzLmV4dGVuc2lvbi5wb3J0TWFuYWdlci5kb2N1bWVudHNQb3J0O1xuXG4gICAgdGhpcy5sb2NhbFN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIodGhpcy5leHRlbnNpb24uZ2V0SW5pdGlhbFN0YXRlKCkpO1xuICAgIHRoaXMuX2FjdGlvbnMgPSBhY3Rpb25GYWN0b3J5KHtcbiAgICAgIHNldFN0YXRlOiB0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyLnNldFN0YXRlLmJpbmQodGhpcy5sb2NhbFN0YXRlTWFuYWdlciksXG4gICAgICBnZXRTdGF0ZTogdGhpcy5sb2NhbFN0YXRlTWFuYWdlci5nZXRTdGF0ZS5iaW5kKHRoaXMubG9jYWxTdGF0ZU1hbmFnZXIpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMubG9jYWxTdGF0ZU1hbmFnZXIub24oJ3N0YXRlQ2hhbmdlZCcsIChzdGF0ZSwgZXhjbHVkZWRUYWJzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlQmFja2dyb3VuZFN0YXRlKHN0YXRlLCBleGNsdWRlZFRhYnMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmV4dGVuc2lvbi5vbmNlKCdyZWFkeScsICgpID0+IHRoaXMuaGFuZGxlQmFja2dyb3VuZFN0YXRlKHRoaXMubG9jYWxTdGF0ZU1hbmFnZXIuc3RhdGUpKTtcblxuICAgICAgdGhpcy5kb2N1bWVudHNQb3J0Lm9uKCdtZXNzYWdlJywgbWVzc2FnZSA9PiB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnY29udGVudFN0YXRlQ2hhbmdlZCcpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNvbnRlbnRTdGF0ZShtZXNzYWdlLmRhdGEsIG1lc3NhZ2UudGFiLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3BhbmVsU3RhdGVDaGFuZ2VkJykge1xuICAgICAgICAgIHRoaXMuaGFuZGxlUGFuZWxTdGF0ZShtZXNzYWdlLmRhdGEsIG1lc3NhZ2UudGFiLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnZGlzcGF0Y2hBY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChtZXNzYWdlLmRhdGEuY29udGV4dCwgbWVzc2FnZS5kYXRhLmFjdGlvbk5hbWUsIC4uLm1lc3NhZ2UuZGF0YS5hY3Rpb25BcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAncmVxdWVzdEJhY2tncm91bmRTdGF0ZScpIHtcbiAgICAgICAgICB0aGlzLmRvY3VtZW50c1BvcnQuc2VuZFRvT25lKG1lc3NhZ2UudGFiLmlkLCB7XG4gICAgICAgICAgICB0b3BpYzogJ2JhY2tncm91bmRTdGF0ZUNoYW5nZWQnLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5iYWNrZ3JvdW5kU3RhdGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmV4dGVuc2lvbi50YWJzQ29udHJvbGxlci5vbigndGFiUmVtb3ZlZCcsICh7IHRhYklkIH0pID0+IHtcbiAgICAgICAgLy8gY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgICAgICAgLy8gKGRlbGF5IGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgbWVzc2FnZXMpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhbmVsU3RhdGVzW3RhYklkXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vbGRQYW5lbFN0YXRlc1t0YWJJZF07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY29udGVudFN0YXRlc1t0YWJJZF07XG4gICAgICAgICAgZGVsZXRlIHRoaXMub2xkQ29udGVudFN0YXRlc1t0YWJJZF07XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmZXRjaCgpIHtcbiAgICAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgaGFuZGxlQmFja2dyb3VuZFN0YXRlKHN0YXRlLCBleGNsdWRlZFRhYnMgPSBbXSkge1xuICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICB0aGlzLm9sZEJhY2tncm91bmRTdGF0ZSA9IHRoaXMuYmFja2dyb3VuZFN0YXRlO1xuICAgIHRoaXMuYmFja2dyb3VuZFN0YXRlID0gc3RhdGU7XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsICdiYWNrZ3JvdW5kJywgdGhpcy5vbGRCYWNrZ3JvdW5kU3RhdGUsIHRoaXMuYmFja2dyb3VuZFN0YXRlKTtcblxuICAgIHRoaXMuZG9jdW1lbnRzUG9ydC5zZW5kKHtcbiAgICAgIHRvcGljOiAnYmFja2dyb3VuZFN0YXRlQ2hhbmdlZCcsXG4gICAgICBkYXRhOiBzdGF0ZSxcbiAgICAgIGV4Y2x1ZGVkVGFicyxcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUNvbnRlbnRTdGF0ZShzdGF0ZSwgdGFiSWQpIHtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdGhpcy5vbGRDb250ZW50U3RhdGVzW3RhYklkXSA9IHRoaXMuY29udGVudFN0YXRlc1t0YWJJZF0gfHwgbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRTdGF0ZXNbdGFiSWRdID0gc3RhdGUuY29udGVudDtcblxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgJ2NvbnRlbnQnLCB0aGlzLm9sZENvbnRlbnRTdGF0ZSwgdGhpcy5jb250ZW50U3RhdGUsIHRhYklkKTtcbiAgfVxuXG4gIGhhbmRsZVBhbmVsU3RhdGUoc3RhdGUsIHRhYklkKSB7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHRoaXMub2xkUGFuZWxTdGF0ZXNbdGFiSWRdID0gdGhpcy5wYW5lbFN0YXRlc1t0YWJJZF0gfHwgbnVsbDtcbiAgICB0aGlzLnBhbmVsU3RhdGVzW3RhYklkXSA9IHN0YXRlLnBhbmVsO1xuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCAncGFuZWwnLCB0aGlzLm9sZFBhbmVsU3RhdGUsIHRoaXMucGFuZWxTdGF0ZSwgdGFiSWQpO1xuICB9XG5cbiAgYmFja2dyb3VuZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLmJhY2tncm91bmRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcywgeyBuYW1lOiAnYmFja2dyb3VuZCcgfSksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnRlbnRDb250ZXh0KHRhYklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXRlOiB0aGlzLmNvbnRlbnRTdGF0ZXNbdGFiSWRdIHx8IHt9LFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzLCB7IG5hbWU6ICdjb250ZW50JywgdGFiSWQgfSksXG4gICAgfTtcbiAgfVxuXG4gIHBhbmVsQ29udGV4dCh0YWJJZCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogdGhpcy5wYW5lbFN0YXRlc1t0YWJJZF0gfHwge30sXG4gICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMsIHsgbmFtZTogJ3BhbmVsJywgdGFiSWQgfSksXG4gICAgfTtcbiAgfVxuXG4gIHNlbmRUb0NvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydC5zZW5kVG9PbmUoY29udGV4dC50YWJJZCwgbWVzc2FnZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvYmFja2dyb3VuZC9GbHV4LmpzIiwiaW1wb3J0IGJyb3dzZXIgZnJvbSAnY2hyb21lL2Jyb3dzZXInO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdiYXNlL2NvbW1vbi9Db21wb25lbnQnO1xuaW1wb3J0IHR1dG9yaWFsTWF0Y2hVcmwgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvdHV0b3JpYWxNYXRjaFVybCc7XG5cbmltcG9ydCB2YWx1ZXMgZnJvbSAnbG9kYXNoL3ZhbHVlcyc7XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5lbENvbnRyb2xsZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGFydCguLi5hcmdzKSB7XG4gICAgc3VwZXIuc3RhcnQoLi4uYXJncyk7XG5cbiAgICB0aGlzLnNldHVwRG9jdW1lbnRzKCk7XG4gICAgdGhpcy5zZXR1cEJyb3dzZXJBY3Rpb24oKTtcbiAgICB0aGlzLnNldHVwVGFicygpO1xuICAgIHRoaXMuc2V0dXBBdXRoKCk7XG4gICAgdGhpcy51cGRhdGVUYWJzQ291bnQoKTtcbiAgfVxuXG4gIHNldHVwRG9jdW1lbnRzKCkge1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmRvY3VtZW50c1BvcnQ7XG4gICAgdGhpcy5kb2N1bWVudHNQb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVEb2N1bWVudHNNZXNzYWdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc2V0dXBCcm93c2VyQWN0aW9uKCkge1xuICAgIHRoaXMuYnJvd3NlckFjdGlvbiA9IHRoaXMuZXh0ZW5zaW9uLmJyb3dzZXJBY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuYnJvd3NlckFjdGlvbi5vbignbWVzc2FnZScsIHRoaXMuX29uQnJvd3NlckFjdGlvbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzZXR1cFRhYnMoKSB7XG4gICAgdGhpcy50YWJzQ29udHJvbGxlciA9IHRoaXMuZXh0ZW5zaW9uLnRhYnNDb250cm9sbGVyO1xuICAgIHRoaXMubW9uaXRvclBhbmVsU3VwcG9ydGVkKCk7XG5cbiAgICB0aGlzLnRhYnNDb250cm9sbGVyLm9uKCd0YWJSZW1vdmVkJywgKHsgdGFiSWQgfSkgPT4ge1xuICAgICAgLy8gY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgICAgIC8vIChkZWxheSBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIG1lc3NhZ2VzKVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdjbGVhclBhbmVsT3BlbicsIHRhYklkKTtcbiAgICAgIH0sIDUwMDApO1xuICAgICAgdGhpcy51cGRhdGVUYWJzQ291bnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldHVwQXV0aCgpIHtcbiAgICB0aGlzLmV4dGVuc2lvbi5hdXRoLm9uKCd1c2VyQ2hhbmdlZCcsICh7IHVzZXIgfSkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudHNQb3J0LnNlbmQoeyB0b3BpYzogJ3VzZXJDaGFuZ2VkJywgZGF0YTogeyB1c2VyIH0gfSk7XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVEb2N1bWVudHNNZXNzYWdlKG1lc3NhZ2UsIHJlc3BvbmQpIHtcbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3Nob3dQYW5lbCcpIHtcbiAgICAgIC8vIG9uIGFsbCB0YWJzIGlmIG1lc3NhZ2UuZGF0YS50YWJJZCBpcyB1bmRlZmluZWQhXG4gICAgICB0aGlzLnNob3dQYW5lbChtZXNzYWdlLmRhdGEuZXhwbGljaXQsIG1lc3NhZ2UuZGF0YS50YWJJZCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnaGlkZVBhbmVsJykge1xuICAgICAgdGhpcy5oaWRlUGFuZWwobWVzc2FnZS5kYXRhLmV4cGxpY2l0LCBtZXNzYWdlLmRhdGEudGFiSWQpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAncmVsb2FkQWxsVGFicycpIHtcbiAgICAgIHRoaXMucmVsb2FkQWxsVGFicygpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAndmlld0xpdmUnKSB7XG4gICAgICB0aGlzLnZpZXdMaXZlKG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS50YWIuaWQpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAncmVnaXN0ZXJQYW5lbENvbnRyb2xsZXInKSB7XG4gICAgICB0aGlzLnRhYnNDb250cm9sbGVyLmdldEFjdGl2ZVRhYklkKCkudGhlbihhY3RpdmVUYWJJZCA9PiB7XG4gICAgICAgIGNvbnN0IHRhYkluZm8gPSB0aGlzLnRhYnNDb250cm9sbGVyLmdldFRhYkluZm8obWVzc2FnZS50YWIuaWQpO1xuICAgICAgICByZXNwb25kKHtcbiAgICAgICAgICB0YWI6IHsgaWQ6IG1lc3NhZ2UudGFiLmlkIH0sXG4gICAgICAgICAgZW5hYmxlZDogbWVzc2FnZS50YWIuaWQgPT09IGFjdGl2ZVRhYklkLFxuICAgICAgICAgIHRhYkluZm8sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvY3VtZW50c1BvcnQuc2VuZFRvT25lKG1lc3NhZ2UudGFiLmlkLCB7XG4gICAgICAgICAgdG9waWM6ICdiYWNrZ3JvdW5kU3RhdGVDaGFuZ2VkJyxcbiAgICAgICAgICBkYXRhOiB0aGlzLm93bkNvbnRleHQoKS5zdGF0ZSxcbiAgICAgICAgICBleGNsdWRlZFRhYnM6IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHdpbGxPcGVuID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFBhbmVsT3Blbk9uTmV3VGFiKG1lc3NhZ2UudGFiKSkge1xuICAgICAgICAgIC8vIGZvcmNlIHBhbmVsIG9wZW5pbmcgaW4gbmV3IHRhYlxuICAgICAgICAgIHRoaXMuc2V0UGFuZWxPcGVuKG1lc3NhZ2UudGFiLmlkLCB0cnVlKTtcbiAgICAgICAgICB3aWxsT3BlbiA9IHRydWU7IC8vIEhBQ0s6IHNldFBhbmVsT3BlbiBpcyBhc3luYywgYnV0IHdlIHdhbnQgdG8gc2VuZCB0aGUgc2hvd1BhbmVsIHJpZ2h0IG5vd1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUGFuZWxPcGVuKG1lc3NhZ2UudGFiLmlkKSB8fCB3aWxsT3Blbikge1xuICAgICAgICAgIHRoaXMuc2hvd1BhbmVsKGZhbHNlLCBtZXNzYWdlLnRhYi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2N1bWVudHNQb3J0LnNlbmRUb09uZShtZXNzYWdlLnRhYi5pZCwge1xuICAgICAgICAgIHRvcGljOiB0aGlzLmV4dGVuc2lvbi5icm93c2VyQ2FwdHVyZS5jYXB0dXJpbmcgPyAnZGlzYWJsZVdpZGdldCcgOiAnZW5hYmxlV2lkZ2V0JyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3BlcnNpc3RQYW5lbFN0YXRlJykge1xuICAgICAgLy8gaWdub3JlIHBlcnNpc3QgZnJvbSBpbmFjdGl2ZSB0YWJzLCBzaW5jZSB0aGV5IGNvdWxkIGJlIGluIGFuIG91dGRhdGVkIHN0YXRlICgjNTI0KVxuICAgICAgLy8gTm90ZTogdGhlIHBlcnNpc3QgaXMgbm90IGlnbm9yZWQgaWYgdGhlIGFjdGl2ZSB0YWIgaXMgXCJuZXdcIiwgc28gdG8gaGFuZGxlIG1lc3NhZ2VzIHNlbnQgb24gXCJvcGVuIGluIGEgbmV3IHRhYlwiIGxpbmtzICgjNTcwKVxuICAgICAgY29uc3QgYWN0aXZlVGFiVGltZSA9IERhdGUubm93KCkgLSB0aGlzLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYlN0YXJ0VGltZTtcbiAgICAgIGlmICh0aGlzLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYklkID09PSBtZXNzYWdlLnRhYi5pZCB8fCBhY3RpdmVUYWJUaW1lIDw9IDUwMCB8fCBtZXNzYWdlLnRhYi5pbmNsdWRlSW52YWxpZFRhYnMpIHtcbiAgICAgICAgdGhpcy5vd25Db250ZXh0KCkuZGlzcGF0Y2goJ3NldFBhbmVsJywgbWVzc2FnZS5kYXRhLCBbbWVzc2FnZS50YWIuaWRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdleHRlbmRQZXJzaXN0ZWRQYW5lbFN0YXRlJykge1xuICAgICAgLy8gaWdub3JlIHBlcnNpc3QgZnJvbSBpbmFjdGl2ZSB0YWJzLCBzaW5jZSB0aGV5IGNvdWxkIGJlIGluIGFuIG91dGRhdGVkIHN0YXRlICgjNTI0KVxuICAgICAgLy8gTm90ZTogdGhlIHBlcnNpc3QgaXMgbm90IGlnbm9yZWQgaWYgdGhlIGFjdGl2ZSB0YWIgaXMgXCJuZXdcIiwgc28gdG8gaGFuZGxlIG1lc3NhZ2VzIHNlbnQgb24gXCJvcGVuIGluIGEgbmV3IHRhYlwiIGxpbmtzICgjNTcwKVxuICAgICAgY29uc3QgYWN0aXZlVGFiVGltZSA9IERhdGUubm93KCkgLSB0aGlzLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYlN0YXJ0VGltZTtcbiAgICAgIGlmICh0aGlzLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYklkID09PSBtZXNzYWdlLnRhYi5pZCB8fCBhY3RpdmVUYWJUaW1lIDw9IDUwMCB8fCBtZXNzYWdlLnRhYi5pbmNsdWRlSW52YWxpZFRhYnMpIHtcbiAgICAgICAgdGhpcy5leHRlbmRQYW5lbFN0YXRlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRm9yQmFja2dyb3VuZChvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICB1cGRhdGVGb3JDb250ZW50KG9sZFN0YXRlLCBzdGF0ZSwgdGFiSWQpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICB1cGRhdGVGb3JQYW5lbChvbGRTdGF0ZSwgc3RhdGUsIHRhYklkKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgX29uQnJvd3NlckFjdGlvbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIGNvbnNvbGUuaW5mbygnQlJPV1NFUiBBQ1RJT04gTUVTU0FHRScsIG1lc3NhZ2UpO1xuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnc2hvd1BhbmVsJykge1xuICAgICAgdGhpcy5zaG93UGFuZWwobWVzc2FnZS5kYXRhLmV4cGxpY2l0LCBtZXNzYWdlLnRhYklkLCBtZXNzYWdlLmRhdGEuY2FwdHVyaW5nKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdoaWRlUGFuZWwnKSB7XG4gICAgICB0aGlzLmhpZGVQYW5lbChtZXNzYWdlLmRhdGEuZXhwbGljaXQsIG1lc3NhZ2UudGFiSWQpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3JlbG9hZEFsbFRhYnMnKSB7XG4gICAgICB0aGlzLnJlbG9hZEFsbFRhYnMoKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBtb3ZlIHRvIENocm9tZVBhbmVsQ29udHJvbGxlclxuICByZWxvYWRBbGxUYWJzKCkge1xuICAgIGJyb3dzZXIudGFicy5xdWVyeSh7fSwgKHRhYnMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgLy8gTm90ZTogZG8gbm90IHJlbG9hZCBjaHJvbWU6Ly9leHRlbnNpb24gcGFnZSBzaW5jZSBzZWVtcyB0byBjYXVzZSBpbmZpbml0ZSByZWxvYWRpbmdcbiAgICAgICAgaWYgKCF0YWIudXJsIHx8IChcbiAgICAgICAgICB0YWIudXJsLmluZGV4T2YoJ2Nocm9tZTovL2V4dGVuc2lvbnMnKSA9PT0gLTEgJiZcbiAgICAgICAgICB0YWIudXJsLmluZGV4T2YoJ2h0dHBzOi8vc3RhcnQuaW9yYWQuY29tJykgPT09IC0xXG4gICAgICAgICkpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuQlJPV1NFUiA9PT0gJ2VkZ2UnKSB7XG4gICAgICAgICAgICAvLyByZWxvYWQgaXNuJ3QgeWV0IHN1cHBvcnRlZCBpbiBlZGdlXG4gICAgICAgICAgICBicm93c2VyLnRhYnMudXBkYXRlKHRhYi5pZCwgeyB1cmw6ICdhYm91dDpibGFuaycgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICBicm93c2VyLnRhYnMudXBkYXRlKHRhYi5pZCwgeyB1cmw6IHRhYi51cmwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJvd3Nlci50YWJzLnJlbG9hZCh0YWIuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vd25Db250ZXh0KCkuZGlzcGF0Y2goJ3RvZ2dsZUlzRXh0ZW5zaW9uSnVzdEluc3RhbGxlZCcsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZpZXdMaXZlKHsgbGl2ZVVSTCwgZG9tYWluIH0sIHRhYklkKSB7XG4gICAgYnJvd3Nlci5jb29raWVzLmdldEFsbCh7IGRvbWFpbiB9LCByZXN1bHRzID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkQ29va2llcyA9IHJlc3VsdHMuZmlsdGVyKGNvb2tpZSA9PlxuICAgICAgICAhY29va2llLmRvbWFpbi5zdGFydHNXaXRoKCcuJykgJiZcbiAgICAgICAgY29va2llLnBhdGggPT09ICcvJyAmJlxuICAgICAgICBjb29raWUuZG9tYWluICE9PSBkb21haW4gJiZcbiAgICAgICAgY29va2llLmRvbWFpbiAhPT0gYHd3dy4ke2RvbWFpbn1gXG4gICAgICApO1xuICAgICAgLy8gdHJ5IGZpcnN0IHdpdGggdGhlIGxvbmdlc3Qgbm9uLXNlc3Npb24gY29va2llXG4gICAgICBsZXQgc3ViRG9tYWluQ29va2llID0gdmFsaWRDb29raWVzXG4gICAgICAgIC5maWx0ZXIoY29va2llID0+IGNvb2tpZS5leHBpcmF0aW9uRGF0ZSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+XG4gICAgICAgICAgYi5leHBpcmF0aW9uRGF0ZSAtIGEuZXhwaXJhdGlvbkRhdGUgLy8gbG9uZ2VzdCBleHBpcmF0aW9uXG4gICAgICAgIClbMF07XG4gICAgICBpZiAoIXN1YkRvbWFpbkNvb2tpZSkge1xuICAgICAgICAvLyBhcyBsYXN0IHJlc29ydCwganVzdCBwaWNrIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgc3ViRG9tYWluQ29va2llID0gdmFsaWRDb29raWVzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ViRG9tYWluQ29va2llKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgbGl2ZVVSTCB3aXRoIHN1YkRvbWFpbkNvb2tpZS5kb21haW5cbiAgICAgICAgY29uc3QgcGFyc2VkTGl2ZVVSTCA9IG5ldyBVUkwobGl2ZVVSTCk7XG4gICAgICAgIHBhcnNlZExpdmVVUkwuaG9zdG5hbWUgPSBzdWJEb21haW5Db29raWUuZG9tYWluO1xuICAgICAgICBsaXZlVVJMID0gcGFyc2VkTGl2ZVVSTC5ocmVmO1xuICAgICAgICBicm93c2VyLnRhYnMudXBkYXRlKHRhYklkLCB7IHVybDogbGl2ZVVSTCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzayB0aGUgc3ViZG9tYWluIHRvIHRoZSB1c2VyXG4gICAgICAgIGJyb3dzZXIudGFicy51cGRhdGUodGFiSWQsIHtcbiAgICAgICAgICB1cmw6ICdodHRwczovL3N0YXJ0LmlvcmFkLmNvbS92aWV3bGl2ZT9kZWZhdWx0PXRydWUnICtcbiAgICAgICAgICAgIGAmbGl2ZVVSTD0ke2VuY29kZVVSSUNvbXBvbmVudChsaXZlVVJMKX1gICtcbiAgICAgICAgICAgIGAmZG9tYWluPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGRvbWFpbil9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1vbml0b3JQYW5lbFN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBjaGVja1RhYiA9ICh0YWJJZCkgPT4ge1xuICAgICAgaWYgKHRhYklkID09PSBudWxsKSByZXR1cm47XG4gICAgICB0aGlzLnRhYnNDb250cm9sbGVyLmdldFRhYih0YWJJZCkudGhlbih0YWIgPT4ge1xuICAgICAgICBpZiAoIXRhYikgcmV0dXJuO1xuICAgICAgICB0aGlzLm93bkNvbnRleHQoKS5kaXNwYXRjaCgndG9nZ2xlSXNQYW5lbFN1cHBvcnRlZCcsIHRoaXMuaXNQYW5lbFN1cHBvcnRlZE9uVGFiKHRhYikpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMudGFic0NvbnRyb2xsZXIub24oJ2FjdGl2ZVRhYkNoYW5nZWQnLCAoeyB0YWJJZCB9KSA9PiBjaGVja1RhYih0YWJJZCkpO1xuICAgIHRoaXMudGFic0NvbnRyb2xsZXIub24oJ3RhYlVwZGF0ZWQnLCAoeyB0YWJJZCB9KSA9PiB7XG4gICAgICBpZiAodGFiSWQgPT09IHRoaXMudGFic0NvbnRyb2xsZXIuYWN0aXZlVGFiSWQpIHtcbiAgICAgICAgLy8gY2hlY2sgYWN0aXZlIHRhYiBvbiB1cmwgY2hhbmdlXG4gICAgICAgIGNoZWNrVGFiKHRhYklkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjaGVja1RhYih0aGlzLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYklkKTtcbiAgfVxuXG4gIGlzUGFuZWxTdXBwb3J0ZWRPblRhYih0YWIpIHtcbiAgICAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzaG93UGFuZWwoZXhwbGljaXQgPSBmYWxzZSwgdGFiSWQgPSBudWxsLCBjYXB0dXJpbmcgPSBmYWxzZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcInNob3dQYW5lbFwiLCBleHBsaWNpdCwgdGFiSWQsIGNhcHR1cmluZyk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgIHRvcGljOiAnc2hvd1BhbmVsJyxcbiAgICAgIGRhdGE6IHsgZXhwbGljaXQsIGNhcHR1cmluZyB9LFxuICAgIH07XG5cbiAgICBpZiAodGFiSWQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0UGFuZWxPcGVuKHRhYklkLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9jdW1lbnRzUG9ydC5zZW5kVG9PbmUodGFiSWQsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbGwgb3BlblxuICAgICAgdGhpcy50YWJzQ29udHJvbGxlci5nZXRBbGxUYWJzKCkudGhlbigoY3VycmVudFRhYnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VGFiIG9mIGN1cnJlbnRUYWJzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQYW5lbE9wZW4oY3VycmVudFRhYi5pZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvY3VtZW50c1BvcnQuc2VuZChtZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhpZGVQYW5lbChleHBsaWNpdCA9IGZhbHNlLCB0YWJJZCA9IG51bGwpIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyB0b3BpYzogJ2hpZGVQYW5lbCcsIGRhdGE6IHsgZXhwbGljaXQgfSB9O1xuXG4gICAgaWYgKHRhYklkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldFBhbmVsT3Blbih0YWJJZCwgZmFsc2UpO1xuICAgICAgdGhpcy5kb2N1bWVudHNQb3J0LnNlbmRUb09uZSh0YWJJZCwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFsbCBjbG9zZWRcbiAgICAgIHRoaXMudGFic0NvbnRyb2xsZXIuZ2V0QWxsVGFicygpLnRoZW4oKGN1cnJlbnRUYWJzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFRhYiBvZiBjdXJyZW50VGFicykge1xuICAgICAgICAgIHRoaXMuc2V0UGFuZWxPcGVuKGN1cnJlbnRUYWIuaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9jdW1lbnRzUG9ydC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kQ2FwdHVyZVN0YXRlKGNhcHR1cmVTdGF0ZSwgZXhjbHVkZWRUYWJzID0gW10pIHtcbiAgICB0aGlzLm93bkNvbnRleHQoKS5kaXNwYXRjaCgnZXh0ZW5kQ2FwdHVyZVN0YXRlJywgY2FwdHVyZVN0YXRlLCBleGNsdWRlZFRhYnMpO1xuICB9XG5cbiAgZXh0ZW5kUGFuZWxTdGF0ZShwYW5lbFN0YXRlLCBleGNsdWRlZFRhYnMgPSBbXSkge1xuICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdleHRlbmRQYW5lbFN0YXRlJywgcGFuZWxTdGF0ZSwgZXhjbHVkZWRUYWJzKTtcbiAgfVxuXG4gIHNldFBhbmVsT3Blbih0YWJJZCwgaXNPcGVuKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiU2V0IHBhbmVsIG9wZW5cIiwgdGFiSWQsIGlzT3Blbik7XG4gICAgdGhpcy5vd25Db250ZXh0KCkuZGlzcGF0Y2goJ3NldFBhbmVsT3BlbicsIHRhYklkLCBpc09wZW4pO1xuICB9XG5cbiAgaXNQYW5lbE9wZW4odGFiSWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm93bkNvbnRleHQoKS5zdGF0ZS5pc1BhbmVsT3Blblt0YWJJZF0pO1xuICB9XG5cbiAgc2hvdWxkUGFuZWxPcGVuT25OZXdUYWIodGFiKSB7XG4gICAgY29uc3QgY3VycmVudFR1dG9yaWFsID0gZ2V0KHRoaXMub3duQ29udGV4dCgpLnN0YXRlLCAncGFuZWwubGVhcm4uY3VycmVudFR1dG9yaWFsJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUdXRvcmlhbCAmJlxuICAgICAgY3VycmVudFR1dG9yaWFsLnN0YXJ0ZWQgJiZcbiAgICAgIHR1dG9yaWFsTWF0Y2hVcmwoY3VycmVudFR1dG9yaWFsLnR1dG9yaWFsRGF0YSwgdGFiLnVybCk7XG4gIH1cbiAgdXBkYXRlVGFic0NvdW50KCkge1xuICAgIGlmICghdGhpcy50YWJzQ29udHJvbGxlci5nZXRUYWJzQ291bnQpIHJldHVybjtcbiAgICB0aGlzLnRhYnNDb250cm9sbGVyLmdldFRhYnNDb3VudCgpXG4gICAgLnRoZW4oKHRhYnNDb3VudCkgPT4ge1xuICAgICAgdGhpcy5vd25Db250ZXh0KClcbiAgICAgICAgLmRpc3BhdGNoKCdzZXRUYWJzQ291bnQnLCB0YWJzQ291bnQpO1xuICAgIH0pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvYmFja2dyb3VuZC9QYW5lbENvbnRyb2xsZXIuanMiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGluaXRpYWxTdGF0ZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgc2V0U3RhdGUobmV3U3RhdGUsIC4uLmFyZ3MpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV3U3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIG5ld1N0YXRlKHRoaXMuc3RhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2VkJywgdGhpcy5zdGF0ZSwgLi4uYXJncyk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vU3RhdGVNYW5hZ2VyLmpzIiwiZXhwb3J0IGRlZmF1bHQgKCkgPT4gYFxuPHN2Z1xuICB3aWR0aD0nNDZweCcgaGVpZ2h0PSc0NnB4JyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgdmlld0JveD1cIjAgMCAxMDAgMTAwXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkXCIgY2xhc3M9XCJzcGlubmVyLXdoaXRlXCJcbj5cbiAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgZmlsbD1cIm5vbmVcIiBjbGFzcz1cImJrXCI+PC9yZWN0PlxuICA8Y2lyY2xlXG4gICAgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiNDVcIlxuICAgIHN0cm9rZS1kYXNoYXJyYXk9XCIxODMuNzgzMTcwMjM1MDAyOSA5OC45NjAxNjg1ODgwNzg0OVwiXG4gICAgc3Ryb2tlPVwiI2ZmZmZmZlwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMTBcIlxuICA+PC9jaXJjbGU+XG48L3N2Zz5cbmA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvc3Bpbm5lci13aGl0ZS5qcyIsImV4cG9ydCBkZWZhdWx0ICgpID0+IGBcbjxzdmcgY2xhc3M9XCJ3aWRnZXQtaWNvblwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE5LjQ4NVwiIGhlaWdodD1cIjI4LjgzXCIgdmlld0JveD1cIjAgMCAxOS40ODUgMjguODNcIj48cGF0aCBmaWxsPVwiI0ZGRlwiIGQ9XCJNLjAyNSAwTDAgMjguODNsOC4yNy03LjU3NCAxMS4yMTUuMDE2elwiLz48L3N2Zz5cbmA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvd2lkZ2V0LWljb24uanMiLCIvLyBOT1RFOiBvcmRlcmluZyBtYXR0ZXJzIGluIHRoaXMgYXJyYXksIHBsYWNlIGZpcnN0IHRoZSBtb3N0IHJlcHJlc2VudGF0aXZlcyBwcm9wZXJ0aWVzXG5jb25zdCBBQ1RJVkVfTElOS19QUk9QX05BTUVTID0gW1xuICAnYmFja2dyb3VuZENvbG9yJyxcbiAgJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJyxcbiAgJ2NvbG9yJ1xuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3RpdmVBbmNob3IocGFyZW50RWwpIHtcbiAgY29uc3QgYW5jaG9yRWxzID0gQXJyYXkuZnJvbShwYXJlbnRFbC5xdWVyeVNlbGVjdG9yQWxsKCdhJykpO1xuICBpZiAoYW5jaG9yRWxzLmxlbmd0aCA8PSAyKSB7XG4gICAgLy9jb25zb2xlLmxvZygndG9vIGZldyBlbGVtZW50cycsIGFuY2hvckVscyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBncm91cHMgPSB7fTtcblxuICAvLyB0cmFjayB3aGljaCBzdHlsZSBwcm9wcyBhcmUgdXNlZFxuICBhbmNob3JFbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgY29uc3QgZWxTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgQUNUSVZFX0xJTktfUFJPUF9OQU1FUy5mb3JFYWNoKHByb3BOYW1lID0+IHtcbiAgICAgIGNvbnN0IGVsUHJvcCA9IGVsU3R5bGVzW3Byb3BOYW1lXTtcblxuICAgICAgZ3JvdXBzW3Byb3BOYW1lXSA9IGdyb3Vwc1twcm9wTmFtZV0gfHwge307XG4gICAgICBncm91cHNbcHJvcE5hbWVdW2VsUHJvcF0gPSBncm91cHNbcHJvcE5hbWVdW2VsUHJvcF0gfHwgW107XG4gICAgICBncm91cHNbcHJvcE5hbWVdW2VsUHJvcF0ucHVzaChlbCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGZpbmQgYSBwcm9wIG9ubHkgdXNlZCBieSBvbmUgaXRlbSAod2hpbGUgb3RoZXJzIGFyZSBhbGwgdXNlZCBieSBtb3JlIHRoYW4gb25lKSxcbiAgLy8gdGhhdCBpdGVtIHdpbGwgYmUgYWN0aXZlIG9uZVxuICBsZXQgYWN0aXZlRWwgPSBudWxsO1xuICBBQ1RJVkVfTElOS19QUk9QX05BTUVTLmZpbmQocHJvcE5hbWUgPT4ge1xuICAgIGlmICghZ3JvdXBzW3Byb3BOYW1lXSkgcmV0dXJuIHRydWU7IC8vIHN0b3BcbiAgICBjb25zdCBlbFByb3BzID0gT2JqZWN0LmtleXMoZ3JvdXBzW3Byb3BOYW1lXSk7XG4gICAgZWxQcm9wcy5maW5kKGVsUHJvcCA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGdyb3Vwc1twcm9wTmFtZV1bZWxQcm9wXS5sZW5ndGggPT09IDEgJiYgLy8gb25seSB1c2VkIGJ5IG9uZSBpdGVtXG4gICAgICAgICFlbFByb3BzLmZpbmQob3RoZXJQcm9wID0+IG90aGVyUHJvcCAhPT0gZWxQcm9wICYmIGdyb3Vwc1twcm9wTmFtZV1bb3RoZXJQcm9wXS5sZW5ndGggPCAyKSAvLyB3aGlsZSBvdGhlcnMgYXJlIGFsbCB1c2VkIGJ5IG1vcmUgdGhhbiBvbmVcbiAgICAgICkge1xuICAgICAgICAvLyBhY3RpdmUgZWwgZm91bmRcbiAgICAgICAgYWN0aXZlRWwgPSBncm91cHNbcHJvcE5hbWVdW2VsUHJvcF1bMF07XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBzdG9wXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFjdGl2ZUVsKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcFxuICB9KTtcbiAgcmV0dXJuIGFjdGl2ZUVsO1xufVxuXG5mdW5jdGlvbiBmaW5kTmF2RWxzKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cIm5hdmlnYXRpb25cIl0sIG5hdiwgI25hdiwgLm5hdicpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROYXZBY3RpdmVBbmNob3IoKSB7XG4gIGNvbnN0IG5hdkVscyA9IGZpbmROYXZFbHMoKTtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIG5hdkVscy5maW5kKG5hdkVsID0+IHtcbiAgICBjb25zdCBhY3RpdmVFbCA9IGZpbmRBY3RpdmVBbmNob3IobmF2RWwpO1xuICAgIGlmIChhY3RpdmVFbCkge1xuICAgICAgcmVzdWx0ID0gYWN0aXZlRWw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB1c2VkIG9uIHBsYXliYWNrXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5hdkVsKGVsKSB7XG4gIGNvbnN0IG5hdkVscyA9IGZpbmROYXZFbHMoKTtcblxuICBsZXQgY3VycmVudEVsID0gZWwucGFyZW50Tm9kZTtcbiAgd2hpbGUgKGN1cnJlbnRFbCkge1xuICAgIGlmIChuYXZFbHMuaW5kZXhPZihjdXJyZW50RWwpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRFbDtcbiAgICB9XG4gICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9hY3RpdmVOYXYuanMiLCIvLyBVc2VmdWwgaW4gY2FzZSB0aGUgYXBwZW5kIG11c3QgYmUgZG9uZSBhcyBzb29uIGFzIHBvc3NpYmxlIG9uIHBhZ2UgbG9hZFxuLy8gYW5kIGRvY3VtZW50LmJvZHkgbWlnaHQgc3RpbGwgYmUgdW5kZWZpbmVkXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBlbmRPbkJvZHlMYXRlcihlbCwgY2FsbGJhY2spIHtcbiAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgLy8gdHJ5IGxhdGVyXG4gICAgc2V0VGltZW91dChhcHBlbmRPbkJvZHlMYXRlci5iaW5kKG51bGwsIGVsLCBjYWxsYmFjayksIDUwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZWwpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvYXBwZW5kT25Cb2R5TGF0ZXIuanMiLCIvLyBOb3RlOiBpbiBuZXcgdmVyc2lvbnMsIHRoZSBtZXNzZW5nZXIgaXMgbGF6eSBjcmVhdGVkIG9ubHkgYWZ0ZXIgdGhlIGxhdW5jaCBidXR0b24gaXMgY2xpY2tlZFxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyY29tTWVzc2VuZ2VyKCkge1xuICBjb25zdCBtZXNzZW5nZXJJZnJhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50ZXJjb20tbWVzc2VuZ2VyLWZyYW1lIGlmcmFtZScpO1xuICBjb25zdCBtZXNzZW5nZXJEb2N1bWVudCA9IG1lc3NlbmdlcklmcmFtZSA/IG1lc3NlbmdlcklmcmFtZS5jb250ZW50RG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgcmV0dXJuIG1lc3NlbmdlckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRlcmNvbS1tZXNzZW5nZXIsICNpbnRlcmNvbS1tZXNzZW5nZXInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyY29tTGF1bmNoZXIoKSB7XG4gIGNvbnN0IGxhdW5jaGVySWZyYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludGVyY29tLWxhdW5jaGVyLWZyYW1lJyk7XG4gIGNvbnN0IGxhdW5jaGVyRG9jdW1lbnQgPSBsYXVuY2hlcklmcmFtZSA/IGxhdW5jaGVySWZyYW1lLmNvbnRlbnREb2N1bWVudCA6IGRvY3VtZW50O1xuICByZXR1cm4gbGF1bmNoZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50ZXJjb20tbGF1bmNoZXIsICNpbnRlcmNvbS1sYXVuY2hlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJjb21QZW5kaW5nTWVzc2FnZXMoKSB7XG4gIGNvbnN0IGxhdW5jaGVyQmFkZ2VJZnJhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50ZXJjb20tbGF1bmNoZXItYmFkZ2UtZnJhbWUnKTtcbiAgY29uc3QgbGF1bmNoZXJCYWRnZURvY3VtZW50ID0gbGF1bmNoZXJCYWRnZUlmcmFtZSA/IGxhdW5jaGVyQmFkZ2VJZnJhbWUuY29udGVudERvY3VtZW50IDogZG9jdW1lbnQ7XG4gIGNvbnN0IGJhZGdlRWwgPSBsYXVuY2hlckJhZGdlRG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludGVyY29tLWxhdW5jaGVyLWJhZGdlJyk7XG4gIHJldHVybiBiYWRnZUVsID8gcGFyc2VJbnQoYmFkZ2VFbC5pbm5lclRleHQsIDEwKSA6IDA7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9pbnRlcmNvbS5qcyIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNQYWdlTG9nZ2VkSW4oKSB7XG4gIGNvbnN0IHplbmRlc2tMb2dnZWRJbiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZXNwYWNlKCd6ZW5kZXNrLWxvZ2dlZEluJykpO1xuICBpZiAoemVuZGVza0xvZ2dlZEluKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBjaGVjayBsb2dvdXQgY2FzZSBpbnN0ZWFkIG9mIGxvZ2luLCBzaW5jZSBpcyBtb3JlIGxpa2VseSBmb3IgbG9naW4gbGlua3MvYnV0dG9ucyB0byBiZVxuICAvLyBpbW1lZGlhdGVsbHkgdmlzaWJsZSBpbiB0aGUgcGFnZSwgd2hpbGUgaW4gY2FzZSBvZiBsb2dpbiB0aGUgbG9nb3V0IGJ1dHRvblxuICAvLyBtaWdodCBiZSBpbnNpZGUgZHJvcGRvd25zIHdob3NlIGNvbnRlbnQgaXMgbG9hZGVkIGxhemlseSBvbiBjbGljayAoZS5nLiBsaW5rZWRpbilcbiAgY29uc3QgaXNQYWdlTG9nZ2VkT3V0ID0gQm9vbGVhbihBcnJheS5mcm9tKGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnYSwgYnV0dG9uJykpLmZpbmQoZWwgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAoZWwuaW5uZXJUZXh0ICYmIGVsLmlubmVyVGV4dC5tYXRjaCgvc2lnbiBpbnxzaWduaW58bG9nIGlufGxvZ2lufHNpZ24gdXB8c2lnbnVwL2kpICE9PSBudWxsKSB8fFxuICAgICAgKGVsLmNsYXNzTmFtZSAmJiBlbC5jbGFzc05hbWUubWF0Y2goL3NpZ25pbnxsb2dpbnxzaWdudXAvaSkgIT09IG51bGwpXG4gICAgKSAmJiAoXG4gICAgICBlbC50YWdOYW1lICE9PSAnQScgfHxcbiAgICAgIChlbC5ocmVmICYmIGVsLmhyZWYubWF0Y2goL3NpZ25pbnxsb2dpbi9pKSAhPT0gbnVsbCkgfHxcbiAgICAgIChlbC5ocmVmICYmIGVsLmhyZWYubWF0Y2goL3NpZ251cC9pKSAhPT0gbnVsbClcbiAgICApICYmIChcbiAgICAgICghZWwuaW5uZXJUZXh0IHx8IGVsLmlubmVyVGV4dC5tYXRjaCgvc2lnbiBvdXR8c2lnbm91dHxsb2cgb3V0fGxvZ291dC9pKSA9PT0gbnVsbCkgJiZcbiAgICAgICghZWwuaHJlZiB8fCBlbC5ocmVmLm1hdGNoKC9zaWdub3V0fGxvZ291dC9pKSA9PT0gbnVsbCkgJiZcbiAgICAgICghZWwuY2xhc3NOYW1lIHx8IGVsLmNsYXNzTmFtZS5tYXRjaCgvc2lnbm91dHxsb2dvdXQvaSkgPT09IG51bGwpXG4gICAgKSAmJiAoXG4gICAgICAvLyBpcyB2aXNpYmxlIChOT1RFOiB2aXNpYmlsaXR5OmhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgdHJlYXRlZCBhcyB2aXNpYmxlKSwgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzQ1NjQ2OVxuICAgICAgISEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKVxuICAgICk7XG4gIH0pKTtcbiAgcmV0dXJuICFpc1BhZ2VMb2dnZWRPdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWdlTG9nZ2VkSW5UeXBlKCkge1xuICBjb25zdCBpc1plbmRlc2sgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJy56ZW5kZXNrLmNvbScpICE9PSAtMTtcbiAgaWYgKGlzWmVuZGVzaykge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJhY2staWQtbmV3LW9yZycpIHx8XG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3pkLWhjLW5hdmJhciBhJykpXG4gICAgICAgIC5maW5kKGVsID0+IC9HdWlkZSBhZG1pbi8udGVzdChlbC5pbm5lclRleHQpKSB8fFxuICAgICAgL1xcL2tub3dsZWRnZVxcL3xcXC9hZG1pblxcLy8udGVzdChkb2N1bWVudC5sb2NhdGlvbi5ocmVmKVxuICAgID8gJ2FkbWluJyA6ICdhZ2VudCc7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvaXNQYWdlTG9nZ2VkSW4uanMiLCJpbXBvcnQgc2FtcGxlIGZyb20gJ2xvZGFzaC9zYW1wbGUnO1xuaW1wb3J0IHRpbWVzIGZyb20gJ2xvZGFzaC90aW1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGggPSAyNSkge1xuICBjb25zdCBjaGFycyA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG4gIHJldHVybiB0aW1lcyhsZW5ndGgsICgpID0+IHtcbiAgICByZXR1cm4gc2FtcGxlKGNoYXJzKTtcbiAgfSkuam9pbignJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9yYW5kb21TdHJpbmcuanMiLCJpbXBvcnQgc2Nyb2xsSW50b1ZpZXcgZnJvbSAnc2Nyb2xsLWludG8tdmlldyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudEhlaWdodCB9IGZyb20gJy4vZG9jdW1lbnRTaXplJztcbmltcG9ydCBjdXJyeSBmcm9tICdsb2Rhc2gvY3VycnknO1xuXG5jb25zdCBnZXRFbGVtZW50U2Nyb2xsID0gKGVsZW1lbnQpID0+IHtcbiAgaWYgKGVsZW1lbnQgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlbGVtZW50LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogZWxlbWVudC5wYWdlWU9mZnNldFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGdldEVsZW1lbnRQb3NpdGlvbiA9IChlbCkgPT4ge1xuICByZXR1cm4gZWwgIT09IHdpbmRvdyA/XG4gICAgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgIHtcbiAgICAgIHdpZHRoOiBlbC5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiBlbC5pbm5lckhlaWdodCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogZWwuaW5uZXJIZWlnaHQsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IGVsLmlubmVyV2lkdGgsXG4gICAgfTtcbn07XG5cbi8vIG1hcmdpbnMgYmVldHdlZW4gdGFyZ2V0IGFuZCBwYXJlbnQgc2lkZXNcbmNvbnN0IGdldFJlbGF0aXZlTWFyZ2lucyA9ICh0YXJnZXQsIHBhcmVudCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKHRhcmdldCk7XG4gICAgY29uc3QgcGFyZW50UG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24ocGFyZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRhcmdldFBvc2l0aW9uLnRvcCAtIHBhcmVudFBvc2l0aW9uLnRvcCxcbiAgICAgICAgbGVmdDogdGFyZ2V0UG9zaXRpb24ubGVmdCAtIHBhcmVudFBvc2l0aW9uLmxlZnQsXG4gICAgICAgIGJvdHRvbTogcGFyZW50UG9zaXRpb24uYm90dG9tIC0gdGFyZ2V0UG9zaXRpb24uYm90dG9tLFxuICAgICAgICByaWdodDogcGFyZW50UG9zaXRpb24ucmlnaHQgLSB0YXJnZXRQb3NpdGlvbi5yaWdodCxcbiAgICB9O1xufVxuXG5jb25zdCBzY3JvbGxBdmFpbGFibGUgPSAoZWwpID0+IHtcbiAgaWYgKGVsID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZWwuaW5uZXJXaWR0aCArIGVsLnBhZ2VYT2Zmc2V0IDwgZWwuZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCxcbiAgICAgIHk6IGVsLmlubmVySGVpZ2h0ICsgZWwucGFnZVlPZmZzZXQgPCBnZXREb2N1bWVudEhlaWdodCgpLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGVsLmNsaWVudFdpZHRoIDwgZWwuc2Nyb2xsV2lkdGgsXG4gICAgICB5OiBlbC5jbGllbnRIZWlnaHQgPCBlbC5zY3JvbGxIZWlnaHRcbiAgICB9O1xuICB9XG59O1xuXG4vLyBtYXJnaW4gaXMgYW4gb2JqZWN0IG9mIG1hcmdpbnMgYmV0d2VlbiB0YXJnZXQgYW5kIHZpZXdwb3J0XG4vLyB3ZSBzYXkgaXQncyBpbiB2aWV3cG9ydCBpZiBhbGwgbWFyZ2lucyBhcmUgYmlnZ2VyIHRoYW4gbWluaW11bVxuLy8gb3Igd2UgY291bGRuJ3Qgc2Nyb2xsIGluIGEgZ2l2ZW4gYXhpc1xuY29uc3QgdGFyZ2V0SW5WaWV3cG9ydCA9IChtaW5NYXJnaW4sIHRhcmdldCwgcGFyZW50KSA9PiB7XG4gIGNvbnN0IG1hcmdpbiA9IGdldFJlbGF0aXZlTWFyZ2lucyh0YXJnZXQsIHBhcmVudCk7XG4gIGNvbnN0IHNjcm9sbGFibGVBeGlzZXMgPSBzY3JvbGxBdmFpbGFibGUocGFyZW50KTtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J11cbiAgICAuZmlsdGVyKChzaWRlLCBpKSA9PlxuICAgICAgbWFyZ2luW3NpZGVdIDwgbWluTWFyZ2luICYmXG4gICAgICBzY3JvbGxhYmxlQXhpc2VzW2kgLSAyIDwgMCA/ICd5JyA6ICd4J11cbiAgICApXG4gICAgLmxlbmd0aCA9PT0gMDtcbn07XG5cbmNvbnN0IG5lYXJlc3RBbGlnbiA9IGN1cnJ5KCh0YXJnZXQsIHBhcmVudCkgPT4ge1xuICBjb25zdCBtYXJnaW4gPSBnZXRSZWxhdGl2ZU1hcmdpbnModGFyZ2V0LCBwYXJlbnQpO1xuXG4gIGNvbnN0IHRvcCA9IG1hcmdpbi50b3AgPCBtYXJnaW4uYm90dG9tID8gMCA6IDE7XG4gIGNvbnN0IGxlZnQgPSBtYXJnaW4ubGVmdCA8IG1hcmdpbi5yaWdodCA/IDAgOiAxO1xuICByZXR1cm4geyB0b3AsIGxlZnQgfTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCAoZWwsIG1pbk1hcmdpbiA9IDAsIGF1dG9BbGlnbiA9IGZhbHNlLCBhbmltYXRpb25UaW1lID0gMzAwKSA9PiB7XG4gIGNvbnN0IGFsaWduID0gYXV0b0FsaWduID8gbmVhcmVzdEFsaWduKGVsKSA6IG51bGw7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB0aW1lOiBhbmltYXRpb25UaW1lLFxuICAgIGFsaWduLFxuICAgIHZhbGlkVGFyZ2V0OiAocGFyZW50KSA9PiAhdGFyZ2V0SW5WaWV3cG9ydChtaW5NYXJnaW4sIGVsLCBwYXJlbnQpLFxuICAgIGlzU2Nyb2xsYWJsZTogKHRhcmdldCwgZGVmYXVsdElzU2Nyb2xsYWJsZSkgPT4ge1xuICAgICAgLy8gQnkgZGVmYXVsdCBzY3JvbGwtaW50by12aWV3IHdpbGwgb25seSBhdHRlbXB0IHRvIHNjcm9sbCBlbGVtZW50cyB0aGF0IGhhdmUgb3ZlcmZsb3cgbm90IHNldCB0byBgXCJoaWRkZW5cImAgYW5kIHdobydzIHNjcm9sbCB3aWR0aC9oZWlnaHQgaXMgbGFyZ2VyIHRoYW4gdGhlaXIgY2xpZW50IGhlaWdodC5cbiAgICAgIC8vIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBjaGVjayBieSBwYXNzaW5nIGFuIGBpc1Njcm9sbGFibGVgIGZ1bmN0aW9uIHRvIHNldHRpbmdzOlxuICAgICAgcmV0dXJuIGRlZmF1bHRJc1Njcm9sbGFibGUodGFyZ2V0KSB8fFxuICAgICAgICAodGFyZ2V0LmNsYXNzTmFtZSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3Njcm9sbGFibGUnKSAhPT0gLTEpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2Nyb2xsZWRQYXJlbnRzID0gc2Nyb2xsSW50b1ZpZXcoZWwsIHBhcmFtcywgKCkgPT4gcmVzb2x2ZSh0cnVlKSk7XG4gICAgICBpZiAoc2Nyb2xsZWRQYXJlbnRzIDw9IDApIHJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvc2Nyb2xsRWxlbWVudEludG9WaWV3LmpzIiwiLy8gaHR0cDovL3d3dy50aGVjb2Rlc2hpcC5jb20vd2ViLWRldmVsb3BtZW50L2FsdGVybmF0aXZlLXRvLWphdmFzY3JpcHQtZXZpbC1zZXRpbnRlcnZhbC9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlU2V0SW50ZXJ2YWwoZnVuYywgd2FpdCwgdGltZXMpe1xuICAgIHZhciBpbnRlcnYgPSBmdW5jdGlvbih3LCB0KXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZih0eXBlb2YgdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0LS0gPiAwKXtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGludGVydiwgdyk7XG4gICAgICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KHdhaXQsIHRpbWVzKTtcblxuICAgIHNldFRpbWVvdXQoaW50ZXJ2LCB3YWl0KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy90aW1lcnMuanMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJ2Jhc2UvY29tbW9uL0NvbXBvbmVudCc7XG5pbXBvcnQgYXBwZW5kT25Cb2R5TGF0ZXIgZnJvbSAnLi4vY29tbW9uL3V0aWxzL2FwcGVuZE9uQm9keUxhdGVyJztcbmltcG9ydCByZWFjdFJlbmRlciBmcm9tICcuLi9jb21tb24vdXRpbHMvcmVhY3RSZW5kZXInO1xuaW1wb3J0IENhcHR1cmVTdGFydERpYWxvZyBmcm9tICcuL2NvbXBvbmVudHMvQ2FwdHVyZVN0YXJ0RGlhbG9nJztcbmltcG9ydCB7IGxpc3RlblRvUHJhY3RpY2VNZXNzYWdlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzL3ByYWN0aWNlUGxheWVyJztcbmltcG9ydCBmbG93UmlnaHQgZnJvbSAnbG9kYXNoL2Zsb3dSaWdodCc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBhc3NpZ25JbiBmcm9tICdsb2Rhc2gvYXNzaWduSW4nO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuaW1wb3J0IGFkZE5ld1N0eWxlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2FkZE5ld1N0eWxlJztcbmltcG9ydCBzcGlubmVyV2hpdGUgZnJvbSAnYmFzZS9jb21tb24vc3ZnSW5saW5lL3NwaW5uZXItd2hpdGUnO1xuaW1wb3J0IHdpZGdldEljb24gZnJvbSAnYmFzZS9jb21tb24vc3ZnSW5saW5lL3dpZGdldC1pY29uJztcbmltcG9ydCB6ZW5kZXNrV2lkZ2V0SWNvbiBmcm9tICdiYXNlL2NvbW1vbi9zdmdJbmxpbmUvemVuZGVzay13aWRnZXQtaWNvbic7XG5pbXBvcnQgemVuZGVzQ2xvc2VJY29uIGZyb20gJ2Jhc2UvY29tbW9uL3N2Z0lubGluZS96ZW5kZXNrLXdpZGdldC1jbG9zZS1pY29uJztcbmltcG9ydCBmZXRjaEVtYmVkVHV0b3JpYWxzIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2ZldGNoRW1iZWRUdXRvcmlhbHMnO1xuaW1wb3J0IGdldFF1ZXJ5TGl2ZUlkIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2dldFF1ZXJ5TGl2ZUlkJztcbmltcG9ydCB3YWl0Rm9yIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL3dhaXRGb3InO1xuaW1wb3J0IGFmdGVyIGZyb20gJ2xvZGFzaC9hZnRlcic7XG5pbXBvcnQgKiBhcyBmcmFtZU1lc3NhZ2VzIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9mcmFtZU1lc3NhZ2VzXCI7XG5pbXBvcnQgeyBhZGRXaW5kb3dMaXN0ZW5lciwgcmVtb3ZlV2luZG93TGlzdGVuZXIgfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy93aW5kb3dFdmVudHMnO1xuaW1wb3J0IHsgZ2V0SW50ZXJjb21MYXVuY2hlciB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2ludGVyY29tJztcbmltcG9ydCB7IHBhZ2Vib3VuZHMyc2NyZWVuLCBzY3JlZW5ib3VuZHMycGFnZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy9jb29yZGluYXRlcyc7XG5pbXBvcnQgeyBnZXRQYWdlTG9nZ2VkSW5UeXBlIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2lzUGFnZUxvZ2dlZEluXCI7XG5pbXBvcnQgeyByZWRpcmVjdElmTmVlZGVkIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL3BsYXllclwiO1xuaW1wb3J0IHsgbG9jYXRlRWxlbWVudCB9IGZyb20gXCIuL2VsZW1lbnRMb2NhdG9yXCI7XG5pbXBvcnQgeyBmaW5kTmF2QWN0aXZlQW5jaG9yIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2FjdGl2ZU5hdlwiO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5jb25zdCBaRU5ERVNLX1dJREdFVF9DT05UQUlORVIgPSAnaGVhZGVyJztcblxuZnVuY3Rpb24gaXNQb3B1cCgpIHtcbiAgcmV0dXJuICh3aW5kb3cub3BlbmVyICE9PSB3aW5kb3cgJiYgd2luZG93Lm1lbnViYXIgJiYgIXdpbmRvdy5tZW51YmFyLnZpc2libGUpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NYXRjaFVybCh1cmxhLCB1cmxiKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZSA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHBhcnNlZC5ob3N0bmFtZS5zcGxpdCgnLicpLnNsaWNlKC0yKS5qb2luKCcuJyk7XG4gIH07XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZSh1cmxhKSA9PT0gbm9ybWFsaXplKHVybGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5lbENvbnRyb2xsZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5wYW5lbEVsID0gbnVsbDtcbiAgICB0aGlzLnBhbmVsSGVpZ2h0ID0gJyc7XG4gICAgdGhpcy5wYW5lbEVsU3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFuZWxEaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFuZWxEcmFnZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmhyZWZIYXNUdXRvcmlhbHMgPSBmYWxzZTtcbiAgICB0aGlzLmN1c3RvbUNvbG9ycyA9IG51bGw7XG4gICAgdGhpcy51c2VyID0gbnVsbDtcblxuICAgIHRoaXMuaW50ZXJjb21JbnN0YWxsZWQgPSBmYWxzZTtcblxuICAgIHRoaXMub3ZlcmxheURpc21pc3NlZCA9IHRydWU7XG5cbiAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gdGhyb3R0bGUodGhpcy5jYWNoZUhlaWdodCwgMTAwMCk7XG4gICAgdGhpcy51cGRhdGVQYW5lbE1heEhlaWdodCA9IHRocm90dGxlKHRoaXMudXBkYXRlUGFuZWxNYXhIZWlnaHQsIDUwKTtcblxuICAgIHRoaXMuZHJhZ2dhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMucGFuZWxEcmFnSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBzdGFydCguLi5hcmdzKSB7XG4gICAgc3VwZXIuc3RhcnQoLi4uYXJncyk7XG5cbiAgICBjb25zdCBlbWJlZCA9IChwcm9jZXNzLmVudi5CUk9XU0VSID09PSAnZW1iZWQnKTtcbiAgICBpZiAoIXRoaXMuZXh0ZW5zaW9uLmlzVG9wRnJhbWUpIHJldHVybjsgLy8gVE9ETzogcmVtb3ZlICh0aGlzIGNvbXBvbmVudCBpcyBleGVjdXRlZCBvbmx5IGluIHRoZSBtYWluIGZyYW1lIGFueXdheSlcbiAgICBpZiAoIWVtYmVkICYmIGlzUG9wdXAoKSkge1xuICAgICAgLy8gb25seSBoaWRlIHBhbmVsL3dpZGdldCAocGFuZWwgSlMgaXMgbmVlZGVkIGZvciBwbGF5ZXIgdG8gd29yaylcbiAgICAgIC8qYWRkTmV3U3R5bGUoYFxuICAgICAgICAuJHtuYW1lc3BhY2UoJ3BhbmVsJyl9LCAuJHtuYW1lc3BhY2UoJ3dpZGdldCcpfSB7XG4gICAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgIGApOyovXG4gICAgfVxuXG4gICAgYWRkV2luZG93TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHRoaXMuY2FjaGVIZWlnaHQoKSk7XG5cbiAgICB0aGlzLnJldHJpZXZlSGVpZ2h0KCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnNldHVwQmFja2dyb3VuZCgpO1xuICAgICAgdGhpcy5zZXR1cFBhbmVsKCk7XG4gICAgICB0aGlzLnNldHVwUHJhY3RpY2VQbGF5ZXIoKTtcbiAgICAgIHRoaXMuc2V0dXBQYWdlKCk7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcmNvbSgpO1xuICAgICAgdGhpcy5tb25pdG9yWmVuZGVzaygpO1xuICAgICAgdGhpcy5yZWdpc3RlclRvQmFja2dyb3VuZCgpO1xuICAgICAgdGhpcy5saXN0ZW5PdmVybGF5KCk7XG4gICAgICB0aGlzLmNoZWNrTGVnYWN5UGFnZVN0YXR1cygpO1xuICAgICAgdGhpcy5jaGVja1BvcHVwUGFnZVN0YXR1cygpO1xuICAgIH0pO1xuICAgIGFkZFdpbmRvd0xpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVBhbmVsTWF4SGVpZ2h0KCk7XG4gICAgICB0aGlzLnNldENsb3NlRWxlbWVudENvb3JkaW5hdGVzKCk7XG4gICAgfSk7XG4gICAgLy9hZGRXaW5kb3dMaXN0ZW5lcigncmVzaXplJywgKCkgPT4gdGhpcy5jYWxjdWxhdGVQYW5lbFJlYWxCb3VuZHMoKSk7XG4gICAgLy9hZGRXaW5kb3dMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4gdGhpcy5jYWxjdWxhdGVQYW5lbFJlYWxCb3VuZHMoKSk7XG4gIH1cblxuICBzZXR1cEJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmJhY2tncm91bmRQb3J0O1xuICAgIHRoaXMuYmFja2dyb3VuZFBvcnQub24oJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZUJhY2tncm91bmRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc2V0dXBQYW5lbCgpIHtcbiAgICB0aGlzLnBhbmVsUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLnBhbmVsUG9ydDtcbiAgICB0aGlzLnBhbmVsUG9ydC5vbignbWVzc2FnZScsIHRoaXMuaGFuZGxlUGFuZWxNZXNzYWdlLmJpbmQodGhpcykpO1xuXG4gICAgbGV0IGN1cnJlbnRIcmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCB7IGhyZWYgfSA9IGRvY3VtZW50LmxvY2F0aW9uO1xuICAgICAgaWYgKGhyZWYgIT09IGN1cnJlbnRIcmVmKSB7XG4gICAgICAgIGN1cnJlbnRIcmVmID0gaHJlZjtcbiAgICAgICAgdGhpcy5vd25Db250ZXh0KCkuZGlzcGF0Y2goJ3NldExvY2F0aW9uSHJlZicsIGhyZWYsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH0sIDUwMCk7XG5cbiAgICBpZiAoZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUuZW5kc1dpdGgoJy56ZW5kZXNrLmNvbScpKSB7XG4gICAgICBsZXQgY3VycmVudFBhZ2VMb2dnZWRJblR5cGU7XG4gICAgICBjb25zdCBjaGVjayA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZUxvZ2dlZEluVHlwZSA9IGdldFBhZ2VMb2dnZWRJblR5cGUoKTtcbiAgICAgICAgaWYgKHBhZ2VMb2dnZWRJblR5cGUgIT09IGN1cnJlbnRQYWdlTG9nZ2VkSW5UeXBlKSB7XG4gICAgICAgICAgY3VycmVudFBhZ2VMb2dnZWRJblR5cGUgPSBwYWdlTG9nZ2VkSW5UeXBlO1xuICAgICAgICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdzZXRQYWdlTG9nZ2VkSW5UeXBlJywgcGFnZUxvZ2dlZEluVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZXRJbnRlcnZhbChjaGVjaywgMzAwMCk7XG4gICAgICBjaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwUHJhY3RpY2VQbGF5ZXIoKSB7XG4gICAgbGlzdGVuVG9QcmFjdGljZU1lc3NhZ2UodGhpcy5oYW5kbGVQcmFjdGljZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzZXR1cFBhZ2UoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAobWVzc2FnZS5mcm9tICE9PSAncGFnZScgfHwgbWVzc2FnZS50byAhPT0gbmFtZXNwYWNlKCkpIHJldHVybjtcbiAgICAgIHRoaXMuaGFuZGxlUGFnZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVQYWdlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgQkFDS0dST1VORF9UT1BJQ1MgPSBbXG4gICAgICAncmVsb2FkQWxsVGFicycsICd2aWV3TGl2ZSdcbiAgICBdO1xuXG4gICAgaWYgKEJBQ0tHUk9VTkRfVE9QSUNTLmluZGV4T2YobWVzc2FnZS50b3BpYykgPj0gMCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwR29vZ2xlVHJhbnNsYXRlKCkge1xuICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCd0b2dnbGVHb29nbGVUcmFuc2xhdGVJbnN0YWxsZWQnLCB0aGlzLmlzR29vZ2xlVHJhbnNsYXRlKCkpO1xuICB9XG5cbiAgaXNDb21iaW5lSW50ZXJjb20oKSB7XG4gICAgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNHb29nbGVUcmFuc2xhdGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9uaXRvckludGVyY29tKCkge1xuICAgIGlmICghRU1CRUQpIHJldHVybjtcblxuICAgIGNvbnN0IGNoZWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJjb21MYXVuY2hlckVsID0gZ2V0SW50ZXJjb21MYXVuY2hlcigpO1xuICAgICAgY29uc3QgaW50ZXJjb21JbnN0YWxsZWQgPSBpbnRlcmNvbUxhdW5jaGVyRWwgIT09IG51bGw7XG4gICAgICBpZiAoaW50ZXJjb21JbnN0YWxsZWQgIT09IHRoaXMuaW50ZXJjb21JbnN0YWxsZWQpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNvbUluc3RhbGxlZCA9IGludGVyY29tSW5zdGFsbGVkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ29tYmluZUludGVyY29tKCkpIHtcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lc3BhY2UoJ2NvbWJpbmUtaW50ZXJjb20nKSk7XG5cbiAgICAgICAgICB0aGlzLm93bkNvbnRleHQoKS5kaXNwYXRjaCgndG9nZ2xlSW50ZXJjb21JbnN0YWxsZWQnLCBpbnRlcmNvbUluc3RhbGxlZCk7XG5cbiAgICAgICAgICAvLyBUT0RPOiBkbyB0aGlzIG9ubHkgb25jZSFcbiAgICAgICAgICBpZiAod2luZG93LkludGVyY29tKSB7XG4gICAgICAgICAgICB3aW5kb3cuSW50ZXJjb20oJ29uU2hvdycsICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZXNwYWNlKCdpbnRlcmNvbS12aXNpYmxlJykpO1xuICAgICAgICAgICAgICB9LCAzMDApOyAvLyB3YWl0IGljb24gY2hhbmdlIG9mIGludGVyY29tIGJ1dHRvbiB0byBwcmV2ZW50IHdlaXJkIHZpc3VhbCBlZmZlY3RcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVDaGF0QnV0dG9uV2lkZ2V0TGFiZWwodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5JbnRlcmNvbSgnb25IaWRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShuYW1lc3BhY2UoJ2ludGVyY29tLXZpc2libGUnKSk7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZUNoYXRCdXR0b25XaWRnZXQoKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnRvZ2dsZUNoYXRCdXR0b25XaWRnZXRMYWJlbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnRlcmNvbUxhdW5jaGVyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2xpZW50WCA9PT0gMCAmJiBlLmNsaWVudFkgPT09IDApIHJldHVybjsgLy8gaWdub3JlIHByb2dyYW1tYXRpYyBjbGlja3NcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWVzcGFjZSgnaW50ZXJjb20tdmlzaWJsZScpKSkgeyAvLyBjbG9zZVxuICAgICAgICAgICAgICAvLyBhbHNvIGNsb3NlIGlvcmFkIHBhbmVsXG4gICAgICAgICAgICAgIGlmICh0aGlzLnBhbmVsRWwpIHRoaXMucGFuZWxFbC5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgnaGlkZScpKTsgLy8gcHJldmVudCB3ZWlyZCBlZmZlY3Qgd2hlcmUgcGFuZWwgaXMgdmlzaWJsZSBmb3IgZmV3IGh1bmRyZWQgbWlsbGlzZWNvbmRzIGJlZm9yZSBiZWluZyBjbG9zZWRcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKHtcbiAgICAgICAgICAgICAgICB0b3BpYzogJ2hpZGVQYW5lbCcsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBleHBsaWNpdDogdHJ1ZSwgdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgLy8gVE9ETzogZG8gdGhpcyBvbmx5IG9uY2UhXG4gICAgICAgICAgLy8gcmVtb3ZlIGZhZGUtaW4gYW5pbWF0aW9uIChodHRwczovL2dpdGh1Yi5jb20vaW9yYWQvSU9SQUQtZXh0ZW5zaW9uL2lzc3Vlcy80MDcjaXNzdWVjb21tZW50LTI2ODMwNzk4NilcbiAgICAgICAgICBhZGROZXdTdHlsZShgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG4gICAgICAgICAgICAjaW50ZXJjb20tY29udGFpbmVyIC5pbnRlcmNvbS1sYXVuY2hlci1mcmFtZSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHRtbCBib2R5ICNpbnRlcmNvbS1jb250YWluZXIgLmludGVyY29tLWFwcCAuaW50ZXJjb20tbWVzc2VuZ2VyLWZyYW1lIHtcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBkbyB0aGlzIG9ubHkgb25jZSFcbiAgICAgICAgICAvLyBqdXN0IG1vdmUgaW50ZXJjb20gYnV0dG9uIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgYWRkTmV3U3R5bGUoYEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuICAgICAgICAgICAgI2ludGVyY29tLWNvbnRhaW5lciAuaW50ZXJjb20tbGF1bmNoZXItZnJhbWUge1xuICAgICAgICAgICAgICByaWdodDogOTBweCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRJbnRlcnZhbChjaGVjaywgNTApO1xuICAgIGNoZWNrKCk7XG4gIH1cblxuICBpc1plbmRlc2soKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYyo9XCJ6ZW5kZXNrXCJdJykgfHxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS5lbmRzV2l0aChcIi56ZW5kZXNrLmNvbVwiKTtcbiAgfVxuXG4gIG1vbml0b3JaZW5kZXNrKCkge1xuICAgIGlmICghdGhpcy5pc1plbmRlc2soKSkgcmV0dXJuO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgnemVuZGVzay12aXNpYmxlJykpO1xuXG4gICAgLy8gYWRtaW4gc2VjdGlvbiB1c2VzIHJhbmRvbSBjbGFzc2VzLCB3ZSBjYW4ndCBqdXN0IHVzZSBhIHNlbGVjdG9yLFxuICAgIC8vIHRodXMgd2UgZmluZCB0aGUgZmlyc3QgZWxlbWVudCBoYXZpbmcgYW4gYWN0dWFsIGJhY2tncm91bmRcbiAgICBmdW5jdGlvbiBmaW5kWmVuZGVza0FjdGlvbkJ1dHRvbkNvbG9yKG5hdmJhckVsKSB7XG4gICAgICBjb25zdCBhbmNob3JCYWNrZ3JvdW5kQ29sb3JzID0gQXJyYXkuZnJvbShuYXZiYXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdsaSBhJykpLm1hcChhbmNob3JFbCA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhbmNob3JFbCkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB6ZW5kZXNrQWN0aW9uQnV0dG9uQ29sb3IgPSBhbmNob3JCYWNrZ3JvdW5kQ29sb3JzLmZpbmQoY29sb3IgPT4gY29sb3Iuc3RhcnRzV2l0aCgncmdiKCcpKTsgLy8gTm90ZTogaWdub3JlIHJnYmEoMCwwLDAsMCkgY29sb3JzXG4gICAgICByZXR1cm4gemVuZGVza0FjdGlvbkJ1dHRvbkNvbG9yO1xuICAgIH1cblxuICAgIHdhaXRGb3IoKCkgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21haW5fbmF2aWdhdGlvbiwgZGl2W3JvbGU9XCJuYXZpZ2F0aW9uXCJdJyksIChuYXZiYXJFbCkgPT4ge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZXNwYWNlKCd6ZW5kZXNrLWxvZ2dlZEluJykpO1xuXG4gICAgICB3YWl0Rm9yKCgpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5hdmJhckVsKS5iYWNrZ3JvdW5kQ29sb3IsIHplbmRlc2tNYWluQ29sb3IgPT4ge1xuICAgICAgICB3YWl0Rm9yKCgpID0+IGZpbmRaZW5kZXNrQWN0aW9uQnV0dG9uQ29sb3IobmF2YmFyRWwpLCB6ZW5kZXNrQWN0aW9uQnV0dG9uQ29sb3IgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlQ29sb3JzKE9iamVjdC5hc3NpZ24odGhpcy5jdXN0b21Db2xvcnMgfHwge30sIHtcbiAgICAgICAgICAgIG1haW46IHplbmRlc2tNYWluQ29sb3IsXG4gICAgICAgICAgICBhY3Rpb25CdXR0b246IHplbmRlc2tBY3Rpb25CdXR0b25Db2xvcixcbiAgICAgICAgICAgIGhpZ2hsaWdodDogemVuZGVza0FjdGlvbkJ1dHRvbkNvbG9yLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIGRvbid0IHNob3cgdGhlIHdpZGdldCBidXR0b24gYWJvdmUgdGhlIGZ1bGxzY3JlZW4gcGxheWVyXG4gICAgLy8gTm90ZTogdGhpcyBvbmx5IHdvcmtzIGluIENocm9tZSAob3RoZXIgYnJvd3NlcnMgdXNlIG90aGVyIHByZWZpeGVzKVxuICAgIGNvbnN0IGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBpc0Z1bGxzY3JlZW4gPSBCb29sZWFuKGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50KTtcbiAgICAgIGlmICh0aGlzLndpZGdldEVsKSB0aGlzLndpZGdldEVsLmNsYXNzTGlzdFtpc0Z1bGxzY3JlZW4gPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lc3BhY2UoJ2Z1bGxzY3JlZW4nKSk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLCBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICByZWdpc3RlclRvQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoXG4gICAgICB7IHRvcGljOiAncmVnaXN0ZXJQYW5lbENvbnRyb2xsZXInIH0sXG4gICAgICAoeyB0YWIsIGVuYWJsZWQsIHRhYkluZm8gfSkgPT4ge1xuICAgICAgICB0aGlzLm5vdGlmeU92ZXJsYXlEaXNtaXNzZWQoQm9vbGVhbih0YWJJbmZvLm92ZXJsYXlEaXNtaXNzZWQpLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5nZXRPck1ha2VXaWRnZXQodGFiLmlkKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRoaXMucGFuZWxFbCB8fFxuICAgICAgICAgICAgICB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRlJykgfHxcbiAgICAgICAgICAgICAgKHRoaXMuY2xvc2VFbCAmJiB0aGlzLmNsb3NlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsb2FkaW5nLXdpZGdldCcpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlV2lkZ2V0KCdzaG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcXVlcnlMaXZlSWQgPSBnZXRRdWVyeUxpdmVJZChsb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICBpZiAocXVlcnlMaXZlSWQpIHtcbiAgICAgICAgICB0aGlzLmF1dG9PcGVuTGl2ZUlkID0gcXVlcnlMaXZlSWQ7XG4gICAgICAgICAgdGhpcy5nZXRPck1ha2VQYW5lbCh0YWIuaWQsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVBhbmVsKCdzaG93JywgdGFiLmlkLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52LkJST1dTRVIgPT09ICdlbWJlZCcpIHtcbiAgICAgICAgICAvLyBwcmVsb2FkIHRoZSBwYW5lbFxuICAgICAgICAgIC8vIE9QVElNSVpBVElPTjogd2UgZG9uJ3QgZG8gdGhpcyBpbiBleHRlbnNpb24gZm9yIHJlZHVjaW5nIHJlc291cmNlcyB1c2FnZSxcbiAgICAgICAgICAvLyBwbHVzIHRoZXJlIHdvdWxkbid0IGJlIGFsbW9zdCBhbnkgZ2Fpbiwgc2luY2Ugd2UgdXNlIGxvY2FsIGZpbGVzIHRoZXJlLlxuICAgICAgICAgIHRoaXMuZ2V0T3JNYWtlUGFuZWwodGFiLmlkLCBmYWxzZSkudGhlbigocGFuZWxFbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ2dhYmxlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVuYWJsZWQpIHRoaXMuZGlzYWJsZVBhbmVsKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZU92ZXJsYXlGYWRlKG1vZGUsIGZvcmNlKSB7XG4gICAgdGhpcy5leHRlbnNpb24ub3ZlcmxheUNvbnRyb2xsZXIudG9nZ2xlQmxhbmtWaXNpYmlsaXR5ICYmXG4gICAgICB0aGlzLmV4dGVuc2lvbi5vdmVybGF5Q29udHJvbGxlci50b2dnbGVCbGFua1Zpc2liaWxpdHkobW9kZSwgZm9yY2UpO1xuICB9XG4gIHNob3VsZFN1cHByZXNzT3ZlcmxheSgpIHtcbiAgICBjb25zdCB7IHBhbmVsIH0gPSB0aGlzLmZsdXguYmFja2dyb3VuZENvbnRleHQoKS5zdGF0ZTtcbiAgICBjb25zdCB7IHN0YXJ0ZWQ6IHR1dG9yaWFsU3RhcnRlZCB9ID0gdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLnN0YXRlO1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm92ZXJsYXlEaXNtaXNzZWQgfHxcbiAgICAgICghdGhpcy5mbHV4LmJhY2tncm91bmRTdGF0ZVJlY2VpdmVkIHx8IChwYW5lbCAmJiBwYW5lbC5sZWFybiAmJiBwYW5lbC5sZWFybi5jdXJyZW50VHV0b3JpYWwuc3RhcnRlZCkpIHx8IC8vIGF2b2lkIGJsaW5rICgjNjY5KVxuICAgICAgdHV0b3JpYWxTdGFydGVkIHx8XG4gICAgICB0aGlzLmV4dGVuc2lvbi5vdmVybGF5Q29udHJvbGxlci5jb3VudGRvd24gfHxcbiAgICAgICgodGhpcy5leHRlbnNpb24uZG9jdW1lbnRDYXB0dXJlICYmIHRoaXMuZXh0ZW5zaW9uLmRvY3VtZW50Q2FwdHVyZS5pc0FjdGl2ZSkgfHwgdGhpcy5jYXB0dXJlUGF1c2VkKSB8fFxuICAgICAgIXRoaXMucGFuZWxFbCB8fCB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWVzcGFjZSgnaGlkZScpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tPdmVybGF5KGZvcmNlKSB7XG4gICAgdGhpcy50b2dnbGVPdmVybGF5RmFkZSh0aGlzLnNob3VsZFN1cHByZXNzT3ZlcmxheSgpID8gJ2hpZGUnIDogJ3Nob3cnLCBmb3JjZSk7XG4gIH1cbiAgbGlzdGVuT3ZlcmxheSgpIHtcbiAgICB0aGlzLmNoZWNrT3ZlcmxheSgpO1xuICAgIHRoaXMuZXh0ZW5zaW9uLmRvY3VtZW50Q2FwdHVyZS5vbignY2hhbmdlOmlzQWN0aXZlJywgKCkgPT4gdGhpcy5jaGVja092ZXJsYXkoKSk7XG4gICAgdGhpcy5vbignY2hhbmdlOmNhcHR1cmVQYXVzZWQnLCAoKSA9PiB0aGlzLmNoZWNrT3ZlcmxheSgpKTtcbiAgICB0aGlzLm9uKCdjaGFuZ2U6cGFuZWxIaWRkZW4nLCAoKSA9PiB0aGlzLmNoZWNrT3ZlcmxheSgpKTtcbiAgICB0aGlzLm9uKCdjaGFuZ2U6b3ZlcmxheURpc21pc3NlZCcsICgpID0+IHRoaXMuY2hlY2tPdmVybGF5KCkpO1xuICB9XG5cbiAgZGlzYWJsZVBhbmVsKCkge1xuICAgIGlmICghdGhpcy5wYW5lbFBvcnQpIHJldHVybjsgLy8gdG9vIGVhcmx5XG4gICAgaWYgKHRoaXMuZGlzYWJsZVBhbmVsVGltZXIpIHRoaXMuZGlzYWJsZVBhbmVsVGltZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5wYW5lbERpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhbmVsUG9ydC5kaXNhYmxlKCk7XG4gICAgdGhpcy5lbWl0KCdkaXNhYmxlUGFuZWwnKTtcbiAgfVxuXG4gIGRpc2FibGVQYW5lbExhdGVyKCkge1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc2FibGVQYW5lbCgpLCA1MDApO1xuICAgIHRoaXMuZGlzYWJsZVBhbmVsVGltZXIgPSB7XG4gICAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlUGFuZWxUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVQYW5lbExhdGVyO1xuICB9XG5cbiAgZW5hYmxlUGFuZWwoKSB7XG4gICAgaWYgKCF0aGlzLnBhbmVsUG9ydCkgcmV0dXJuOyAvLyB0b28gZWFybHlcbiAgICBpZiAodGhpcy5kaXNhYmxlUGFuZWxUaW1lcikgdGhpcy5kaXNhYmxlUGFuZWxUaW1lci5yZW1vdmUoKTtcbiAgICB0aGlzLnBhbmVsRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhbmVsUG9ydC5lbmFibGUoKTtcbiAgICB0aGlzLnBhbmVsUG9ydC5zZW5kKCdiYWNrZ3JvdW5kU3RhdGVDaGFuZ2VkJywgdGhpcy5mbHV4LmJhY2tncm91bmRTdGF0ZSk7IC8vIEhBQ0tcbiAgICB0aGlzLnBhbmVsUG9ydC5zZW5kKCdjb250ZW50U3RhdGVDaGFuZ2VkJywgdGhpcy5mbHV4LmNvbnRlbnRTdGF0ZSk7IC8vIEhBQ0tcbiAgICB0aGlzLmVtaXQoJ2VuYWJsZVBhbmVsJyk7XG4gIH1cblxuICBjaGVja0xlZ2FjeVBhZ2VTdGF0dXMoKSB7XG4gICAgd2FpdEZvcigoKSA9PiBkb2N1bWVudC5ib2R5LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wYW5lbERpc2FibGVkIHx8IGRvY3VtZW50LmhpZGRlbikgcmV0dXJuOyAvLyB0b28gbGF0ZVxuICAgICAgY29uc3Qgc3RhdHVzID0gZG9jdW1lbnQuYm9keS50YWdOYW1lID09PSAnRlJBTUVTRVQnO1xuICAgICAgdGhpcy5mbHV4LmJhY2tncm91bmRDb250ZXh0KCkuZGlzcGF0Y2goJ3RvZ2dsZUlzQ3VycmVudFBhZ2VMZWdhY3knLCBzdGF0dXMpO1xuICAgIH0pO1xuICB9XG5cbiAgY2hlY2tQb3B1cFBhZ2VTdGF0dXMoKSB7XG4gICAgd2FpdEZvcigoKSA9PiBkb2N1bWVudC5ib2R5LCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wYW5lbERpc2FibGVkIHx8IGRvY3VtZW50LmhpZGRlbikgcmV0dXJuOyAvLyB0b28gbGF0ZVxuICAgICAgY29uc3Qgc3RhdHVzID0gaXNQb3B1cCgpO1xuICAgICAgdGhpcy5mbHV4LmJhY2tncm91bmRDb250ZXh0KCkuZGlzcGF0Y2goJ3RvZ2dsZUlzQ3VycmVudFBhZ2VQb3B1cCcsIHN0YXR1cyk7XG4gICAgfSk7XG4gIH1cblxuICByZXRyaWV2ZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb24uc3RvcmFnZS5nZXQoeyAncGFuZWxIZWlnaHQnOiAnJyB9KS50aGVuKCh7IHBhbmVsSGVpZ2h0IH0pID0+IHtcbiAgICAgIHRoaXMucGFuZWxIZWlnaHQgPSBwYW5lbEhlaWdodDtcbiAgICAgIHJldHVybiBwYW5lbEhlaWdodDtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUJhY2tncm91bmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvL2xvZ2dlci5kZWJ1ZygnUGFuZWxDb250cm9sbGVyOiBnb3QgbWVzc2FnZSBmcm9tIGJhY2tncm91bmQnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuXG4gICAgbWVzc2FnZS5kYXRhID0gbWVzc2FnZS5kYXRhIHx8IHt9O1xuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdzaG93UGFuZWwnICYmIHRoaXMuZXh0ZW5zaW9uLmlzVG9wRnJhbWUpIHtcbiAgICAgIHRoaXMudG9nZ2xlUGFuZWwoXG4gICAgICAgICdzaG93JyxcbiAgICAgICAgbWVzc2FnZS50YWIuaWQsXG4gICAgICAgIG1lc3NhZ2UuZGF0YSAmJiBtZXNzYWdlLmRhdGEuZXhwbGljaXQsXG4gICAgICAgIG1lc3NhZ2UuZGF0YSAmJiBtZXNzYWdlLmRhdGEuY2FwdHVyaW5nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBbJ2hpZGVQYW5lbCcsICdzdGFydENvdW50ZXInLCAnc3RvcENvdW50ZXInLCAnc2hvd1N0YXJ0Q2FwdHVyZSddLmluZGV4T2YobWVzc2FnZS50b3BpYykgPiAtMSAmJlxuICAgICAgdGhpcy5leHRlbnNpb24uaXNUb3BGcmFtZVxuICAgICkge1xuICAgICAgdGhpcy50b2dnbGVQYW5lbChcbiAgICAgICAgJ2hpZGUnLFxuICAgICAgICBtZXNzYWdlLnRhYi5pZCxcbiAgICAgICAgbWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5leHBsaWNpdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3N0YXJ0Q291bnRlcicgJiYgdGhpcy5leHRlbnNpb24uaXNUb3BGcmFtZSkge1xuICAgICAgdGhpcy5jaGVja092ZXJsYXkoKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdoaWRlUGF1c2VkJyAmJiB0aGlzLmV4dGVuc2lvbi5pc1RvcEZyYW1lKSB7XG4gICAgICB0aGlzLmNhcHR1cmVQYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hlY2tPdmVybGF5KHRydWUpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnc3RlcEZvdW5kSW5BY3RpdmVUYWInICYmIHRoaXMuZXh0ZW5zaW9uLmlzVG9wRnJhbWUpIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlVGFiID0gbWVzc2FnZS50YWIuaWQgPT09IG1lc3NhZ2UuZGF0YS5hY3RpdmVUYWJJZDtcbiAgICAgIGNvbnN0IHNob3cgPSBpc0FjdGl2ZVRhYiB8fCAhbWVzc2FnZS5kYXRhLmZvdW5kO1xuXG4gICAgICB0aGlzLnRvZ2dsZVBhbmVsKFxuICAgICAgICBzaG93ID8gJ3Nob3cnIDogJ2hpZGUnLFxuICAgICAgICBtZXNzYWdlLnRhYi5pZCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICd1c2VyQ2hhbmdlZCcgJiYgdGhpcy5leHRlbnNpb24uaXNUb3BGcmFtZSkge1xuICAgICAgdGhpcy51c2VyID0gbWVzc2FnZS5kYXRhLnVzZXI7XG5cbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgYnkgbW92aW5nIHVzZXIgaW50byB0aGUgYmFja2dyb3VuZCBvciBjb250ZW50IHN0YXRlXG4gICAgICBjb25zdCBzZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goJ3VzZXJDaGFuZ2VkJywgdGhpcy51c2VyKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5wYW5lbERpc2FibGVkKSB0aGlzLm9uY2UoJ2VuYWJsZVBhbmVsJywgc2VuZCk7XG4gICAgICBlbHNlIHNlbmQoKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3N0YXJ0QnJvd3NlckNhcHR1cmUnKSB7XG4gICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goJ3N0YXJ0QnJvd3NlckNhcHR1cmUnKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQYW5lbE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vbG9nZ2VyLmRlYnVnKCdQYW5lbENvbnRyb2xsZXI6IGdvdCBtZXNzYWdlIGZyb20gcGFuZWwnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdyZWdpc3RlcicpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJQYW5lbCgpO1xuICAgICAgdGhpcy5zZXR1cEdvb2dsZVRyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhY2tncm91bmRSZWRpcmVjdFRvcGljcyA9IFtcbiAgICAgICdwZXJzaXN0UGFuZWxTdGF0ZScsICdleHRlbmRQZXJzaXN0ZWRQYW5lbFN0YXRlJywgJ3Jlc3VtZUNhcHR1cmUnLFxuICAgICAgJ3BhdXNlQ2FwdHVyZScsICdjYW5jZWxDYXB0dXJlJywgJ2NvbXBsZXRlQ2FwdHVyZScsXG4gICAgICAnc2F2ZUNhcHR1cmVkVHV0b3JpYWwnLCAncGxheUF1ZGlvJywgJ3N0b3BBdWRpbycsICd1cGRhdGVBdWRpb011dGVkJyxcbiAgICAgICdoaWRlUGFuZWwnLFxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICBiYWNrZ3JvdW5kUmVkaXJlY3RUb3BpY3MuaW5kZXhPZihtZXNzYWdlLnRvcGljKSAhPT0gLTEgJiZcbiAgICAgIHRoaXMuZXh0ZW5zaW9uLmlzVG9wRnJhbWVcbiAgICApIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3N0YXJ0Q2FwdHVyZScpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7IHRvcGljOiAnc2hvd1N0YXJ0Q2FwdHVyZScgfSk7XG4gICAgICAvKnRoaXMuY29uZmlybUNhcHR1cmVTdGFydCgpLnRoZW4oKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7IHRvcGljOiAnc3RhcnRDYXB0dXJlJyB9KTtcbiAgICAgIH0pOyovXG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAncmVzdGFydENhcHR1cmUnKSB7XG4gICAgICB0aGlzLmlzQ2FwdHVyZVN0YXJ0Q29uZmlybWF0aW9uTmVlZGVkKCkudGhlbigoY29uZmlybU5lZWRlZCkgPT4ge1xuICAgICAgICBpZiAoY29uZmlybU5lZWRlZCkge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7IHRvcGljOiAncGF1c2VDYXB0dXJlJyB9KTtcbiAgICAgICAgICB0aGlzLmNvbmZpcm1DYXB0dXJlU3RhcnQoKS50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcykgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoeyB0b3BpYzogJ3Jlc3VtZUNhcHR1cmUnIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7IHRvcGljOiAncmVzdW1lQ2FwdHVyZScgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnc2hvd1ByYWN0aWNlVHV0b3JpYWwnKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbi5vdmVybGF5Q29udHJvbGxlci50b2dnbGVQcmFjdGljZVR1dG9yaWFsKCdzaG93JywgbWVzc2FnZS5kYXRhLnBsYXllclVSTCk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdoaWRlUHJhY3RpY2VUdXRvcmlhbCcpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uLm92ZXJsYXlDb250cm9sbGVyLnRvZ2dsZVByYWN0aWNlVHV0b3JpYWwoJ2hpZGUnKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ2NhbmNlbENhcHR1cmUnKSB7XG4gICAgICB0aGlzLnNob3dDbG9zZVdpZGdldCgpO1xuICAgICAgdGhpcy50b2dnbGVEcmFnSGFuZGxlcignc2hvdycpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAndXBkYXRlVXNlckRhdGEnKSB7XG4gICAgICB0aGlzLnNldFVzZXJEYXRhKG1lc3NhZ2UuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdvcGVuSW50ZXJjb20nKSB7XG4gICAgICB0aGlzLnRvZ2dsZUludGVyY29tKCk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdzdGFydGVkJykge1xuICAgICAgdGhpcy5wYW5lbEVsU3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdwYW5lbEhlaWdodENoYW5nZWQnKSB7XG4gICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBtZXNzYWdlLmRhdGEgKyAncHgnO1xuICAgICAgdGhpcy51cGRhdGVDb250YWluZXIoeyBjb250YWluZXJIZWlnaHQgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdjbGljaycpIHtcbiAgICAgIHRoaXMubm90aWZ5T3ZlcmxheURpc21pc3NlZChmYWxzZSk7XG4gICAgfVxuXG5cbiAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3N0YXJ0VHV0b3JpYWwnKSB7XG4gICAgICAvLyBUaGlzIGlzIGV4ZWN1dGVkIG9ubHkgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBcIkd1aWRlIG1lXCIgYnV0dG9uXG4gICAgICBjb25zdCB7IGN1cnJlbnRTdGVwLCBsb2FkVVJMIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG4gICAgICBpZiAoY3VycmVudFN0ZXApIHtcbiAgICAgICAgY29uc3QgaXNSZWRpcmVjdGluZyA9IHJlZGlyZWN0SWZOZWVkZWQoY3VycmVudFN0ZXAud2luZG93LnVybCwgbG9hZFVSTCk7XG4gICAgICAgIGlmICghaXNSZWRpcmVjdGluZykge1xuICAgICAgICAgIHRoaXMucmVkaXJlY3RJZk5lZWRlZEJ5TmF2KGN1cnJlbnRTdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSBcImNoYW5nZUxvY2F0aW9uSHJlZlwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG1lc3NhZ2UuZGF0YS5sb2NhdGlvbkhyZWY7XG4gICAgfVxuICB9XG5cbiAgLy8gTk9URTogdGhpcyB3b24ndCB3b3JrIGlmIHRoZSBuYXYgaXMgaW5zaWRlIGFuIGlmcmFtZVxuICByZWRpcmVjdElmTmVlZGVkQnlOYXYoY3VycmVudFN0ZXApIHtcbiAgICAvLyBhbHRlcm5hdGl2ZSByZWRpcmVjdCBtZXRob2Q6IGNoZWNrIGFjdGl2ZSBuYXYgaXRlbVxuICAgIGNvbnN0IHsgbmF2QWN0aXZlQW5jaG9ySW5mbyB9ID0gY3VycmVudFN0ZXAud2luZG93O1xuICAgIGNvbnN0IGRvbWFpbk1hdGNoZXMgPSBkb21haW5NYXRjaFVybChjdXJyZW50U3RlcC53aW5kb3cudXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgY29uc3QgaXNaZW5kZXNrID0gKG5ldyBVUkwoY3VycmVudFN0ZXAud2luZG93LnVybCkpLmhvc3RuYW1lLmVuZHNXaXRoKCcuemVuZGVzay5jb20nKTsgLy8gdGhlIGdlbmVyYWwgcmVkaXJlY3QgcnVsZSBpcyBlbm91Z2ggZm9yIGl0XG4gICAgaWYgKG5hdkFjdGl2ZUFuY2hvckluZm8gJiYgZG9tYWluTWF0Y2hlcyAmJiAhaXNaZW5kZXNrKSB7XG4gICAgICBjb25zdCBzdGVwTmF2QWN0aXZlQW5jaG9yID0gbG9jYXRlRWxlbWVudChuYXZBY3RpdmVBbmNob3JJbmZvLmxvY2F0b3IpLmVsOyAvLyBhbmNob3IgdGhhdCB3YXMgYWN0aXZlIGR1cmluZyBjYXB0dXJlIG9mIHRoaXMgc3RlcFxuICAgICAgaWYgKHN0ZXBOYXZBY3RpdmVBbmNob3IgJiYgc3RlcE5hdkFjdGl2ZUFuY2hvci5ocmVmKSB7XG4gICAgICAgIGNvbnN0IG5hdkFjdGl2ZUFuY2hvciA9IGZpbmROYXZBY3RpdmVBbmNob3IoKTsgLy8gYW5jaG9yIHRoYXQgaXMgYWN0aXZlIHJpZ2h0IG5vd1xuICAgICAgICBpZiAobmF2QWN0aXZlQW5jaG9yICYmIG5hdkFjdGl2ZUFuY2hvciAhPT0gc3RlcE5hdkFjdGl2ZUFuY2hvcikge1xuICAgICAgICAgIC8vIHRoaXMgZGlzcGF0Y2ggaXMgbmVlZGVkIHNpbmNlIHRoZSBwYW5lbFxuICAgICAgICAgIC8vIGRvZXNuJ3Qga25vdyB3ZSBhcmUgZ29pbmcgdG8gcmVkaXJlY3RcbiAgICAgICAgICAvLyAodW5saWtlIHdpdGggdGhlIHJlZ3VsYXIgcmVkaXJlY3RJZk5lZWRlZClcbiAgICAgICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goJ3NldExpdmVMb2FkaW5nU3RlcFBhZ2UnLCB0cnVlKTtcblxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gc3RlcE5hdkFjdGl2ZUFuY2hvci5ocmVmO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5vdGlmeU92ZXJsYXlEaXNtaXNzZWQodmFsdWUsIG5vdGlmeUJhY2tncm91bmQgPSB0cnVlKSB7XG4gICAgdGhpcy5vdmVybGF5RGlzbWlzc2VkID0gdmFsdWU7XG4gICAgdGhpcy5lbWl0KCdjaGFuZ2U6b3ZlcmxheURpc21pc3NlZCcsIHRoaXMub3ZlcmxheURpc21pc3NlZCk7XG4gICAgaWYgKG5vdGlmeUJhY2tncm91bmQpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7XG4gICAgICAgIHRvcGljOiAnb3ZlcmxheURpc21pc3NlZENoYW5nZWQnLFxuICAgICAgICBkYXRhOiB7IG92ZXJsYXlEaXNtaXNzZWQ6IHZhbHVlIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQcmFjdGljZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgICAgLy8gdG9waWMgICAgICAgICAgaGFuZGxlciAodG9waWMsIGRhdGEpID0+IHt9XG4gICAgICBbJ3ByYWN0aWNlUmVhZHknLCAodCkgPT4gdGhpcy5wYW5lbFBvcnQuc2VuZCh0KV1cbiAgICBdO1xuXG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09IGhbMF0pIGhbMV0obWVzc2FnZS50b3BpYywgbWVzc2FnZS5kYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRvZ2dsZVBhbmVsKG1vZGUsIHRhYklkLCBleHBsaWNpdCA9IGZhbHNlLCBjYXB0dXJpbmcgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRvZ2dsZSA9ICgpID0+IHtcbiAgICAgICBpZiAobW9kZSA9PT0gJ2hpZGUnKSB7XG4gICAgICAgICB0aGlzLmNsb3NlUGFuZWwoKTtcbiAgICAgICAgIHRoaXMuaGlkZUNsb3NlV2lkZ2V0KCk7XG4gICAgICAgICB0aGlzLnRvZ2dsZURyYWdIYW5kbGVyKCdoaWRlJyk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmICghdGhpcy5wYW5lbEVsU3RhcnRlZCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRQYW5lbCgpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgIGlmICghY2FwdHVyaW5nKSB7XG4gICAgICAgICAgdGhpcy5zaG93Q2xvc2VXaWRnZXQoKTtcbiAgICAgICAgICB0aGlzLnRvZ2dsZURyYWdIYW5kbGVyKCdzaG93Jyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgIHRoaXMudG9nZ2xlRHJhZ0hhbmRsZXIoJ2hpZGUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgdGhpcy5lbWl0KCdjaGFuZ2U6cGFuZWxIaWRkZW4nKTtcbiAgICAgfTtcblxuICAgIC8vIHdhaXQgZm9yIGlmcmFtZSBsb2FkIGZvciBhIHNtb290aCBhbmltYXRpb25cbiAgICB0aGlzLmdldE9yTWFrZVBhbmVsKHRhYklkLCBleHBsaWNpdCkudGhlbigocGFuZWwpID0+IHtcbiAgICAgIHRoaXMuc2V0RHJhZ2dhYmxlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRvZ2dsZSgpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmFkZChuYW1lc3BhY2UoJ3BhbmVsLWxvYWRlZCcpKSwgMjAwMCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9hZENvb3JkaW5hdGVzKCk7XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZVBhbmVsKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzcGFjZSgncGFuZWwtb3BlbicpKTtcbiAgICB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmFkZChuYW1lc3BhY2UoJ2hpZGUnKSk7XG4gICAgdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLmRpc3BhdGNoKCdjbG9zZVBhbmVsJyk7XG4gICAgdGhpcy50b2dnbGVXaWRnZXQoJ3Nob3cnKTtcbiAgICByZXR1cm4gdGhpcy5wYW5lbEVsO1xuICB9XG5cbiAgb3BlblBhbmVsKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgncGFuZWwtb3BlbicpKTtcbiAgICB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lc3BhY2UoJ2hpZGUnKSk7XG4gICAgdGhpcy50b2dnbGVXaWRnZXQoJ2hpZGUnKTtcbiAgICByZXR1cm4gdGhpcy5wYW5lbEVsO1xuICB9XG5cbiAgc3RhcnRQYW5lbCgpIHtcbiAgICAvLyBTdGFydHMgdHV0b3JpYWxzIGZldGNoaW5nIGluIHRoZSBwYW5lbCwgZXRjLlxuICAgIGNvbnN0IGlmcmFtZSA9IHRoaXMucGFuZWxFbC5xdWVyeVNlbGVjdG9yKCdpZnJhbWUnKTtcbiAgICB0aGlzLl93YWl0SWZyYW1lTG9hZChpZnJhbWUpLnRoZW4oKCkgPT4ge1xuICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0b3BpYzogbmFtZXNwYWNlKCdzdGFydEFwcCcpLFxuICAgICAgICBzcmM6IHRoaXMucGFuZWxTcmMsXG4gICAgICAgIHVwd2FyZFN0YXRlOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdGhpcy5mbHV4LmJhY2tncm91bmRDb250ZXh0KCkuc3RhdGUsXG4gICAgICAgICAgY29udGVudDogdGhpcy5mbHV4LmNvbnRlbnRDb250ZXh0KCkuc3RhdGUsXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHRoaXMuZ2V0UGFuZWxPcHRpb25zKCksXG4gICAgICB9LCAnKicpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0UGFuZWxPcHRpb25zKCkge1xuICAgIGNvbnN0IGltcGxpY2l0RG9tYWlucyA9IHRoaXMuZ2V0SW1wbGljaXREb21haW5zKCkubWFwKGQgPT4gZXNjYXBlKGQpKS5qb2luKCcsJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IGxvY2F0aW9uLmhyZWYsXG4gICAgICBkb21haW46IGxvY2F0aW9uLmhvc3QsXG4gICAgICBpbnRlcmNvbUluc3RhbGxlZDogdGhpcy5pbnRlcmNvbUluc3RhbGxlZCxcbiAgICAgIGNvbG9yczogdGhpcy5jdXN0b21Db2xvcnMsXG4gICAgICBpbXBsaWNpdERvbWFpbnMsXG4gICAgfTtcbiAgfVxuXG4gIGdldE9yTWFrZVBhbmVsKHRhYklkLCB3YWl0Rm9yTG9hZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuICF0aGlzLnBhbmVsRWwgP1xuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLmNyZWF0ZVBhbmVsKHRhYklkKTtcblxuICAgICAgICAvLyBJbiBlbWJlZCBtb2RlIHdlIHByZWxvYWQgdGhlIHVzZXIgYW5kIHR1dG9yaWFsIGRhdGEgYXMgdGhlIHBhbmVsXG4gICAgICAgIC8vIGxvYWRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5CUk9XU0VSID09PSAnZW1iZWQnKSB7XG4gICAgICAgICAgdGhpcy5zZW5kRW1iZWRUdXRvcmlhbHMocGFuZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNFbWJlZCA9IHByb2Nlc3MuZW52LkJST1dTRVIgPT09ICdlbWJlZCc7XG4gICAgICAgIGxldCBjbG9zZTtcbiAgICAgICAgaWYgKCFpc0VtYmVkKSB7XG4gICAgICAgICAgY2xvc2UgPSB0aGlzLmlzWmVuZGVzaygpID8gdGhpcy5jcmVhdGVaZW5kZXNrQ2xvc2VQYW5lbCh0YWJJZCkgOiB0aGlzLmNyZWF0ZUNsb3NlUGFuZWwodGFiSWQpO1xuICAgICAgICAgIHRoaXMuY2xvc2VFbCA9IGNsb3NlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWZ0ZXJQYW5lbEFwcGVuZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRW1iZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVuZGVzaygpKSB7XG4gICAgICAgICAgICAgIHdhaXRGb3IoKCkgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihaRU5ERVNLX1dJREdFVF9DT05UQUlORVIpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbG9zZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3YWl0Rm9yTG9hZCkgcmVzb2x2ZShwYW5lbCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbG9zZSk7XG4gICAgICAgICAgICAgIGlmICghd2FpdEZvckxvYWQpIHJlc29sdmUocGFuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXdhaXRGb3JMb2FkKSByZXNvbHZlKHBhbmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMocGFuZWwpKSBhZnRlclBhbmVsQXBwZW5kKCk7XG4gICAgICAgIGVsc2UgYXBwZW5kT25Cb2R5TGF0ZXIocGFuZWwsIGFmdGVyUGFuZWxBcHBlbmQpO1xuXG4gICAgICAgIGlmICh3YWl0Rm9yTG9hZCkge1xuICAgICAgICAgIHRoaXMuX3dhaXRJZnJhbWVMb2FkKCkudGhlbigoKSA9PiByZXNvbHZlKHBhbmVsKSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICA6IFByb21pc2UucmVzb2x2ZSh0aGlzLnBhbmVsRWwpO1xuICB9XG5cbiAgc2VuZEVtYmVkVHV0b3JpYWxzKHBhbmVsKSB7XG4gICAgLy8gZmV0Y2ggZW1iZWQgdHV0b3JpYWxzIGZyb20gYXBpXG4gICAgbGV0IGVtYmVkVHV0b3JpYWxzO1xuICAgIGNvbnN0IGlmcmFtZSA9IHBhbmVsLnF1ZXJ5U2VsZWN0b3IoJ2lmcmFtZScpO1xuICAgIC8vIFdlIHdhbnQgdG8gcG9zdCBhZnRlciB3ZSd2ZSBib3RoIGxvYWRlZCB0aGUgZGF0YSBhbmQgdGhlIHBhbmVsIGlmcmFtZSBoYXMgbG9hZGVkXG4gICAgY29uc3QgcG9zdCA9IGFmdGVyKDIsIGZ1bmN0aW9uIHBvc3QoKSB7XG4gICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7IHRvcGljOiBuYW1lc3BhY2UoJ2VtYmVkVHV0b3JpYWxzJyksIGVtYmVkVHV0b3JpYWxzIH0sICcqJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl93YWl0SWZyYW1lTG9hZChpZnJhbWUpLnRoZW4ocG9zdCk7XG5cbiAgICBmZXRjaEVtYmVkVHV0b3JpYWxzKHRoaXMuZXh0ZW5zaW9uLmVtYmVkT3B0aW9ucy51c2VySWQsIFt3aW5kb3cubG9jYXRpb24uaHJlZiwgLi4udGhpcy5nZXRJbXBsaWNpdERvbWFpbnMoKV0pXG4gICAgICAudGhlbihfZW1iZWRUdXRvcmlhbHMgPT4ge1xuICAgICAgICBlbWJlZFR1dG9yaWFscyA9IF9lbWJlZFR1dG9yaWFscztcbiAgICAgICAgcG9zdCgpO1xuICAgICAgfSk7XG4gIH1cblxuICBjcmVhdGVQYW5lbCh0YWJJZCkge1xuICAgIGlmIChFTUJFRCkge1xuICAgICAgdGhpcy5zaG93Q2xvc2VXaWRnZXQoKTtcbiAgICAgIGlmICh0aGlzLmNsb3NlRWwpIHRoaXMuY2xvc2VFbC5jbGFzc0xpc3QuYWRkKCdsb2FkaW5nLXdpZGdldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZWZldGNoZWRQYW5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgbmFtZXNwYWNlKCdwYW5lbFByZWZldGNoJykpO1xuICAgIGNvbnN0IHByZWZldGNoZWRJZnJhbWUgPSBwcmVmZXRjaGVkUGFuZWwgPyBwcmVmZXRjaGVkUGFuZWwucXVlcnlTZWxlY3RvcignaWZyYW1lJykgOiBudWxsO1xuXG4gICAgY29uc3QgcGFuZWxFbCA9IHRoaXMucGFuZWxFbCA9IChwcmVmZXRjaGVkUGFuZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuXG4gICAgLy8gUmVtb3ZlIHN0cmV0Y2hpbmcgZWZmZWN0IGZvciBpbml0aWFsIGxvYWRcbiAgICBwYW5lbEVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZXNwYWNlKCdwYW5lbC1sb2FkZWQnKSk7XG5cbiAgICBwYW5lbEVsLmNsYXNzTmFtZSA9IG5hbWVzcGFjZSgncGFuZWwnLCAnaGlkZScpICsgJyB3aWRnZXQtcGFuZWwnO1xuICAgIHBhbmVsRWwuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5wYW5lbEhlaWdodH0haW1wb3J0YW50YDtcbiAgICBwYW5lbEVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8gbmVlZGVkIGluIGNhc2Ugb2YgcHJlZmV0Y2hlZFBhbmVsIHRvIHJlbW92ZSAnaGlkZSdcblxuICAgIGNvbnN0IGlmcmFtZSA9IHByZWZldGNoZWRJZnJhbWUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLndpZHRoID0gJzEwMCUnO1xuICAgIGlmcmFtZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgaWZyYW1lLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIGlmcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIGlmcmFtZS5hbGxvd1RyYW5zcGFyZW5jeSA9ICd0cnVlJztcblxuICAgIGxldCBzcmMgPSB0aGlzLmV4dGVuc2lvbi5nZXRVUkwoJy9wYW5lbC9pbmRleC5odG1sJyk7XG4gICAgdGhpcy5wYW5lbFNyYyA9IHNyYztcbiAgICBpZiAoIXByZWZldGNoZWRJZnJhbWUpIGlmcmFtZS5zcmMgPSBzcmM7XG4gICAgdGhpcy5fd2FpdElmcmFtZUxvYWQoaWZyYW1lKTtcbiAgICBpZiAoIXByZWZldGNoZWRJZnJhbWUpIHBhbmVsRWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0aGlzLnVwZGF0ZVBhbmVsTWF4SGVpZ2h0KCk7XG5cbiAgICByZXR1cm4gcGFuZWxFbDtcbiAgfVxuXG4gIHNldENsb3NlRWxlbWVudENvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IHsgY2xvc2VFbCB9ID0gdGhpcztcbiAgICBjb25zdCBwYW5lbENvb3JkaW5hdGVzID0gdGhpcy5nZXRQYW5lbENvb3JkaW5hdGVzKCk7XG5cbiAgICAvLyBLZWVwIGluaXRpYWwgY2xvc2UgZWxlbWVudCBjb29yZGluYXRlcyBpZiBwYW5lbCBkcmFnIGhhcyd0IGhhcHBlbmVkIHlldFxuICAgIGlmICghY2xvc2VFbCB8fCB0aGlzLmlzWmVuZGVzaygpIHx8ICFwYW5lbENvb3JkaW5hdGVzIHx8ICFwYW5lbENvb3JkaW5hdGVzLnRvcCB8fCAhcGFuZWxDb29yZGluYXRlcy5sZWZ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IHRoaXMuZ2V0Q2xvc2VFbGVtZW50Q29vcmRpbmF0ZXMocGFuZWxDb29yZGluYXRlcyk7XG4gICAgY2xvc2VFbC5zdHlsZS50b3AgPSBgJHsgdG9wIH1weGA7XG4gICAgY2xvc2VFbC5zdHlsZS5sZWZ0ID0gYCR7IGxlZnQgfXB4YDtcbiAgfVxuXG4gIGdldENsb3NlRWxlbWVudENvb3JkaW5hdGVzKHsgdG9wLCBsZWZ0IH0pIHtcbiAgICBjb25zdCBwYW5lbEhlaWdodCA9IHRoaXMucGFuZWxFbC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcih0aGlzLnBhbmVsSGVpZ2h0LnJlcGxhY2UoJ3B4JywgJycpKTtcbiAgICBjb25zdCB0b3BPZmZzZXQgPSBwYW5lbEhlaWdodCAtIDMwO1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSAzMzU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0b3AgKyB0b3BPZmZzZXQsXG4gICAgICBsZWZ0OiBsZWZ0ICsgbGVmdE9mZnNldCxcbiAgICB9O1xuICB9XG5cbiAgZ2V0UGFuZWxDb29yZGluYXRlcygpIHtcbiAgICBpZiAoIXRoaXMucGFuZWxFbCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdG9wID0gTnVtYmVyKHRoaXMucGFuZWxFbC5zdHlsZS50b3AucmVwbGFjZSgncHgnLCAnJykpO1xuICAgIGNvbnN0IGxlZnQgPSBOdW1iZXIodGhpcy5wYW5lbEVsLnN0eWxlLmxlZnQucmVwbGFjZSgncHgnLCAnJykpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgIH07XG4gIH1cblxuICBzdG9yZUNvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IHBhbmVsQ29vcmRpbmF0ZXMgPSB0aGlzLmdldFBhbmVsQ29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoIXBhbmVsQ29vcmRpbmF0ZXMpIHJldHVybjtcbiAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gdGhpcy5nZXRDbG9zZUVsZW1lbnRDb29yZGluYXRlcyhwYW5lbENvb3JkaW5hdGVzKTtcblxuICAgIHBhbmVsQ29vcmRpbmF0ZXMuY2xvc2VFbFRvcCA9IHRvcDtcbiAgICBwYW5lbENvb3JkaW5hdGVzLmNsb3NlRWxMZWZ0ID0gbGVmdDtcblxuICAgIHRoaXMuZXh0ZW5zaW9uLnN0b3JhZ2Uuc2V0KHsgcGFuZWxDb29yZGluYXRlcyB9KTtcbiAgfVxuXG4gIHJlc2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgdGhpcy5wYW5lbERyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4dGVuc2lvbi5zdG9yYWdlLnNldCh7IHBhbmVsQ29vcmRpbmF0ZXM6IHt9IH0pO1xuICAgIGNvbnN0IHsgcGFuZWxFbCwgY2xvc2VFbCB9ID0gdGhpcztcbiAgICBwYW5lbEVsLnN0eWxlLnRvcCA9ICcnO1xuICAgIHBhbmVsRWwuc3R5bGUubGVmdCA9ICcnO1xuXG4gICAgaWYgKCFjbG9zZUVsIHx8IHRoaXMuaXNaZW5kZXNrKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbG9zZUVsLnN0eWxlLnRvcCA9ICcnO1xuICAgIGNsb3NlRWwuc3R5bGUubGVmdCA9ICcnO1xuICB9XG5cbiAgbG9hZENvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IHsgZXh0ZW5zaW9uOiB7IHN0b3JhZ2UgfSwgcGFuZWxFbCwgY2xvc2VFbCB9ID0gdGhpcztcbiAgICBzdG9yYWdlLmdldCh7IHBhbmVsQ29vcmRpbmF0ZXM6IHt9IH0pLnRoZW4oKHsgcGFuZWxDb29yZGluYXRlcyB9KSA9PiB7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCwgY2xvc2VFbFRvcCwgY2xvc2VFbExlZnQgfSA9IHBhbmVsQ29vcmRpbmF0ZXM7XG4gICAgICBpZiAoIWxlZnQgfHwgIXRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFuZWxEcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIHBhbmVsRWwuc3R5bGUudG9wID0gYCR7IHRvcCB9cHhgO1xuICAgICAgcGFuZWxFbC5zdHlsZS5sZWZ0ID0gYCR7IGxlZnQgfXB4YDtcblxuICAgICAgaWYgKCFjbG9zZUVsIHx8IHRoaXMuaXNaZW5kZXNrKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBwYW5lbCBpcyBoaWRkZW4gLSB1c2UgY29vcmRpbmF0ZXMgZnJvbSBzdG9yYWdlLFxuICAgICAgLy8gb3RoZXJ3aXNlIC0gY2FsY3VsYXRlIGl0IHVzaW5nIHBhbmVsJ3MgY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IGlzUGFuZWxIaWRkZW4gPSB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWVzcGFjZSgnaGlkZScpKTtcbiAgICAgIGlmIChpc1BhbmVsSGlkZGVuKSB7XG4gICAgICAgIGNsb3NlRWwuc3R5bGUudG9wID0gYCR7IGNsb3NlRWxUb3AgfXB4YDtcbiAgICAgICAgY2xvc2VFbC5zdHlsZS5sZWZ0ID0gYCR7IGNsb3NlRWxMZWZ0IH1weGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRDbG9zZUVsZW1lbnRDb29yZGluYXRlcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlRHJhZ0hhbmRsZXIoKSB7XG4gICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkcmFnSGFuZGxlci5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgnaWNvbi1kcmFnZ2FibGUnKSk7XG4gICAgZHJhZ0hhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCAoKSA9PiB0aGlzLnJlc2V0Q29vcmRpbmF0ZXMoKSk7XG5cbiAgICByZXR1cm4gZHJhZ0hhbmRsZXI7XG4gIH1cblxuICB0b2dnbGVEcmFnSGFuZGxlcihtb2RlKSB7XG4gICAgY29uc3QgeyBwYW5lbERyYWdIYW5kbGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZGVDbGFzcyA9IG5hbWVzcGFjZSgnaGlkZScpO1xuXG4gICAgcmV0dXJuIHBhbmVsRHJhZ0hhbmRsZXIgJiZcbiAgICAgIChtb2RlID09PSAnc2hvdydcbiAgICAgICAgPyBwYW5lbERyYWdIYW5kbGVyLmNsYXNzTGlzdC5yZW1vdmUoaGlkZUNsYXNzKVxuICAgICAgICA6IHBhbmVsRHJhZ0hhbmRsZXIuY2xhc3NMaXN0LmFkZChoaWRlQ2xhc3MpXG4gICAgICApO1xuICB9XG5cbiAgc2V0RHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB3YWl0Rm9yKCgpID0+IGRvY3VtZW50LmJvZHksICgpID0+IHtcbiAgICAgICAgLy8gRHJhZ2dhYmxlIGxpYnJhcnkgc2hvdWxkIGJlIGxvYWRlZCBoZXJlLCBiZWNhdXNlIGl0IGhhcyBzb21lIGJvZHktcmVsYXRlZCBpbml0aWFsaXphdGlvbixcbiAgICAgICAgLy8gd2hpY2ggYnJlYWtzIHRoZSBleHRlbnNpb24gaWYgdGhlcmUgaXMgbm8gYm9keSB5ZXRcbiAgICAgICAgY29uc3QgRHJhZ2dhYmxlID0gcmVxdWlyZSgnZHJhZ2dhYmxlJyk7XG4gICAgICAgIGNvbnN0IHsgcGFuZWxFbCwgY2xvc2VFbCB9ID0gdGhpcztcblxuICAgICAgICBpZiAoIXBhbmVsRWwpIHtcbiAgICAgICAgICByZXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGFuZWxEcmFnSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMucGFuZWxEcmFnSGFuZGxlciA9IHRoaXMuY3JlYXRlRHJhZ0hhbmRsZXIoKTtcbiAgICAgICAgICBwYW5lbEVsLnByZXBlbmQodGhpcy5wYW5lbERyYWdIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcbiAgICAgICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSBwYW5lbEVsO1xuICAgICAgICBsZXQgY2xvc2VFbFRyYW5zaXRpb25TdHlsZSA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZUluc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5kcmFnZ2FibGVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdnYWJsZUluc3RhbmNlID0gbmV3IERyYWdnYWJsZShwYW5lbEVsLCB7XG4gICAgICAgICAgdXNlR1BVOiBmYWxzZSxcbiAgICAgICAgICBoYW5kbGU6IHRoaXMucGFuZWxEcmFnSGFuZGxlcixcbiAgICAgICAgICBzZXRQb3NpdGlvbjogZmFsc2UsXG4gICAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIHg6IFsgMSwgaW5uZXJXaWR0aCAtIG9mZnNldFdpZHRoIF0sXG4gICAgICAgICAgICB5OiBbIDEsIGlubmVySGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0IF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNsb3NlRWwpIHtcbiAgICAgICAgICAgICAgLy8gQ2xlYXIgd2lkZ2V0IHRyYW5zaXRpb24gdG8gcHJldmVudCBkZWxheWVkIGRyYWdcbiAgICAgICAgICAgICAgY2xvc2VFbFRyYW5zaXRpb25TdHlsZSA9IGNsb3NlRWwuc3R5bGUudHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgY2xvc2VFbC5zdHlsZS50cmFuc2l0aW9uID0gJ2luaXRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25EcmFnOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcGFuZWxFbC5zdHlsZVsnei1pbmRleCddID0gJyc7XG4gICAgICAgICAgICB0aGlzLnNldENsb3NlRWxlbWVudENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkRyYWdFbmQ6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMucGFuZWxEcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIERyYWdnYWJsZSBzZXRzIHNvbWUgei1pbmRleCBvbiBkcmFnZ2luZywgd2hpY2ggc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIC8vIChtYWtlIHRoaXMgYXN5bmMgdG8gbWFrZSBzdXJlIGl0IHJ1bnMgYWZ0ZXIgRHJhZ2dhYmxlIGNvZGUpXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBwYW5lbEVsLnN0eWxlWyd6LWluZGV4J10gPSAnJywgMCk7XG5cbiAgICAgICAgICAgIGlmIChjbG9zZUVsKSB7XG4gICAgICAgICAgICAgIGNsb3NlRWwuc3R5bGUudHJhbnNpdGlvbiA9IGNsb3NlRWxUcmFuc2l0aW9uU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VFbGVtZW50Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgcmVzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUNsb3NlUGFuZWwodGFiSWQpIHtcbiAgICBjb25zdCBjbG9zZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2xvc2VFbC5jbGFzc05hbWUgPSBuYW1lc3BhY2UoJ3dpZGdldCcsICdoaWRlJykgKyAnIGNsb3NlLXBhbmVsJztcbiAgICBjbG9zZUVsLmlubmVySFRNTCA9IHNwaW5uZXJXaGl0ZSgpO1xuICAgIGNsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm9uQ2xvc2VXaWRnZXRDbGljayh0YWJJZCkpO1xuXG4gICAgcmV0dXJuIGNsb3NlRWw7XG4gIH1cblxuICBjcmVhdGVaZW5kZXNrQ2xvc2VQYW5lbCh0YWJJZCkge1xuICAgIGNvbnN0IGNsb3NlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjbG9zZUVsLmNsYXNzTmFtZSA9IG5hbWVzcGFjZSgnemVuZGVzay13aWRnZXQnLCAnemVuZGVzay13aWRnZXQtY2xvc2UnLCAnaGlkZScpICsgJyBlbWJlci12aWV3IGRyb3Bkb3duIHB1bGwtcmlnaHQgdXNlcl9vcHRpb24nO1xuICAgIGNsb3NlRWwuaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImxvdHVzLXByb2ZpbGUtbWVudVwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJqcy1sb3R1cy1wcm9maWxlLW1lbnVfX3RvZ2dsZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZW1iZXItdmlldyByb3VuZC1hdmF0YXJcIj5cbiAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XCJ0aHVtYm5haWwtY29udGFpbmVyIHRodW1ibmFpbC1jb250YWluZXItLXNtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgJHt6ZW5kZXNDbG9zZUljb24oKX1cbiAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJcIj48L2k+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICAgIGNsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm9uQ2xvc2VXaWRnZXRDbGljayh0YWJJZCkpO1xuXG4gICAgcmV0dXJuIGNsb3NlRWw7XG4gIH1cblxuICBnZXRJbXBsaWNpdERvbWFpbnMoKSB7XG4gICAgLy8gc2hvdyB6ZW5kZXNrIHR1dG9yaWFscyBvbiB6ZW5kZXNrIHBhZ2VzIHdpdGggY3VzdG9tIGRvbWFpblxuICAgIC8vIChub3QgemVuZGVzay5jb20gc3ViZG9tYWlucylcbiAgICBjb25zdCBpc0RldkVtYmVkID0gKHByb2Nlc3MuZW52LkJST1dTRVIgPT09ICdlbWJlZCcgJiYgcHJvY2Vzcy5lbnYuTkFNRSA9PT0gJ2RldmVsb3BtZW50Jyk7XG4gICAgY29uc3QgaW1wbGljaXREb21haW5zID0gW1xuICAgICAgdGhpcy5pc1plbmRlc2soKSA/ICd3d3cuemVuZGVzay5jb20nIDogJycsXG4gICAgICBpc0RldkVtYmVkID8gJ3Rlc3QuaW9yYWQuY29tJyA6ICcnLFxuICAgIF0uZmlsdGVyKGQgPT4gISFkKTtcbiAgICByZXR1cm4gaW1wbGljaXREb21haW5zO1xuICB9XG5cbiAgdG9nZ2xlV2lkZ2V0KG1vZGUpIHtcbiAgICBpZiAoIXRoaXMud2lkZ2V0RWwpIHJldHVybjtcblxuICAgIGlmIChtb2RlID09PSAnaGlkZScpIHtcbiAgICAgIHRoaXMuaGlkZVdpZGdldCgpO1xuICAgICAgdGhpcy5zaG93Q2xvc2VXaWRnZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93V2lkZ2V0KCk7XG4gICAgICB0aGlzLmhpZGVDbG9zZVdpZGdldCgpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGVXaWRnZXQoKSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUobmFtZXNwYWNlKCd3aWRnZXQtdmlzaWJsZScpKTtcbiAgICB0aGlzLndpZGdldEVsLmNsYXNzTGlzdC5hZGQobmFtZXNwYWNlKCdoaWRlJykpO1xuICAgIHJldHVybiB0aGlzLndpZGdldEVsO1xuICB9XG5cbiAgc2hvd1dpZGdldCgpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lc3BhY2UoJ3dpZGdldC12aXNpYmxlJykpO1xuICAgIHRoaXMud2lkZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lc3BhY2UoJ2hpZGUnKSk7XG4gICAgcmV0dXJuIHRoaXMud2lkZ2V0RWw7XG4gIH1cblxuICAvLyBcIldpZGdldFwiIGhlcmUgcmVmZXJzIHRvIHRoZSBsaXR0bGUgYnV0dG9uIHRoYXQgY2FuIGxhdW5jaCB0aGUgcGFuZWwuXG4gIGdldE9yTWFrZVdpZGdldCh0YWJJZCkge1xuICAgIC8vIEFsd2F5cyBzaG93IGluIGVtYmVkIG1vZGUsIG9ubHkgc2hvdyBmb3IgemVuZGVzayBpbiBleHRlbnNpb24gbW9kZSAoVE9ETzogaW1wbGVtZW50IGEgZnVsbCB3aGl0ZWxpc3QsIHNlZSAjNzE3KVxuICAgIGNvbnN0IHNob3VsZFNob3dCdXR0b24gPSBFTUJFRCB8fCB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUuZW5kc1dpdGgoXCIuemVuZGVzay5jb21cIik7XG4gICAgaWYgKCFzaG91bGRTaG93QnV0dG9uKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IC8vIFRlbXBvcmFyeSBoYWNrIHRvIGZpeCAjMzg4LiBCdXQgdGhlIHdpZGdldCBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGVtYmVkIHNwZWNpZmljIGZpbGVzXG5cbiAgICByZXR1cm4gIXRoaXMud2lkZ2V0RWwgP1xuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgd2lkZ2V0ID0gdGhpcy5pc1plbmRlc2soKSA/IHRoaXMuY3JlYXRlWmVuZGVza1dpZGdldCh0YWJJZCkgOiB0aGlzLmNyZWF0ZVdpZGdldCh0YWJJZCk7XG4gICAgICAgIHRoaXMud2lkZ2V0RWwgPSB3aWRnZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNaZW5kZXNrKCkpIHtcbiAgICAgICAgICB3YWl0Rm9yKCgpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoWkVOREVTS19XSURHRVRfQ09OVEFJTkVSKSwgKCkgPT4ge1xuICAgICAgICAgICAgYXBwZW5kT25Cb2R5TGF0ZXIod2lkZ2V0LCAoKSA9PiB7IHJlc29sdmUod2lkZ2V0KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kT25Cb2R5TGF0ZXIod2lkZ2V0LCAoKSA9PiB7IHJlc29sdmUod2lkZ2V0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICA6IFByb21pc2UucmVzb2x2ZSh0aGlzLndpZGdldEVsKTtcbiAgfVxuXG4gIGNyZWF0ZVdpZGdldCh0YWJJZCkge1xuICAgIGNvbnN0IGljb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGljb25FbC5jbGFzc05hbWUgPSBuYW1lc3BhY2UoJ3dpZGdldCcsICdoaWRlJyk7XG4gICAgaWNvbkVsLmlubmVySFRNTCA9IHdpZGdldEljb24oKTtcblxuICAgIGljb25FbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMub25XaWRnZXRDbGljayh0YWJJZCkpO1xuXG4gICAgcmV0dXJuIGljb25FbDtcbiAgfVxuXG4gIGNyZWF0ZVplbmRlc2tXaWRnZXQodGFiSWQpIHtcbiAgICBjb25zdCBpY29uRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpY29uRWwuY2xhc3NOYW1lID0gbmFtZXNwYWNlKCd6ZW5kZXNrLXdpZGdldCcsICdoaWRlJykgKyAnIGVtYmVyLXZpZXcgZHJvcGRvd24gcHVsbC1yaWdodCB1c2VyX29wdGlvbic7XG4gICAgaWNvbkVsLmlubmVySFRNTCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJsb3R1cy1wcm9maWxlLW1lbnVcIj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwianMtbG90dXMtcHJvZmlsZS1tZW51X190b2dnbGVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVtYmVyLXZpZXcgcm91bmQtYXZhdGFyXCI+XG4gICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVwidGh1bWJuYWlsLWNvbnRhaW5lciB0aHVtYm5haWwtY29udGFpbmVyLS1zbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICR7emVuZGVza1dpZGdldEljb24oKX1cbiAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJcIj48L2k+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICAgIGljb25FbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMub25XaWRnZXRDbGljayh0YWJJZCkpO1xuXG4gICAgcmV0dXJuIGljb25FbDtcbiAgfVxuXG4gIHVwZGF0ZVdpZGdldCh7IGxvYWRpbmdTdGVwUGFnZSA9IGZhbHNlLCBjYXB0dXJpbmdBY3RpdmUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuY2xvc2VFbCkge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY2xvc2VFbC5jbGFzc0xpc3Q7XG4gICAgICBsb2FkaW5nU3RlcFBhZ2UgPyBjLmFkZCgnbG9hZGluZy13aWRnZXQnKSA6IGMucmVtb3ZlKCdsb2FkaW5nLXdpZGdldCcpO1xuICAgICAgY2FwdHVyaW5nQWN0aXZlID8gYy5hZGQobmFtZXNwYWNlKCdjYXB0dXJpbmcnKSkgOiBjLnJlbW92ZShuYW1lc3BhY2UoJ2NhcHR1cmluZycpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXN0b21Db2xvcnMgJiYgdGhpcy5jdXN0b21Db2xvcnMubWFpbikge1xuICAgICAgaWYgKHRoaXMud2lkZ2V0RWwgJiYgIXRoaXMuaXNaZW5kZXNrKCkpIHRoaXMud2lkZ2V0RWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jdXN0b21Db2xvcnMubWFpbjtcbiAgICAgIGlmICh0aGlzLmNsb3NlRWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZW5kZXNrKCkpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlRWwucXVlcnlTZWxlY3RvcignY2lyY2xlJykuc3R5bGUuZmlsbCA9IHRoaXMuY3VzdG9tQ29sb3JzLmFjdGlvbkJ1dHRvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsb3NlRWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jdXN0b21Db2xvcnMubWFpbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uV2lkZ2V0Q2xpY2sodGFiSWQpIHtcbiAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgdG9waWM6ICdzaG93UGFuZWwnLFxuICAgICAgZGF0YTogeyBleHBsaWNpdDogdHJ1ZSwgdGFiSWQgfSxcbiAgICB9KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5CUk9XU0VSICE9PSAnZW1iZWQnKSB7XG4gICAgICAvLyBtaW1pYyBjaHJvbWUgZXh0ZW5zaW9uIGJ1dHRvbiBjbGlja1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKHsgdG9waWM6ICdoYW5kbGVBY3Rpb25CdXR0b25DbGljaycgfSk7XG4gICAgfVxuICB9XG5cbiAgbW9uaXRvckJvZHlGb3JQYW5lbCgpIHtcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5wYW5lbEVsKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ1BhbmVsIHdhcyByZW1vdmVkISBSZS1hZGRpbmcuLi4nKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnBhbmVsRWwpO1xuXG4gICAgICAgIC8vIHJlLXNldCBzcmMgaW4gY2FzZSBpdCB3YXMgcmVtb3ZlZFxuICAgICAgICB0aGlzLnBhbmVsRWwucXVlcnlTZWxlY3RvcignaWZyYW1lJykuc3JjID0gdGhpcy5wYW5lbFNyYztcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9XG5cbiAgY2FjaGVIZWlnaHQoaGVpZ2h0KSB7XG4gICAgaWYgKHRoaXMucGFuZWxFbCkge1xuICAgICAgbGV0IGZpbmFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFmaW5hbEhlaWdodCkge1xuICAgICAgICBmaW5hbEhlaWdodCA9ICh0aGlzLnBhbmVsRWwub2Zmc2V0SGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VJbnQoZmluYWxIZWlnaHQsIDEwKSA9PT0gMCkgZmluYWxIZWlnaHQgPSAnJztcblxuICAgICAgdGhpcy5wYW5lbEhlaWdodCA9IGZpbmFsSGVpZ2h0O1xuICAgICAgdGhpcy5leHRlbnNpb24uc3RvcmFnZS5zZXQoeyBwYW5lbEhlaWdodDogZmluYWxIZWlnaHQgfSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlUGFuZWxSZWFsQm91bmRzKCkge1xuICAgIHJldHVybjsgLy8gRElTQUJMRUQgRk9SIE5PV1xuXG4gICAgaWYgKCF0aGlzLnBhbmVsRWwpIHJldHVybjtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnBhbmVsSW5uZXJIZWlnaHQ7XG4gICAgY29uc3QgY2FwdHVyaW5nQWN0aXZlID0gdGhpcy5wYW5lbEVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lc3BhY2UoJ2NhcHR1cmluZycpKTtcbiAgICBjb25zdCBwYW5lbEJvdW5kcyA9IHRoaXMucGFuZWxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwYW5lbFJlYWxIZWlnaHQgPSBoZWlnaHQgJiYgKCFpc05hTihoZWlnaHQpIHx8IGhlaWdodC5pbmRleE9mKCdweCcpICE9PSAtMSlcbiAgICAgID8gcGFyc2VJbnQoaGVpZ2h0LCAxMClcbiAgICAgIDogcGFuZWxCb3VuZHMuaGVpZ2h0O1xuXG4gICAgLy8gKGFzc2lnbkluIHNpbmNlIHBhbmVsQm91bmRzIHByb3BzIGFyZW4ndCBvd25lZClcbiAgICB0aGlzLnBhbmVsUmVhbEJvdW5kcyA9IGFzc2lnbkluKHt9LCBwYW5lbEJvdW5kcywge1xuICAgICAgaGVpZ2h0OiBwYW5lbFJlYWxIZWlnaHQsXG5cbiAgICAgIC4uLihcbiAgICAgICAgY2FwdHVyaW5nQWN0aXZlXG4gICAgICAgID8geyBib3R0b206IHBhbmVsQm91bmRzLnRvcCArIHBhbmVsUmVhbEhlaWdodCB9XG4gICAgICAgIDogeyB0b3A6IHBhbmVsQm91bmRzLmJvdHRvbSAtIHBhbmVsUmVhbEhlaWdodCB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVQYW5lbE1heEhlaWdodCgpIHtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heChNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQgLSA2MCwgNjMwKSwgMjUwKTtcbiAgICBpZiAodGhpcy5wYW5lbEVsKSB0aGlzLnBhbmVsRWwuc3R5bGUubWF4SGVpZ2h0ID0gYCR7bWF4SGVpZ2h0fXB4YDtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRhaW5lcih7IGNvbnRhaW5lckhlaWdodCwgY2FwdHVyaW5nQWN0aXZlIH0pIHtcbiAgICBpZiAoIXRoaXMucGFuZWxFbCkgcmV0dXJuO1xuXG4gICAgY29uc3QgbXV0YXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYW5lbEVsLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcblxuICAgICAgLy8gV2FpdCBmb3IgaGVpZ2h0IHN0cmV0Y2hpbmcgdG8gZmluaXNoXG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldENsb3NlRWxlbWVudENvb3JkaW5hdGVzKCksIDEwMDApO1xuICAgICAgdGhpcy5jYWNoZUhlaWdodCgpO1xuXG4gICAgICAvL3RoaXMucGFuZWxJbm5lckhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgIC8vdGhpcy5jYWxjdWxhdGVQYW5lbFJlYWxCb3VuZHMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wYW5lbEVsLmNsYXNzTGlzdFtjb250YWluZXJIZWlnaHQubWF0Y2goJyUnKSA/ICdyZW1vdmUnIDogJ2FkZCddKG5hbWVzcGFjZSgnYWRhcHRpdmUnKSk7XG5cbiAgICBpZiAoY2FwdHVyaW5nQWN0aXZlKSB7XG4gICAgICB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LmFkZChuYW1lc3BhY2UoJ2NhcHR1cmluZycpKTtcbiAgICAgIHRoaXMucmVzZXRDb29yZGluYXRlcygpO1xuICAgICAgdGhpcy50b2dnbGVEcmFnSGFuZGxlcignaGlkZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhbmVsRWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lc3BhY2UoJ2NhcHR1cmluZycpKTtcbiAgICB9XG5cbiAgICBtdXRhdGUoKTtcbiAgfVxuXG4gIGlzQ2FwdHVyZVN0YXJ0Q29uZmlybWF0aW9uTmVlZGVkKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpOyAvLyBESVNBQkxFRFxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoXG4gICAgICAgIHsgdG9waWM6ICdnZXRDb25maXJtQ2FwdHVyZVN0YXJ0JyB9LFxuICAgICAgICAoeyBjb25maXJtQ2FwdHVyZVN0YXJ0IH0pID0+IHJlc29sdmUoY29uZmlybUNhcHR1cmVTdGFydClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgY29uZmlybUNhcHR1cmVTdGFydCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHNhdmVEb250U2hvdyA9IChkb250U2hvdykgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgICAgIHRvcGljOiAnc2V0Q29uZmlybUNhcHR1cmVTdGFydCcsXG4gICAgICAgICAgZGF0YTogeyBjb25maXJtQ2FwdHVyZVN0YXJ0OiAhZG9udFNob3cgfSxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5pc0NhcHR1cmVTdGFydENvbmZpcm1hdGlvbk5lZWRlZCgpLnRoZW4oKGNvbmZpcm1OZWVkZWQpID0+IHtcbiAgICAgICAgaWYgKCFjb25maXJtTmVlZGVkKSByZXNvbHZlKHRydWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgICAgICAgdG9waWM6ICdoaWRlUGFuZWwnLFxuICAgICAgICAgICAgZGF0YTogeyBleHBsaWNpdDogdHJ1ZSB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgY29uc3QgY2xvc2VEaWFsb2cgPSAoKSA9PiBkaWFsb2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaWFsb2cpO1xuICAgICAgICAgIGNvbnN0IHJlbmRlciA9ICgpID0+IHJlYWN0UmVuZGVyKENhcHR1cmVTdGFydERpYWxvZywge1xuICAgICAgICAgICAgb25TdGFydDogZmxvd1JpZ2h0KCgpID0+IHJlc29sdmUodHJ1ZSksIGNsb3NlRGlhbG9nLCBzYXZlRG9udFNob3cpLFxuICAgICAgICAgICAgb25DbG9zZTogZmxvd1JpZ2h0KCgpID0+IHJlc29sdmUoZmFsc2UpLCBjbG9zZURpYWxvZylcbiAgICAgICAgICB9LCBkaWFsb2cpO1xuICAgICAgICAgIGFwcGVuZE9uQm9keUxhdGVyKGRpYWxvZywgcmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVGb3JCYWNrZ3JvdW5kKG9sZFN0YXRlLCBzdGF0ZSwgdGFiSWQpIHtcbiAgICBpZiAoIXRoaXMuZXh0ZW5zaW9uLmlzVG9wRnJhbWUpIHJldHVybjtcblxuICAgIHRoaXMuY2hlY2tPdmVybGF5KCk7XG5cbiAgICBjb25zdCBjYXB0dXJlUGF1c2VkID0gQm9vbGVhbihzdGF0ZS5jYXB0dXJlICYmIHN0YXRlLmNhcHR1cmUuYnJvd3NlclN0YXRlID09PSAncGF1c2VkJyk7XG4gICAgaWYgKHRoaXMuY2FwdHVyZVBhdXNlZCAhPT0gY2FwdHVyZVBhdXNlZCkge1xuICAgICAgdGhpcy5jYXB0dXJlUGF1c2VkID0gY2FwdHVyZVBhdXNlZDtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlOmNhcHR1cmVQYXVzZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsdXgudXBkYXRlcihvbGRTdGF0ZSwgc3RhdGUsIFtcbiAgICAgIFsnYWN0aXZlVGFiSWQnLCAoYWN0aXZlVGFiSWQpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZVRhYklkICE9PSB0YWJJZCAmJiAhc3RhdGUuaXNDdXJyZW50UGFnZVBvcHVwKSB7XG4gICAgICAgICAgLy8gZGVsYXllZCBiZWNhdXNlIG9mICM4MDJcbiAgICAgICAgICB0aGlzLmRpc2FibGVQYW5lbExhdGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVQYW5lbCgpO1xuICAgICAgICB9XG4gICAgICB9XSxcblxuICAgICAgWydpc0N1cnJlbnRQYWdlUG9wdXAnLCAoaXNDdXJyZW50UGFnZVBvcHVwKSA9PiB7XG4gICAgICAgIGlmIChpc0N1cnJlbnRQYWdlUG9wdXApIHtcbiAgICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIHVwZGF0ZSB0aGUgcGFuZWwgaW4gdGhlIHBhcmVudCB3aW5kb3dcbiAgICAgICAgICB0aGlzLmVuYWJsZVBhbmVsKCk7XG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVGb3JQYW5lbChvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lcihzdGF0ZSk7XG4gICAgdGhpcy51cGRhdGVXaWRnZXQoc3RhdGUpO1xuICAgIHRoaXMuY2hlY2tPdmVybGF5KCk7XG5cbiAgICB0aGlzLmZsdXgudXBkYXRlcihvbGRTdGF0ZSwgc3RhdGUsIFtcbiAgICAgIFsnY29udGFpbmVySGVpZ2h0JywgdGhpcy5jYWNoZUhlaWdodC5iaW5kKHRoaXMpXSxcbiAgICAgIFsndHV0b3JpYWxzQ291bnQnLCAodHV0b3JpYWxzQ291bnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZFBvcnQpIHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgICAgICAgdG9waWM6ICd0dXRvcmlhbHNDb3VudENoYW5nZWQnLFxuICAgICAgICAgICAgZGF0YTogeyB0dXRvcmlhbHNDb3VudCB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XVxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlRm9yQ29udGVudChvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICB0aGlzLmZsdXgudXBkYXRlcihvbGRTdGF0ZSwgc3RhdGUsIFtcbiAgICAgIFtFTUJFRCAmJiAnaW50ZXJjb21JbnN0YWxsZWQnLCB0aGlzLnRvZ2dsZUludGVyY29tRXhpc3RlbmNlLmJpbmQodGhpcyldXG4gICAgXSk7XG4gIH1cblxuICAvLyBOT1RFOiB0aGlzIGlzIHVzZWQgYnkgaW5qZWN0LmpzXG4gIGhhbmRsZUNvbG9ycyhjb2xvcnMpIHtcbiAgICB0aGlzLmN1c3RvbUNvbG9ycyA9IGNvbG9ycztcblxuICAgIC8vIGFsc28gdXBkYXRlIHBhbmVsXG4gICAgdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLmRpc3BhdGNoKCdjb2xvcnNDaGFuZ2VkJywgY29sb3JzKTtcblxuICAgIHRoaXMudXBkYXRlV2lkZ2V0KCk7XG4gIH1cblxuICByZWdpc3RlclBhbmVsKCkge1xuICAgIHRoaXMucGFuZWxQb3J0LnNlbmQoJ2hhbmRsZVVwd2FyZFN0YXRlJywge1xuICAgICAgYmFja2dyb3VuZDogdGhpcy5mbHV4LmJhY2tncm91bmRDb250ZXh0KCkuc3RhdGUsXG4gICAgICBwYW5lbDogdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLnN0YXRlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5nZXRVc2VyRGF0YSgpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuZmx1eC5wYW5lbENvbnRleHQoKS5kaXNwYXRjaCgncmVzdG9yZVNhdmVkU3RhdGUnLCBkYXRhKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5hdXRvT3BlbkxpdmVJZCkge1xuICAgICAgY29uc3Qgb3BlbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLmRpc3BhdGNoKCdzZWxlY3RUdXRvcmlhbCcsIHRoaXMuYXV0b09wZW5MaXZlSWQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7IHRvcGljOiAnaGlkZVR1dG9yaWFsU2VsZWN0JyB9KTtcbiAgICAgIGlmICh0aGlzLnBhbmVsUG9ydC5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdlbmFibGVQYW5lbCcsIG9wZW4pO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoeyB0b3BpYzogJ3JlcXVpcmVUYWJGb2N1cycgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0VXNlckRhdGEoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoeyB0b3BpYzogJ2dldFVzZXJEYXRhJyB9LCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldFVzZXJEYXRhKHVzZXJEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmJhY2tncm91bmRQb3J0XG4gICAgICAgIC5zZW5kKHsgdG9waWM6ICdzZXRVc2VyRGF0YScsIGRhdGE6IHsgdXNlckRhdGEgfSB9LCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRvZ2dsZUludGVyY29tRXhpc3RlbmNlKHRvZ2dsZSkge1xuICAgIGlmICh0b2dnbGUpIHtcbiAgICAgIGNvbnN0IGlzUGFuZWxPcGVuID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhuYW1lc3BhY2UoJ3BhbmVsLW9wZW4nKSk7XG4gICAgICBpZiAoaXNQYW5lbE9wZW4pIHRoaXMuc2hvd0NoYXRCdXR0b25XaWRnZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlQ2hhdEJ1dHRvbldpZGdldCgpO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUludGVyY29tKCkge1xuICAgIGNvbnN0IGVsID0gZ2V0SW50ZXJjb21MYXVuY2hlcigpO1xuICAgIGlmIChlbCkgZWwuY2xpY2soKTtcbiAgfVxuXG4gIG9wZW5UdXRvcmlhbHMoKSB7XG4gICAgdGhpcy50b2dnbGVJbnRlcmNvbSgpOyAvLyBjbG9zZSBJbnRlcmNvbVxuICAgIHRoaXMudG9nZ2xlQ2hhdEJ1dHRvbldpZGdldExhYmVsKCk7XG4gICAgdGhpcy5zaG93Q2hhdEJ1dHRvbldpZGdldCgpO1xuICB9XG5cbiAgb25DbG9zZVdpZGdldENsaWNrKHRhYklkKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKHtcbiAgICAgIHRvcGljOiAnaGlkZVBhbmVsJyxcbiAgICAgIGRhdGE6IHsgZXhwbGljaXQ6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIC8vIFdhaXQgYSBiaXQgdG8gbGV0IHBhbmVsIGRpc2FwcGVhclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzZXRDb29yZGluYXRlcygpLCA1MDApO1xuICB9XG5cbiAgaGlkZUNsb3NlV2lkZ2V0KCkge1xuICAgIGlmICh0aGlzLmNsb3NlRWwpIHRoaXMuY2xvc2VFbC5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgnaGlkZScpKTtcbiAgICByZXR1cm4gdGhpcy5jbG9zZUVsO1xuICB9XG5cbiAgc2hvd0Nsb3NlV2lkZ2V0KCkge1xuICAgIGlmICh0aGlzLmNsb3NlRWwpIHRoaXMuY2xvc2VFbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzcGFjZSgnaGlkZScpKTtcbiAgICByZXR1cm4gdGhpcy5jbG9zZUVsO1xuICB9XG5cbiAgLy8gaWZyYW1lIGlzIG9wdGlvbmFsIChtdXN0IGJlIHBhc3NlZCBvbmx5IGlmIGl0IGlzbid0IGFwcGVuZGVkIGludG8gdGhpcy5wYW5lbEVsIHlldClcbiAgX3dhaXRJZnJhbWVMb2FkKGlmcmFtZSkge1xuICAgIGlmICh0aGlzLl93YWl0SWZyYW1lTG9hZFByb21pc2UpIHJldHVybiB0aGlzLl93YWl0SWZyYW1lTG9hZFByb21pc2U7XG4gICAgdGhpcy5fd2FpdElmcmFtZUxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWZyYW1lID0gaWZyYW1lIHx8IHRoaXMucGFuZWxFbC5xdWVyeVNlbGVjdG9yKCdpZnJhbWUnKTtcbiAgICAgIGNvbnN0IGhhbmRsZUxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGxldCB0aW1lcjtcblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vaW9yYWQvaW9yYWQtZXh0ZW5zaW9uL2lzc3Vlcy84NjcjaXNzdWVjb21tZW50LTMyOTE3ODU2NFxuICAgICAgICAvLyBDaHJvbWUgcmVwbGFjZXMgdGhlIHBhbmVsIGlmcmFtZSB3aW5kb3cgd2l0aCBhbm90aGVyIGlmcmFtZSBpbiB0aGUgcGFnZSxcbiAgICAgICAgLy8gdGhlIGFjdHVhbCBwYW5lbCAtPiBwYWdlIGNvbW11bmljYXRpb24gc3RpbGwgd29ya3MsIGJ1dCB0aGUgb3RoZXIgd2F5IGFyb3VuZCBkb2Vzbid0LFxuICAgICAgICAvLyB0aHVzIHdlIGRldGVjdCB0aGlzIGNhc2UgYnkgY2hlY2tpbmcgaWYgdGhlIHBhbmVsIGlzIHJlY2VpdmluZyB0aGUgcGFnZSBtZXNzYWdlcyxcbiAgICAgICAgLy8gaWYgdGhhdCBkb2Vzbid0IGhhcHBlbiBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUsIHRoZW4gd2Uga25vdyB0aGUgYnVnIGhhcHBlbmVkXG4gICAgICAgIC8vIGFuZCB3ZSBmaXggaXQgYnkgcmVsb2FkaW5nIHRoZSBpZnJhbWUuXG5cbiAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoeyB0b3BpYzogJ3BhbmVsQ2hhbGxlbmdlOnJlcXVlc3QnIH0sICcqJyk7XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBbJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdvYmplY3QnIHx8IG1lc3NhZ2UgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ3BhbmVsQ2hhbGxlbmdlOnJlc3BvbnNlJykge1xuICAgICAgICAgICAgcmVtb3ZlV2luZG93TGlzdGVuZXIoLi4ubGlzdGVuZXIpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfV07XG4gICAgICAgIGFkZFdpbmRvd0xpc3RlbmVyKC4uLmxpc3RlbmVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVyKC4uLmxpc3RlbmVyKTtcbiAgICAgICAgICAvLyByZWxvYWQgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgIGNvbnN0IGlmcmFtZVNyYyA9IGlmcmFtZS5zcmM7XG4gICAgICAgICAgaWZyYW1lLnNyYyA9ICcnO1xuICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gaWZyYW1lU3JjO1xuICAgICAgICAgICAgdGhpcy5fd2FpdElmcmFtZUxvYWQoaWZyYW1lKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LmlvcmFkUGFuZWxJZnJhbWVMb2FkZWQpIGhhbmRsZUxvYWQoKTsgLy8gKGZvciBwcmVmZXRjaGVkIGlmcmFtZSwgaW4gZW1iZWQpXG4gICAgICBlbHNlIGlmcmFtZS5vbmxvYWQgPSBoYW5kbGVMb2FkO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl93YWl0SWZyYW1lTG9hZFByb21pc2U7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9QYW5lbENvbnRyb2xsZXIuanMiLCJpbXBvcnQgbGFzdCBmcm9tIFwibG9kYXNoL2xhc3RcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwibG9kYXNoL3Rocm90dGxlXCI7XG5cbmltcG9ydCAqIGFzIGZyYW1lTWVzc2FnZXMgZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2ZyYW1lTWVzc2FnZXNcIjtcbmltcG9ydCBnZXRFbGVtZW50VmlzdWFsQm91bmRzIGZyb20gXCIuLi9nZXRFbGVtZW50VmlzdWFsQm91bmRzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsT2Zmc2V0IGZyb20gXCIuLi9nZXRXaW5kb3dTY3JvbGxPZmZzZXRcIjtcbmltcG9ydCB7IGxvY2F0ZUVsZW1lbnQgfSBmcm9tIFwiLi4vZWxlbWVudExvY2F0b3JcIjtcbmltcG9ydCB7IHNhZmVTZXRJbnRlcnZhbCB9IGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy90aW1lcnNcIjtcbmltcG9ydCB7IGdldERvY3VtZW50SGVpZ2h0IH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2RvY3VtZW50U2l6ZVwiO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlXCI7XG5pbXBvcnQgeyBnZXRGaWxlTG9nZ2VyIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2xvZ2dlclwiO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcbmltcG9ydCBlbGVtZW50T25Ub3AgZnJvbSBcIi4vZWxlbWVudE9uVG9wXCI7XG5pbXBvcnQgeyBjbG9zZXN0IH0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvZG9tJztcblxuLy8gU29tZSB1dGl0aWxpZXMgdGhhdCBJIHdhbnRlZCB0byBhdm9pZCBsb2FkaW5nIGZyb20gbG9kYXNoIGJlY2F1c2UgdGhpcyBnb2VzXG4vLyBpbnRvIHRoZSBwZXItZnJhbWUgYnVuZGxlXG5mdW5jdGlvbiBtYXhCeShhcnksIG1hcHBlcikge1xuICByZXR1cm4gYXJ5LnJlZHVjZSgoYSwgYikgPT4gbWFwcGVyKGIpID4gbWFwcGVyKGEpID8gYiA6IGEpO1xufVxuXG5mdW5jdGlvbiBldmVyeShhcnksIG1hcHBlcikge1xuICBmb3IgKHZhciB4IG9mIGFyeSlcbiAgICBpZiAoIW1hcHBlcih4KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc29tZShhcnksIG1hcHBlcikge1xuICBmb3IgKHZhciB4IG9mIGFyeSlcbiAgICBpZiAobWFwcGVyKHgpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3aXRob3V0KGFyeSwgaXRlbSkge1xuICByZXR1cm4gYXJ5LmZpbHRlcih4ID0+IHggIT09IGl0ZW0pO1xufVxuXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXggPSBcIlwiKSB7XG4gIHJldHVybiBwcmVmaXggKyB1bmlxdWVJZC5jb3VudGVyKys7XG59XG51bmlxdWVJZC5jb3VudGVyID0gMDtcblxuLy8gSnVzdCBoYW5kbGVzIHNpbXBsZSBvYmplY3RzXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAga2V5c0Euc29ydCgpO1xuICBrZXlzQi5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNBW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50SW5WaWV3cG9ydChkb2N1bWVudCwgZWwpIHtcbiAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIHJldHVybiByZWN0LnRvcCA+PSAwICYmXG4gICAgcmVjdC5sZWZ0ID49IDAgJiZcbiAgICBNYXRoLmZsb29yKHJlY3QuYm90dG9tKSA8PVxuICAgICAgKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAmJlxuICAgIE1hdGguZmxvb3IocmVjdC5yaWdodCkgPD1cbiAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpICYmXG4gICAgZWxlbWVudE9uVG9wKGVsLCByZWN0KTtcbn1cblxuY2xhc3MgUlBDVGltZW91dCBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobSkge1xuICAgIHN1cGVyKG0gfHwgXCJUaW1lb3V0XCIpO1xuICAgIHRoaXMucnBjdGltZW91dCA9IHRydWU7XG4gIH1cbn1cblxuY2xhc3MgRnJhbWVSUEMge1xuICBjb25zdHJ1Y3RvcihuYW1lc3BhY2UsIHRpbWVvdXQgPSA1MDAwKSB7XG4gICAgdGhpcy5fcGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX21ldGhvZHMgPSB7fTtcbiAgICB0aGlzLl9uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZnJhbWVNZXNzYWdlcy5vbk1lc3NhZ2UoXG4gICAgICBuYW1lc3BhY2UgKyBcIjpycGM6Y2FsbFwiLFxuICAgICAgdGhpcy5fcmVjZWl2ZUNhbGwuYmluZCh0aGlzKVxuICAgICk7XG4gICAgZnJhbWVNZXNzYWdlcy5vbk1lc3NhZ2UoXG4gICAgICBuYW1lc3BhY2UgKyBcIjpycGM6cmVzcG9uc2VcIixcbiAgICAgIHRoaXMuX3JlY2VpdmVSZXNwb25zZS5iaW5kKHRoaXMpXG4gICAgKTtcbiAgICBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZShcbiAgICAgIG5hbWVzcGFjZSArIFwiOnJwYzpoZWFydGJlYXRcIixcbiAgICAgIHRoaXMuX3JlY2VpdmVkSGVhcnRiZWF0LmJpbmQodGhpcylcbiAgICApO1xuICAgIHRoaXMuX3RpbWVvdXQgPSB0aW1lb3V0O1xuICB9XG5cbiAgX3JlY2VpdmVDYWxsKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIGFyZyB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgY29uc3Qgc2VuZCA9IChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICBmcmFtZU1lc3NhZ2VzLnNlbmQobWVzc2FnZS5mcmFtZUlkLCB0aGlzLl9uYW1lc3BhY2UgKyBcIjpycGM6cmVzcG9uc2VcIiwge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgICBzZW50ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICAgIGZyYW1lTWVzc2FnZXMuc2VuZChtZXNzYWdlLmZyYW1lSWQsIHRoaXMuX25hbWVzcGFjZSArIFwiOnJwYzpoZWFydGJlYXRcIiwge1xuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgaW4gdGhpcy5fbWV0aG9kcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbWV0aG9kc1xuICAgICAgICBbXG4gICAgICAgICAgbWV0aG9kXG4gICAgICAgIF0oYXJnLCB0aHJvdHRsZShoZWFydGJlYXQsIE1hdGgubWluKDUwMCwgdGhpcy5fdGltZW91dCAvIDEwKSwgeyBsZWFkaW5nOiBmYWxzZSB9KSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHNlbmQobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAgIHNlbmQoZXJyb3IudG9TdHJpbmcoKSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kKFwiUlBDIG1ldGhvZCBub3QgZm91bmRcIiwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgX3JlY2VpdmVSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgY29uc3QgeyBpZCwgcmVzdWx0LCBlcnJvciB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgIGlmIChpZCBpbiB0aGlzLl9wZW5kaW5nKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJSZWNlaXZlZCByZXNwb25zZSBmb3IgcGVuZGluZyBpZFwiLCBpZCk7XG4gICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dElkIH0gPSB0aGlzLl9wZW5kaW5nW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nW2lkXTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkdvdCBhIHJlc3BvbnNlIGZvciBhIGNhbGwgd2UgZG9uJ3QgaGF2aW5nIHBlbmRpbmdcIik7XG4gICAgfVxuICB9XG5cbiAgX3JlY2VpdmVkSGVhcnRiZWF0KG1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGlkIH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgdGhpcy5fcmVzZXRUaW1lb3V0KGlkKTtcbiAgICBpZiAoaWQgaW4gdGhpcy5fcGVuZGluZykge1xuICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLl9wZW5kaW5nW2lkXTtcbiAgICAgIGlmIChvcHRpb25zLmhlYXJ0YmVhdCkge1xuICAgICAgICBvcHRpb25zLmhlYXJ0YmVhdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZXNldFRpbWVvdXQoaWQpIHtcbiAgICBpZiAoIShpZCBpbiB0aGlzLl9wZW5kaW5nKSkgcmV0dXJuO1xuICAgIGNvbnN0IHsgb3B0aW9ucywgdGltZW91dEZuLCB0aW1lb3V0SWQsIG1ldGhvZCB9ID0gdGhpcy5fcGVuZGluZ1tpZF07XG4gICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgbG9nZ2VyLmluZm8oXCJSZXNldCB0aW1lb3V0IGluIEZyYW1lUlBDLCBpZFwiLCBpZCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgbmV3VGltZW91dElkID0gc2V0VGltZW91dChcbiAgICAgIHRpbWVvdXRGbixcbiAgICAgIG9wdGlvbnMudGltZW91dCA9PSBudWxsID8gdGhpcy5fdGltZW91dCA6IG9wdGlvbnMudGltZW91dFxuICAgICk7XG4gICAgdGhpcy5fcGVuZGluZ1tpZF0udGltZW91dElkID0gbmV3VGltZW91dElkO1xuICB9XG5cbiAgcmVnaXN0ZXIobWV0aG9kLCBmbikge1xuICAgIHRoaXMuX21ldGhvZHNbbWV0aG9kXSA9IGZuO1xuICB9XG5cbiAgLy8gT25seSB1c2UgdGhpcyB3aXRoIGRlc3RpbmF0aW9ucyB0aGF0IGluZGljYXRlIGEgc2luZ2xlIGZyYW1lXG4gIGNhbGwoZGVzdGluYXRpb24sIG1ldGhvZCwgYXJnLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSB1bmlxdWVJZCgpO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2FsbFwiLCBtZXRob2QsIFwid2l0aCBpZFwiLCBpZCk7XG4gICAgICBjb25zdCB0aW1lb3V0Rm4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChpZCBpbiB0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdbaWRdO1xuICAgICAgICAgIHJlamVjdChuZXcgUlBDVGltZW91dChcIlRpbWVvdXQ6IFwiICsgbWV0aG9kKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9wZW5kaW5nW2lkXSA9IHtcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICB0aW1lb3V0SWQ6IG51bGwsXG4gICAgICAgIHRpbWVvdXRGbixcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3Jlc2V0VGltZW91dChpZCk7XG4gICAgICBmcmFtZU1lc3NhZ2VzLnNlbmQoZGVzdGluYXRpb24sIHRoaXMuX25hbWVzcGFjZSArIFwiOnJwYzpjYWxsXCIsIHtcbiAgICAgICAgYXJnLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGlkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBSdW5zIGluIGFsbCBmcmFtZXMgKGluY2x1ZGluZyB0b3ApXG5jbGFzcyBMb2NhdG9yU2VhcmNoZXJOb2RlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcnBjID0gbmV3IEZyYW1lUlBDKFwiTG9jYXRvclNlYXJjaGVyTm9kZVwiKTtcbiAgICB0aGlzLl9ycGMucmVnaXN0ZXIoXCJzZWFyY2hcIiwgdGhpcy5zZWFyY2guYmluZCh0aGlzLCB3aW5kb3cuZG9jdW1lbnQpKTtcbiAgICB0aGlzLl9ycGMucmVnaXN0ZXIoXCJwaW5nXCIsIHRoaXMuX3BpbmdSZWNlaXZlZC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX2lzRG9tQ29udGVudExvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMubG9jYXRlZEVscyA9IFtdO1xuXG4gICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5fZnJhbWVSZXNwb25kcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fZG9tVmVyc2lvbiA9IERhdGUubm93KCk7XG4gIH1cblxuICBhc3luYyBfcGluZ1JlY2VpdmVkKCkge1xuICAgIHJldHVybiBcInBvbmdcIjtcbiAgfVxuXG4gIGFzeW5jIF9kb2VzRnJhbWVSZXNwb25kKGlmcmFtZSkge1xuICAgIC8vIFRPRE86IE1heWJlIHdlIHNob3VsZCByZWNoZWNrIGV2ZXJ5IHRpbWUgcGVyaW9kP1xuICAgIGlmICghdGhpcy5fZnJhbWVSZXNwb25kcy5oYXMoaWZyYW1lKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcnBjLmNhbGwoaWZyYW1lLmNvbnRlbnRXaW5kb3csIFwicGluZ1wiLCBudWxsLCB7XG4gICAgICAgICAgdGltZW91dDogMTAwMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZnJhbWVSZXNwb25kcy5zZXQoaWZyYW1lLCB7IHJlc3BvbmRzOiB0cnVlIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBlIGluc3RhbmNlIFJQQ1RpbWVvdXQgZG9lc24ndCB3b3JrIGhlcmUgZm9yIHNvbWUgcmVhc29uLiBUaGVcbiAgICAgICAgLy8gY29uc3RydWN0b3IgbmFtZSBvZiB0aGUgZXJyb3IgYWx3YXlzIHNlZW1zIHRvIGJlIFwiRXJyb3JcIi4gRnJvbVxuICAgICAgICAvLyBsb29raW5nIGF0IHRoZSBvdXRwdXQgc291cmNlIEkgKnRoaW5rKiBpdCdzIGEgYmFiZWwgYnVnIGJ1dCBJJ20gbm90XG4gICAgICAgIC8vIHN1cmUuIEFueXdheSwgSSdtIHVzaW5nIHRoZSAucnBjdGltZW91dCBwcm9wIGluc3RlYWQgb2YgYW4gaW5zdGFuY2VvZlxuICAgICAgICAvLyBjaGVjay5cbiAgICAgICAgaWYgKGUucnBjdGltZW91dCkge1xuICAgICAgICAgIHRoaXMuX2ZyYW1lUmVzcG9uZHMuc2V0KGlmcmFtZSwgeyByZXNwb25kczogZmFsc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZnJhbWVSZXNwb25kcy5nZXQoaWZyYW1lKS5yZXNwb25kcztcbiAgfVxuXG4gIF9zZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2lzRG9tQ29udGVudExvYWRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9ub3RpZnlGcmFtZUNoYW5nZSgpO1xuICAgIH0pO1xuICAgIGlmIChcbiAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiXG4gICAgKSB7XG4gICAgICB0aGlzLl9pc0RvbUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhaXQgZm9yIGNoYW5nZXMgaW4gdGhlIGhyZWYgKHBvc3NpYmxlIGluIG1vcmUgcGxhY2VzIHRoYW4ganVzdFxuICAgIC8vIHRoZSBoYXNoIGJlY2F1c2Ugb2YgaGlzdG9yeSBhcGkpXG4gICAgbGV0IGN1cnJlbnRIcmVmID0gbnVsbDtcbiAgICBzYWZlU2V0SW50ZXJ2YWwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gZG9jdW1lbnQubG9jYXRpb247XG4gICAgICAgIGlmIChocmVmICE9PSBjdXJyZW50SHJlZikge1xuICAgICAgICAgIGN1cnJlbnRIcmVmID0gaHJlZjtcbiAgICAgICAgICB0aGlzLl9ub3RpZnlGcmFtZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgNTAwXG4gICAgKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInNjcm9sbFwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9ub3RpZnlGcmFtZUNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgW1wicmVzaXplXCJdLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIHRocm90dGxlKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeUZyYW1lQ2hhbmdlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAyMDBcbiAgICAgICAgKSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keSB8fCAhdGhpcy5sb2NhdGVkRWxzKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5sb2NhdGVkRWxzLmxlbmd0aCAmJiB0aGlzLmxvY2F0ZWRFbHNbMF0uZWxzLmZpbmQoZWwgPT4gIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKSkge1xuICAgICAgICAvLyBhIGxvY2F0ZWQgZWxlbWVudCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgICAgLy8gTk9URTogdXNlIHJlc2V0IG9wdGlvbiBpbiBjYXNlIHRoZSBcInNhbWVcIiBlbGVtZW50IGlzIGFkZGVkIGxhdGVyIChzZWUgIzkyMylcbiAgICAgICAgdGhpcy5fZG9tVmVyc2lvbiA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeUZyYW1lQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICgpID0+IHtcbiAgICAgICAgZnJhbWVNZXNzYWdlcy5zZW5kKGZyYW1lTWVzc2FnZXMuVE9QLCBcIkNvbnRlbnRQbGF5ZXI6bW91c2Vkb3duXCIpO1xuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgX25vdGlmeUZyYW1lQ2hhbmdlKG9wdGlvbnMpIHtcbiAgICBmcmFtZU1lc3NhZ2VzLnNlbmQoZnJhbWVNZXNzYWdlcy5UT1AsIFwiTG9jYXRvclNlYXJjaGVyTm9kZTpmcmFtZUNoYW5nZVwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlzR29vZEVsZW1lbnQoZWwpIHtcbiAgICBpZiAoIWVsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSByZXR1cm4gc29tZShlbCwgZWwgPT4gdGhpcy5pc0dvb2RFbGVtZW50KGVsKSk7XG4gICAgaWYgKGVsID09PSB3aW5kb3cpIHJldHVybiB0cnVlO1xuICAgIC8vIEkndmUgcmVtb3ZlZCB0aGUgZG9jdW1lbnQuY29udGFpbnMgY2hlY2sgYmVjYXVzZSB3ZSBzb21ldGltZXMgbG9vayBpbnNpZGVcbiAgICAvLyBzYW1lIG9yaWdpbiBpZnJhbWVzIC10b21cbiAgICAvLyBpZiAoIWRvY3VtZW50LmNvbnRhaW5zKGVsKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gTm90ZTogd2UgdXNlIHRoaXMgJ2V2ZXJ5JyBhcHByb2FjaCBzaW5jZVxuICAgIC8vIGJvdW5kcyBwcm9wZXJ0eSBhcmUgbm90IGVudW1lcmFibGVzIChhcmUgdmlydHVhbHMpXG4gICAgLypjb25zdCBib3VuZHMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZXZlcnkoW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSwgYiA9PiBib3VuZHNbYl0gPT09IDApKVxuICAgICAgcmV0dXJuIGZhbHNlOyovXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnRWaXNpYmxlKGRvY3VtZW50LCBlbCkge1xuICAgIGlmICghdGhpcy5pc0dvb2RFbGVtZW50KGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghZWxlbWVudEluVmlld3BvcnQoZG9jdW1lbnQsIGVsKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBhc3luYyBzZWFyY2goZG9jdW1lbnQsIG9wdGlvbnMsIHNlbmRIZWFydGJlYXQgPSAoKSA9PiB7fSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcInNlYXJjaDogc2VhcmNoIGluIGRvY3VtZW50XCIsIGRvY3VtZW50KTtcblxuICAgIGlmICghdGhpcy5faXNEb21Db250ZW50TG9hZGVkKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJzZWFyY2g6IGRvbSBjb250ZW50IG5vdCBsb2FkZWRcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaXMgdGhpcyBhIHplcm8gaGVpZ2h0IGZyYW1lP1xuICAgIGlmIChnZXREb2N1bWVudEhlaWdodCgpIDw9IDgpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcInNlYXJjaDogbm8gaGVpZ2h0IGZyYW1lXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaWZyYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlmcmFtZVwiKVxuICAgICk7XG4gICAgY29uc3QgeyBvZmZzZXQsIGZyYW1lSWQgfSA9IG9wdGlvbnM7XG5cbiAgICBzZW5kSGVhcnRiZWF0KCk7XG5cbiAgICBjb25zdCBjYW5kaWRhdGVzID0gKGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgaWZyYW1lcy5tYXAoYXN5bmMgaWZyYW1lID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGJlbG9uZ3MgdG8gdGhlIGV4dGVuc2lvbiB0aGVuIGlnbm9yZSBpdFxuICAgICAgICBjb25zdCBpc0V4dGVuc2lvbkJhc2VVcmwgPSBpZnJhbWUuc3JjLnN0YXJ0c1dpdGgoXG4gICAgICAgICAgXCJjaHJvbWUtZXh0ZW5zaW9uOi8vXCJcbiAgICAgICAgKSB8fFxuICAgICAgICAgIGlmcmFtZS5zcmMuc3RhcnRzV2l0aChcIm1zLWJyb3dzZXItZXh0ZW5zaW9uOi8vXCIpIHx8XG4gICAgICAgICAgaWZyYW1lLnNyYy5zdGFydHNXaXRoKFwibW96LWV4dGVuc2lvbjovL1wiKTtcbiAgICAgICAgaWYgKGlzRXh0ZW5zaW9uQmFzZVVybCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEVsZW1lbnRWaXN1YWxCb3VuZHMoaWZyYW1lKTtcbiAgICAgICAgY29uc3QgZnJhbWVPcHRpb25zID0ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgZGVwdGg6IG9wdGlvbnMuZGVwdGggKyAxLFxuICAgICAgICAgIG9mZnNldDogeyB4OiBib3VuZHMueCArIG9mZnNldC54LCB5OiBib3VuZHMueSArIG9mZnNldC55IH0sXG4gICAgICAgICAgZnJhbWVJZDogZnJhbWVJZCA9PT0gZnJhbWVNZXNzYWdlcy5mcmFtZUlkID8gdW5kZWZpbmVkIDogZnJhbWVJZCAvLyByZXNldCBmcmFtZUlkIHNvIHRoYXQgd2UgY2FuIGFsc28gc2VhcmNoIG9uIGl0cyBzdWIgZnJhbWVzXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJcyBjb2RlIHJ1bm5pbmcgaW5zaWRlIHRoZSBpZnJhbWUgcmVzcG9uZGluZz9cbiAgICAgICAgICBpZiAoYXdhaXQgdGhpcy5fZG9lc0ZyYW1lUmVzcG9uZChpZnJhbWUpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgIFwic2VhcmNoOiBpZnJhbWUgcmVzcG9uZHMgdG8gbWVzc2FnZXMsIGNhbGxpbmcgdmlhIHJwY1wiLFxuICAgICAgICAgICAgICBpZnJhbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcnBjLmNhbGwoXG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LFxuICAgICAgICAgICAgICBcInNlYXJjaFwiLFxuICAgICAgICAgICAgICBmcmFtZU9wdGlvbnMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBoZWFydGJlYXQ6IHNlbmRIZWFydGJlYXQgLy8gRm9yd2FyZCBoZWFydGJlYXQgc2lnbmFscyB1cCB0aGUgY2hhaW5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90IHJlc3BvbmRpbmcuIEJ1dCBtYXliZSB3ZSBjYW4gYWNjZXNzIGRpcmVjdGx5IGludG8gdGhlIGZyYW1lP1xuICAgICAgICAgICAgLy8gKHdpbGwgd29yayBpZiB0aGUgZnJhbWUgaXMgc2FtZSBvcmlnaW4uIFRoaXMgaXMgb2Z0ZW4gdXNlZnVsIGluXG4gICAgICAgICAgICAvLyBXaWRnZXQgbW9kZSwgY2FuJ3QgdGhpbmsgd2hlbiBpdCdkIGV2ZXIgYmUgdXNlZCBpbiBleHRlbnNpb24gbW9kZVxuICAgICAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3QgaHVydClcbiAgICAgICAgICAgIGxldCBmcmFtZURvY3VtZW50O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcInNlYXJjaDogY2FsbGluZyB2aWEgZGlyZWN0IGFjY2VzcyBmb3IgZnJhbWVcIixcbiAgICAgICAgICAgICAgICBpZnJhbWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gV2Ugd2VyZW4ndCBhbGxvd2VkIHRvIGFjY2VzcyB0aGUgZG9jdW1lbnQgKGNyb3NzIG9yaWdpbiksIHNvIGlnbm9yZSB0aGlzIGZyYW1lXG4gICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcInNlYXJjaDogY2FuJ3QgYWNjZXNzIGZyYW1lLCBpZ25vcmluZ1wiLCBpZnJhbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlYXJjaChcbiAgICAgICAgICAgICAgZnJhbWVEb2N1bWVudCxcbiAgICAgICAgICAgICAgZnJhbWVPcHRpb25zLFxuICAgICAgICAgICAgICBzZW5kSGVhcnRiZWF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkdvdCBlcnJvciBmcm9tIGNoaWxkIHNlYXJjaCBjYWxsOiBcIiArIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZW5kSGVhcnRiZWF0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKSkuZmlsdGVyKHggPT4geCAhPSBudWxsKTtcblxuICAgIGxldCBiZXN0Q2FuZGlkYXRlID0gY2FuZGlkYXRlcy5sZW5ndGggPiAwXG4gICAgICA/IG1heEJ5KGNhbmRpZGF0ZXMsIGMgPT4gYy5zY29yZSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChiZXN0Q2FuZGlkYXRlKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJzZWFyY2g6IGdvdCBjYW5kaWRhdGVcIiwgYmVzdENhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gU2VlIGlmIHdlIGNhbiBmaW5kIChiZXR0ZXIpIGNhbmRpZGF0ZXMgb24gdGhpcyBmcmFtZSBpdHNlbGZcbiAgICB7XG4gICAgICBsZXQgbG9jYXRvckRhdGE7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBmcmFtZUlkICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGZyYW1lSWQgIT09IGZyYW1lTWVzc2FnZXMuZnJhbWVJZCAmJlxuICAgICAgICB0aGlzLmxvY2F0b3JEYXRhXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBmcmFtZSBkaWRuJ3QgY2hhbmdlLCBqdXN0IHJldXNlIHRoZSBvbGQgcmVzdWx0XG4gICAgICAgIGxvY2F0b3JEYXRhID0gdGhpcy5sb2NhdG9yRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0b3JEYXRhID0gdGhpcy5sb2NhdG9yRGF0YSA9IGxvY2F0ZUVsZW1lbnQob3B0aW9ucy5sb2NhdG9yLCB7XG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgbXVsdGlwbGVNYXRjaGVzOiBvcHRpb25zLm11bHRpcGxlTWF0Y2hlc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAoYmVzdENhbmRpZGF0ZSA9PSBudWxsIHx8IGxvY2F0b3JEYXRhLnNjb3JlID4gYmVzdENhbmRpZGF0ZS5zY29yZSkgJiZcbiAgICAgICAgbG9jYXRvckRhdGEuZWwgJiZcbiAgICAgICAgdGhpcy5pc0dvb2RFbGVtZW50KGxvY2F0b3JEYXRhLmVsKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IEFycmF5LmlzQXJyYXkobG9jYXRvckRhdGEuZWwpXG4gICAgICAgICAgPyBsb2NhdG9yRGF0YS5lbFxuICAgICAgICAgIDogW2xvY2F0b3JEYXRhLmVsXTtcbiAgICAgICAgY29uc3QgbG9jYXRvcklkID0gdW5pcXVlSWQoZnJhbWVNZXNzYWdlcy5mcmFtZUlkKTtcblxuICAgICAgICAvLyBtYWtlIHRoZW0gdmlzaWJsZSBiZWZvcmUgY2FsY3VsYXRpbmcgYm91bmRzXG4gICAgICAgIC8vIChvciB0aGV5IHdpbGwgYmUgMClcbiAgICAgICAgdGhpcy5tYWtlQW5jZXN0b3JzVmlzaWJsZShlbHMpO1xuXG4gICAgICAgIHRoaXMubG9jYXRlZEVscyA9IFt7IGVscywgbG9jYXRvcklkIH0sIC4uLnRoaXMubG9jYXRlZEVsc10uc2xpY2UoMCwgMyk7IC8vIEtlZXAgdGhlIGxhc3QgMyBhcm91bmRcblxuICAgICAgICBiZXN0Q2FuZGlkYXRlID0ge1xuICAgICAgICAgIGxvY2F0b3JJZCxcbiAgICAgICAgICAuLi5sb2NhdG9yRGF0YSxcbiAgICAgICAgICBlbDogISFsb2NhdG9yRGF0YS5lbCxcbiAgICAgICAgICBmcmFtZUlkOiBmcmFtZU1lc3NhZ2VzLmZyYW1lSWQsXG4gICAgICAgICAgZG9tVmVyc2lvbjogdGhpcy5fZG9tVmVyc2lvbixcbiAgICAgICAgICBlbGVtZW50Qm91bmRzOiBlbHMubWFwKGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyhlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlID0gdGhpcy5lbGVtZW50VmlzaWJsZShkb2N1bWVudCwgZWwpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IGJvdW5kcyB0byB0aGUgcmVmZXJlbmNlIGZyYW1lIG9mIHRoZSByb290IGZyYW1lXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiB4ICsgb2Zmc2V0LngsXG4gICAgICAgICAgICAgIHk6IHkgKyBvZmZzZXQueSxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgdmlzaWJsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcInNlYXJjaDogZm91bmQgYmV0dGVyIGNhbmRpZGF0ZVwiLCBiZXN0Q2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdENhbmRpZGF0ZTtcbiAgfVxuXG4gIC8vIEV4cGVyaW1lbnRhbCwgc2VlICM5NjBcbiAgbWFrZUFuY2VzdG9yc1Zpc2libGUoZWxlbWVudHMpIHtcbiAgICBjb25zdCBydWxlcyA9IHtcbiAgICAgIGRpc3BsYXk6IFsnbm9uZScsICdpbmxpbmUtYmxvY2snXSxcbiAgICAgIG9wYWNpdHk6IFsnMCcsICcxJ10sXG4gICAgICB2aXNpYmlsaXR5OiBbJ2hpZGRlbicsICd2aXNpYmxlJ10sXG4gICAgICBoZWlnaHQ6IFsnMHB4JywgJ2F1dG8nXVxuICAgIH07XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGNsb3Nlc3QoZWwucGFyZW50RWxlbWVudCwgcGFyZW50RWwgPT4ge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudEVsKTtcbiAgICAgICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2gocHJvcE5hbWUgPT4ge1xuICAgICAgICAgIC8vY29uc29sZS5sb2cocGFyZW50RWwsIHByb3BOYW1lLCBjb21wdXRlZFN0eWxlc1twcm9wTmFtZV0pO1xuICAgICAgICAgIGNvbnN0IFtoaWRkZW5WYWx1ZSwgdmlzaWJsZVZhbHVlXSA9IHJ1bGVzW3Byb3BOYW1lXTtcbiAgICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZXNbcHJvcE5hbWVdID09PSBoaWRkZW5WYWx1ZSkge1xuICAgICAgICAgICAgcGFyZW50RWwuc3R5bGVbcHJvcE5hbWVdID0gdmlzaWJsZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSEFDSzogdXNlIGNsb3Nlc3QoKSBhcyBhIGZvckVhY2ggZm9yIGFuY2VzdG9yc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gT25seSBydW5zIGluIHRoZSB0b3AgZnJhbWVcbmNsYXNzIExvY2F0b3JTZWFyY2hlckNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnBlbmRpbmdTZWFyY2hlcyA9IFtdO1xuICB9XG5cbiAgLy8gVGFrZXMgYSBsb2NhdG9yIGFuZCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgYXN5bmMgc2VhcmNoKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nU2VhcmNoZXMuZmluZCgoW28sIHBdKSA9PlxuICAgICAgZGVlcEVxdWFsKG8sIG9wdGlvbnMpKTtcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgcmV0dXJuIHBlbmRpbmdbMV07XG4gICAgfVxuXG4gICAgLy8gV2Ugd2FudCB0byBvbmx5IGJlIGRvaW5nIG9uZSBzZWFyY2ggYXQgYSB0aW1lIChpdCdzIHRvbyBpbnRlbnNpdmVcbiAgICAvLyBvdGhlcndpc2UpXG4gICAgY29uc3QgbGFzdFBlbmRpbmcgPSBsYXN0KHBlbmRpbmcpO1xuICAgIGNvbnN0IGxhc3RQZW5kaW5nUHJvbWlzZSA9IGxhc3RQZW5kaW5nID8gbGFzdFBlbmRpbmdbMV0gOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBwcm9taXNlID0gbGFzdFBlbmRpbmdQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVxuICAgICAgICAuc2VhcmNoKHdpbmRvdy5kb2N1bWVudCwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgb2Zmc2V0OiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICBkZXB0aDogMFxuICAgICAgICB9KVxuICAgICAgICAudGhlbihsb2NhdG9yRGF0YSA9PiB7XG4gICAgICAgICAgaWYgKGxvY2F0b3JEYXRhICYmIGxvY2F0b3JEYXRhLmVsZW1lbnRCb3VuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0V2luZG93U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Qm91bmRzID0gbG9jYXRvckRhdGEuZWxlbWVudEJvdW5kcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmxvY2F0b3JEYXRhLFxuICAgICAgICAgICAgICBlbGVtZW50Qm91bmRzOiBlbGVtZW50Qm91bmRzLm1hcChiID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uYixcbiAgICAgICAgICAgICAgICB4OiBiLnggKyB4LFxuICAgICAgICAgICAgICAgIHk6IGIueSArIHlcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbG9jYXRvckRhdGE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gW29wdGlvbnMsIHByb21pc2VdO1xuICAgIHRoaXMucGVuZGluZ1NlYXJjaGVzLnB1c2gocGVuZGluZ0l0ZW0pO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gV2lsbCBhbHdheXMgYmUgdGhlIGZpcnN0IG9uZSBzbyB3ZSBjb3VsZCBqdXN0IHVzZSBhIHNsaWNlIGhlcmUgYXNzdW1pbmdcbiAgICAgIC8vIHdlJ3JlIHN0aWxsIG9ubHkgYWxsb3dpbmcgb25lIHNlYXJjaCB0byBoYXBwZW4gYXQgb25jZSwgYnV0IGxldCdzIGJlIGFcbiAgICAgIC8vIGJpdCBtb3JlIHJvYnVzdCB0byBmdXR1cmUgY29kZSBjaGFuZ2VzIDopXG4gICAgICB0aGlzLnBlbmRpbmdTZWFyY2hlcyA9IHdpdGhvdXQodGhpcy5wZW5kaW5nU2VhcmNoZXMsIHBlbmRpbmdJdGVtKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgTG9jYXRvclNlYXJjaGVySW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgaXNUb3BGcmFtZSA9IHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdztcbiAgICB0aGlzLl9ycGMgPSBuZXcgRnJhbWVSUEMoXCJMb2NhdG9yU2VhcmNoZXJJbnRlcmZhY2VcIik7XG5cbiAgICB0aGlzLl9ub2RlID0gbmV3IExvY2F0b3JTZWFyY2hlck5vZGUoKTtcblxuICAgIGlmIChpc1RvcEZyYW1lKSB7XG4gICAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IExvY2F0b3JTZWFyY2hlckNvbnRyb2xsZXIodGhpcy5fbm9kZSk7XG4gICAgICB0aGlzLl9ycGMucmVnaXN0ZXIoXG4gICAgICAgIFwic2VhcmNoXCIsXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIuc2VhcmNoLmJpbmQodGhpcy5fY29udHJvbGxlcilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9va3VwIHRoZSBhY3R1YWwgZWxlbWVudHMgZm9yIGEgZ2l2ZW4gbG9jYXRvcklkIChvbmx5IHdvcmtzIGlmIHRoZSBsb2NhdG9yXG4gIC8vIHdhcyBpbiB0aGlzIGZyYW1lIEFORCBpZiB3YXMgMyBzZWFyY2hlcyBhZ28gb3IgbGVzcylcbiAgZ2V0RWxzKGxvY2F0b3JJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzLl9ub2RlLmxvY2F0ZWRFbHMuZmluZCh4ID0+IHgubG9jYXRvcklkID09PSBsb2NhdG9ySWQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGZvdW5kLmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHNlYXJjaChsb2NhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBBcyBhbiBvcHRpbWlzYXRpb24gd2Ugc2tpcCB0aGUgUlBDIGNhbGwgd2hlbiB3ZSdyZSBhbHJlYWR5IGF0IHRoZSByb290XG4gICAgaWYgKHRoaXMuX2NvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyLnNlYXJjaCh7IGxvY2F0b3IsIC4uLm9wdGlvbnMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9ycGMuY2FsbChmcmFtZU1lc3NhZ2VzLlRPUCwgXCJzZWFyY2hcIiwge1xuICAgICAgICBsb2NhdG9yLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgRFVQRV9DSEVDS19LRVkgPSBuYW1lc3BhY2UoXCJMb2NhdG9yU2VhcmNoZXItbG9hZGVkXCIpO1xuaWYgKHdpbmRvd1tEVVBFX0NIRUNLX0tFWV0pIHtcbiAgLy8gV2VicGFjayBDb21tb25zQ2h1bmtQbHVnaW4gc2hvdWxkIGVuc3VyZSB0aGlzLCBidXQgaXQnbGwgY2F1c2UgY3JhenkgaGFyZFxuICAvLyB0byBmaW5kIGJ1Z3MgaWYgaXQgYnJlYWtzXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIklPUkFEOiBTaG91bGQgYmUgb25seSBvbmUgaW5zdGFuY2Ugb2YgbG9jYXRvcnNlYXJjaGVyIHBlciBjb250ZW50XCJcbiAgKTtcbn1cbndpbmRvd1tEVVBFX0NIRUNLX0tFWV0gPSB0cnVlO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgTG9jYXRvclNlYXJjaGVySW50ZXJmYWNlKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL0xvY2F0b3JTZWFyY2hlci5qcyIsImltcG9ydCB7IGxvY2F0ZUVsZW1lbnQgfSBmcm9tICcuLi9lbGVtZW50TG9jYXRvcic7XG5pbXBvcnQgZXhwYW5kTWFya2VyIGZyb20gJy4uLy4uL2NvbW1vbi91dGlscy9leHBhbmRNYXJrZXInO1xuaW1wb3J0IHJnYlRvQXJyYXkgZnJvbSAnLi4vLi4vY29tbW9uL3V0aWxzL3JnYlRvQXJyYXknO1xuaW1wb3J0IHJnYmFUb0FycmF5IGZyb20gJy4uLy4uL2NvbW1vbi91dGlscy9yZ2JhVG9BcnJheSc7XG5pbXBvcnQgZXZlcnkgZnJvbSAnbG9kYXNoL2V2ZXJ5JztcbmltcG9ydCBmbG93UmlnaHQgZnJvbSAnbG9kYXNoL2Zsb3dSaWdodCc7XG5pbXBvcnQgbWFwVmFsdWVzIGZyb20gJ2xvZGFzaC9tYXBWYWx1ZXMnO1xuaW1wb3J0IHRpbWVzIGZyb20gJ2xvZGFzaC90aW1lcyc7XG5pbXBvcnQgdG9QYWlycyBmcm9tICdsb2Rhc2gvdG9QYWlycyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJ2xvZGFzaC92YWx1ZXMnO1xuaW1wb3J0IGhlYWQgZnJvbSAnbG9kYXNoL2hlYWQnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IGdldEVsZW1lbnRWaXN1YWxCb3VuZHMgZnJvbSAnLi4vZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyc7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZSc7XG5pbXBvcnQgeyB0b29sVHlwZVRvU3ZnIH0gZnJvbSAnYmFzZS9jb21tb24vc3ZnSW5saW5lL3Rvb2xzJztcbmltcG9ydCBwYXJzZUNvbG9yIGZyb20gJ3BhcnNlLWNvbG9yJztcblxuY29uc3QgZGVsYXkgPSAobXMpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG5leHBvcnQgY29uc3QgU0VMRUNUT1JfSUQgPSBuYW1lc3BhY2UoJ2luLXBhZ2Utc2VsZWN0b3ItJyk7XG5jb25zdCBkaXJlY3Rpb25zID0gWyd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnXTtcbmNvbnN0IGNsYXNzTmFtZSA9IChzKSA9PiBTRUxFQ1RPUl9JRCArIHM7IC8vIGF2b2lkIGNvbmZsaWN0c1xuXG5jb25zdCBESVNBQkxFRF9PUEFDSVRZID0gJzEnO1xuY29uc3QgRU5BQkxFRF9PUEFDSVRZID0gJzEnO1xuY29uc3QgQkdfT1BBQ0lUWSA9ICcwLjInO1xuXG5mdW5jdGlvbiBhZGRDb2xvck9wYWNpdHkoYm9yZGVyQ29sb3IsIG9wYWNpdHkpIHtcbiAgbGV0IHJnYmFBcnJheTtcblxuICBpZiAoYm9yZGVyQ29sb3Iuc3RhcnRzV2l0aCgncmdiKCcpKSB7XG4gICAgcmdiYUFycmF5ID0gcmdiVG9BcnJheShib3JkZXJDb2xvcikuY29uY2F0KFtvcGFjaXR5XSk7XG4gIH0gZWxzZSBpZiAoYm9yZGVyQ29sb3Iuc3RhcnRzV2l0aCgncmdiYSgnKSkge1xuICAgIHJnYmFBcnJheSA9IHJnYmFUb0FycmF5KGJvcmRlckNvbG9yKTtcbiAgICByZ2JhQXJyYXlbcmdiYUFycmF5Lmxlbmd0aCAtIDFdID0gb3BhY2l0eTtcbiAgfVxuXG4gIHJldHVybiBgcmdiYSgke3JnYmFBcnJheS5qb2luKCcsICcpfSlgO1xufVxuXG5mdW5jdGlvbiBzdW1DU1NQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMucmVkdWNlKChjb3VudCwgcHJvcCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVtwcm9wXSwgMTApO1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiBjb3VudDtcbiAgICByZXR1cm4gY291bnQgKyB2YWx1ZTtcbiAgfSwgMCk7XG59XG5cbmNvbnN0IHNlbGVjdG9yU3R5bGUgPSAodHlwZSwgaW5kZXgpID0+ICh7XG4gICdwb2ludGVyLWV2ZW50cyc6ICdub25lJyxcbiAgJ2JvcmRlci13aWR0aCc6ICh0eXBlID09PSAnUFJFVklFVycgPyAnM3B4JyA6ICc2cHgnKSxcbiAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAndHJhbnNpdGlvbic6ICdhbGwgMC41cyBlYXNlLWluLW91dCcsXG4gICd0cmFuc2l0aW9uJzogJ3Zpc2liaWxpdHkgMHMnLFxuICAnei1pbmRleCc6IFN0cmluZygyMTQ3NTgyOTk2IC0gaW5kZXgpLFxuICAnd2hpdGUtc3BhY2UnOiAnbm93cmFwJyxcbn0pO1xuY29uc3QgaW5mb1N0eWxlID0gKHR5cGUpID0+ICh7XG4gICdkaXNwbGF5JzogKHR5cGUgPT09ICdQUkVWSUVXJykgPyAnbm9uZScgOiAnJyxcbiAgJ2hlaWdodCc6ICc0MHB4JyxcbiAgJ3BhZGRpbmcnOiAnNXB4JyxcbiAgJ3BhZGRpbmctcmlnaHQnOiAnMTBweCcsXG4gICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAnYm94LXNoYWRvdyc6ICcwcHggMTBweCAzNXB4IDVweCByZ2JhKDAsMCwwLDAuMTMpJyxcbiAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbWF4LWhlaWdodCwgbWF4LXdpZHRoLCBwYWRkaW5nLCBib3R0b20sIHRvcCwgbGVmdCwgcmlnaHQnLFxuICAndHJhbnNpdGlvbi1kdXJhdGlvbic6ICcuM3MnLFxufSk7XG5jb25zdCBpY29uU3R5bGUgPSAoKSA9PiAoe1xuICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6ICdjZW50ZXIgY2VudGVyJyxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6ICcxMDAlJyxcbiAgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcsXG4gICd2ZXJ0aWNhbC1hbGlnbic6ICdib3R0b20nLFxufSk7XG5cbmNvbnN0IHR5cGVUb1RleHQgPSAodHlwZSwgaXNNb2JpbGUsIHsgZGJsQ2xpY2sgPSBmYWxzZSB9KSA9PiAoe1xuICBSRUFEOiAnUmVhZCcsXG4gIExFRlRfQ0xJQ0s6IGlzTW9iaWxlID8gJ1RhcCcgOiAoZGJsQ2xpY2sgPyAnRG91YmxlY2xpY2snIDogJ0NsaWNrJyksXG4gIFJJR0hUX0NMSUNLOiBpc01vYmlsZSA/ICdUYXAnIDogJ1JpZ2h0IGNsaWNrJyxcbiAgU0NST0xMOiAnU2Nyb2xsJyxcbiAgVFlQSU5HOiAnVHlwZScsXG4gIERSQUc6ICdEcmFnJyxcbiAgRFJPUDogJ0Ryb3AnLFxuICBIT1ZFUjogJ0hvdmVyJyxcbn0pW3R5cGVdO1xuXG5jb25zdCBhcHBlbmRJbXBvcnRhbnQgPSAocykgPT4gYCR7c30gIWltcG9ydGFudGA7XG5jb25zdCBtYWtlU3R5bGVJbXBvcnRhbnQgPSAoc3R5bGUpID0+IG1hcFZhbHVlcyhzdHlsZSwgYXBwZW5kSW1wb3J0YW50KTtcbmNvbnN0IHN0eWxlT2JqVG9TdHJpbmcgPSAobykgPT4gdG9QYWlycyhvKS5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn07YCkuam9pbignJyk7XG5jb25zdCBzdHlsZU9ialRvSW1wb3J0YW50U3RyaW5nID0gZmxvd1JpZ2h0KHN0eWxlT2JqVG9TdHJpbmcsIG1ha2VTdHlsZUltcG9ydGFudCk7XG5cbmZ1bmN0aW9uIG1ha2VNYXJrZXJJbmZvKHR5cGUsIGNvbG9yID0gJycsIGlzTW9iaWxlLCBvcHRzKSB7XG4gIGNvbnN0IFtpbmZvRWwsIGljb24sIHRleHRdID1cbiAgICB0aW1lcygzLCAoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIGluZm9FbC5jbGFzc05hbWUgPSBjbGFzc05hbWUoJ21hcmtlci1pbmZvJyk7XG4gIGluZm9FbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGVPYmpUb0ltcG9ydGFudFN0cmluZyhpbmZvU3R5bGUodHlwZSkpKTtcbiAgaWYgKGNvbG9yKSB7XG4gICAgaW5mb0VsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIGluZm9FbC5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yOyAvLyB0aGUgYXJyb3cgaW5oZXJpdHMgdGhpc1xuICB9XG4gIGljb24uY2xhc3NOYW1lID0gY2xhc3NOYW1lKCdpY29uJyk7XG4gIGljb24uc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlT2JqVG9JbXBvcnRhbnRTdHJpbmcoaWNvblN0eWxlKCkpKTtcbiAgY29uc3Qgc3ZnQmdTdHlsZSA9IGNvbG9yID8gYGZpbGw6ICR7Y29sb3J9ICFpbXBvcnRhbnQ7YCA6ICcnO1xuICBjb25zdCBzdmdTdHlsZSA9IGBnLmlvcmFkLXRvb2wtaWNvbiAqeyR7c3ZnQmdTdHlsZX19Zy5pb3JhZC10b29sLWljb24gLmZpbGx7ZmlsbDogI2ZmZiAhaW1wb3J0YW50fWA7XG4gIGNvbnN0IGljb25TdmcgPSB0b29sVHlwZVRvU3ZnKHR5cGUpO1xuICBpY29uLmlubmVySFRNTCA9IGljb25TdmcgPyBpY29uU3ZnKHsgc3R5bGVzOiBzdmdTdHlsZSB9KSA6ICcnO1xuICB0ZXh0LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSgndGV4dCcpO1xuICB0ZXh0LmlubmVySFRNTCA9IHR5cGVUb1RleHQodHlwZSwgaXNNb2JpbGUsIG9wdHMpIHx8IHR5cGUucmVwbGFjZSgnXycsICcgJyk7XG4gIFtpY29uLCB0ZXh0XS5tYXAoZWwgPT4gaW5mb0VsLmFwcGVuZENoaWxkKGVsKSk7XG5cbiAgcmV0dXJuIGluZm9FbDtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZU1hcmtlckluZm8oaW5mbywgcG9zaXRpb24pIHtcbiAgaWYgKCFwb3NpdGlvbiB8fCBwb3NpdGlvbiA9PT0gJ2hpZGUnKSByZXR1cm47XG4gIGNvbnN0IHZlcnRpY2FsU3RhcnQgPSB7XG4gICAgbWF4SGVpZ2h0OiAnMCcsXG4gICAgcGFkZGluZ1RvcDogJzAnLFxuICAgIHBhZGRpbmdCb3R0b206ICcwJyxcbiAgfTtcbiAgY29uc3QgdmVydGljYWxBZnRlclN0YXJ0ID0ge1xuICAgIG1heEhlaWdodDogJzQwcHgnLFxuICAgIHBhZGRpbmdUb3A6ICc1cHgnLFxuICAgIHBhZGRpbmdCb3R0b206ICc1cHgnLFxuICB9O1xuICBjb25zdCBob3Jpem9udGFsID0ge1xuICAgIHN0YXJ0OiB7XG4gICAgICBtYXhXaWR0aDogJzAnLFxuICAgICAgcGFkZGluZ0xlZnQ6ICcwJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJzAnLFxuICAgIH0sXG4gICAgYWZ0ZXJTdGFydDoge1xuICAgICAgbWF4V2lkdGg6ICcxMTVweCcsXG4gICAgICBwYWRkaW5nTGVmdDogJzVweCcsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcxMHB4JyxcbiAgICB9LFxuICB9O1xuICBjb25zdCBzdHlsZXMgPSB7XG4gICAgdG9wOiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICAuLi52ZXJ0aWNhbFN0YXJ0LFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgIH0sXG4gICAgICBhZnRlclN0YXJ0OiB7XG4gICAgICAgIC4uLnZlcnRpY2FsQWZ0ZXJTdGFydCxcbiAgICAgICAgdG9wOiBpbmZvLnN0eWxlLnRvcCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHN0YXJ0OiB7XG4gICAgICAgIC4uLnZlcnRpY2FsU3RhcnQsXG4gICAgICAgIGJvdHRvbTogJzAnLFxuICAgICAgfSxcbiAgICAgIGFmdGVyU3RhcnQ6IHtcbiAgICAgICAgLi4udmVydGljYWxBZnRlclN0YXJ0LFxuICAgICAgICBib3R0b206IGluZm8uc3R5bGUuYm90dG9tLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGxlZnQ6IGhvcml6b250YWwsXG4gICAgcmlnaHQ6IGhvcml6b250YWwsXG4gIH07XG4gIE9iamVjdC5hc3NpZ24oaW5mby5zdHlsZSwgc3R5bGVzW3Bvc2l0aW9uXS5zdGFydCk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oaW5mby5zdHlsZSwgc3R5bGVzW3Bvc2l0aW9uXS5hZnRlclN0YXJ0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtlckluZm9Qb3NpdGlvbihtYXJrZXJCb3VuZHMsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQsIG11bHRpcGxlTWF0Y2hlcykge1xuICAvLyBob3cgbWFueSBweCBvZiB0aGUgbWFya2VyLWluZm8gd2UgY2FuIGFmZm9yZCB0byBjdXRcbiAgLy8gaW4gY2FzZSB0aGVyZSBpc24ndCBlbm91Z2ggc3BhY2UsIGluIG9yZGVyIHRvIHN0aWxsIGRpc3BsYXkgaXQuXG4gIGNvbnN0IHRvbGVyYW5jZSA9IDA7XG5cbiAgY29uc3QgcmVxdWlyZWRYU2l6ZSA9IHtcbiAgICB4OiAxNDEgLSB0b2xlcmFuY2UsXG4gICAgeTogNDAgLSB0b2xlcmFuY2UsXG4gIH07XG4gIGNvbnN0IHJlcXVpcmVkWVNpemUgPSB7XG4gICAgeDogMTI1IC0gdG9sZXJhbmNlLFxuICAgIHk6IDU2IC0gdG9sZXJhbmNlLFxuICB9O1xuICBjb25zdCBtYXJrZXJIQ2VudGVyID0gbWFya2VyQm91bmRzLnggKyBtYXJrZXJCb3VuZHMud2lkdGggLyAyO1xuICBjb25zdCBtYXJrZXJWQ2VudGVyID0gbWFya2VyQm91bmRzLnkgKyBtYXJrZXJCb3VuZHMuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbWFya2VyQm90dG9tID0gbWFya2VyQm91bmRzLnkgKyBtYXJrZXJCb3VuZHMuaGVpZ2h0O1xuICBjb25zdCBtYXJrZXJSaWdodCA9IG1hcmtlckJvdW5kcy54ICsgbWFya2VyQm91bmRzLndpZHRoO1xuXG4gIC8vIGluZm8gaXMgZGlzcGxheWVkIG9uIGNlbnRlciwgdGh1cyB3ZSBuZWVkIGhhbGYgc3BhY2Ugb24gbGVmdC90b3BcbiAgLy8gYW5kIGhhbGYgc3BhY2Ugb24gcmlnaHQvYm90dG9tXG4gIC8vIGNoZWNrIHRoZSBpY29uIHNpemUgKGkuZS4gdGhlIGNpcmNsZSBzaXplKVxuICBjb25zdCBtaW5YU3BhY2UgPSAocmVxdWlyZWRYU2l6ZS55IC8gMikgLSB0b2xlcmFuY2U7XG4gIGNvbnN0IG1pbllTcGFjZSA9IChyZXF1aXJlZFlTaXplLnggLyAyKSAtIHRvbGVyYW5jZTtcbiAgY29uc3QgaXNIb3Jpem9udGFsU3VpdGFibGUgPSBtaW5ZU3BhY2UgPT09XG4gICAgTWF0aC5taW4oXG4gICAgICBtaW5ZU3BhY2UsIC8vIHJlcXVpcmVkIHNwYWNlXG4gICAgICBtYXJrZXJIQ2VudGVyLCAvLyBhdmFpbGFibGUgc3BhY2Ugb24gdGhlIHJpZ2h0XG4gICAgICBjb250YWluZXJXaWR0aCAtIG1hcmtlckhDZW50ZXIgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIHRoZSBsZWZ0XG4gICAgKTtcbiAgY29uc3QgaXNWZXJ0aWNhbFN1aXRhYmxlID0gbWluWFNwYWNlID09PVxuICAgIE1hdGgubWluKFxuICAgICAgbWluWFNwYWNlLCAvLyByZXF1aXJlZCBzcGFjZVxuICAgICAgbWFya2VyVkNlbnRlciwgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIHRoZSB0b3BcbiAgICAgIGNvbnRhaW5lckhlaWdodCAtIG1hcmtlclZDZW50ZXIgLy8gYXZhaWxhYmxlIHNwYWNlIG9uIHRoZSBib3R0b21cbiAgICApO1xuXG4gIC8vIGNoZWNrIHRoZSB3aG9sZSBzaXplICh3aXRoIGFycm93KVxuICBjb25zdCBpc1RvcFN1aXRhYmxlID0gKFxuICAgIG1hcmtlckJvdW5kcy55ID49IHJlcXVpcmVkWVNpemUueVxuICAgICYmIGlzSG9yaXpvbnRhbFN1aXRhYmxlXG4gICk7XG4gIGNvbnN0IGlzQm90dG9tU3VpdGFibGUgPSAoXG4gICAgY29udGFpbmVySGVpZ2h0IC0gbWFya2VyQm90dG9tID49IHJlcXVpcmVkWVNpemUueVxuICAgICYmIGlzSG9yaXpvbnRhbFN1aXRhYmxlXG4gICk7XG4gIGNvbnN0IGlzTGVmdFN1aXRhYmxlID0gKFxuICAgIG1hcmtlckJvdW5kcy54ID49IHJlcXVpcmVkWFNpemUueFxuICAgICYmIGlzVmVydGljYWxTdWl0YWJsZVxuICApO1xuICBjb25zdCBpc1JpZ2h0U3VpdGFibGUgPSAoXG4gICAgY29udGFpbmVyV2lkdGggLSBtYXJrZXJSaWdodCA+PSByZXF1aXJlZFhTaXplLnhcbiAgICAmJiBpc1ZlcnRpY2FsU3VpdGFibGVcbiAgKTtcblxuICBjb25zdCBwb3NpdGlvblRvQ2xhc3MgPSBtdWx0aXBsZU1hdGNoZXMgP1xuICAgIFtcbiAgICAgIC8vIHBvc2l0aW9uICAgIGluZm8gY2xhc3MgICAgYXJyb3cgY2xhc3NcbiAgICAgIFtpc1RvcFN1aXRhYmxlLCAndG9wJ10sXG4gICAgICBbaXNMZWZ0U3VpdGFibGUsICdsZWZ0J10sXG4gICAgICBbaXNSaWdodFN1aXRhYmxlLCAncmlnaHQnXSxcbiAgICAgIFtpc0JvdHRvbVN1aXRhYmxlLCAnYm90dG9tJ10sXG4gICAgICBbdHJ1ZSwgJ2hpZGUnXSwgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHNwYWNlLCBkb24ndCBkaXNwbGF5IGl0IGF0IGFsbFxuICAgIF1cbiAgOlxuICAgIFtcbiAgICAgIC8vIHBvc2l0aW9uICAgIGluZm8gY2xhc3MgICAgYXJyb3cgY2xhc3NcbiAgICAgIFtpc0JvdHRvbVN1aXRhYmxlLCAnYm90dG9tJ10sXG4gICAgICBbaXNUb3BTdWl0YWJsZSwgJ3RvcCddLFxuICAgICAgW2lzUmlnaHRTdWl0YWJsZSwgJ3JpZ2h0J10sXG4gICAgICBbaXNMZWZ0U3VpdGFibGUsICdsZWZ0J10sXG4gICAgICBbdHJ1ZSwgJ2hpZGUnXSwgLy8gdGhlcmUgaXNuJ3QgZW5vdWdoIHNwYWNlLCBkb24ndCBkaXNwbGF5IGl0IGF0IGFsbFxuICAgIF07XG4gIC8vIGNob29zZSB0aGUgZmlyc3QgdHJ1ZVxuICByZXR1cm4gcG9zaXRpb25Ub0NsYXNzLmZpbHRlcihoZWFkKVswXVsxXTtcbn1cblxuY29uc3QgYm9yZGVyV2lkdGggPSA2O1xubGV0IGN1cnJlbnRQcm9taXNlID0gbnVsbDtcbmxldCBuZXdUaW1lID0gbnVsbDtcblxuYXN5bmMgZnVuY3Rpb24gX2RyYXdNYXJrZXIoXG4gIG1hcmtlckJvdW5kcywgdHlwZSwgY29sb3IgPSAnJywgZW5hYmxlZE1hcmtlckluZGV4ID0gMCwgaWQgPSAnJywgaXNNb2JpbGUsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IHRpbWUgPSBuZXdUaW1lO1xuICBtYXJrZXJCb3VuZHMgPSBBcnJheS5pc0FycmF5KG1hcmtlckJvdW5kcykgPyBtYXJrZXJCb3VuZHMgOiBbbWFya2VyQm91bmRzXTsgLy8gbWlnaHQgYWxzbyBiZSBbbnVsbF0gIVxuXG4gIGNvbnN0IGN1cnJlbnRFbHMgPSBBcnJheS5mcm9tKCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJytTRUxFQ1RPUl9JRCkgKTtcbiAgY29uc3QgbmV3RWxzID0gW107XG4gIGNvbnN0IHBhbmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7bmFtZXNwYWNlKCdwYW5lbCcpfWApO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2VyQm91bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGJvdW5kcyA9IG1hcmtlckJvdW5kc1tpXTtcbiAgICBsZXQgbWFya2VyRWwgPSBjdXJyZW50RWxzW2ldOyAvLyBtaWdodCBiZSB1bmRlZmluZWRcbiAgICBpZiAoYm91bmRzID09PSBudWxsIHx8IChldmVyeSh2YWx1ZXMoYm91bmRzKSwgYiA9PiBiID09PSAwKSkpIHtcbiAgICAgIGlmIChtYXJrZXJFbCkge1xuICAgICAgICBtYXJrZXJFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICB9XG4gICAgICBuZXdFbHMucHVzaChudWxsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJvcmRlciBleHBhbmRzIGluc2lkZSByYXRoZXIgdGhhbiBvdXRzaWRlIHRvIHByZXZlbnQgd2luZG93IG92ZXJmbG93XG4gICAgLy8gYW5kIHdlIGV4cGFuZCBtYXJrZXIgc2l6ZSByZXNwZWN0aXZlbHkgYnV0IGxpbWl0ZWQgd2l0aCB3aW5kb3cgc2l6ZVxuICAgIGJvdW5kcyA9IGV4cGFuZE1hcmtlcihcbiAgICAgIGJvcmRlcldpZHRoLFxuICAgICAgd2luZG93LmlubmVyV2lkdGgsXG4gICAgICB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICBib3VuZHNcbiAgICApO1xuXG4gICAgbGV0IHJlcGxhY2VJbmZvID0gdHJ1ZTtcbiAgICBjb25zdCBpbmZvS2V5ID0gYCR7dHlwZX0tJHtjb2xvcn0tJHtpc01vYmlsZX0tJHtpfWA7XG4gICAgaWYgKCFtYXJrZXJFbCkge1xuICAgICAgbWFya2VyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZUluZm8gPSBtYXJrZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5mby1rZXknKSAhPT0gaW5mb0tleTtcbiAgICB9XG5cbiAgICBjb25zdCBnaXZlbklkID0gbWFya2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgY29uc3QgdWlkID0gYCR7aWR9LSR7aX1gO1xuXG4gICAgaWYgKHJlcGxhY2VJbmZvKSB7XG4gICAgICBtYXJrZXJFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5mby1rZXknLCBpbmZvS2V5KTtcbiAgICAgIG1hcmtlckVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgbWFya2VyRWwuYXBwZW5kQ2hpbGQobWFrZU1hcmtlckluZm8odHlwZSwgY29sb3IsIGlzTW9iaWxlLCBvcHRzKSk7XG4gICAgICAvLyB3ZSBhbHdheXMgc2V0IHRoZSBzdHlsZSBiZWNhdXNlIGl0IG1pZ2h0IGNoYW5nZSBmcm9tIFBSRVZJRVcgdG8gbm9uIFBSRVZJRVcgdHlwZVxuICAgICAgbWFya2VyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlT2JqVG9JbXBvcnRhbnRTdHJpbmcoc2VsZWN0b3JTdHlsZSh0eXBlLCBpKSkpO1xuICAgIH1cblxuICAgIC8vIFdlIGFsd2F5cyBhcHBlbmQgYmVjYXVzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSdyZSBhbHdheXMgdGhlXG4gICAgLy8gKmxhc3QqIGVsZW1lbnQgb2YgYm9keSBhbmQgZXZlbiBpZiB3ZSd2ZSBhcHBlbmRlZCBiZWZvcmUgb3RoZXJcbiAgICAvLyB0aGluZ3MgbWlnaHQgaGF2ZSBiZWVuIGFkZGVkIGFmdGVyIHVzIHNpbmNlLlxuICAgIC8vIHBhbmVsIHNob3VsZCBiZSBhZnRlciBtYXJrZXIgc28gaXQgZG9lc24ndCBvdmVybGFwXG4gICAgLy8gRklYTUU6IG1heWJlIHdlIHNob3VsZCBtb3ZlIHBhbmVsIHRvIHRoZSBlbmQgYXMgd2VsbFxuICAgIGlmIChwYW5lbCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUobWFya2VyRWwsIHBhbmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtYXJrZXJFbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFya2VySW5mb0VsID0gbWFya2VyRWwuZmlyc3RDaGlsZDtcbiAgICBkaXJlY3Rpb25zLm1hcChzID0+IG1hcmtlckluZm9FbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZShzKSkpO1xuICAgIGNvbnN0IGluZm9Qb3NpdGlvbiA9IG1hcmtlckluZm9Qb3NpdGlvbihcbiAgICAgIGJvdW5kcyxcbiAgICAgIHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgbWFya2VyQm91bmRzLmxlbmd0aCA+IDEsXG4gICAgKTtcbiAgICBtYXJrZXJJbmZvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUoaW5mb1Bvc2l0aW9uKSk7XG4gICAgbWFya2VySW5mb0VsLnN0eWxlLmJvcmRlckNvbG9yID0gY29sb3IgfHwgJyc7XG4gICAgLy8gc2hvdyB0aGUgbWFya2VyIGluZm8gb25seSBvbiB0aGUgZmlyc3QgbWFya2VyXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1hcmtlckluZm9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlckluZm9FbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgaWYgKGdpdmVuSWQgIT09IHVpZCkge1xuICAgICAgLy9pZiAoaSA9PSBlbmFibGVkTWFya2VySW5kZXgpIGFuaW1hdGVNYXJrZXJJbmZvKG1hcmtlckluZm9FbCwgaW5mb1Bvc2l0aW9uKTtcbiAgICAgIG1hcmtlckVsLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsIHVpZCk7XG4gICAgfVxuXG4gICAgbWFya2VyRWwuY2xhc3NOYW1lID0gU0VMRUNUT1JfSUQgKyAnICcgKyBjbGFzc05hbWUodHlwZSkgK1xuICAgICAgKGlzTW9iaWxlID8gYCAke2NsYXNzTmFtZSgnbW9iaWxlJyl9YCA6ICcnKTtcbiAgICBtYXJrZXJFbC5zdHlsZS5sZWZ0ID0gYCR7Ym91bmRzLnh9cHhgO1xuICAgIG1hcmtlckVsLnN0eWxlLnRvcCA9IGAke2JvdW5kcy55fXB4YDtcbiAgICBtYXJrZXJFbC5zdHlsZS53aWR0aCA9IGAke2JvdW5kcy53aWR0aH1weGA7XG4gICAgbWFya2VyRWwuc3R5bGUuaGVpZ2h0ID0gYCR7Ym91bmRzLmhlaWdodH1weGA7XG4gICAgbWFya2VyRWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblxuICAgIGNvbnN0IGJvcmRlckNvbG9yU3RyID0gY29sb3IgfHwgKHR5cGUgPT09ICdQUkVWSUVXJyA/ICdyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNCknIDogJycpO1xuICAgIG1hcmtlckVsLnN0eWxlLmJvcmRlckNvbG9yID0gYm9yZGVyQ29sb3JTdHI7XG4gICAgY29uc3QgYm9yZGVyQ29sb3IgPSBwYXJzZUNvbG9yKGJvcmRlckNvbG9yU3RyKS5yZ2I7XG4gICAgaWYgKCFpc01vYmlsZSkge1xuICAgICAgbWFya2VyRWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYHJnYmEoJHtbLi4uYm9yZGVyQ29sb3JTdHIsIEJHX09QQUNJVFldfSlgO1xuICAgIH1cbiAgICBpZiAoaSA9PSBlbmFibGVkTWFya2VySW5kZXgpIHtcbiAgICAgIG1hcmtlckVsLnN0eWxlLmJvcmRlckNvbG9yID0gYHJnYmEoJHtbLi4uYm9yZGVyQ29sb3JTdHIsIEVOQUJMRURfT1BBQ0lUWV19KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlckVsLnN0eWxlLmJvcmRlckNvbG9yID0gYHJnYmEoJHtbLi4uYm9yZGVyQ29sb3JTdHIsIERJU0FCTEVEX09QQUNJVFldfSlgO1xuICAgIH1cblxuICAgIG5ld0Vscy5wdXNoKG1hcmtlckVsKTtcblxuICAgIGlmICgoaSArIDEpICUgNTAgPT09IDApIHtcbiAgICAgIC8vIGRlbGF5IGV2ZXJ5IDUwIG1hcmtlcnNcbiAgICAgIGF3YWl0IGRlbGF5KDApO1xuICAgIH1cbiAgICBpZiAodGltZSAhPT0gbmV3VGltZSkge1xuICAgICAgLy8gc3RvcCBleGVjdXRpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLy8gaGlkZSBleGNlZWRpbmcgbWFya2VycyAoaWYgYW55KVxuICBmb3IgKGxldCBpID0gbWFya2VyQm91bmRzLmxlbmd0aDsgaSA8IGN1cnJlbnRFbHMubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50RWxzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZHJhd01hcmtlciguLi5hcmdzKSB7XG4gIG5ld1RpbWUgPSBEYXRlLm5vdygpO1xuICBpZiAoY3VycmVudFByb21pc2UpIHtcbiAgICBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICByZXR1cm4gZHJhd01hcmtlciguLi5hcmdzKTtcbiAgfVxuICBjdXJyZW50UHJvbWlzZSA9IF9kcmF3TWFya2VyKC4uLmFyZ3MpLnRoZW4oKCkgPT4ge1xuICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVNYXJrZXIoKSB7XG4gIGNvbnN0IGN1cnJlbnRFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJytTRUxFQ1RPUl9JRCk7XG4gIGNvbnN0IHZpc2libGVNYXJrZXJzID0gQXJyYXkuZnJvbShjdXJyZW50RWxzKS5maWx0ZXIobWFya2VyRWwgPT4gbWFya2VyRWwuc3R5bGUudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbicpO1xuXG4gIEFycmF5LmZyb20oY3VycmVudEVscykuZm9yRWFjaChtYXJrZXJFbCA9PiBtYXJrZXJFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbicpO1xuXG4gIC8vIFJldHVybiBhIHRydWUgaWYgd2UgaGlkIGFueSBtYXJrZXJzIGFuZCBmYWxzZSBpZiB0aGVyZSB3ZXJlbid0IGFueSB0byBoaWRlXG4gIHJldHVybiAodmlzaWJsZU1hcmtlcnMubGVuZ3RoICE9PSAwKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvZHJhd01hcmtlci5qcyIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcbi8vIENhY2hlIHBhbmVsRWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbmxldCBwYW5lbEVsO1xuZnVuY3Rpb24gZ2V0UGFuZWxFbCgpIHtcbiAgaWYgKCFwYW5lbEVsKSB7XG4gICAgcGFuZWxFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke25hbWVzcGFjZSgncGFuZWwnKX1gKTtcbiAgfVxuICByZXR1cm4gcGFuZWxFbDtcbn1cblxuLy8gSWdub3JlIGNhc2Ugd2hlcmUgdGhlIGlvcmFkIHBhbmVsIGlzIGFib3ZlIHRoZSBlbGVtZW50LCBzaW5jZSB3ZSdsbCBtb3ZlIHRoZSBwYW5lbCBhY2NvcmRpbmdseS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVsZW1lbnRPblRvcChlbCwgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB7XG4gIGNvbnN0IE1BUkdJTiA9IDU7XG4gIGNvbnN0IGVsZW1lbnRBdENlbnRlciA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAqIDAuNSwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAqIDAuNSk7XG4gIGNvbnN0IGVsZW1lbnRBdENlbnRlckxlZnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHJlY3QubGVmdCArIE1BUkdJTiwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAqIDAuNSk7XG4gIGNvbnN0IGVsZW1lbnRBdENlbnRlclJpZ2h0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChyZWN0LnJpZ2h0IC0gTUFSR0lOLCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0ICogMC41KTtcblxuICBjb25zdCBwYW5lbEVsID0gZ2V0UGFuZWxFbCgpO1xuICByZXR1cm4gKHBhbmVsRWwgJiYgcGFuZWxFbC5jb250YWlucyhlbGVtZW50QXRDZW50ZXIpKSB8fFxuICAgIGVsLmNvbnRhaW5zKGVsZW1lbnRBdENlbnRlcikgfHxcbiAgICBlbC5jb250YWlucyhlbGVtZW50QXRDZW50ZXJMZWZ0KSB8fFxuICAgIGVsLmNvbnRhaW5zKGVsZW1lbnRBdENlbnRlclJpZ2h0KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvZWxlbWVudE9uVG9wLmpzIiwiZXhwb3J0ICogZnJvbSAnLi9SRUFEJztcbmV4cG9ydCAqIGZyb20gJy4vTEVGVF9DTElDSyc7XG5leHBvcnQgKiBmcm9tICcuL1JJR0hUX0NMSUNLJztcbmV4cG9ydCAqIGZyb20gJy4vU0NST0xMJztcbmV4cG9ydCAqIGZyb20gJy4vVFlQSU5HJztcbmV4cG9ydCAqIGZyb20gJy4vRFJBRyc7XG5leHBvcnQgKiBmcm9tICcuL0RST1AnO1xuZXhwb3J0ICogZnJvbSAnLi9IT1ZFUic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL2luZGV4LmpzIiwiaW1wb3J0IFN0b3JhZ2UgZnJvbSAnYmFzZS9jb21tb24vU3RvcmFnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtYmVkU3RvcmFnZSBleHRlbmRzIFN0b3JhZ2Uge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2NvbW1vbi9FbWJlZFN0b3JhZ2UuanMiLCIvLyBPUFRJTUlaQVRJT046IHVzZSBzdHViIGNvbXBvbmVudHMgaW5zdGVhZCBvZiBmdWxsIFwiYmFzZSBleHRlbnNpb25zXCIgdG8gc2F2ZSBLQnMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHViQ29tcG9uZW50IHtcbiAgc3RhcnQoZXh0ZW5zaW9uKSB7XG4gICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG4gIH1cbiAgb24oKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvY29tbW9uL1N0dWJDb21wb25lbnQuanMiLCJpbXBvcnQgQ29tbW9uU2hhcmVkTWVtb3J5IGZyb20gJ2Jhc2UvY29tbW9uL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFyZWRNZW1vcnkgZXh0ZW5kcyBDb21tb25TaGFyZWRNZW1vcnkge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5LmpzIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHNoYXJlZEVtaXR0ZXIgZnJvbSAnLi9zaGFyZWRFbWl0dGVyJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuY29uc3QgdGFiS2V5UHJlZml4ID0gbmFtZXNwYWNlKCd0YWItJyk7XG5cbmNvbnN0IFRBQl9USU1FT1VUID0gNTAwMDtcbi8vIGludmFsaWQgdGFicyBhcmVuJ3QgaW1tZWRpYXRlbGx5IGRlbGV0ZWQsIHNpbmNlIHRoZSBiYWNrZ3JvdW5kXG4vLyBuZWVkcyB0aGVtIHRvIGhhbmRsZSBtZXNzYWdlcyBzZW50IGp1c3QgYmVmb3JlIHBhZ2UgcmVsb2FkIChwZXJzaXN0UGFuZWxTdGF0ZSwgZXRjLiAjNTMyKVxuY29uc3QgVEFCX0NMRUFOX1RJTUVPVVQgPSAzMDAwMDtcblxuLy8gTm90ZTogdGhpcyBmdW5jdGlvbiBoYXMgc2lkZSBlZmZlY3RzIGlmIGNsZWFuSW52YWxpZFRhYnMgaXMgdHJ1ZSwgc2luY2Vcbi8vIGl0IHdpbGwgcmVtb3ZlIGFueSBvYnNvbGV0ZSB0YWIgZnJvbSBsb2NhbCBzdG9yYWdlLlxuLy8gUmV0dXJuIHRoZSB2YWxpZCB0YWJzLlxuZnVuY3Rpb24gZmlsdGVyVGFicyh0YWJzLCBjbGVhbkludmFsaWRUYWJzKSB7XG4gIGNvbnN0IHZhbGlkVGFicyA9IHt9O1xuXG4gIGNvbnN0IGRhdGVOb3cgPSBEYXRlLm5vdygpO1xuICBmb3IgKGNvbnN0IHRhYklkIG9mIE9iamVjdC5rZXlzKHRhYnMpKSB7XG4gICAgY29uc3QgdGFiID0gdGFic1t0YWJJZF07XG4gICAgY29uc3QgaW52YWxpZCA9ICF0YWIgfHwgIXRhYi5wcml2YXRlIHx8IHRhYi5wcml2YXRlLmludmFsaWQgfHwgKGRhdGVOb3cgLSB0YWIucHJpdmF0ZS50aW1lID4gVEFCX1RJTUVPVVQpO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgdmFsaWRUYWJzW3RhYklkXSA9IHRhYjtcbiAgICB9IGVsc2UgaWYgKGNsZWFuSW52YWxpZFRhYnMgJiYgKCF0YWIgfHwgIXRhYi5wcml2YXRlIHx8IChkYXRlTm93IC0gdGFiLnByaXZhdGUudGltZSA+IFRBQl9DTEVBTl9USU1FT1VUKSkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRhYktleVByZWZpeCArIHRhYklkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsaWRUYWJzO1xufVxuXG5mdW5jdGlvbiBnZXRUYWJJZEZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc2xpY2UodGFiS2V5UHJlZml4Lmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFRhYnMoc2tpcEludmFsaWRUYWJzLCBjbGVhbkludmFsaWRUYWJzKSB7XG4gIGxldCB0YWJzID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHRhYktleVByZWZpeCkpIHtcbiAgICAgIGNvbnN0IGlkID0gZ2V0VGFiSWRGcm9tS2V5KGtleSk7XG4gICAgICB0YWJzW2lkXSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgfVxuICB9XG4gIGlmIChza2lwSW52YWxpZFRhYnMpIHtcbiAgICB0YWJzID0gZmlsdGVyVGFicyh0YWJzLCBjbGVhbkludmFsaWRUYWJzKTtcbiAgfVxuICByZXR1cm4gdGFicztcbn1cblxuLy8gY2FuIG9ubHkgcmVhZFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFic1N0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2xlYW5JbnZhbGlkVGFicyA9IG9wdGlvbnMuY2xlYW5JbnZhbGlkVGFicyB8fCBmYWxzZTtcblxuICAgIHRoaXMuX3RhYnMgPSBnZXRUYWJzKHRydWUsIHRoaXMuY2xlYW5JbnZhbGlkVGFicyk7XG5cbiAgICB0aGlzLl9saXN0ZW5Gb3JDaGFuZ2VzKCk7XG4gIH1cblxuICBfbGlzdGVuRm9yQ2hhbmdlcygpIHtcbiAgICAvLyBOb3RlOiB0aGUgd2luZG93ICdzdG9yYWdlJyBldmVudCBpcyBub3QgZmlyZWQgb24gdGhlIHNhbWUgcGFnZSAoZnJhbWU/KSB0aGF0IGlzIG1ha2luZyB0aGUgY2hhbmdlc1xuICAgIHNoYXJlZEVtaXR0ZXIub24oJ2NoYW5nZScsIChrZXksIHsgbmV3VmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHRhYktleVByZWZpeCkpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZFRhYklkID0gZ2V0VGFiSWRGcm9tS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRUYWIgPSBuZXdWYWx1ZTtcblxuICAgICAgICBjb25zdCBvbGRUYWJzID0gdGhpcy5fdGFicztcbiAgICAgICAgY29uc3QgbmV3VGFicyA9IHRoaXMuX3RhYnMgPSBmaWx0ZXJUYWJzKE9iamVjdC5hc3NpZ24oe30sIG9sZFRhYnMsIHtcbiAgICAgICAgICBbY2hhbmdlZFRhYklkXTogY2hhbmdlZFRhYixcbiAgICAgICAgfSksIHRoaXMuY2xlYW5JbnZhbGlkVGFicyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFRhYnMsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1RhYnMsXG4gICAgICAgICAgY2hhbmdlVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyByZXR1cm4gdGFicyBvYmplY3Q6IDxpZCwgdGFiPlxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl90YWJzKTtcbiAgfVxuXG4gIGdldEFsbEluY2x1ZGluZ0ludmFsaWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRUYWJzKGZhbHNlKSwgdGhpcy5jbGVhbkludmFsaWRUYWJzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvY29tbW9uL3NoYXJlZE1lbW9yeS9UYWJzU3RvcmUuanMiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZSc7XG5cbi8vIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiB0byBhbnkgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgYW55IE9iamVjdFN0b3JlLFxuLy8gYm90aCBmcm9tIHNhbWUgZnJhbWUsIGRpZmZlcmVudCBmcmFtZSBhbmQgZGlmZmVyZW50IHRhYi5cbmNvbnN0IHNoYXJlZEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbi8vIE5vdGU6IHRoZSB3aW5kb3cgJ3N0b3JhZ2UnIGV2ZW50IGlzIG5vdCBmaXJlZCBvbiB0aGUgc2FtZSBwYWdlIChmcmFtZT8pIHRoYXQgaXMgbWFraW5nIHRoZSBjaGFuZ2VzXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIChlKSA9PiB7XG4gIGlmICghZS5rZXkuc3RhcnRzV2l0aChuYW1lc3BhY2UoKSArICctJykpIHJldHVybjsgLy8gbm90IG9uZSBvZiBvdXIga2V5c1xuXG4gIGNvbnN0IGNoYW5nZUluZm8gPSB7XG4gICAgb2xkVmFsdWU6IGUub2xkVmFsdWUgJiYgSlNPTi5wYXJzZShlLm9sZFZhbHVlKSxcbiAgICBuZXdWYWx1ZTogZS5uZXdWYWx1ZSAmJiBKU09OLnBhcnNlKGUubmV3VmFsdWUpLFxuICAgIGNoYW5nZVRpbWU6IERhdGUubm93KCksXG4gIH07XG4gIHNoYXJlZEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgZS5rZXksIGNoYW5nZUluZm8pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNoYXJlZEVtaXR0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9jb21tb24vc2hhcmVkTWVtb3J5L3NoYXJlZEVtaXR0ZXIuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2Nzc2VzY2FwZSB2MS41LjEgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcblx0XHQvLyBGb3IgTm9kZS5qcy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBGb3IgQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeS5iaW5kKHJvb3QsIHJvb3QpKTtcblx0fSBlbHNlIHtcblx0XHQvLyBGb3IgYnJvd3NlciBnbG9iYWxzIChub3QgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uIHNlcGFyYXRlbHkpLlxuXHRcdGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0odHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRpZiAocm9vdC5DU1MgJiYgcm9vdC5DU1MuZXNjYXBlKSB7XG5cdFx0cmV0dXJuIHJvb3QuQ1NTLmVzY2FwZTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcblx0dmFyIGNzc0VzY2FwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYENTUy5lc2NhcGVgIHJlcXVpcmVzIGFuIGFyZ3VtZW50LicpO1xuXHRcdH1cblx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVVuaXQ7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBmaXJzdENvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0Ly8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcblx0XHRcdC8vIHBhaXJzLCBvciBsb25lIHN1cnJvZ2F0ZXMuXG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aGUgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHQvLyAoVStGRkZEKS5cblx0XHRcdGlmIChjb2RlVW5pdCA9PSAweDAwMDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXHVGRkZEJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgW1xcMS1cXDFGXSAoVSswMDAxIHRvIFUrMDAxRikgb3IgaXNcblx0XHRcdFx0Ly8gVSswMDdGLCBb4oCmXVxuXHRcdFx0XHQoY29kZVVuaXQgPj0gMHgwMDAxICYmIGNvZGVVbml0IDw9IDB4MDAxRikgfHwgY29kZVVuaXQgPT0gMHgwMDdGIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cblx0XHRcdFx0KGluZGV4ID09IDAgJiYgY29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSkgfHxcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIGAtYCAoVSswMDJEKSwgW+KApl1cblx0XHRcdFx0KFxuXHRcdFx0XHRcdGluZGV4ID09IDEgJiZcblx0XHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXG5cdFx0XHRcdFx0Zmlyc3RDb2RlVW5pdCA9PSAweDAwMkRcblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyLWFzLWNvZGUtcG9pbnRcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIGNvZGVVbml0LnRvU3RyaW5nKDE2KSArICcgJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpcyBhIGAtYCAoVSswMDJEKSwgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIHNlY29uZCBjaGFyYWN0ZXIsIFvigKZdXG5cdFx0XHRcdGluZGV4ID09IDAgJiZcblx0XHRcdFx0bGVuZ3RoID09IDEgJiZcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBub3QgaGFuZGxlZCBieSBvbmUgb2YgdGhlIGFib3ZlIHJ1bGVzIGFuZCBpc1xuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFUrMDA4MCwgaXMgYC1gIChVKzAwMkQpIG9yIGBfYCAoVSswMDVGKSwgb3Jcblx0XHRcdC8vIGlzIGluIG9uZSBvZiB0aGUgcmFuZ2VzIFswLTldIChVKzAwMzAgdG8gVSswMDM5KSwgW0EtWl0gKFUrMDA0MSB0b1xuXHRcdFx0Ly8gVSswMDVBKSwgb3IgW2Etel0gKFUrMDA2MSB0byBVKzAwN0EpLCBb4oCmXVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwODAgfHxcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDA1RiB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5IHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA0MSAmJiBjb2RlVW5pdCA8PSAweDAwNUEgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgaXRzZWxmXG5cdFx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXJcblx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmICghcm9vdC5DU1MpIHtcblx0XHRyb290LkNTUyA9IHt9O1xuXHR9XG5cblx0cm9vdC5DU1MuZXNjYXBlID0gY3NzRXNjYXBlO1xuXHRyZXR1cm4gY3NzRXNjYXBlO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy5lc2NhcGUvY3NzLmVzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlUmFuZG9tID0gcmVxdWlyZSgnLi9fYmFzZVJhbmRvbScpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNhbXBsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hcnJheVNhbXBsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDU0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gKlxuICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAqIH0pO1xuICpcbiAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAqL1xuZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBuID0gdG9JbnRlZ2VyKG4pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvYWZ0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9jb21wYWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1NDhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKSxcbiAgICBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjdXN0b21PbWl0Q2xvbmUgPSByZXF1aXJlKCcuL19jdXN0b21PbWl0Q2xvbmUnKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgIHJldHVybiBwYXRoO1xuICB9KTtcbiAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvb21pdC5qc1xuLy8gbW9kdWxlIGlkID0gNTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICpcbiAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gKi9cbmZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIG4gPSB0b0ludGVnZXIobik7XG4gIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gIGl0ZXJhdGVlID0gY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKTtcbiAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvdGltZXMuanNcbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJpbXBvcnQgRWRpdG9yRnJhbWVOb2RlIGZyb20gJ2Jhc2UvY29udGVudC9FZGl0b3JGcmFtZU5vZGUnO1xuXG5jb25zdCBlZGl0b3JOb2RlID0gbmV3IEVkaXRvckZyYW1lTm9kZShCUk9XU0VSLCBWRVJTSU9OLCAnZW1iZWQnKTtcbmVkaXRvck5vZGUuc3RhcnQoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2luamVjdF9lZGl0b3JGcmFtZU5vZGUuanMiLCJpbXBvcnQgQ29udGVudFBsYXllckZyYW1lTm9kZSBmcm9tICdiYXNlL2NvbnRlbnQvcGxheWVyL0NvbnRlbnRQbGF5ZXJGcmFtZU5vZGUnO1xuXG5jb25zdCBjb250ZW50UGxheWVyTm9kZSA9IG5ldyBDb250ZW50UGxheWVyRnJhbWVOb2RlKCk7XG5jb250ZW50UGxheWVyTm9kZS5zdGFydCgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvaW5qZWN0X3BsYXllckZyYW1lTm9kZS5qcyIsInJlcXVpcmUoJ2NvcmUtanMvZXM2L3N5bWJvbCcpO1xuXG5pbXBvcnQgJy4vY29udGVudC9zdHlsZXMvc3R5bGUuc2Nzcyc7XG5pbXBvcnQgQ29udGVudEV4dGVuc2lvbiBmcm9tICcuL2NvbnRlbnQvRW1iZWRFeHRlbnNpb24nO1xuaW1wb3J0IEJhY2tncm91bmRFeHRlbnNpb24gZnJvbSAnLi9iYWNrZ3JvdW5kL0VtYmVkRXh0ZW5zaW9uJztcbmltcG9ydCBmaW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRSZWplY3Rpb24nLCAoZXJyb3IpID0+IHtcbiAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IGVycm9yKTtcbiAgdGhyb3cgZXJyb3I7XG59KTtcblxuKGZ1bmN0aW9uIGNoZWNrQm9keSgpIHtcbiAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgLy8gdHJ5IGxhdGVyXG4gICAgc2V0VGltZW91dChjaGVja0JvZHksIDUwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjb250ZW50RXh0ZW5zaW9uID0gbmV3IENvbnRlbnRFeHRlbnNpb24oKTtcblxuICAvLyBpbmplY3QgQ1NTXG4gIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gIGxpbmsuaHJlZiA9IGNvbnRlbnRFeHRlbnNpb24uZ2V0VVJMKCdpbmplY3QuY3NzJyk7XG4gIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuXG4gIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgaWYgKCFjb250ZW50RXh0ZW5zaW9uLmlzVG9wRnJhbWUpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIGxldCBpbnRlcnZhbHMgPSB7fTtcbiAgICBmdW5jdGlvbiBhZGRJbnRlcnZhbChuYW1lLCBjYiwgdGltZW91dCkge1xuICAgICAgaW50ZXJ2YWxzW25hbWVdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNiKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGludGVydmFsc1tuYW1lXSkgeyAvLyAocHJldmVudCBjYWxsIGlmIGFscmVhZHkgY2xlYXJlZClcbiAgICAgICAgICAgIGFkZEludGVydmFsKG5hbWUsIGNiLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWxzKCkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGludGVydmFscykpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsc1tuYW1lXSk7XG4gICAgICB9XG4gICAgICBpbnRlcnZhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbmRDdXJyZW50VGFiID0gKHB1YmxpY09iaiA9IHt9LCBwcml2YXRlT2JqID0ge30pID0+IHtcbiAgICAgIHJldHVybiBjb250ZW50RXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS50YWIuc2V0QnlGdW5jdGlvbih0YWIgPT4ge1xuICAgICAgICBpZiAoIXRhYikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdleHRlbmRDdXJyZW50VGFiOiB0YWIgbm90IGZvdW5kJywgY29udGVudEV4dGVuc2lvbi5mcmFtZUlkKTtcbiAgICAgICAgICByZXR1cm4gdGFiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFiLnB1YmxpYyA9IE9iamVjdC5hc3NpZ24oe30sIHRhYi5wdWJsaWMgfHwge30sIHB1YmxpY09iaik7XG4gICAgICAgIHRhYi5wcml2YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGFiLnByaXZhdGUgfHwge30sIHtcbiAgICAgICAgICAuLi5wcml2YXRlT2JqLFxuICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFiO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uQWN0aXZlQ2hhbmdlID0gKGlzQWN0aXZlKSA9PiB7XG4gICAgICByZXR1cm4gZXh0ZW5kQ3VycmVudFRhYih7IGFjdGl2ZTogaXNBY3RpdmUgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNoZWNrVGFicyA9ICgpID0+IHtcbiAgICAgIHJldHVybiBjb250ZW50RXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS50YWJzLmdldEFsbCgpLnRoZW4oYXN5bmMgKHRhYnMgPSB7fSkgPT4ge1xuICAgICAgICAvLyBpcyB0aGVyZSBhIGJhY2tncm91bmQgdGFiP1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kVGFiID0gZmluZCh0YWJzLCB0YWIgPT4gdGFiLnByaXZhdGUuYmFja2dyb3VuZCk7XG4gICAgICAgIGlmICghYmFja2dyb3VuZFRhYikge1xuICAgICAgICAgIC8vIGZpbmQgdGFiIHdpdGggbG93ZXN0IGlkXG4gICAgICAgICAgY29uc3QgbmV3QmFja2dyb3VuZFRhYiA9IHNvcnRCeSh0YWJzLCB0YWIgPT4gdGFiLnB1YmxpYy5pZClbMF07XG4gICAgICAgICAgaWYgKG5ld0JhY2tncm91bmRUYWIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnaW5qZWN0OiBuZXdCYWNrZ3JvdW5kVGFiJywgbmV3QmFja2dyb3VuZFRhYik7XG4gICAgICAgICAgICBpZiAobmV3QmFja2dyb3VuZFRhYi5wdWJsaWMuaWQgPT09IGNvbnRlbnRFeHRlbnNpb24uZnJhbWVJZCkge1xuICAgICAgICAgICAgICAvLyB3ZSBhcmUgdGhlIG9uZSwgcnVuIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgIGF3YWl0IGNvbnRlbnRFeHRlbnNpb24uc2hhcmVkTWVtb3J5LnRhYi5zZXRCeVBhdGgoeyAncHJpdmF0ZS5iYWNrZ3JvdW5kJzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEV4dGVuc2lvbiA9IG5ldyBCYWNrZ3JvdW5kRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICAgIGJhY2tncm91bmRFeHRlbnNpb24uc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8tb3A6IHRoZSBvbmx5IHRhYiBpcyBiZWluZyByZWZyZXNoZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGVjayA9ICgpID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbigoKSA9PiBjaGVja1RhYnMoKSk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIHRoZSB0YWJcbiAgICByZXR1cm4gY29udGVudEV4dGVuc2lvbi5zaGFyZWRNZW1vcnkudGFiLnNldCh7XG4gICAgICBwdWJsaWM6IHtcbiAgICAgICAgaWQ6IGNvbnRlbnRFeHRlbnNpb24uZnJhbWVJZCxcbiAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBwcml2YXRlOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGZhbHNlLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgfSxcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIC8vIG1vbml0b3IgYWN0aXZlIHN0YXRlXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4gb25BY3RpdmVDaGFuZ2UoIWRvY3VtZW50LmhpZGRlbikpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgLy8gZG9jdW1lbnQuaGlkZGVuIGlzIHRydWUgZHVyaW5nIHRoZSBwYWdlIHByZS1yZW5kZXIsXG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIHRhYiBpcyBhY3RpdmVcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGFnZV9WaXNpYmlsaXR5X0FQSSlcbiAgICAgICAgb25BY3RpdmVDaGFuZ2UoIWRvY3VtZW50LmhpZGRlbik7XG4gICAgICB9KTtcbiAgICAgIG9uQWN0aXZlQ2hhbmdlKCFkb2N1bWVudC5oaWRkZW4pO1xuXG4gICAgICAvLyBrZWVwIHJlZ2lzdHJhdGlvbiB1cGRhdGVkXG4gICAgICBhZGRJbnRlcnZhbCgnZXh0ZW5kQ3VycmVudFRhYicsICgpID0+IGV4dGVuZEN1cnJlbnRUYWIoKSwgMTAwMCk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWxzKCk7XG4gICAgICAgIGNvbnRlbnRFeHRlbnNpb24uc2hhcmVkTWVtb3J5LnRhYi5zZXRCeVBhdGgoeyAncHJpdmF0ZS5pbnZhbGlkJzogdHJ1ZSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBhZGRJbnRlcnZhbCgnY2hlY2snLCAoKSA9PiBjaGVjaygpLCAxMDAwKTtcbiAgICAgIHJldHVybiBjaGVjaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIGluaXQoKS50aGVuKCgpID0+IHtcbiAgICBjb250ZW50RXh0ZW5zaW9uLnN0YXJ0KCk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBBUElcbiAgd2luZG93LmlvcmFkV2lkZ2V0ID0ge1xuICAgIHRvZ2dsZVBhbmVsOiAoc2hvd09ySGlkZSkgPT4ge1xuICAgICAgY29udGVudEV4dGVuc2lvbi5wb3J0TWFuYWdlci5iYWNrZ3JvdW5kUG9ydC5zZW5kKHtcbiAgICAgICAgdG9waWM6IHNob3dPckhpZGUgPyAnc2hvd1BhbmVsJyA6ICdoaWRlUGFuZWwnLFxuICAgICAgICBkYXRhOiB7IGV4cGxpY2l0OiB0cnVlIH0sXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ29sb3JzOiAoY29sb3JzKSA9PiB7XG4gICAgICBjb250ZW50RXh0ZW5zaW9uLnBhbmVsQ29udHJvbGxlci5oYW5kbGVDb2xvcnMoY29sb3JzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlSW50ZXJjb206ICh2YWx1ZSkgPT4ge1xuICAgICAgY29udGVudEV4dGVuc2lvbi5mbHV4LmNvbnRlbnRDb250ZXh0KCkuZGlzcGF0Y2goJ3RvZ2dsZUludGVyY29tSW5zdGFsbGVkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVHb29nbGVUcmFuc2xhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29udGVudEV4dGVuc2lvbi5mbHV4LmNvbnRlbnRDb250ZXh0KCkuZGlzcGF0Y2goJ3RvZ2dsZUdvb2dsZVRyYW5zbGF0ZUluc3RhbGxlZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgcmVzZXRDb2xvcnM6ICgpID0+IHtcbiAgICAgIGNvbnRlbnRFeHRlbnNpb24ucGFuZWxDb250cm9sbGVyLmhhbmRsZUNvbG9ycyhjb250ZW50RXh0ZW5zaW9uLmVtYmVkT3B0aW9ucy5jb2xvcnMpO1xuICAgIH0sXG5cbiAgICBjb250ZW50RXh0ZW5zaW9uLFxuICB9O1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2luamVjdF90b3BGcmFtZS5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnYmFzZS9jb21tb24vQ29tcG9uZW50JztcbmltcG9ydCBBdWRpb1BsYXllciBmcm9tICdiYXNlL2NvbW1vbi9BdWRpb1BsYXllcic7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvQ29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXJ0KC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdGFydCguLi5hcmdzKTtcblxuICAgIHRoaXMuc2V0dXBBdWRpb1BsYXllcigpO1xuICAgIHRoaXMuc2V0dXBEb2N1bWVudHMoKTtcbiAgfVxuXG4gIHNldHVwQXVkaW9QbGF5ZXIoKSB7XG4gICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW9QbGF5ZXIoKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IFtcbiAgICAgIC8vIGV2ZW50ICAgICAgICAgIG1lc3NhZ2UgdG8gZG9jdW1lbnRzXG4gICAgICBbJ3BsYXknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdzZXRBdWRpb1BsYXlpbmcnLCB0cnVlKTtcbiAgICAgIH1dLFxuICAgICAgWydlbmQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdzZXRBdWRpb1BsYXlpbmcnLCBmYWxzZSk7XG4gICAgICB9XSxcbiAgICAgIFsndm9sdW1lQ2hhbmdlZCcsICh2YWwpID0+IHtcbiAgICAgICAgdGhpcy5vd25Db250ZXh0KCkuZGlzcGF0Y2goJ3NldEF1ZGlvTXV0ZWQnLCB2YWwgPT09IDApO1xuICAgICAgfV0sXG4gICAgXTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBhdWRpby5vbihhWzBdLCAoLi4uYXJncykgPT4gYVsxXSguLi5hcmdzKSk7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpbyA9IGF1ZGlvO1xuICB9XG5cbiAgc2V0dXBEb2N1bWVudHMoKSB7XG4gICAgdGhpcy5kb2N1bWVudHNQb3J0ID0gdGhpcy5leHRlbnNpb24ucG9ydE1hbmFnZXIuZG9jdW1lbnRzUG9ydDtcbiAgICB0aGlzLmRvY3VtZW50c1BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZURvY3VtZW50c01lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBoYW5kbGVEb2N1bWVudHNNZXNzYWdlKG1lc3NhZ2UsIHJlc3BvbmQpIHtcbiAgICAvLyBkbyBub3QgaGFuZGxlIGF1ZGlvIHJlcXVlc3RzIGZyb20gaW5hY3RpdmUgdGFicyAoIzUyNClcbiAgICAvLyBOb3RlOiB0aGUgcmVxdWVzdCBpcyBub3QgaWdub3JlZCBpZiB0aGUgYWN0aXZlIHRhYiBpcyBcIm5ld1wiLCBzbyB0byBoYW5kbGUgbWVzc2FnZXMgc2VudCBvbiBcIm9wZW4gaW4gYSBuZXcgdGFiXCIgbGlua3MgKCM1NzApXG4gICAgY29uc3QgYWN0aXZlVGFiVGltZSA9IERhdGUubm93KCkgLSB0aGlzLmV4dGVuc2lvbi50YWJzQ29udHJvbGxlci5hY3RpdmVUYWJTdGFydFRpbWU7XG4gICAgaWYgKHRoaXMuZXh0ZW5zaW9uLnRhYnNDb250cm9sbGVyLmFjdGl2ZVRhYklkICE9PSBtZXNzYWdlLnRhYi5pZCAmJiBhY3RpdmVUYWJUaW1lID4gNTAwMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgYXVkaW9IYW5kbGVycyA9IFtcbiAgICAgIC8vIHRvcGljICAgIGhhbmRsZXJcbiAgICAgIFsncGxheUF1ZGlvJywgKCkgPT4ge1xuICAgICAgICAvLyAoZG9uJ3QgcGxheSB0aGUgc2FtZSBhdWRpbyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW9yYWQvSU9SQUQtZXh0ZW5zaW9uL2lzc3Vlcy8yNzgjaXNzdWVjb21tZW50LTIxNzY1Mjg2MSlcbiAgICAgICAgaWYgKHRoaXMuYXVkaW8uZ2V0VXJsKCkgIT09IG1lc3NhZ2UuZGF0YS51cmwpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvLnNldFVybChtZXNzYWdlLmRhdGEudXJsKTtcbiAgICAgICAgICB0aGlzLmF1ZGlvLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfV0sXG4gICAgICBbJ3N0b3BBdWRpbycsICgpID0+IHtcbiAgICAgICAgdGhpcy5hdWRpby5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXVkaW8uc2V0VXJsKCcnKTtcbiAgICAgIH1dLFxuICAgICAgWyd1cGRhdGVBdWRpb011dGVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmF1ZGlvLnN0b3AoKTtcbiAgICAgICAgdGhpcy5hdWRpby5zZXRVcmwoJycpO1xuICAgICAgICB0aGlzLmF1ZGlvLnNldFZvbHVtZShtZXNzYWdlLmRhdGEubXV0ZWQgPyAwIDogMSlcbiAgICAgIH1dLFxuICAgIF07XG4gICAgYXVkaW9IYW5kbGVycy5mb3JFYWNoKChhKSA9PiB7IGlmIChtZXNzYWdlLnRvcGljID09PSBhWzBdKSBhWzFdKCkgfSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvYmFja2dyb3VuZC9BdWRpb0NvbnRyb2xsZXIuanMiLCIvLyBSRUFETUU6IGtlZXAgdGhpcyBmaWxlIGFzIHNtYWxsIGFzIHBvc3NpYmxlLCBtb3ZlIGFueSBsb2dpYyB0byBzcGVjaWZpYyBtb2R1bGVzXG4vLyBhbmQgaW5pdGlhbGl6ZS9zdGFydCB0aGVtIGhlcmUgaWYgbmVlZGVkLlxuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgcmFuZG9tU3RyaW5nIGZyb20gJy4uL2NvbW1vbi91dGlscy9yYW5kb21TdHJpbmcnO1xuaW1wb3J0IEZsdXggZnJvbSAnLi9GbHV4JztcbmltcG9ydCBTaGFyZWRNZW1vcnkgZnJvbSAnLi4vY29tbW9uL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnknO1xuaW1wb3J0IEF1ZGlvQ29udHJvbGxlciBmcm9tICcuL0F1ZGlvQ29udHJvbGxlcic7XG5pbXBvcnQgU2hvcnRjdXRzQ29udHJvbGxlciBmcm9tICcuL1Nob3J0Y3V0c0NvbnRyb2xsZXInO1xuaW1wb3J0IFVzZXJEYXRhIGZyb20gJy4vVXNlckRhdGEnO1xuaW1wb3J0IFBhbmVsQ29udHJvbGxlciBmcm9tICcuL1BhbmVsQ29udHJvbGxlcic7XG5cbi8vIE5lZWRzIHRvIGJlIGltcG9ydGVkIHNvIGl0IGNhbiBydW4gaXRzIGVjaG8gc2VydmVyXG5pbXBvcnQgJy4uL2NvbW1vbi91dGlscy9mcmFtZU1lc3NhZ2VzJztcblxuaW1wb3J0IHsgZ2V0RmlsZUxvZ2dlciB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRlbnNpb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhbmVsOiB7fSxcbiAgICAgIGNhcHR1cmU6IHtcbiAgICAgICAgYnJvd3NlclN0YXRlOiAnaW5pdGlhbCcsXG4gICAgICAgIGRlc2t0b3BTdGF0ZTogJ2luaXRpYWwnLFxuXG4gICAgICAgIC8vIHRoZSBtb2RlIHNob3VsZCBiZSBhbHNvIHNldCBpZiB0aGUgY2FwdHVyZSB3YXMgc3RhcnRlZCBkaXJlY3RseSBmcm9tIGFwcFxuICAgICAgICBtb2RlOiAnYnJvd3NlcicsIC8vIG5hdGl2ZVxuXG4gICAgICAgIGNhcHR1cmVzOiAwLFxuICAgICAgICBjYXB0dXJlU2VydmljZUluc3RhbGxlZDogbnVsbCxcbiAgICAgICAgY2FwdHVyZWRTdGVwczogW10sXG4gICAgICB9LFxuXG4gICAgICAvLyBJbiBFTUJFRCBtYWtlIHRoaXMgZGF0YSBqdXN0IGEgYm9vbGVhbiBpbnN0ZWFkIHRoYXQgYSBtYXAgZGVwZW5kaW5nIG9uIHRoZSB0YWIgaWRcbiAgICAgIC8vICh3ZSBkb24ndCBoYXZlIGdyZWF0IGNvbnRyb2wgb3ZlciB0YWJzLCB0aHVzIHdlIGVpdGhlciBzaG93IG9yIGhpZGUgdGhlIHBhbmVsIGluIGFsbCB0YWJzL3BhZ2VzKVxuICAgICAgaXNQYW5lbE9wZW46IEVNQkVEID8gZmFsc2UgOiB7fSxcblxuICAgICAgaXNQYW5lbFN1cHBvcnRlZDogdHJ1ZSwgLy8gZm9yIHRoZSBjdXJyZW50IHRhYlxuICAgICAgaXNDdXJyZW50UGFnZUxlZ2FjeTogZmFsc2UsXG4gICAgICBpc0N1cnJlbnRQYWdlUG9wdXA6IGZhbHNlLFxuICAgICAgaXNFeHRlbnNpb25KdXN0SW5zdGFsbGVkOiBmYWxzZSxcbiAgICAgIGF1ZGlvUGxheWluZzogZmFsc2UsXG4gICAgICBhdWRpb011dGVkOiBmYWxzZSxcbiAgICAgIGFjdGl2ZVRhYklkOiBudWxsLFxuICAgICAgaXNTdGFydENhcHR1cmVPdmVybGF5VmlzaWJsZTogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGdldFBvcnRNYW5hZ2VyQ2xhc3MoKSB7XG4gICAgLy8gYWJzdHJhY3RcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0Rmx1eENsYXNzKCkge1xuICAgIHJldHVybiBGbHV4O1xuICB9XG5cbiAgZ2V0U2hhcmVkTWVtb3J5Q2xhc3MoKSB7XG4gICAgcmV0dXJuIFNoYXJlZE1lbW9yeTtcbiAgfVxuXG4gIGdldFN0b3JhZ2VDbGFzcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0VGFic0NvbnRyb2xsZXJDbGFzcygpIHtcbiAgICAvLyBhYnN0cmFjdFxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRQYW5lbENvbnRyb2xsZXJDbGFzcygpIHtcbiAgICByZXR1cm4gUGFuZWxDb250cm9sbGVyO1xuICB9XG5cbiAgZ2V0QnJvd3NlckNhcHR1cmVDbGFzcygpIHtcbiAgICAvLyBhYnN0cmFjdFxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRCcm93c2VyQWN0aW9uTWFuYWdlckNsYXNzKCkge1xuICAgIC8vIGFic3RyYWN0XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEJyaWRnZUNsYXNzKCkge1xuICAgIC8vIGFic3RyYWN0XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEF1ZGlvQ29udHJvbGxlckNsYXNzKCkge1xuICAgIHJldHVybiBBdWRpb0NvbnRyb2xsZXI7XG4gIH1cblxuICBnZXRTaG9ydGN1dHNDb250cm9sbGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFNob3J0Y3V0c0NvbnRyb2xsZXI7XG4gIH1cblxuICBnZXRVc2VyRGF0YUNsYXNzKCkge1xuICAgIHJldHVybiBVc2VyRGF0YTtcbiAgfVxuXG4gIGdldEF1dGhDbGFzcygpIHtcbiAgICAvLyBhYnN0cmFjdFxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvLyBpbnN0YW50aWF0ZSBtb2R1bGVzXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIGlkKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcblxuICAgIHRoaXMuYmFja2dyb3VuZElkID0gJ2lvcmFkXycgKyByYW5kb21TdHJpbmcoKTtcblxuICAgIGNvbnN0IFBvcnRNYW5hZ2VyQ2xhc3MgPSB0aGlzLmdldFBvcnRNYW5hZ2VyQ2xhc3MoKTtcbiAgICB0aGlzLnBvcnRNYW5hZ2VyID0gbmV3IFBvcnRNYW5hZ2VyQ2xhc3MoKTtcblxuICAgIGNvbnN0IEZsdXhDbGFzcyA9IHRoaXMuZ2V0Rmx1eENsYXNzKCk7XG4gICAgdGhpcy5mbHV4ID0gbmV3IEZsdXhDbGFzcygpO1xuXG4gICAgY29uc3QgU2hhcmVkTWVtb3J5Q2xhc3MgPSB0aGlzLmdldFNoYXJlZE1lbW9yeUNsYXNzKCk7XG4gICAgdGhpcy5zaGFyZWRNZW1vcnkgPSBuZXcgU2hhcmVkTWVtb3J5Q2xhc3MoKTtcblxuICAgIGNvbnN0IFN0b3JhZ2VDbGFzcyA9IHRoaXMuZ2V0U3RvcmFnZUNsYXNzKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGFzcygpO1xuXG4gICAgY29uc3QgUGFuZWxDb250cm9sbGVyQ2xhc3MgPSB0aGlzLmdldFBhbmVsQ29udHJvbGxlckNsYXNzKCk7XG4gICAgdGhpcy5wYW5lbENvbnRyb2xsZXIgPSBuZXcgUGFuZWxDb250cm9sbGVyQ2xhc3MoKTtcblxuICAgIGNvbnN0IEJyb3dzZXJDYXB0dXJlQ2xhc3MgPSB0aGlzLmdldEJyb3dzZXJDYXB0dXJlQ2xhc3MoKTtcbiAgICB0aGlzLmJyb3dzZXJDYXB0dXJlID0gbmV3IEJyb3dzZXJDYXB0dXJlQ2xhc3MoKTtcblxuICAgIGNvbnN0IEJyb3dzZXJBY3Rpb25NYW5hZ2VyQ2xhc3MgPSB0aGlzLmdldEJyb3dzZXJBY3Rpb25NYW5hZ2VyQ2xhc3MoKTtcbiAgICB0aGlzLmJyb3dzZXJBY3Rpb25NYW5hZ2VyID0gbmV3IEJyb3dzZXJBY3Rpb25NYW5hZ2VyQ2xhc3MoKTtcblxuICAgIGNvbnN0IEF1ZGlvQ29udHJvbGxlckNsYXNzID0gdGhpcy5nZXRBdWRpb0NvbnRyb2xsZXJDbGFzcygpO1xuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyID0gbmV3IEF1ZGlvQ29udHJvbGxlckNsYXNzKCk7XG5cbiAgICBjb25zdCBTaG9ydGN1dHNDb250cm9sbGVyQ2xhc3MgPSB0aGlzLmdldFNob3J0Y3V0c0NvbnRyb2xsZXJDbGFzcygpO1xuICAgIHRoaXMuc2hvcnRjdXRzQ29udHJvbGxlciA9IG5ldyBTaG9ydGN1dHNDb250cm9sbGVyQ2xhc3MoKTtcblxuICAgIGNvbnN0IFVzZXJEYXRhQ2xhc3MgPSB0aGlzLmdldFVzZXJEYXRhQ2xhc3MoKTtcbiAgICB0aGlzLnVzZXJEYXRhID0gbmV3IFVzZXJEYXRhQ2xhc3MoKTtcblxuICAgIGNvbnN0IFRhYnNDb250cm9sbGVyQ2xhc3MgPSB0aGlzLmdldFRhYnNDb250cm9sbGVyQ2xhc3MoKTtcbiAgICB0aGlzLnRhYnNDb250cm9sbGVyID0gbmV3IFRhYnNDb250cm9sbGVyQ2xhc3MoKTtcblxuICAgIGNvbnN0IEF1dGhDbGFzcyA9IHRoaXMuZ2V0QXV0aENsYXNzKCk7XG4gICAgdGhpcy5hdXRoID0gbmV3IEF1dGhDbGFzcygpO1xuICB9XG5cbiAgLy8gc3RhcnQgbW9kdWxlc1xuICAvLyAoaGF2aW5nIGEgc2VwYXJhdGUgbWV0aG9kIGZvciB0aGlzIHJlZHVjZXMgY2lyY3VsYXIgZGVwZW5kZW5jeSBwcm9ibGVtcylcbiAgc3RhcnQoKSB7XG4gICAgY29uc3QgQ2hyb21lQnJpZGdlQ2xhc3MgPSB0aGlzLmdldEJyaWRnZUNsYXNzKCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuc2V0dXBJb3JhZEV4dGVuc2lvbkV4aXN0ZW5jZSgpKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5wb3J0TWFuYWdlci5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuZmx1eC5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuc2hhcmVkTWVtb3J5LnN0YXJ0KHRoaXMpKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zdG9yYWdlLnN0YXJ0KHRoaXMpKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy50YWJzQ29udHJvbGxlci5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMucGFuZWxDb250cm9sbGVyLnN0YXJ0KHRoaXMpKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5icm93c2VyQ2FwdHVyZS5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuYnJvd3NlckFjdGlvbk1hbmFnZXIuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmF1ZGlvQ29udHJvbGxlci5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuc2hvcnRjdXRzQ29udHJvbGxlci5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMudXNlckRhdGEuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmF1dGguc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiBDaHJvbWVCcmlkZ2VDbGFzcy5saXN0ZW4odGhpcykpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzdGFydCBiYWNrZ3JvdW5kJywgZSkpO1xuICB9XG5cbiAgc2V0dXBJb3JhZEV4dGVuc2lvbkV4aXN0ZW5jZSgpIHtcbiAgICAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uOiBuby1vcFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2JhY2tncm91bmQvRXh0ZW5zaW9uLmpzIiwiaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9ydE1hbmFnZXIge1xuICBnZXREb2N1bWVudHNQb3J0Q2xhc3MoKSB7XG4gICAgLy8gYWJzdHJhY3RcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgc3RhcnQoZXh0ZW5zaW9uKSB7XG4gICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbiAgICB0aGlzLnNldHVwRG9jdW1lbnRzUG9ydCgpO1xuICB9XG5cbiAgc2V0dXBEb2N1bWVudHNQb3J0KCkge1xuICAgIC8vIHRoaXMgY29ubmVjdHMgaW1tZWRpYXRlbHlcbiAgICBjb25zdCBEb2N1bWVudHNQb3J0Q2xhc3MgPSB0aGlzLmdldERvY3VtZW50c1BvcnRDbGFzcygpO1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydCA9IG5ldyBEb2N1bWVudHNQb3J0Q2xhc3MobnVsbCwgJycsIHRoaXMuZXh0ZW5zaW9uKTtcbiAgICB0aGlzLmRvY3VtZW50c1BvcnQuY29ubmVjdCgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2JhY2tncm91bmQvUG9ydE1hbmFnZXIuanMiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNob3J0Y3V0c0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcblxuICAgIHRoaXMuc2V0dXBEb2N1bWVudHMoKTtcbiAgfVxuXG4gIHNldHVwRG9jdW1lbnRzKCkge1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmRvY3VtZW50c1BvcnQ7XG4gICAgdGhpcy5kb2N1bWVudHNQb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVEb2N1bWVudHNNZXNzYWdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlRG9jdW1lbnRzTWVzc2FnZShtZXNzYWdlLCByZXNwb25kKSB7XG4gICAgaWYgKG1lc3NhZ2UuaG90S2V5KSB7XG4gICAgICBjb25zdCBob3RLZXkgPSBtZXNzYWdlLmhvdEtleTtcbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhcImNvbWluZyBmcm9tIGhvdCBrZXlcIixob3RLZXkpO1xuXG4gICAgICAvLyBjb21wYXJlIHdpdGggdXNlciBzaG9ydGN1dHNcbiAgICAgIHRoaXMuZXh0ZW5zaW9uLnVzZXJEYXRhLmdldFVzZXJEYXRhKCkudGhlbigoeyBzaG9ydGN1dHMgfSkgPT4ge1xuICAgICAgICAvLyBUT0RPIDogdXNlIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGtleURvbmUgPSBzaG9ydGN1dHMuZG9uZSB8fCAnQWx0ICsgRCc7XG4gICAgICAgIGNvbnN0IGtleUNhcHR1cmUgPSBzaG9ydGN1dHMudG9nZ2xlQ2FwdHVyZSB8fCAnQWx0ICsgUCc7XG5cbiAgICAgICAgaWYgKGhvdEtleS50b0xvd2VyQ2FzZSgpID09PSBrZXlDYXB0dXJlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2tleTpjYXB0dXJlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaG90S2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleURvbmUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgna2V5OmRvbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2JhY2tncm91bmQvU2hvcnRjdXRzQ29udHJvbGxlci5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnYmFzZS9jb21tb24vQ29tcG9uZW50JztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFic0NvbnRyb2xsZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hY3RpdmVUYWJJZCA9IG51bGw7XG4gICAgdGhpcy50YWJJbmZvTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgc3RhcnQoLi4uYXJncykge1xuICAgIHN1cGVyLnN0YXJ0KC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5zZXR1cERvY3VtZW50cygpO1xuICAgIHRoaXMubW9uaXRvckFjdGl2ZVRhYklkKCk7XG5cbiAgICB0aGlzLmxpc3RlblRhYk9uVXBkYXRlZCgodGFiSWQsIF8sIHRhYikgPT4gdGhpcy5vblRhYlVwZGF0ZWQoeyB0YWJJZCwgdGFiIH0pKTtcbiAgICB0aGlzLmxpc3RlblRhYk9uUmVtb3ZlZCh0YWJJZCA9PiB0aGlzLm9uVGFiUmVtb3ZlZCh7IHRhYklkIH0pKTtcbiAgfVxuXG4gIHNldHVwRG9jdW1lbnRzKCkge1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmRvY3VtZW50c1BvcnQ7XG4gICAgdGhpcy5kb2N1bWVudHNQb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVEb2N1bWVudHNNZXNzYWdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgbW9uaXRvckFjdGl2ZVRhYklkKCkge1xuICAgIHRoaXMuZ2V0QWN0aXZlVGFiSWQoKS50aGVuKHRhYklkID0+IHtcbiAgICAgIHRoaXMub25BY3RpdmVUYWJDaGFuZ2VkKHsgdGFiSWQgfSk7XG4gICAgICB0aGlzLmxpc3RlblRhYk9uQWN0aXZhdGVkKGluZm8gPT4gdGhpcy5vbkFjdGl2ZVRhYkNoYW5nZWQoaW5mbykpO1xuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlRG9jdW1lbnRzTWVzc2FnZShtZXNzYWdlLCByZXNwb25kKSB7XG4gICAgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbjogbm8tb3BcbiAgfVxuXG4gIGxpc3RlblRhYk9uVXBkYXRlZChjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBsaXN0ZW5UYWJPbkFjdGl2YXRlZChjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBsaXN0ZW5UYWJPblJlbW92ZWQoY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0VGFiKHRhYklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEFjdGl2ZVRhYklkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRBbGxUYWJzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBzZXRUYWJJbmZvKGlkLCBpbmZvKSB7XG4gICAgY29uc3QgdXBkYXRlZEluZm8gPSB7XG4gICAgICAuLi50aGlzLmdldFRhYkluZm8oaWQpLFxuICAgICAgLi4uaW5mbyxcbiAgICB9O1xuICAgIHRoaXMudGFiSW5mb01hcC5zZXQoaWQsIHVwZGF0ZWRJbmZvKTtcbiAgICByZXR1cm4gdXBkYXRlZEluZm87XG4gIH1cblxuICBnZXRUYWJJbmZvKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFiSW5mb01hcC5nZXQoaWQpIHx8IHt9O1xuICB9XG5cbiAgY2xlYXJUYWJJbmZvKGlkKSB7XG4gICAgdGhpcy50YWJJbmZvTWFwLmRlbGV0ZShpZCk7XG4gIH1cblxuICBvbkFjdGl2ZVRhYkNoYW5nZWQoaW5mbykge1xuICAgIHRoaXMuYWN0aXZlVGFiSWQgPSBpbmZvLnRhYklkO1xuICAgIHRoaXMuYWN0aXZlVGFiU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMub3duQ29udGV4dCgpLmRpc3BhdGNoKCdzZXRBY3RpdmVUYWJJZCcsIGluZm8udGFiSWQpO1xuICAgIHRoaXMuZW1pdCgnYWN0aXZlVGFiQ2hhbmdlZCcsIGluZm8pO1xuICB9XG5cbiAgb25UYWJVcGRhdGVkKGluZm8pIHtcbiAgICB0aGlzLmVtaXQoJ3RhYlVwZGF0ZWQnLCBpbmZvKTtcbiAgfVxuXG4gIG9uVGFiUmVtb3ZlZChpbmZvKSB7XG4gICAgdGhpcy5lbWl0KCd0YWJSZW1vdmVkJywgaW5mbyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvYmFja2dyb3VuZC9UYWJzQ29udHJvbGxlci5qcyIsImltcG9ydCBwaWNrQnkgZnJvbSAnbG9kYXNoL3BpY2tCeSc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJ2xvZGFzaC92YWx1ZXMnO1xuXG5pbXBvcnQgeyBnZXRGaWxlTG9nZ2VyIH0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXJEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICB9XG5cbiAgc3RhcnQoZXh0ZW5zaW9uKSB7XG4gICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbiAgICB0aGlzLnNldHVwRG9jdW1lbnRzKCk7XG4gICAgdGhpcy5yZWZyZXNoVXNlckRhdGEoKTtcbiAgfVxuXG4gIHNldHVwRG9jdW1lbnRzKCkge1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmRvY3VtZW50c1BvcnQ7XG4gICAgdGhpcy5kb2N1bWVudHNQb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVEb2N1bWVudHNNZXNzYWdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlRG9jdW1lbnRzTWVzc2FnZShtZXNzYWdlLCByZXNwb25kKSB7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBnZXRVc2VyRGF0YTogKCkgPT4gcmVzcG9uZCh0aGlzLnVzZXJEYXRhKSxcbiAgICAgIHNldFVzZXJEYXRhOiAoKSA9PiB0aGlzLnNldFVzZXJEYXRhKG1lc3NhZ2UuZGF0YS51c2VyRGF0YSksXG4gICAgfTtcblxuICAgIGNvbnN0IG1hdGNoZWRIYW5kbGVycyA9IHBpY2tCeShoYW5kbGVycywgKHYsIGspID0+IGsgPT09IG1lc3NhZ2UudG9waWMpO1xuICAgIHZhbHVlcyhtYXRjaGVkSGFuZGxlcnMpLmZvckVhY2goZiA9PiBmKCkpOyAvLyBydW5uaW5nIGhhbmRsZXJzXG4gIH1cblxuICByZWZyZXNoVXNlckRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VXNlckRhdGEoKS50aGVuKHVzZXJEYXRhID0+IHRoaXMudXNlckRhdGEgPSB1c2VyRGF0YSk7XG4gIH1cblxuICBnZXRVc2VyRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb24uc3RvcmFnZS5nZXQoe1xuICAgICAgdmlld2VkVHV0b3JpYWxzOiBbXSxcbiAgICAgIHByZWZzOiB7XG4gICAgICAgICdrZXlfY2FwdHVyZSc6ICdBbHQgKyBQJyxcbiAgICAgICAgJ2tleV9kb25lJzogJ0FsdCArIEQnLFxuICAgICAgfSxcbiAgICAgIHNob3duTWVzc2FnZXM6IFtdLFxuICAgIH0pLnRoZW4oKHsgcHJlZnMsIHZpZXdlZFR1dG9yaWFscywgc2hvd25NZXNzYWdlcyB9KSA9PiAoe1xuICAgICAgc2hvcnRjdXRzOiB7XG4gICAgICAgIHRvZ2dsZUNhcHR1cmU6IHByZWZzLmtleV9jYXB0dXJlLFxuICAgICAgICBkb25lOiBwcmVmcy5rZXlfZG9uZSxcbiAgICAgIH0sXG4gICAgICB2aWV3ZWRUdXRvcmlhbHMsXG4gICAgICBzaG93bk1lc3NhZ2VzLFxuICAgIH0pKTtcbiAgfVxuXG4gIHNldFVzZXJEYXRhKHVzZXJEYXRhKSB7XG4gICAgdGhpcy51c2VyRGF0YSA9IHsgLi4udGhpcy51c2VyRGF0YSwgLi4udXNlckRhdGEgfTtcbiAgICBjb25zdCB7IHNob3J0Y3V0cywgLi4uZGF0YSB9ID0gdGhpcy51c2VyRGF0YTtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb24uc3RvcmFnZS5zZXQoe1xuICAgICAgcHJlZnM6IHtcbiAgICAgICAgJ2tleV9jYXB0dXJlJzogc2hvcnRjdXRzLnRvZ2dsZUNhcHR1cmUsXG4gICAgICAgICdrZXlfZG9uZSc6IHNob3J0Y3V0cy5kb25lLFxuICAgICAgfSxcbiAgICAgIC4uLmRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvYmFja2dyb3VuZC9Vc2VyRGF0YS5qcyIsImltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFjdGlvbnNGYWN0b3J5KHsgc2V0U3RhdGUsIGdldFN0YXRlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBzZXRQYW5lbE9wZW4odGFiSWQsIGlzT3Blbikge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiUmVjZWl2ZWQgc2V0UGFuZWxPcGVuXCIsIHRhYklkLCBpc09wZW4sIEVNQkVEKTtcbiAgICAgIGlmIChFTUJFRCkge1xuICAgICAgICBpZiAoaXNPcGVuID09PSBnZXRTdGF0ZSgpLmlzUGFuZWxPcGVuKSByZXR1cm47XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc1BhbmVsT3BlbjogaXNPcGVuLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKHN0YXRlID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgaXNQYW5lbE9wZW46IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmlzUGFuZWxPcGVuLFxuICAgICAgICAgICAgW3RhYklkXTogaXNPcGVuLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXJQYW5lbE9wZW4odGFiSWQpIHtcbiAgICAgIGlmIChFTUJFRCkgcmV0dXJuO1xuICAgICAgc2V0U3RhdGUoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBpc1BhbmVsT3BlbiA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmlzUGFuZWxPcGVuKTtcbiAgICAgICAgZGVsZXRlIGlzUGFuZWxPcGVuW3RhYklkXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBpc1BhbmVsT3BlbixcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXRQYW5lbChwYW5lbCwgZXhjbHVkZWRUYWJzKSB7XG4gICAgICBzZXRTdGF0ZSh7IHBhbmVsIH0sIGV4Y2x1ZGVkVGFicyk7XG4gICAgfSxcblxuICAgIGV4dGVuZFBhbmVsU3RhdGUocGFuZWxTdGF0ZSwgZXhjbHVkZWRUYWJzID0gW10pIHtcbiAgICAgIHNldFN0YXRlKHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBwYW5lbDoge1xuICAgICAgICAgIC4uLnN0YXRlLnBhbmVsLFxuICAgICAgICAgIC4uLnBhbmVsU3RhdGUsXG4gICAgICAgIH0sXG4gICAgICB9KSwgZXhjbHVkZWRUYWJzKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kQ2FwdHVyZVN0YXRlKGNhcHR1cmVTdGF0ZSwgZXhjbHVkZWRUYWJzID0gW10pIHtcbiAgICAgIHNldFN0YXRlKHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBjYXB0dXJlOiB7XG4gICAgICAgICAgLi4uc3RhdGUuY2FwdHVyZSxcbiAgICAgICAgICAuLi5jYXB0dXJlU3RhdGUsXG4gICAgICAgIH1cbiAgICAgIH0pLCBleGNsdWRlZFRhYnMpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVJc0N1cnJlbnRQYWdlTGVnYWN5KHZhbHVlKSB7XG4gICAgICBzZXRTdGF0ZSh7IGlzQ3VycmVudFBhZ2VMZWdhY3k6IHZhbHVlIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGVJc0N1cnJlbnRQYWdlUG9wdXAodmFsdWUpIHtcbiAgICAgIHNldFN0YXRlKHsgaXNDdXJyZW50UGFnZVBvcHVwOiB2YWx1ZSB9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlSXNFeHRlbnNpb25KdXN0SW5zdGFsbGVkKHZhbHVlKSB7XG4gICAgICBzZXRTdGF0ZSh7IGlzRXh0ZW5zaW9uSnVzdEluc3RhbGxlZDogdmFsdWUgfSk7XG4gICAgfSxcblxuICAgIHRvZ2dsZUlzUGFuZWxTdXBwb3J0ZWQodmFsdWUpIHtcbiAgICAgIHNldFN0YXRlKHsgaXNQYW5lbFN1cHBvcnRlZDogdmFsdWUgfSk7XG4gICAgfSxcblxuICAgIHNldEF1ZGlvUGxheWluZyh2YWx1ZSkge1xuICAgICAgc2V0U3RhdGUoeyBhdWRpb1BsYXlpbmc6IHZhbHVlIH0pO1xuICAgIH0sXG5cbiAgICBzZXRBdWRpb011dGVkKHZhbHVlKSB7XG4gICAgICBzZXRTdGF0ZSh7IGF1ZGlvTXV0ZWQ6IHZhbHVlIH0pO1xuICAgIH0sXG5cbiAgICBzZXRBY3RpdmVUYWJJZCh2YWx1ZSkge1xuICAgICAgc2V0U3RhdGUoeyBhY3RpdmVUYWJJZDogdmFsdWUgfSk7XG4gICAgfSxcblxuICAgIHNldFRhYnNDb3VudCh2YWx1ZSkge1xuICAgICAgc2V0U3RhdGUoeyB0YWJzQ291bnQ6IHZhbHVlIH0pO1xuICAgIH0sXG5cblxuICAgIHRvZ2dsZUlzU3RhcnRDYXB0dXJlT3ZlcmxheVZpc2libGUodmFsdWUpIHtcbiAgICAgIHNldFN0YXRlKHsgaXNTdGFydENhcHR1cmVPdmVybGF5VmlzaWJsZTogdmFsdWUgfSk7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9iYWNrZ3JvdW5kL2FjdGlvbnMuanMiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cblxuY2xhc3MgQXVkaW9QbGF5ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXJsID0gdXJsIHx8ICcnO1xuICAgIHRoaXMuc291bmQgPSBuZXcgQXVkaW8odXJsKTtcbiAgICB0aGlzLnNvdW5kLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCAoKSA9PiB0aGlzLmVtaXQoJ3BsYXknKSk7XG4gICAgdGhpcy5zb3VuZC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHRoaXMuZW1pdCgnZW5kJykpO1xuICB9XG4gIHBsYXkoKSB7XG4gICAgaWYgKHRoaXMuc291bmQucGF1c2VkIHx8IHRoaXMuc291bmQuY3VycmVudFRpbWUgPT09IDApIHRoaXMuc291bmQucGxheSgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zb3VuZC5wYXVzZSgpO1xuICAgIGlmICh0aGlzLnNvdW5kLmN1cnJlbnRUaW1lICE9PSAwKSB7IC8vIChGRiBmaXg6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMzkwNTUwLzE0MTgwNDksICM0NDApXG4gICAgICB0aGlzLnNvdW5kLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG4gIH1cbiAgc2V0Vm9sdW1lKHZhbCkge1xuICAgIHRoaXMuc291bmQudm9sdW1lID0gdmFsO1xuICAgIHRoaXMuZW1pdCgndm9sdW1lQ2hhbmdlZCcsIHZhbCk7XG4gIH1cbiAgc2V0VXJsKHVybCkge1xuICAgIGlmICh0aGlzLnNvdW5kLnNyYyAhPT0gdXJsKSB0aGlzLnNvdW5kLnNyYyA9IHVybDtcbiAgfVxuICBnZXRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291bmQuc3JjO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvUGxheWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vQXVkaW9QbGF5ZXIuanMiLCIvLyBBYnN0cmFjdCBjbGFzc1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgfVxuXG4gIGdldChrZXlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIHNldChpdGVtcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICByZW1vdmUoa2V5cykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9TdG9yYWdlLmpzIiwiZXhwb3J0IGRlZmF1bHQgKHsgc3R5bGVzIH0pID0+IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjMgMjNcIj5cbiAgPGRlZnM+XG4gICAgPHN0eWxlPiR7c3R5bGVzfS5jbHMtMXtmaWxsOiMwMDkwZTI7fX08L3N0eWxlPlxuICA8L2RlZnM+XG4gIDx0aXRsZT5kcmFnLW4tZHJvcDwvdGl0bGU+XG4gIDxnIGlkPVwi0KHQu9C+0LlfMlwiIGRhdGEtbmFtZT1cItCh0LvQvtC5IDJcIiBjbGFzcz1cImlvcmFkLXRvb2wtaWNvblwiPlxuICAgIDxnIGlkPVwiQ29udGVudFwiPlxuICAgICAgPHBvbHlnb24gY2xhc3M9XCJjbHMtMSBmaWxsXCIgcG9pbnRzPVwiMTUgMTggMTEuNSAyMyA4IDE4IDE1IDE4XCIvPlxuICAgICAgPHBvbHlnb24gY2xhc3M9XCJjbHMtMSBmaWxsXCIgcG9pbnRzPVwiOCA1IDExLjUgMCAxNSA1IDggNVwiLz5cbiAgICAgIDxyZWN0IGNsYXNzPVwiY2xzLTEgZmlsbFwiIHg9XCIxMVwiIHk9XCI1XCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMTNcIi8+XG4gICAgICA8cmVjdCBjbGFzcz1cImNscy0xIGZpbGxcIiB4PVwiMTFcIiB5PVwiNVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjEzXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIzIDApIHJvdGF0ZSg5MClcIi8+XG4gICAgICA8cG9seWdvbiBjbGFzcz1cImNscy0xIGZpbGxcIiBwb2ludHM9XCI1IDE1IDAgMTEuNSA1IDggNSAxNVwiLz5cbiAgICAgIDxwb2x5Z29uIGNsYXNzPVwiY2xzLTEgZmlsbFwiIHBvaW50cz1cIjE4IDggMjMgMTEuNSAxOCAxNSAxOCA4XCIvPlxuICAgICAgPGNpcmNsZSBjbGFzcz1cImNscy0xIGZpbGxcIiBjeD1cIjExLjVcIiBjeT1cIjExLjVcIiByPVwiMi41XCIvPlxuICAgIDwvZz5cbiAgPC9nPlxuPC9zdmc+XG5gO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vc3ZnSW5saW5lL2RyYWctbi1kcm9wLmpzIiwiZXhwb3J0IGRlZmF1bHQgKHsgc3R5bGVzIH0pID0+IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTggMjdcIj5cbiAgPGRlZnM+PHN0eWxlPiR7c3R5bGVzfS5jbHMtMXtmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPlxuICA8dGl0bGU+aG92ZXI8L3RpdGxlPlxuICA8ZyBpZD1cItCh0LvQvtC5XzJcIiBkYXRhLW5hbWU9XCLQodC70L7QuSAyXCIgY2xhc3M9XCJpb3JhZC10b29sLWljb25cIj5cbiAgICA8ZyBpZD1cItCh0LvQvtC5XzEtMlwiIGRhdGEtbmFtZT1cItCh0LvQvtC5IDFcIj5cbiAgICAgIDxnIGlkPVwi0KHQu9C+0LlfMi0yXCIgZGF0YS1uYW1lPVwi0KHQu9C+0LkgMlwiPlxuICAgICAgICA8ZyBpZD1cIkNvbnRlbnRcIj5cbiAgICAgICAgICA8cGF0aCBjbGFzcz1cImNscy0xIGZpbGxcIiBkPVwiTTksMmE3LDcsMCwwLDEsNyw3djlBNyw3LDAsMCwxLDIsMThWOUE3LDcsMCwwLDEsOSwyTTksMEE5LDksMCwwLDAsMCw5djlhOSw5LDAsMCwwLDE4LDBWOUE5LDksMCwwLDAsOSwwWlwiLz5cbiAgICAgICAgICA8cGF0aCBjbGFzcz1cImNscy0xIGZpbGxcIiBkPVwiTTksMTRhMSwxLDAsMCwxLTEtMVYxYTEsMSwwLDAsMSwyLDBWMTNBMSwxLDAsMCwxLDksMTRaXCIvPlxuICAgICAgICA8L2c+XG4gICAgICA8L2c+XG4gICAgPC9nPlxuICA8L2c+XG48L3N2Zz5cbmA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvaG92ZXIuanMiLCJleHBvcnQgZGVmYXVsdCAoeyBzdHlsZXMgfSkgPT4gYFxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxOCAyN1wiPlxuICA8ZGVmcz48c3R5bGU+JHtzdHlsZXN9LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6IzAwOTBlMjt9PC9zdHlsZT48L2RlZnM+XG4gIDx0aXRsZT5sZWZ0LWNsaWNrPC90aXRsZT5cbiAgPGcgaWQ9XCLQodC70L7QuV8yXCIgZGF0YS1uYW1lPVwi0KHQu9C+0LkgMlwiIGNsYXNzPVwiaW9yYWQtdG9vbC1pY29uXCI+XG4gICAgPGcgaWQ9XCJDb250ZW50XCI+XG4gICAgICA8cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk05LDI2YTgsOCwwLDAsMS04LThWOUE4LDgsMCwxLDEsMTcsOXY5QTgsOCwwLDAsMSw5LDI2WlwiLz5cbiAgICAgIDxwYXRoIGNsYXNzPVwiY2xzLTIgZmlsbFwiIGQ9XCJNOSwyYTcsNywwLDAsMSw3LDd2OUE3LDcsMCwwLDEsMiwxOFY5QTcsNywwLDAsMSw5LDJNOSwwQTksOSwwLDAsMCwwLDl2OWE5LDksMCwwLDAsMTgsMFY5QTksOSwwLDAsMCw5LDBaXCIvPlxuICAgICAgPHBhdGggY2xhc3M9XCJjbHMtMiBmaWxsXCIgZD1cIk0wLDl2NUg5VjBBOSw5LDAsMCwwLDAsOVpcIi8+XG4gICAgPC9nPlxuICA8L2c+XG48L3N2Zz5cbmA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvbGVmdC1jbGljay5qcyIsImV4cG9ydCBkZWZhdWx0ICh7IHN0eWxlcyB9KSA9PiBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0Ljc4IDE1XCI+XG4gIDxkZWZzPlxuICAgIDxzdHlsZT4ke3N0eWxlc30uY2xzLTF7ZmlsbDojZmZmO3N0cm9rZTojMDA5MGUyO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS13aWR0aDoycHg7fS5jbHMtMntmaWxsOiMwMDkwZTI7fTwvc3R5bGU+XG4gIDwvZGVmcz5cbiAgPHRpdGxlPnJlYWQ8L3RpdGxlPlxuICA8ZyBpZD1cItCh0LvQvtC5XzJcIiBkYXRhLW5hbWU9XCLQodC70L7QuSAyXCIgY2xhc3M9XCJpb3JhZC10b29sLWljb25cIj5cbiAgICA8ZyBpZD1cIkNvbnRlbnRcIj5cbiAgICAgIDxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTEuNDYsNi4yNmExLjksMS45LDAsMCwwLDAsMi40N0ExNC40MywxNC40MywwLDAsMCwxMi4zOSwxNCwxNC40MywxNC40MywwLDAsMCwyMy4zMyw4Ljc0YTEuOSwxLjksMCwwLDAsMC0yLjQ3QTE0LjQzLDE0LjQzLDAsMCwwLDEyLjM5LDEsMTQuNDMsMTQuNDMsMCwwLDAsMS40Niw2LjI2WlwiLz5cbiAgICAgIDxjaXJjbGUgY2xhc3M9XCJjbHMtMiBmaWxsXCIgY3g9XCIxMi4zOVwiIGN5PVwiNy41XCIgcj1cIjMuNVwiLz5cbiAgICA8L2c+XG4gIDwvZz5cbjwvc3ZnPlxuYDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9yZWFkLmpzIiwiZXhwb3J0IGRlZmF1bHQgKHsgc3R5bGVzIH0pID0+IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMTggMjdcIj5cbiAgPGRlZnM+XG4gICAgPHN0eWxlPiR7c3R5bGVzfS5jbHMtMXtmaWxsOiNmZmY7fS5jbHMtMntmaWxsOiMwMDkwZTI7fTwvc3R5bGU+XG4gIDwvZGVmcz5cbiAgPHRpdGxlPnJpZ2h0LWNsaWNrPC90aXRsZT5cbiAgPGcgaWQ9XCLQodC70L7QuV8yXCIgZGF0YS1uYW1lPVwi0KHQu9C+0LkgMlwiIGNsYXNzPVwiaW9yYWQtdG9vbC1pY29uXCI+XG4gICAgPGcgaWQ9XCJDb250ZW50XCI+XG4gICAgICA8cGF0aCBjbGFzcz1cImNscy0xXCIgZD1cIk05LDI2YTgsOCwwLDAsMS04LThWOUE4LDgsMCwxLDEsMTcsOXY5QTgsOCwwLDAsMSw5LDI2WlwiLz5cbiAgICAgIDxwYXRoIGNsYXNzPVwiY2xzLTIgZmlsbFwiIGQ9XCJNOSwyYTcsNywwLDAsMSw3LDd2OUE3LDcsMCwwLDEsMiwxOFY5QTcsNywwLDAsMSw5LDJNOSwwQTksOSwwLDAsMCwwLDl2OWE5LDksMCwwLDAsMTgsMFY5QTksOSwwLDAsMCw5LDBaXCIvPlxuICAgICAgPHBhdGggY2xhc3M9XCJjbHMtMiBmaWxsXCIgZD1cIk0xOCw5djVIOVYwQTksOSwwLDAsMSwxOCw5WlwiLz5cbiAgICA8L2c+XG4gIDwvZz5cbjwvc3ZnPlxuYDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9yaWdodC1jbGljay5qcyIsImV4cG9ydCBkZWZhdWx0ICh7IHN0eWxlcyB9KSA9PiBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE4IDI3XCI+XG4gIDxkZWZzPlxuICAgIDxzdHlsZT4ke3N0eWxlc30uY2xzLTF7ZmlsbDojZmZmO30uY2xzLTJ7ZmlsbDojMDA5MGUyO308L3N0eWxlPlxuICA8L2RlZnM+XG4gIDx0aXRsZT5zY3JvbGw8L3RpdGxlPlxuICA8ZyBpZD1cItCh0LvQvtC5XzJcIiBkYXRhLW5hbWU9XCLQodC70L7QuSAyXCIgY2xhc3M9XCJpb3JhZC10b29sLWljb25cIj5cbiAgICA8ZyBpZD1cIkNvbnRlbnRcIj5cbiAgICAgIDxwYXRoIGNsYXNzPVwiY2xzLTFcIiBkPVwiTTksMjZhOCw4LDAsMCwxLTgtOFY5QTgsOCwwLDEsMSwxNyw5djlBOCw4LDAsMCwxLDksMjZaXCIvPlxuICAgICAgPHBhdGggY2xhc3M9XCJjbHMtMiBmaWxsXCIgZD1cIk05LDJhNyw3LDAsMCwxLDcsN3Y5QTcsNywwLDAsMSwyLDE4VjlBNyw3LDAsMCwxLDksMk05LDBBOSw5LDAsMCwwLDAsOXY5YTksOSwwLDAsMCwxOCwwVjlBOSw5LDAsMCwwLDksMFpcIi8+XG4gICAgICA8cmVjdCBjbGFzcz1cImNscy0yIGZpbGxcIiB4PVwiN1wiIHk9XCI0XCIgd2lkdGg9XCI0XCIgaGVpZ2h0PVwiOVwiIHJ4PVwiMlwiIHJ5PVwiMlwiLz5cbiAgICA8L2c+XG4gIDwvZz5cbjwvc3ZnPlxuYDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS9zY3JvbGwuanMiLCJpbXBvcnQgZHJhZ0FuZERyb3AgZnJvbSAnLi9kcmFnLW4tZHJvcCc7XG5pbXBvcnQgbGVmdENsaWNrIGZyb20gJy4vbGVmdC1jbGljayc7XG5pbXBvcnQgcmlnaHRDbGljayBmcm9tICcuL3JpZ2h0LWNsaWNrJztcbmltcG9ydCByZWFkIGZyb20gJy4vcmVhZCc7XG5pbXBvcnQgc2Nyb2xsIGZyb20gJy4vc2Nyb2xsJztcbmltcG9ydCB0eXBlIGZyb20gJy4vdHlwZSc7XG5pbXBvcnQgaG92ZXIgZnJvbSAnLi9ob3Zlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGVmdENsaWNrLCByaWdodENsaWNrLCByZWFkLCBzY3JvbGwsIHR5cGUsIGRyYWdBbmREcm9wLCBob3Zlcixcbn07XG5cbmV4cG9ydCBjb25zdCB0b29sVHlwZVRvU3ZnID0gKHRvb2xUeXBlKSA9PiAoe1xuICBSRUFEOiByZWFkLFxuICBMRUZUX0NMSUNLOiBsZWZ0Q2xpY2ssXG4gIFJJR0hUX0NMSUNLOiByaWdodENsaWNrLFxuICBTQ1JPTEw6IHNjcm9sbCxcbiAgVFlQSU5HOiB0eXBlLFxuICBEUkFHOiBkcmFnQW5kRHJvcCxcbiAgRFJPUDogZHJhZ0FuZERyb3AsXG4gIEhPVkVSOiBob3Zlcixcbn0pW3Rvb2xUeXBlXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS90b29scy5qcyIsImV4cG9ydCBkZWZhdWx0ICh7IHN0eWxlcyB9KSA9PiBgXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gIDxkZWZzPlxuICAgIDxzdHlsZT4ke3N0eWxlc30uY2xzLTF7ZmlsbDojZmZmO30uY2xzLTIsLmNscy0ze2ZpbGw6IzAwOTBlMjt9LmNscy0ze2ZvbnQtc2l6ZToxNnB4O2ZvbnQtZmFtaWx5OlRpbWVzTmV3Um9tYW5QUy1Cb2xkTVQsIFRpbWVzIE5ldyBSb21hbjtmb250LXdlaWdodDo3MDA7bGV0dGVyLXNwYWNpbmc6LTAuMDJlbTt9PC9zdHlsZT5cbiAgPC9kZWZzPlxuICA8dGl0bGU+dHlwZTwvdGl0bGU+XG4gIDxnIGlkPVwi0KHQu9C+0LlfMlwiIGRhdGEtbmFtZT1cItCh0LvQvtC5IDJcIiBjbGFzcz1cImlvcmFkLXRvb2wtaWNvblwiPlxuICAgIDxnIGlkPVwiQ29udGVudFwiPlxuICAgICAgPHJlY3QgY2xhc3M9XCJjbHMtMVwiIHg9XCIxXCIgeT1cIjFcIiB3aWR0aD1cIjIyXCIgaGVpZ2h0PVwiMjJcIiByeD1cIjNcIiByeT1cIjNcIi8+XG4gICAgICA8cGF0aCBjbGFzcz1cImNscy0yIGZpbGxcIiBkPVwiTTIwLDJhMiwyLDAsMCwxLDIsMlYyMGEyLDIsMCwwLDEtMiwySDRhMiwyLDAsMCwxLTItMlY0QTIsMiwwLDAsMSw0LDJIMjBtMC0ySDRBNCw0LDAsMCwwLDAsNFYyMGE0LDQsMCwwLDAsNCw0SDIwYTQsNCwwLDAsMCw0LTRWNGE0LDQsMCwwLDAtNC00WlwiLz5cbiAgICAgIDx0ZXh0IGNsYXNzPVwiY2xzLTMgZmlsbFwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2LjgxIDE3KVwiPlQ8L3RleHQ+XG4gICAgPC9nPlxuICA8L2c+XG48L3N2Zz5cbmA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi9zdmdJbmxpbmUvdHlwZS5qcyIsImV4cG9ydCBkZWZhdWx0ICgpID0+IGBcbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgPGRlZnM+XG4gICAgICAgICAgPHN0eWxlPlxuICAgICAgICAgICAgICAuY2xzLXplbmRlc2std2lkZ2V0LWNsb3NlLWljb24tMiB7XG4gICAgICAgICAgICAgICAgICBmaWxsOiBub25lO1xuICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAjZmZmO1xuICAgICAgICAgICAgICAgICAgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1xuICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICA8L3N0eWxlPlxuICAgICAgPC9kZWZzPlxuICAgICAgPHRpdGxlPtCg0LXRgdGD0YDRgSAxODwvdGl0bGU+XG4gICAgICA8ZyBpZD1cItCh0LvQvtC5XzJcIiBkYXRhLW5hbWU9XCLQodC70L7QuSAyXCI+XG4gICAgICAgICAgPGcgaWQ9XCJDb250ZW50XCI+XG4gICAgICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiMzMGFhYmNcIiBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCIxMlwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMi4wMiAyMS41Nikgcm90YXRlKC03OS4yOSlcIiAvPlxuICAgICAgICAgICAgICA8bGluZSBjbGFzcz1cImNscy16ZW5kZXNrLXdpZGdldC1jbG9zZS1pY29uLTJcIiB4MT1cIjguNDdcIiB5MT1cIjguNDdcIiB4Mj1cIjE1LjU0XCIgeTI9XCIxNS41NFwiIC8+XG4gICAgICAgICAgICAgIDxsaW5lIGNsYXNzPVwiY2xzLXplbmRlc2std2lkZ2V0LWNsb3NlLWljb24tMlwiIHgxPVwiMTUuNTRcIiB5MT1cIjguNDdcIiB4Mj1cIjguNDdcIiB5Mj1cIjE1LjU0XCIgLz5cbiAgICAgICAgICA8L2c+XG4gICAgICA8L2c+XG4gIDwvc3ZnPlxuYDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS96ZW5kZXNrLXdpZGdldC1jbG9zZS1pY29uLmpzIiwiZXhwb3J0IGRlZmF1bHQgKCkgPT4gYFxuICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgPGc+XG4gICAgICA8Zz5cbiAgICAgICAgPGNpcmNsZSBmaWxsPVwiI2RlZGVkZVwiIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEyXCIgLz5cbiAgICAgICAgPHBvbHlnb24gZmlsbD1cIiNmZmZcIiBwb2ludHM9XCI5IDUuOSA4Ljk5IDE4LjI0IDEyLjUzIDE1IDE3LjMzIDE1LjAxIDkgNS45XCIgLz5cbiAgICAgIDwvZz5cbiAgICA8L2c+XG4gIDwvc3ZnPlxuYDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3N2Z0lubGluZS96ZW5kZXNrLXdpZGdldC1pY29uLmpzIiwiaW1wb3J0IHsgZ2V0RG9jdW1lbnRIZWlnaHQgfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9kb2N1bWVudFNpemUnO1xuXG4vLyBmdW5jdGlvbiBpcyBzZXJpYWxpemFibGUgdG8gc3RyaW5nLFxuLy8gc28gaXQgc2hvdWxkIGtlZXAgYWxsIHRoaW5ncyBpdCBuZWVkcyBpbiBpdHNlbGZcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjcm9sbFdpbmRvd0ludG9WaWV3KGJvdW5kcywgYW5pbWF0aW9uVGltZSA9IDMwMCkge1xuICBjb25zdCBmaW5kSG9yaXpvbnRhbFNjcm9sbCA9IChib3VuZHMpID0+IHtcbiAgICBjb25zdCBwb3MgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBib3VuZHMubGVmdDtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHBvcyxcbiAgICAgICAgcG9zIC0gKHdpbmRvdy5pbm5lcldpZHRoIC0gYm91bmRzLndpZHRoKSAvIDIsXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggLSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgKVxuICAgICk7XG4gIH07XG4gIGNvbnN0IGZpbmRWZXJ0aWNhbFNjcm9sbCA9IChib3VuZHMpID0+IHtcbiAgICBjb25zdCBwb3MgPSB3aW5kb3cucGFnZVlPZmZzZXQgKyBib3VuZHMudG9wO1xuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3MgLSAod2luZG93LmlubmVySGVpZ2h0IC0gYm91bmRzLmhlaWdodCkgLyAyLFxuICAgICAgICBnZXREb2N1bWVudEhlaWdodCgpIC0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgICApXG4gICAgKTtcbiAgfVxuICBjb25zdCBmaW5kVGFyZ2V0U2Nyb2xsID0gKGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IHggPSBib3VuZHMubGVmdCA8IDAgfHwgYm91bmRzLnJpZ2h0ID4gd2luZG93LmlubmVyV2lkdGggP1xuICAgICAgZmluZEhvcml6b250YWxTY3JvbGwoYm91bmRzKVxuICAgICAgOiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgY29uc3QgeSA9IGJvdW5kcy50b3AgPCAwIHx8IGJvdW5kcy5ib3R0b20gPiB3aW5kb3cuaW5uZXJIZWlnaHQgP1xuICAgICAgZmluZFZlcnRpY2FsU2Nyb2xsKGJvdW5kcylcbiAgICAgIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfVxuICBjb25zdCByYWYgPSAoXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICkuYmluZCh3aW5kb3cpO1xuICBjb25zdCBhbmltYXRlID0gKHN0YXJ0VGltZSwgdGFyZ2V0U2Nyb2xsKSA9PiB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB0YXJnZXRTY3JvbGw7XG4gICAgICAvLyBhbmltYXRpb24gdGltZSBwcm9ncmVzcyBmcm9tIDAgdG8gMVxuICAgICAgY29uc3QgdGltZVZhbHVlID0gTWF0aC5taW4oMSAvIGFuaW1hdGlvblRpbWUgKiB0aW1lLCAxKTtcbiAgICAgIGlmICh0aW1lVmFsdWUgPj0gMSkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChcbiAgICAgICAgICB4IC0gKHggLSB3aW5kb3cucGFnZVhPZmZzZXQpICogTWF0aC5wb3coMSAtIHRpbWVWYWx1ZSwgdGltZVZhbHVlIC8gMiksXG4gICAgICAgICAgeSAtICh5IC0gd2luZG93LnBhZ2VZT2Zmc2V0KSAqIE1hdGgucG93KDEgLSB0aW1lVmFsdWUsIHRpbWVWYWx1ZSAvIDIpXG4gICAgICAgICk7XG4gICAgICAgIGFuaW1hdGUoc3RhcnRUaW1lLCB0YXJnZXRTY3JvbGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNjcm9sbFRvID0gKHBvcykgPT4gYW5pbWF0ZShEYXRlLm5vdygpLCBwb3MpO1xuXG5cbiAgY29uc3QgdGFyZ2V0U2Nyb2xsID0gZmluZFRhcmdldFNjcm9sbChib3VuZHMpO1xuICBzY3JvbGxUbyh0YXJnZXRTY3JvbGwpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvU2Nyb2xsV2luZG93SW50b1ZpZXcuanMiLCJpbXBvcnQgbmFtZXNwYWNlIGZyb20gJy4vbmFtZXNwYWNlJztcbmltcG9ydCB3YWl0Rm9yIGZyb20gJy4vd2FpdEZvcic7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzc5MTgwMTIvMTQxODA0OVxuLy8gVXNlZnVsIGZvciBvdmVycmlkaW5nICFpbXBvcnRhbnQgcnVsZXNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZE5ld1N0eWxlKG5ld1N0eWxlKSB7XG4gIGxldCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuYW1lc3BhY2UoJ3N0eWxlc19qcycpKTtcbiAgaWYgKCFzdHlsZUVsZW1lbnQpIHtcbiAgICBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZUVsZW1lbnQuaWQgPSBuYW1lc3BhY2UoJ3N0eWxlc19qcycpO1xuICAgIHdhaXRGb3IoKCkgPT4gZG9jdW1lbnQuaGVhZCwgKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIH0sIDApO1xuICB9XG4gIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdTdHlsZSkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvYWRkTmV3U3R5bGUuanMiLCJpbXBvcnQgeyBhcGlGZXRjaCB9IGZyb20gJy4vYXV0aEZldGNoJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi9zZXR0aW5ncyc7XG5pbXBvcnQgaXNNb2JpbGVCcm93c2VycyBmcm9tICcuLi91dGlscy9pc01vYmlsZUJyb3dzZXJzJztcblxuaW1wb3J0IHsgZ2V0RmlsZUxvZ2dlciB9IGZyb20gJy4uLy4uL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKHVzZXJJZCwgdXJscykge1xuICBjb25zdCBtb2JpbGVNb2RlID0gaXNNb2JpbGVCcm93c2VycygpO1xuICBjb25zdCByID0gYXdhaXQgYXBpRmV0Y2goc2V0dGluZ3MuZ2V0KCdzZXJ2ZXIudHV0b3JpYWxMaXZlTGlzdC51cmwnLCB7XG4gICAgdXJsczogdXJscyAmJiB1cmxzLm1hcChlc2NhcGUpLmpvaW4oJywnKSxcbiAgICBzZWFyY2hLZXk6ICcnLFxuICAgIGVtYmVkOiB0cnVlLFxuICAgIG1vYmlsZU1vZGUsXG4gIH0pKTtcbiAgaWYgKFsyMDAsIDIwNCwgMzA0XS5pbmRleE9mKHIuc3RhdHVzKSA9PT0gLTEpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEZldGNoIGVtYmVkIHR1dG9yaWFsczogaW52YWxpZCByZXNwb25zZWApO1xuICB9XG4gIGlmIChbMjAwLCAzMDRdLmluZGV4T2Yoci5zdGF0dXMpICE9PSAtMSkge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByLmpzb24oKTtcbiAgICByZXR1cm4ganNvbiB8fCBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2ZldGNoRW1iZWRUdXRvcmlhbHMuanMiLCJleHBvcnQgZGVmYXVsdCAoc2VhcmNoID0gJycpID0+IHtcbiAgY29uc3QgbGl2ZUlkTWF0Y2ggPSBzZWFyY2gubWF0Y2goL2lvcmFkTGl2ZUlkPShcXGQrKS8pO1xuICBjb25zdCBsaXZlSWRDb3JyZWN0QnJvd3NlciA9IHNlYXJjaC5tYXRjaCgvaW9yYWRMaXZlRW1iZWQ9dHJ1ZS8pID09PSBudWxsID9cbiAgICBwcm9jZXNzLmVudi5CUk9XU0VSICE9PSAnZW1iZWQnIDpcbiAgICBwcm9jZXNzLmVudi5CUk9XU0VSID09PSAnZW1iZWQnO1xuICByZXR1cm4gKGxpdmVJZE1hdGNoICYmIGxpdmVJZE1hdGNoWzFdICYmIGxpdmVJZENvcnJlY3RCcm93c2VyKSA/XG4gICAgbGl2ZUlkTWF0Y2hbMV0gOiAnJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbW1vbi91dGlscy9nZXRRdWVyeUxpdmVJZC5qcyIsImNvbnN0IGRlZmF1bHRDb25zb2xlTWV0aG9kcyA9IFsnYXNzZXJ0JywgJ2NsZWFyJywgJ2NvdW50JywgJ2RlYnVnJywgJ2RpcicsICdkaXJ4bWwnLFxuICAnZXJyb3InLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnZ3JvdXBFbmQnLCAnaW5mbycsXG4gICdsb2cnLCAncHJvZmlsZScsICdwcm9maWxlRW5kJywgJ3RpbWUnLCAndGltZUVuZCcsXG4gICd0aW1lbGluZScsICd0aW1lbGluZUVuZCcsICd0aW1lU3RhbXAnLCAndHJhY2UnLCAnd2FybicsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoaWRlQ29uc29sZU1lc3NhZ2VzKGNvbnNvbGVNZXRob2RzID0gZGVmYXVsdENvbnNvbGVNZXRob2RzLCBoaWRlRXhjZXB0aW9ucyA9IGZhbHNlKSB7XG4gIGNvbnNvbGVNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIHdpbmRvdy5jb25zb2xlW21ldGhvZF0gPSAoKSA9PiB7fTtcbiAgfSk7XG5cbiAgaWYgKGhpZGVFeGNlcHRpb25zKSB7XG4gICAgd2luZG93Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAvLyByZXR1cm4gdHJ1ZSB0byBzdXBwcmVzcyBleGNlcHRpb25cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29tbW9uL3V0aWxzL2hpZGVDb25zb2xlTWVzc2FnZXMuanMiLCIvKlxuICBET0NVTUVOVEFUSU9OXG4gIGlzU3ByaXRlSG9sZGVyKClcbiAgICByZXR1cm5zIHRydWUgb3IgZmFsc2UgKGlzIG9yIGlzIG5vdCBhIHNwcml0ZSBob2xkZXIpXG5cbiAgICBBaW1lZCBhdCB0aGUgR29vZ2xlIERvY3MvTVMgT2ZmaWNlIHNwcml0ZSB0ZWNobmlxdWVcbiAgICBJbiB0aGVzZSBzaXRlcywgYnV0dG9ucyBnZXQgdGhlaXIgaW1hZ2UgYnkgYSBsYXJnZSBzcHJpdGUgZWxlbWVudCBjb250YWluZWRcbiAgICBpbnNpZGUgdGhlIGJ1dHRvbi4gaW9yYWQgbmVlZHMgdGhlIGJ1dHRvbiBpdHNlbGYsIGFuZCBub3QgdGhlIHNwcml0ZSBlbGVtZW50LFxuICAgIGFzIGEgdGFyZ2V0LlxuXG4gICAgQW4gZWxlbWVudCBpcyBhIHNwcml0ZSBob2xkZXIgaWYgdGhlIGZvbGxvd2luZyB0aHJlZSBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAgIGEpIGl0IGhhcyBlbXB0eSBpbm5lciBodG1sXG4gICAgYikgaXQgaGFzIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBjKSBpdCBpcyBsYXJnZXIgdGhhbiBpdHMgcGFyZW50XG4gICAgZCkgaXQgaGFzIGEgKGJhY2tncm91bmQpIGltYWdlIHRoYXQncyByZXBlYXRlZCBlbHNld2hlcmUgb24gdGhlIHBhZ2UuXG4gICAgVGhpcyBzY3JpcHQgY2hlY2tzIGZvciB0aGVzZSB0aHJlZSBjb25kaXRpb25zIGFuZCByZXR1cm5zIHRydWUgaWYgdGhleSdyZVxuICAgIGFsbCB0cnVlOyBmYWxzZSBpZiB0aGV5J3JlIG5vdC5cbiAgICBcbiAgICBQb3NpdGlvbjogYWJzb2x1dGUgaXMgc2ltcGxlOiBnZXRDb21wdXRlZFN0eWxlIGZvciBwb3NpdGlvbjsgaWYgaXQncyBcbiAgICAnYWJzb2x1dGUnIHRoZSBjb25kaXRpb24gaXMgc2F0aXNmaWVkLlxuICAgIFxuICAgIERpbWVuc2lvbnMgYXJlIGFsc28gc2ltcGxlOiB0YWtlIHRoZSBvZmZzZXRXaWR0aC9IZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICBhbmQgaXRzIHBhcmVudCBhbmQgY29tcGFyZSB0aGVtLiBJZiB0aGUgZWxlbWVudCBoYXMgYSBsYXJnZXIgb2Zmc2V0IGluXG4gICAgYXQgbGVhc3Qgb25lIGRpbWVuc2lvbiBpdCdzIGxhcmdlciB0aGFuIGl0cyBwYXJlbnQgYW5kIHRoaXMgY29uZGl0aW9uIGlzXG4gICAgc2F0aXNmaWVkLlxuICAgIE5vdGU6IHNsaWdodCBwZXJmb3JtYW5jZSBoaXQ7IG1lYXN1cmluZyBvZmZzZXRXaWR0aC9IZWlnaHQgcmVxdWlyZXMgYVxuICAgIHJlLWxheW91dC4gU2luY2Ugd2UncmUgb25seSBjaGVja2luZyB0d28gZWxlbWVudHMsIHRob3VnaCwgYW5kIG9ubHlcbiAgICB3aGVuIHRoZSB1c2VyIGNsaWNrcywgdGhpcyBzaG91bGQgbm90IGJlIGEgaHVnZSBwcm9ibGVtLlxuICAgIFxuICAgIFRoZSAoYmFja2dyb3VuZCkgaW1hZ2UgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGV4LiBGaXJzdCB3ZSBjaGVjayBpZiB0aGVcbiAgICBlbGVtZW50IGhhcyBhIGJhY2tncm91bmQgaW1hZ2UuIElmIHNvLCB3ZSBzZWFyY2ggZm9yIG90aGVyIGVsZW1lbnRzIHdpdGhcbiAgICB0aGUgc2FtZSBub2RlTmFtZSAodGFnIG5hbWUpIGFuZCBjbGFzc05hbWUsIGFuZCBjaGVjayB0aGVtIGZvciBiYWNrZ3JvdW5kXG4gICAgaW1hZ2VzIGFzIHdlbGwuXG4gICAgSWYgd2UgZmluZCBhdCBsZWFzdCBNSU5fQkFDS0dST1VORF9NQVRDSEVTIG90aGVyIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgYmFja2dyb3VuZCBpbWFnZSxcbiAgICB0aGlzIGNvbmRpdGlvbiBpcyBzYXRpc2ZpZWQuXG4gICAgVGhlIHR3byBlbGVtZW50cyBkbyBub3QgaGF2ZSB0byBkZWZpbmUgdGhlaXIgYmFja2dyb3VuZCBpbWFnZXMgaW4gdGhlIHNhbWUgd2F5O1xuICAgIGkuZS4gaWYgb25lIHVzZXMgOmJlZm9yZSBhbmQgdGhlIG90aGVyIHNyYyB0aGlzIGlzIGNvdW50ZWQgYXMgYSBtYXRjaFxuICAgIGFuZCB0aGUgY29uZGl0aW9uIGlzIHNhdGlzZmllZC4gVGhpcyBzZWVtcyB1bmxpa2VseSB0byBjcm9wIHVwIGluIHRoZVxuICAgIHdpbGQuXG4gICAgXG4gICAgTG9va2luZyBmb3IgYmFja2dyb3VuZHMgaXMgdGhlIGpvYiBvZiBmaW5kQmFja2dyb3VuZCgpLiBJdCByZXR1cm5zIGVpdGhlclxuICAgIGEgYmFja2dyb3VuZCBzdHJpbmcgKGFzIGRlbGl2ZXJlZCBieSB0aGUgYnJvd3NlciksIG9yIGZhbHNlIGlmIG5vXG4gICAgYmFja2dyb3VuZCB3YXMgZm91bmQuXG4gICAgXG4gICAgV2UgbG9vayBmb3IgYmFja2dyb3VuZCBpbWFnZXMgaW4gdGhyZWUgd2F5czsgaW4gdGhpcyBvcmRlcjpcbiAgICAtIEEgc3JjIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCBpdHNlbGYgKE1TIE9mZmljZSB1c2UgY2FzZSkuXG4gICAgLSBBIGJhY2tncm91bmQgZGVjbGFyYXRpb24gb24gdGhlIGVsZW1lbnQgaXRzZWxmIChjdXJyZW50bHkgbm8gdXNlIGNhc2UpXG4gICAgLSBBIGJhY2tncm91bmQgZGVjbGFyYXRpb24gb24gZWxlbWVudDpiZWZvcmUgKEdvb2dsZSBEb2NzIHVzZSBjYXNlKVxuICAgIEFzIHNvb24gYXMgdGhlIHNjcmlwdCBmaW5kcyBvbmUgYmFja2dyb3VuZCBpbWFnZSBpdCBzdG9wcyBjaGVja2luZy5cbiAgICBJbiB0aGUgdW5saWtlbHkgY2FzZSB0aGF0IGFuIGVsZW1lbnQgd291bGQgaGF2ZSB0d28gYmFja2dyb3VuZCBpbWFnZXMgaXRcbiAgICBmaW5kcyBvbmx5IHRoZSBvbmUgd2hvc2UgZnVuY3Rpb24gZmlyZXMgZmlyc3QuICBcbiAgICBcbiAgICB0ZXN0RnVuY3Rpb25zIGNvbnRhaW5zIHRoZSB0ZXN0IGZ1bmN0aW9ucy4gTm90ZSBpdCdzIGFuIGFycmF5OyB0aGUgZnVuY3Rpb25zXG4gICAgYXJlIHJ1biBpbiBvcmRlci5cbiAgICBcbiAgICBBZGRpbmcgYSBjaGVjayBpcyBlYXN5OiBqdXN0IGFkZCBhIGZ1bmN0aW9uIHRvIHRlc3RGdW5jdGlvbnMuXG4gICAgXG4gICAgQ2hhbmdpbmcgdGhlIG9yZGVyIGlzIGVhc3kgYXMgd2VsbDoganVzdCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZVxuICAgIGZ1bmN0aW9ucyBpbiB0ZXN0RnVuY3Rpb25zLlxuICAgIFxuICAgIEFmdGVyIGFuIGltYWdlIGhhcyBiZWVuIGZvdW5kIHdlIGNoZWNrIGlmIGl0IGhhcyBhbiBodHRwIG9yIGh0dHBzLiBJZiBpdFxuICAgIGRvZXMgaXQncyBhIHRydWUgYmFja2dyb3VuZCBpbWFnZSwgYW5kIGFueSBjb21wYXJpc29ucyBhcmUgdmFsaWQuXG4gICAgSWYgaXQgZG9lcyBub3QgaXQgaXMgcmVqZWN0ZWQsIGFuZCB3ZSBwcm9jZWVkIGFzIGlmIHRoZSBlbGVtZW50IGhhc1xuICAgIG5vIGJhY2tncm91bmQgaW1hZ2UuXG4gIFxuKi9cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmNvbnN0IE1JTl9CQUNLR1JPVU5EX01BVENIRVMgPSAxO1xuXG5jb25zdCBURVNUX0ZVTkNUSU9OUyA9IFtcbiAgZWwgPT4gZWwuc3JjLFxuICAoZWwsIGNvbXB1dGVkU3R5bGUpID0+IGNvbXB1dGVkU3R5bGUuYmFja2dyb3VuZCxcbiAgZWwgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsICc6OmJlZm9yZScpLmNvbnRlbnQsXG5dO1xuXG5mdW5jdGlvbiBmaW5kQmFja2dyb3VuZChlbGVtZW50LCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBURVNUX0ZVTkNUSU9OUy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZuID0gVEVTVF9GVU5DVElPTlNbaV07XG4gICAgY29uc3QgYmcgPSBmbihlbGVtZW50LCBjb21wdXRlZFN0eWxlKTtcbiAgICBpZiAoL2h0dHBzPy8udGVzdChiZykpIHtcbiAgICAgIHJldHVybiBiZztcbiAgICB9XG4gIH1cbiAgbG9nZ2VyLmRlYnVnKCdObyBiYWNrZ3JvdW5kIGZvdW5kJyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Nwcml0ZUhvbGRlcihlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudC5pbm5lckhUTUwpIHtcbiAgICBsb2dnZXIuZGVidWcoJ0hhcyBlbXB0eSBpbm5lciBIVE1MJyk7XG5cbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgaGFzUG9zaXRpb25BYnNvbHV0ZSA9IChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKTtcbiAgICBpZiAoaGFzUG9zaXRpb25BYnNvbHV0ZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdIYXMgcG9zaXRpb24gYWJzb2x1dGUnKTtcblxuICAgICAgY29uc3QgZWxlbWVudERpbWVuc2lvbnMgPSBbZWxlbWVudC5vZmZzZXRXaWR0aCwgZWxlbWVudC5vZmZzZXRIZWlnaHRdO1xuICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcGFyZW50RGltZW5zaW9ucyA9IFtwYXJlbnQub2Zmc2V0V2lkdGgsIHBhcmVudC5vZmZzZXRIZWlnaHRdO1xuICAgICAgY29uc3QgaXNMYXJnZXIgPSAoZWxlbWVudERpbWVuc2lvbnNbMF0gPiBwYXJlbnREaW1lbnNpb25zWzBdIHx8IGVsZW1lbnREaW1lbnNpb25zWzFdID4gcGFyZW50RGltZW5zaW9uc1sxXSk7XG4gICAgICBpZiAoaXNMYXJnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdFbGVtZW50IGxhcmdlciB0aGFuIGl0cyBwYXJlbnQnKTtcblxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kSW1hZ2UgPSBmaW5kQmFja2dyb3VuZChlbGVtZW50LCBjb21wdXRlZFN0eWxlKTtcbiAgICAgICAgaWYgKGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnQmFja2dyb3VuZCBpbWFnZSBmb3VuZDogJyArIGJhY2tncm91bmRJbWFnZSk7XG5cbiAgICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IGVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgICA/IGVsZW1lbnQudGFnTmFtZSArICcuJyArIGVsZW1lbnQuY2xhc3NMaXN0WzBdXG4gICAgICAgICAgICA6IGVsZW1lbnQudGFnTmFtZTtcbiAgICAgICAgICBjb25zdCBvdGhlckVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnlTdHJpbmcpO1xuICAgICAgICAgIGxldCBtYXRjaGVzID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJFbHNbaV0gPT09IGVsZW1lbnQgfHwgb3RoZXJFbHNbaV0uaW5uZXJIVE1MKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGJnQ29tcGFyZSA9IGZpbmRCYWNrZ3JvdW5kKG90aGVyRWxzW2ldKTtcbiAgICAgICAgICAgIGlmIChiZ0NvbXBhcmUgPT09IGJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICAgICAgICBtYXRjaGVzKys7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVzID49IE1JTl9CQUNLR1JPVU5EX01BVENIRVMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0hhcyBzYW1lIGJhY2tncm91bmQgYXMgb3RoZXIgZWxlbWVudHMnKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0FjY2VwdGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nZ2VyLmRlYnVnKCdSZWplY3RlZCcpO1xuICByZXR1cm4gZmFsc2U7IC8vIG9yIHJldHVybiBlbGVtZW50P1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvaXNTcHJpdGVIb2xkZXIuanMiLCIvLyByZ2Igc3RyaW5nIHRvIGFycmF5XG5leHBvcnQgZGVmYXVsdCAocmdiQ29sb3IpID0+IHtcbiAgbGV0IHJnYkFycmF5ID0gcmdiQ29sb3Iuc3BsaXQoJywnKTtcbiAgcmdiQXJyYXlbMF0gPSByZ2JBcnJheVswXS5zdWJzdHIocmdiQXJyYXlbMF0uaW5kZXhPZignKCcpICsgMSk7IC8vIGZyb20gXCIgcmdiKCBYWVogXCIgdG8gXCIgWFlaIFwiXG4gIHJnYkFycmF5WzJdID0gcmdiQXJyYXlbMl0uc3Vic3RyKDAsIHJnYkFycmF5WzJdLmluZGV4T2YoJyknKSk7IC8vIGZyb20gXCIgWFlaICkgXCIgdG8gXCIgIFhZWiBcIlxuICByZ2JBcnJheSA9IHJnYkFycmF5Lm1hcCgodmFsdWUpID0+IHBhcnNlRmxvYXQodmFsdWUudHJpbSgpLCAxMCkpO1xuICByZXR1cm4gcmdiQXJyYXk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvcmdiVG9BcnJheS5qcyIsIi8vIHJnYmEgc3RyaW5nIHRvIGFycmF5XG5leHBvcnQgZGVmYXVsdCAocmdiYUNvbG9yKSA9PiB7XG4gIGxldCByZ2JhQXJyYXkgPSByZ2JhQ29sb3Iuc3BsaXQoJywnKTtcbiAgcmdiYUFycmF5WzBdID0gcmdiYUFycmF5WzBdLnN1YnN0cihyZ2JhQXJyYXlbMF0uaW5kZXhPZignKCcpICsgMSk7IC8vIGZyb20gXCIgcmdiKCBYWVogXCIgdG8gXCIgWFlaIFwiXG4gIHJnYmFBcnJheVszXSA9IHJnYmFBcnJheVszXS5zdWJzdHIoMCwgcmdiYUFycmF5WzNdLmluZGV4T2YoJyknKSk7IC8vIGZyb20gXCIgWFlaICkgXCIgdG8gXCIgIFhZWiBcIlxuICByZ2JhQXJyYXkgPSByZ2JhQXJyYXkubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZS50cmltKCksIDEwKSk7XG4gIHJldHVybiByZ2JhQXJyYXk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb21tb24vdXRpbHMvcmdiYVRvQXJyYXkuanMiLCIvLyBCcmlkZ2VzIEVkaXRvciBhbmQgQmFja2dyb3VuZCAobmVlZGVkIGluIEVkZ2Ugd2hlcmUgb25Db25uZWN0RXh0ZXJuYWwgaXNuJ3Qgc3VwcG9ydGVkKVxuXG5pbXBvcnQgYnJvd3NlciBmcm9tICdjaHJvbWUvYnJvd3Nlcic7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZSc7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyaWRnZSB7XG4gIHN0YXRpYyBsaXN0ZW4oKSB7XG4gICAgLy8gd2FpdCBmb3IgZWRpdG9yIGNvbm5lY3Rpb25zXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnb2JqZWN0JyB8fCBtZXNzYWdlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgIC8vbG9nZ2VyLmRlYnVnKCdCcmlkZ2UgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgaWYgKG1lc3NhZ2UuZnJvbSA9PT0gJ2lvcmFkLWVkaXRvcicgJiYgbWVzc2FnZS50byA9PT0gbmFtZXNwYWNlKCkgJiYgbWVzc2FnZS5jb25uZWN0KSB7XG4gICAgICAgIGNvbnN0IGVkaXRvckNvbm5lY3RQb3J0ID0gZXZlbnQucG9ydHNbMF07XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb25uZWN0UG9ydCA9IGJyb3dzZXIucnVudGltZS5jb25uZWN0KG1lc3NhZ2UuY29ubmVjdERhdGEpO1xuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHRoaXMoKTtcbiAgICAgICAgaW5zdGFuY2Uuc3RhcnQoZWRpdG9yQ29ubmVjdFBvcnQsIGJhY2tncm91bmRDb25uZWN0UG9ydCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVkaXRvckNvbm5lY3RQb3J0ID0gbnVsbDtcbiAgICB0aGlzLmJhY2tncm91bmRDb25uZWN0UG9ydCA9IG51bGw7XG4gIH1cblxuICBzdGFydChlZGl0b3JDb25uZWN0UG9ydCwgYmFja2dyb3VuZENvbm5lY3RQb3J0KSB7XG4gICAgdGhpcy5lZGl0b3JDb25uZWN0UG9ydCA9IGVkaXRvckNvbm5lY3RQb3J0O1xuICAgIHRoaXMuYmFja2dyb3VuZENvbm5lY3RQb3J0ID0gYmFja2dyb3VuZENvbm5lY3RQb3J0O1xuXG4gICAgdGhpcy5iaW5kRWRpdG9yRXZlbnRzKCk7XG4gICAgdGhpcy5iaW5kQmFja2dyb3VuZEV2ZW50cygpO1xuICB9XG5cblxuICBiaW5kRWRpdG9yRXZlbnRzKCkge1xuICAgIHRoaXMuZWRpdG9yQ29ubmVjdFBvcnQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcblxuICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS5kaXNjb25uZWN0KSB7XG4gICAgICAgIC8vbG9nZ2VyLmRlYnVnKCdCUklER0U6IGVkaXRvciBkaXNjb25uZWN0ZWQnLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29ubmVjdFBvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9sb2dnZXIuZGVidWcoJ0JSSURHRTogZ290IG1lc3NhZ2UgZnJvbSBlZGl0b3InLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29ubmVjdFBvcnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGJpbmRCYWNrZ3JvdW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmFja2dyb3VuZENvbm5lY3RQb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAvL2xvZ2dlci5kZWJ1ZygnQlJJREdFOiBiYWNrZ3JvdW5kIGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgdGhpcy5lZGl0b3JDb25uZWN0UG9ydC5wb3N0TWVzc2FnZSh7IGRpc2Nvbm5lY3Q6IHRydWUgfSk7XG4gICAgICB0aGlzLmVkaXRvckNvbm5lY3RQb3J0LmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRDb25uZWN0UG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2UpID0+IHtcbiAgICAgIC8vbG9nZ2VyLmRlYnVnKCdCUklER0U6IGdvdCBtZXNzYWdlIGZyb20gYmFja2dyb3VuZCcsIG1lc3NhZ2UpO1xuICAgICAgdGhpcy5lZGl0b3JDb25uZWN0UG9ydC5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L0JyaWRnZS5qcyIsImltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi9jb21tb24vc2V0dGluZ3MnO1xuaW1wb3J0IHdhaXRGb3IgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvd2FpdEZvcic7XG5pbXBvcnQgQnJpZGdlIGZyb20gJy4vQnJpZGdlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdG9yRnJhbWVOb2RlIHtcbiAgZ2V0QnJpZGdlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEJyaWRnZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIGlkKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IEJyaWRnZUNsYXNzID0gdGhpcy5nZXRCcmlkZ2VDbGFzcygpO1xuXG4gICAgdGhpcy5zZXR1cElvcmFkRXh0ZW5zaW9uRXhpc3RlbmNlKCk7XG4gICAgQnJpZGdlQ2xhc3MubGlzdGVuKCk7XG4gIH1cblxuICBzZXR1cElvcmFkRXh0ZW5zaW9uRXhpc3RlbmNlKCkge1xuICAgIHdhaXRGb3IoKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLSR7bmFtZXNwYWNlKCl9YCwgdGhpcy5uYW1lKTtcbiAgICAgIGlmIChkb2N1bWVudC5sb2NhdGlvbi5ocmVmLm1hdGNoKCdpb3JhZC5jb20nKSAhPT0gbnVsbCB8fCBkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2Rldi5pb3JhZC5kZXYnKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtJHtuYW1lc3BhY2UoJ3ZlcnNpb24nKX1gLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLSR7bmFtZXNwYWNlKCdidWlsZCcpfWAsIHNldHRpbmdzLmdldChgZXh0ZW5zaW9uLiR7dGhpcy5uYW1lfS5pZHMuJHt0aGlzLmlkfS5idWlsZGApKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcblxuICAgIC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgLy8gICB0ZXN0TW9kZSgpO1xuICAgIC8vICAgdGVzdE91dGxpbmVEcmF3aW5nKCk7XG4gICAgLy8gfSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9FZGl0b3JGcmFtZU5vZGUuanMiLCIvLyBSRUFETUU6IGtlZXAgdGhpcyBmaWxlIGFzIHNtYWxsIGFzIHBvc3NpYmxlLCBtb3ZlIGFueSBsb2dpYyB0byBzcGVjaWZpYyBtb2R1bGVzXG4vLyBhbmQgaW5pdGlhbGl6ZS9zdGFydCB0aGVtIGhlcmUgaWYgbmVlZGVkLlxuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgcmFuZG9tU3RyaW5nIGZyb20gJy4uL2NvbW1vbi91dGlscy9yYW5kb21TdHJpbmcnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL2NvbW1vbi9zZXR0aW5ncyc7XG5pbXBvcnQgaGlkZUNvbnNvbGVNZXNzYWdlcyBmcm9tICcuLi9jb21tb24vdXRpbHMvaGlkZUNvbnNvbGVNZXNzYWdlcyc7XG4vL2ltcG9ydCB0ZXN0TW9kZSBmcm9tICcuL3Rlc3RNb2RlJztcbi8vaW1wb3J0IHsgdGVzdE91dGxpbmVEcmF3aW5nIH0gZnJvbSAnLi90ZXN0TW9kZSc7XG5pbXBvcnQgd2FpdEZvciBmcm9tICcuLi9jb21tb24vdXRpbHMvd2FpdEZvcic7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZSc7XG5pbXBvcnQgd2FpdEZvckNvbXBvbmVudCBmcm9tICcuL3dhaXRGb3JDb21wb25lbnQnO1xuXG5pbXBvcnQgRmx1eCBmcm9tICcuL0ZsdXgnO1xuaW1wb3J0IFNoYXJlZE1lbW9yeSBmcm9tICcuLi9jb21tb24vc2hhcmVkTWVtb3J5L1NoYXJlZE1lbW9yeSc7XG5pbXBvcnQgS2V5Ym9hcmRTaG9ydGN1dHMgZnJvbSAnLi9LZXlib2FyZFNob3J0Y3V0cyc7XG5pbXBvcnQgT3ZlcmxheUNvbnRyb2xsZXIgZnJvbSAnLi9PdmVybGF5Q29udHJvbGxlcic7XG5pbXBvcnQgeyBzdGFydCBhcyBzdGFydFpvb20gfSBmcm9tICcuL3pvb20vem9vbVRvcEZyYW1lJztcbmltcG9ydCBDb250ZW50UGxheWVyVG9wRnJhbWUgZnJvbSBcImJhc2UvY29udGVudC9wbGF5ZXIvQ29udGVudFBsYXllclRvcEZyYW1lXCI7XG5pbXBvcnQgRG9jdW1lbnRDYXB0dXJlVG9wRnJhbWUgZnJvbSBcImJhc2UvY29udGVudC9jYXB0dXJlL0RvY3VtZW50Q2FwdHVyZVRvcEZyYW1lXCI7XG5pbXBvcnQgUGFuZWxDb250cm9sbGVyIGZyb20gJ2Jhc2UvY29udGVudC9QYW5lbENvbnRyb2xsZXInO1xuaW1wb3J0ICogYXMgZnJhbWVNZXNzYWdlcyBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9mcmFtZU1lc3NhZ2VzJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZW5zaW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uSHJlZjogbnVsbCxcbiAgICAgIGxvY2F0aW9uSHJlZkNoYW5nZWRBdDogbnVsbCxcblxuICAgICAgcGFnZUxvZ2dlZEluVHlwZTogbnVsbCxcblxuICAgICAgaW50ZXJjb21JbnN0YWxsZWQ6IGZhbHNlLFxuICAgICAgZ29vZ2xlVHJhbnNsYXRlSW5zdGFsbGVkOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0VVJMKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRQb3J0TWFuYWdlckNsYXNzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRGbHV4Q2xhc3MoKSB7XG4gICAgcmV0dXJuIEZsdXg7XG4gIH1cblxuICBnZXRTaGFyZWRNZW1vcnlDbGFzcygpIHtcbiAgICByZXR1cm4gU2hhcmVkTWVtb3J5O1xuICB9XG5cbiAgZ2V0U3RvcmFnZUNsYXNzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXRLZXlib2FyZFNob3J0Y3V0c0NsYXNzKCkge1xuICAgIHJldHVybiBLZXlib2FyZFNob3J0Y3V0cztcbiAgfVxuXG4gIGdldE92ZXJsYXlDb250cm9sbGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIE92ZXJsYXlDb250cm9sbGVyO1xuICB9XG5cbiAgZ2V0UGFuZWxDb250cm9sbGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFBhbmVsQ29udHJvbGxlcjtcbiAgfVxuXG4gIGdldENvbnRlbnRQbGF5ZXJDbGFzcygpIHtcbiAgICByZXR1cm4gQ29udGVudFBsYXllclRvcEZyYW1lO1xuICB9XG5cbiAgZ2V0RG9jdW1lbnRDYXB0dXJlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIERvY3VtZW50Q2FwdHVyZVRvcEZyYW1lO1xuICB9XG5cbiAgLy8gaW5zdGFudGlhdGUgbW9kdWxlc1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2ZXJzaW9uLCBpZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLmZyYW1lSWQgPSAnaW9yYWRfJyArIHJhbmRvbVN0cmluZygpO1xuXG4gICAgdGhpcy5pc1RvcEZyYW1lID0gKHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdyk7XG4gICAgbG9nZ2VyLmRlYnVnKCdJcyB0b3AgZnJhbWU/JywgdGhpcy5pc1RvcEZyYW1lLCBkb2N1bWVudC5sb2NhdGlvbi5ocmVmKTtcblxuICAgIGNvbnN0IFBvcnRNYW5hZ2VyQ2xhc3MgPSB0aGlzLmdldFBvcnRNYW5hZ2VyQ2xhc3MoKTtcbiAgICB0aGlzLnBvcnRNYW5hZ2VyID0gbmV3IFBvcnRNYW5hZ2VyQ2xhc3MoKTtcblxuICAgIGNvbnN0IEZsdXhDbGFzcyA9IHRoaXMuZ2V0Rmx1eENsYXNzKCk7XG4gICAgdGhpcy5mbHV4ID0gbmV3IEZsdXhDbGFzcygpO1xuXG4gICAgY29uc3QgU2hhcmVkTWVtb3J5Q2xhc3MgPSB0aGlzLmdldFNoYXJlZE1lbW9yeUNsYXNzKCk7XG4gICAgdGhpcy5zaGFyZWRNZW1vcnkgPSBuZXcgU2hhcmVkTWVtb3J5Q2xhc3ModGhpcy5mcmFtZUlkKTtcblxuICAgIGNvbnN0IFN0b3JhZ2VDbGFzcyA9IHRoaXMuZ2V0U3RvcmFnZUNsYXNzKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGFzcygpO1xuXG4gICAgY29uc3QgS2V5Ym9hcmRTaG9ydGN1dHNDbGFzcyA9IHRoaXMuZ2V0S2V5Ym9hcmRTaG9ydGN1dHNDbGFzcygpO1xuICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dHMgPSBuZXcgS2V5Ym9hcmRTaG9ydGN1dHNDbGFzcygpO1xuXG4gICAgY29uc3QgT3ZlcmxheUNvbnRyb2xsZXJDbGFzcyA9IHRoaXMuZ2V0T3ZlcmxheUNvbnRyb2xsZXJDbGFzcygpO1xuICAgIHRoaXMub3ZlcmxheUNvbnRyb2xsZXIgPSBuZXcgT3ZlcmxheUNvbnRyb2xsZXJDbGFzcygpO1xuXG4gICAgY29uc3QgUGFuZWxDb250cm9sbGVyQ2xhc3MgPSB0aGlzLmdldFBhbmVsQ29udHJvbGxlckNsYXNzKCk7XG4gICAgdGhpcy5wYW5lbENvbnRyb2xsZXIgPSBuZXcgUGFuZWxDb250cm9sbGVyQ2xhc3MoKTtcblxuICAgIGNvbnN0IENvbnRlbnRQbGF5ZXJDbGFzcyA9IHRoaXMuZ2V0Q29udGVudFBsYXllckNsYXNzKCk7XG4gICAgdGhpcy5jb250ZW50UGxheWVyID0gbmV3IENvbnRlbnRQbGF5ZXJDbGFzcygpO1xuXG4gICAgY29uc3QgRG9jdW1lbnRDYXB0dXJlQ2xhc3MgPSB0aGlzLmdldERvY3VtZW50Q2FwdHVyZUNsYXNzKCk7XG4gICAgdGhpcy5kb2N1bWVudENhcHR1cmUgPSBuZXcgRG9jdW1lbnRDYXB0dXJlQ2xhc3MoKTtcbiAgfVxuXG4gIC8vIHN0YXJ0IG1vZHVsZXNcbiAgLy8gKGhhdmluZyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgdGhpcyByZWR1Y2VzIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbXMpXG4gIHN0YXJ0KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zZXR1cExvZ2dpbmcoKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMucG9ydE1hbmFnZXIuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmZsdXguc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLnNoYXJlZE1lbW9yeS5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuc3RvcmFnZS5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHN0YXJ0Wm9vbSh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMua2V5Ym9hcmRTaG9ydGN1dHMuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLm92ZXJsYXlDb250cm9sbGVyLnN0YXJ0KHRoaXMpKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5wYW5lbENvbnRyb2xsZXIuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmNvbnRlbnRQbGF5ZXIuc3RhcnQodGhpcykpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmRvY3VtZW50Q2FwdHVyZS5zdGFydCh0aGlzKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgfSk7XG4gIH1cblxuICBzZXR1cExvZ2dpbmcoKSB7XG4gICAgaWYgKHNldHRpbmdzLmdldCgnZGVidWcuaXNEaXNhYmxlZCcpKSBoaWRlQ29uc29sZU1lc3NhZ2VzKFsnbG9nJywgJ2luZm8nXSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9FeHRlbnNpb24uanMiLCJpbXBvcnQgQ29tbW9uRmx1eCBmcm9tICdiYXNlL2NvbW1vbi9GbHV4JztcbmltcG9ydCBTdGF0ZU1hbmFnZXIgZnJvbSAnYmFzZS9jb21tb24vU3RhdGVNYW5hZ2VyJztcbmltcG9ydCBhY3Rpb25GYWN0b3J5IGZyb20gJy4vYWN0aW9ucyc7XG5cbmltcG9ydCBtZXJnZVdpdGggZnJvbSAnbG9kYXNoL21lcmdlV2l0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsdXggZXh0ZW5kcyBDb21tb25GbHV4IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5vd25Db250ZXh0TmFtZSA9ICdjb250ZW50JztcblxuICAgIHRoaXMuY29udGVudFN0YXRlID0ge307XG4gICAgdGhpcy5vbGRDb250ZW50U3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYW5lbFN0YXRlID0ge307XG4gICAgdGhpcy5vbGRQYW5lbFN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMuYmFja2dyb3VuZFN0YXRlID0ge307XG4gICAgdGhpcy5vbGRCYWNrZ3JvdW5kU3RhdGUgPSBudWxsO1xuICAgIHRoaXMuYmFja2dyb3VuZFN0YXRlUmVjZWl2ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXJ0KGV4dGVuc2lvbikge1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgIHRoaXMucGFuZWxQb3J0ID0gdGhpcy5leHRlbnNpb24ucG9ydE1hbmFnZXIucGFuZWxQb3J0O1xuICAgIHRoaXMuYmFja2dyb3VuZFBvcnQgPSB0aGlzLmV4dGVuc2lvbi5wb3J0TWFuYWdlci5iYWNrZ3JvdW5kUG9ydDtcblxuICAgIHRoaXMucG9ydHNCeUNvbnRleHQgPSB7XG4gICAgICBwYW5lbDogdGhpcy5wYW5lbFBvcnQsXG4gICAgICBiYWNrZ3JvdW5kOiB0aGlzLmJhY2tncm91bmRQb3J0LFxuICAgIH07XG5cbiAgICB0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyID0gbmV3IFN0YXRlTWFuYWdlcih0aGlzLmV4dGVuc2lvbi5nZXRJbml0aWFsU3RhdGUoKSk7XG4gICAgdGhpcy5fYWN0aW9ucyA9IGFjdGlvbkZhY3Rvcnkoe1xuICAgICAgc2V0U3RhdGU6IHRoaXMubG9jYWxTdGF0ZU1hbmFnZXIuc2V0U3RhdGUuYmluZCh0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyKSxcbiAgICAgIGdldFN0YXRlOiB0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyLmdldFN0YXRlLmJpbmQodGhpcy5sb2NhbFN0YXRlTWFuYWdlciksXG4gICAgfSk7XG5cbiAgICB0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyLm9uKCdzdGF0ZUNoYW5nZWQnLCAoc3RhdGUpID0+IHRoaXMuaGFuZGxlQ29udGVudFN0YXRlKHN0YXRlKSk7XG4gICAgdGhpcy5leHRlbnNpb24ub25jZSgncmVhZHknLCAoKSA9PiB0aGlzLmhhbmRsZUNvbnRlbnRTdGF0ZSh0aGlzLmxvY2FsU3RhdGVNYW5hZ2VyLnN0YXRlKSk7XG5cbiAgICB0aGlzLnBhbmVsUG9ydC5vbignbWVzc2FnZScsIG1lc3NhZ2UgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdwYW5lbFN0YXRlQ2hhbmdlZCcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5lbFN0YXRlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnZGlzcGF0Y2hBY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2gobWVzc2FnZS5kYXRhLmNvbnRleHQsIG1lc3NhZ2UuZGF0YS5hY3Rpb25OYW1lLCAuLi5tZXNzYWdlLmRhdGEuYWN0aW9uQXJncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRQb3J0Lm9uKCdtZXNzYWdlJywgbWVzc2FnZSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS50b3BpYyA9PT0gJ2JhY2tncm91bmRTdGF0ZUNoYW5nZWQnKSB7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gbWVzc2FnZS5leGNsdWRlZFRhYnMgJiYgbWVzc2FnZS5leGNsdWRlZFRhYnMuaW5kZXhPZihtZXNzYWdlLnRhYi5pZCkgIT09IC0xO1xuICAgICAgICB0aGlzLmhhbmRsZUJhY2tncm91bmRTdGF0ZShtZXNzYWdlLmRhdGEsIGV4Y2x1ZGVkLCBtZXNzYWdlLnRhYi5pZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnZGlzcGF0Y2hBY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2gobWVzc2FnZS5kYXRhLmNvbnRleHQsIG1lc3NhZ2UuZGF0YS5hY3Rpb25OYW1lLCAuLi5tZXNzYWdlLmRhdGEuYWN0aW9uQXJncyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZXF1ZXN0IGN1cnJlbnQgc3RhdGVcbiAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoeyB0b3BpYzogJ3JlcXVlc3RCYWNrZ3JvdW5kU3RhdGUnIH0pO1xuICAgIHRoaXMucGFuZWxQb3J0LnNlbmQoeyB0b3BpYzogJ3JlcXVlc3RQYW5lbFN0YXRlJyB9KTtcbiAgfVxuXG4gIGhhbmRsZUNvbnRlbnRTdGF0ZShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICB0aGlzLm9sZENvbnRlbnRTdGF0ZSA9IHRoaXMuY29udGVudFN0YXRlO1xuICAgIHRoaXMuY29udGVudFN0YXRlID0gc3RhdGU7XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsICdjb250ZW50JywgdGhpcy5vbGRDb250ZW50U3RhdGUsIHRoaXMuY29udGVudFN0YXRlKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7XG4gICAgICB0b3BpYzogJ2NvbnRlbnRTdGF0ZUNoYW5nZWQnLFxuICAgICAgZGF0YTogc3RhdGUsXG4gICAgfSk7XG4gICAgdGhpcy5wYW5lbFBvcnQuc2VuZCgnY29udGVudFN0YXRlQ2hhbmdlZCcsIHN0YXRlKTtcbiAgfVxuXG4gIGhhbmRsZVBhbmVsU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdGhpcy5vbGRQYW5lbFN0YXRlID0gdGhpcy5wYW5lbFN0YXRlO1xuICAgIHRoaXMucGFuZWxTdGF0ZSA9IHN0YXRlO1xuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCAncGFuZWwnLCB0aGlzLm9sZFBhbmVsU3RhdGUsIHRoaXMucGFuZWxTdGF0ZSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgdG9waWM6ICdwYW5lbFN0YXRlQ2hhbmdlZCcsXG4gICAgICBkYXRhOiBzdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGZpeEJhY2tncm91bmRTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZSA/IG1lcmdlV2l0aChcbiAgICAgIHt9LFxuICAgICAgdGhpcy5iYWNrZ3JvdW5kU3RhdGUgfHwge30sXG4gICAgICBzdGF0ZSB8fCB7fSxcblxuICAgICAgLy8gZG8gbm90IHVwZGF0ZSBlbXB0eSB2YWx1ZXNcbiAgICAgIChvbGQsIHVwZGF0ZWQpID0+ICh0eXBlb2YgdXBkYXRlZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdXBkYXRlZCA9PT0gbnVsbClcbiAgICAgICAgPyBvbGRcbiAgICAgICAgOiB1cGRhdGVkXG4gICAgKSA6IG51bGw7XG4gIH1cblxuICAvLyBOb3RlOiB0YWJJZCBpcyBvdXIgb3duIHRhYiBpZFxuICBoYW5kbGVCYWNrZ3JvdW5kU3RhdGUoc3RhdGUsIGV4Y2x1ZGVkID0gZmFsc2UsIHRhYklkKSB7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHRoaXMub2xkQmFja2dyb3VuZFN0YXRlID0gdGhpcy5iYWNrZ3JvdW5kU3RhdGU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kU3RhdGUgPSBzdGF0ZSA9IHRoaXMuZml4QmFja2dyb3VuZFN0YXRlKHN0YXRlKTtcbiAgICB0aGlzLmJhY2tncm91bmRTdGF0ZVJlY2VpdmVkID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kU3RhdGUpIHJldHVybjtcblxuICAgIGlmICghZXhjbHVkZWQpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgJ2JhY2tncm91bmQnLCB0aGlzLm9sZEJhY2tncm91bmRTdGF0ZSwgdGhpcy5iYWNrZ3JvdW5kU3RhdGUsIHRhYklkKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhbmVsUG9ydC5zZW5kKCdiYWNrZ3JvdW5kU3RhdGVDaGFuZ2VkJywgc3RhdGUsIGV4Y2x1ZGVkKTtcbiAgfVxuXG4gIGNvbnRlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogdGhpcy5jb250ZW50U3RhdGUsXG4gICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMsIHsgbmFtZTogJ2NvbnRlbnQnIH0pLFxuICAgIH07XG4gIH1cblxuICBiYWNrZ3JvdW5kQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGU6IHRoaXMuYmFja2dyb3VuZFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzLCB7IG5hbWU6ICdiYWNrZ3JvdW5kJyB9KSxcbiAgICB9O1xuICB9XG5cbiAgcGFuZWxDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZTogdGhpcy5wYW5lbFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzLCB7IG5hbWU6ICdwYW5lbCcgfSksXG4gICAgfTtcbiAgfVxuXG4gIGRpc3BhdGNoKGNvbnRleHQsIGFjdGlvbk5hbWUsIC4uLmFjdGlvbkFyZ3MpIHtcbiAgICBpZiAoY29udGV4dC5uYW1lICE9PSB0aGlzLm93bkNvbnRleHROYW1lKSB7XG4gICAgICB0aGlzLmNhbGxSZW1vdGVBY3Rpb24oY29udGV4dCwgYWN0aW9uTmFtZSwgYWN0aW9uQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRpcmVjdFxuICAgICAgdGhpcy5jYWxsTG9jYWxBY3Rpb24oYWN0aW9uTmFtZSwgYWN0aW9uQXJncyk7XG4gICAgfVxuICB9XG5cbiAgc2VuZFRvQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgaWYgKGNvbnRleHQubmFtZSA9PT0gJ3BhbmVsJykge1xuICAgICAgdGhpcy5wb3J0c0J5Q29udGV4dFtjb250ZXh0Lm5hbWVdLnNlbmQobWVzc2FnZS50b3BpYywgbWVzc2FnZS5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3J0c0J5Q29udGV4dFtjb250ZXh0Lm5hbWVdLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvRmx1eC5qcyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWJvYXJkU2hvcnRjdXRzIHtcbiAgc3RhcnQoZXh0ZW5zaW9uKSB7XG4gICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbiAgICB0aGlzLmJhY2tncm91bmRQb3J0ID0gdGhpcy5leHRlbnNpb24ucG9ydE1hbmFnZXIuYmFja2dyb3VuZFBvcnQ7XG5cbiAgICAvLyBiaW5kaW5nIGtleWRvd24gZm9yIGhvdEtleSBjb21iaW5hdGlvblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgbGV0IHNwZWNpYWw7XG4gICAgICBsZXQga2V5O1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLmFsdEtleSkge1xuICAgICAgICBzcGVjaWFsID0gKGUuc2hpZnRLZXkpID8gJ3NoaWZ0S2V5J1xuICAgICAgICAgIDogKGUubWV0YUtleSkgID8gJ21ldGFLZXknXG4gICAgICAgICAgOiAoZS5jdHJsS2V5KSAgPyAnY3RybEtleSdcbiAgICAgICAgICA6IChlLmFsdEtleSkgICA/ICdhbHRLZXknXG4gICAgICAgICAgOiAnJztcbiAgICAgICAga2V5ID0gKGUud2hpY2ggfHwgZS5rZXlDb2RlIHx8IGUuY2hhckNvZGUpO1xuICAgICAgICB2YWx1ZSA9IHNwZWNpYWwucmVwbGFjZSgvS2V5LywgJycpICsgJyArICcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleSk7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUG9ydC5zZW5kKHsgJ2hvdEtleSc6IHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvS2V5Ym9hcmRTaG9ydGN1dHMuanMiLCIvLyBOb3RlOiBhc3N1bWVzIHRoYXQgXCJkb2N1bWVudHNcIiBpcyB0aGUgb25seSBvdGhlciBlbnRpdHkgZnJvbSB3aGVyZSBpdCBjYW4gc2VuZC9yZWNlaXZlIG1lc3NhZ2VzLlxuaW1wb3J0IFBvcnQgZnJvbSAnLi4vY29tbW9uL1BvcnQnO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuaW1wb3J0IHsgYWRkV2luZG93TGlzdGVuZXIgfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy93aW5kb3dFdmVudHMnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5lbFBvcnQgZXh0ZW5kcyBQb3J0IHtcbiAgX2JpbmRIYW5kbGVycygpIHtcbiAgICBpZiAodGhpcy5fYm91bmQpIHJldHVybjtcbiAgICB0aGlzLl9ib3VuZCA9IHRydWU7XG5cbiAgICAvLyBSZWNlaXZlIHBhbmVsIG1lc3NhZ2VzIChkaXJlY3Qgb3IgZnJvbSBhIHBhcmVudCBmcmFtZSkgYW5kIHJvdXRlIHRoZW0gdG8gY2hpbGQgZnJhbWVzXG4gICAgYWRkV2luZG93TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgLy9pZiAoZXZlbnQuc291cmNlICE9PSB3aW5kb3cpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKG1lc3NhZ2UuZnJvbSAhPT0gbmFtZXNwYWNlKCdwYW5lbCcpIHx8IG1lc3NhZ2UudG8gIT09IG5hbWVzcGFjZSgnY29udGVudCcpKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvL2xvZ2dlci5kZWJ1ZygnUGFuZWxQb3J0OiByZWNlaXZlZCBwYW5lbCBtZXNzYWdlJywgbWVzc2FnZSk7XG5cbiAgICAgIHRoaXMuX29uTWVzc2FnZVJlY2VpdmVkKG1lc3NhZ2UsICgpID0+IHt9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY29ubmVjdCBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG5cbiAgc2VuZCh0b3BpYywgZGF0YSwgZXhjbHVkZWQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9kaXNhYmxlZCkgcmV0dXJuO1xuICAgIC8vbG9nZ2VyLmRlYnVnKCdQYW5lbFBvcnQ6IHNlbmQnLCB0b3BpYywgZGF0YSk7XG5cbiAgICBjb25zdCBtZXNzYWdlID0geyB0b3BpYywgZGF0YSwgZXhjbHVkZWQsIGZyb206IG5hbWVzcGFjZSgnY29udGVudCcpLCB0bzogbmFtZXNwYWNlKCdwYW5lbCcpIH07XG5cbiAgICBjb25zdCBwYW5lbElmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke25hbWVzcGFjZSgncGFuZWwnKX0gaWZyYW1lYCk7XG4gICAgaWYgKCFwYW5lbElmcmFtZSkgcmV0dXJuOyAvLyBUT0RPOiBzdG9yZSBpbiBxdWV1ZSBhbmQgc2VuZCB3aGVuIHBhbmVsIGlzIGxvYWRlZD9cblxuICAgIHBhbmVsSWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IHRydWU7XG4gIH1cblxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L1BhbmVsUG9ydC5qcyIsImltcG9ydCBQYW5lbFBvcnQgZnJvbSAnLi9QYW5lbFBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3J0TWFuYWdlciB7XG4gIGdldEJhY2tncm91bmRQb3J0Q2xhc3MoKSB7XG4gICAgLy8gYWJzdHJhY3RcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFBhbmVsUG9ydENsYXNzKCkge1xuICAgIHJldHVybiBQYW5lbFBvcnQ7XG4gIH1cblxuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcblxuICAgIHRoaXMuc2V0dXBCYWNrZ3JvdW5kUG9ydCgpO1xuICAgIHRoaXMuc2V0dXBQYW5lbFBvcnQoKTtcbiAgfVxuXG4gIHNldHVwQmFja2dyb3VuZFBvcnQoKSB7XG4gICAgY29uc3QgQmFja2dyb3VuZFBvcnRDbGFzcyA9IHRoaXMuZ2V0QmFja2dyb3VuZFBvcnRDbGFzcygpO1xuICAgIHRoaXMuYmFja2dyb3VuZFBvcnQgPSBuZXcgQmFja2dyb3VuZFBvcnRDbGFzcyhudWxsLCAnJywgdGhpcy5leHRlbnNpb24pO1xuICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuY29ubmVjdCgpO1xuICB9XG5cbiAgc2V0dXBQYW5lbFBvcnQoKSB7XG4gICAgY29uc3QgUGFuZWxQb3J0Q2xhc3MgPSB0aGlzLmdldFBhbmVsUG9ydENsYXNzKCk7XG4gICAgdGhpcy5wYW5lbFBvcnQgPSBuZXcgUGFuZWxQb3J0Q2xhc3MobnVsbCwgJycsIHRoaXMuZXh0ZW5zaW9uKTtcbiAgICB0aGlzLnBhbmVsUG9ydC5jb25uZWN0KCk7XG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L1BvcnRNYW5hZ2VyLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWN0aW9uc0ZhY3RvcnkoeyBzZXRTdGF0ZSB9KSB7XG4gIHJldHVybiB7XG4gICAgc2V0TG9jYXRpb25IcmVmKHZhbHVlLCBjaGFuZ2VkQXQpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgbG9jYXRpb25IcmVmOiB2YWx1ZSxcbiAgICAgICAgbG9jYXRpb25IcmVmQ2hhbmdlZEF0OiBjaGFuZ2VkQXQsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2V0UGFnZUxvZ2dlZEluVHlwZSh2YWx1ZSkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBwYWdlTG9nZ2VkSW5UeXBlOiB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0b2dnbGVJbnRlcmNvbUluc3RhbGxlZCh2YWx1ZSkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpbnRlcmNvbUluc3RhbGxlZDogdmFsdWUsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlR29vZ2xlVHJhbnNsYXRlSW5zdGFsbGVkKHZhbHVlKSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGdvb2dsZVRyYW5zbGF0ZUluc3RhbGxlZDogdmFsdWUsXG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L2FjdGlvbnMuanMiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldExvY2F0b3IgfSBmcm9tICcuL2VsZW1lbnRMb2NhdG9yJztcbmltcG9ydCB7IHBhZ2Vib3VuZHMyc2NyZWVuIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzL2Nvb3JkaW5hdGVzJztcbmltcG9ydCBnZXRQYXJlbnRQb3B1cCBmcm9tICcuLi9jb21tb24vdXRpbHMvZ2V0UGFyZW50UG9wdXAnO1xuaW1wb3J0IGdldEVsZW1lbnRWaXN1YWxCb3VuZHMgZnJvbSAnLi9nZXRFbGVtZW50VmlzdWFsQm91bmRzJztcbmltcG9ydCBDU1NFc2NhcGUgZnJvbSAnY3NzLmVzY2FwZSc7XG5pbXBvcnQgaXNTcHJpdGVIb2xkZXIgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvaXNTcHJpdGVIb2xkZXInO1xuaW1wb3J0IHsgY2xvc2VzdCB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2RvbSc7XG5cbmltcG9ydCBmaW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBtYXAgZnJvbSAnbG9kYXNoL21hcCc7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbi8vIHN0cmluZzogdGFnIG5hbWVcbi8vIGZ1bmN0aW9uOiB0ZXN0ZXIgb24gdGhlIGVsZW1lbnRcbmNvbnN0IEJBU0lDX1RZUEVfUlVMRVMgPSB7XG4gICdCVVRUT04nOiBbXG4gICAgJ2J1dHRvbicsXG4gICAgZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdidG4nKSxcbiAgICBlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2J1dHRvbicpLFxuICBdLFxuICAnTElOSyc6IFsnYSddLFxuICAnTkFUSVZFX0RST1BET1dOJzogWydzZWxlY3QnXSxcbiAgJ0lNQUdFJzogWydpbWcnLCAnc3ZnJywgJ2NhbnZhcyddLFxuICAnTEFCRUwnOiBbXG4gICAgJ2xhYmVsJyxcbiAgICBlbCA9PiBlbC5oYXNBdHRyaWJ1dGUoJ2ZvcicpLFxuICBdLFxuICAnQVVESU8nOiBbJ2F1ZGlvJ10sXG4gICdWSURFTyc6IFsndmlkZW8nXSxcbiAgLy8gbGFzdCByZXNvcnRcbiAgJ1RFWFRfRklFTEQnOiBbXG4gICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2InLFxuICAgICdzdHJvbmcnLCAnaScsICd1JywgJ2NhcHRpb24nLCAnY29kZScsICdwcmUnLFxuICAgIGVsID0+IHtcbiAgICAgIC8vIGVsIG9ubHkgY29udGFpbnMgdGV4dFxuICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50ICYmIGVsLnRleHRDb250ZW50ID09PSBlbC5pbm5lckhUTUw7XG4gICAgfSxcbiAgXSxcbn07XG5cbmNvbnN0IElOUFVUX1RZUEVfTUFQUElORyA9IHtcbiAgYnV0dG9uOiBcIkJVVFRPTlwiLFxuICBjaGVja2JveDogXCJDSEVDS19CT1hcIixcbiAgcmFkaW86IFwiUkFESU9fQlVUVE9OXCIsXG4gIGltYWdlOiBcIkJVVFRPTlwiLFxuICBzdWJtaXQ6IFwiQlVUVE9OXCIsXG4gIHJlc2V0OiBcIkJVVFRPTlwiLFxuICBoaWRkZW46IFwiVU5ERUZJTkVEXCIsXG59O1xuXG5jb25zdCBST0xFX01BUFBJTkcgPSB7XG4gIGxpbms6IFwiTElOS1wiLFxuICBhbGVydGRpYWxvZzogXCJESUFMT0dcIixcbiAgZGlhbG9nOiBcIkRJQUxPR1wiLFxuICBidXR0b246IFwiQlVUVE9OXCIsXG4gIG9wdGlvbjogXCJPUFRJT05cIixcbiAgY2hlY2tib3g6IFwiQ0hFQ0tfQk9YXCIsXG4gIGNvbWJvYm94OiBcIkNPTUJPX0JPWFwiLFxuICByYWRpbzogXCJSQURJT19CVVRUT05cIixcbiAgdGFiOiBcIlRBQlwiLFxuICBwcmVzZW50YXRpb246IFwiUFJFU0VOVEFUSU9OXCIsXG59O1xuXG5jb25zdCBTVFlMRV9QUk9QRVJUSUVTID0gW1xuICAnY29sb3InLCAnYmFja2dyb3VuZC1jb2xvcicsICdmb250LXNpemUnLCAnZm9udC13ZWlnaHQnLCAnZm9udC1mYW1pbHknLFxuXTtcblxuLy8gdHlwZXMgdGlwaWNhbGx5IGNvbnZleWluZyBsb3RzIG9mIGluZm9ybWF0aW9uIGFuZCBhY3Rpb25zIChuYW1lLCBjbGljaywgZXRjLilcbmNvbnN0IEhJR0hfUFJJT1JJVFkgPSBbXG4gIFwiSUZSQU1FXCIsIFwiTElOS1wiLCBcIkJVVFRPTlwiLCBcIkNIRUNLX0JPWFwiLFxuICBcIlJBRElPX0JVVFRPTlwiLCBcIk5BVElWRV9EUk9QRE9XTlwiLCBcIkNPTUJPX0JPWFwiLCBcIlRFWFRfSU5QVVRcIixcbiAgXCJUQUJcIlxuXTtcblxuLy8gYXZvaWRzIHRvIHVzZSB0aGUgd2hvbGUgcGFnZSBjb250ZW50IGFzIG5hbWVcbmNvbnN0IE5BTUVfVEVYVENPTlRFTlRfTUFYX0xFTkdUSCA9IDIwMDtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZShlbCkge1xuICAvLyAoZG9jdW1lbnQgYW5kIHdpbmRvdyBoYXZlIG5vIHRhZ25hbWUpXG4gIHJldHVybiAoZWwgJiYgdHlwZW9mIGVsLnRhZ05hbWUgPT09ICdzdHJpbmcnKSA/IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlRnJvbUJhc2ljUnVsZXMoZWwpIHtcbiAgY29uc3QgZWxUYWdOYW1lID0gZ2V0VGFnTmFtZShlbCk7XG5cbiAgZm9yIChjb25zdCBjdXJyZW50VHlwZSBvZiBPYmplY3Qua2V5cyhCQVNJQ19UWVBFX1JVTEVTKSkge1xuICAgIGNvbnN0IHJ1bGVzID0gQkFTSUNfVFlQRV9SVUxFU1tjdXJyZW50VHlwZV07XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICBpZiAodHlwZW9mIHJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHJ1bGUgaXMgdGhlIHRhZ25hbWVcbiAgICAgICAgaWYgKGVsVGFnTmFtZSA9PT0gcnVsZSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAocnVsZShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJ1VOREVGSU5FRCc7XG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoZWwpIHtcbiAgaWYgKCFlbC5jbGFzc0xpc3QpIHtcbiAgICAvLyBNYXliZSB0aGUgZG9jdW1lbnQvd2luZG93IGFuZCBub3QgYSBwcm9wZXIgZWxlbWVudFxuICAgIHJldHVybiAnVU5ERUZJTkVEJztcbiAgfVxuXG4gIGNvbnN0IGVsVGFnTmFtZSA9IGdldFRhZ05hbWUoZWwpO1xuXG4gIC8vIHRvcCBwcmlvcml0eSBlbGVtZW50LCBhbiBpbm5lciBjb250ZW50IHNjcmlwdCBjYW4gcHJvYmFibHkgcmV0dXJuIGEgYmV0dGVyIGluZm9cbiAgaWYgKGVsVGFnTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICByZXR1cm4gJ0lGUkFNRSc7XG4gIH1cblxuICBpZiAoZWxUYWdOYW1lID09PSAnaW5wdXQnIHx8IGVsVGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgcmV0dXJuIElOUFVUX1RZUEVfTUFQUElOR1tlbC50eXBlXSB8fCAnVEVYVF9JTlBVVCc7XG4gIH1cblxuICAvLyBhIHNlbGVjdCBlbGVtZW50IGlzIGEgTkFUSVZFX0RST1BET1dOIG5vIG1hdHRlciB3aGF0IGl0cyByb2xlIGF0dHJpYnV0ZSBpcyxcbiAgLy8gc2luY2UgdGhlIGJhY2tncm91bmQgb25seSBkcmF3cyBuYXRpdmUgZHJvcGRvd25zIGZvciB0aGF0IHR5cGVcbiAgaWYgKGVsVGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gJ05BVElWRV9EUk9QRE9XTic7XG4gIH1cblxuICBpZiAoZWwuaGFzQXR0cmlidXRlKCdyb2xlJykpIHtcbiAgICBjb25zdCByb2xlID0gZWwuZ2V0QXR0cmlidXRlKCdyb2xlJyk7XG4gICAgLy8gbG9nZ2VyLmRlYnVnKCdST0xFJywgcm9sZSlcbiAgICBpZiAocm9sZSBpbiBST0xFX01BUFBJTkcpIHtcbiAgICAgIHJldHVybiBST0xFX01BUFBJTkdbcm9sZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRldGVjdFR5cGVGcm9tQmFzaWNSdWxlcyhlbCk7XG59XG5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0cywgbm90IGZvciB1c2VyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0TmFtZShlbCkge1xuICBpZiAoIWVsLmNsYXNzTGlzdCkge1xuICAgIC8vIE1heWJlIHRoZSBkb2N1bWVudC93aW5kb3cgYW5kIG5vdCBhIHByb3BlciBlbGVtZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGVsVGFnTmFtZSA9IGdldFRhZ05hbWUoZWwpO1xuXG4gIGlmIChlbFRhZ05hbWUgPT09ICdzZWxlY3QnICYmIGVsLnNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGVsLnNlbGVjdGVkT3B0aW9uc1swXS5sYWJlbDtcbiAgfVxuXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkge1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgfVxuXG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpKSB7XG4gICAgY29uc3QgbGFiZWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JykpO1xuICAgIGlmIChsYWJlbEVsKSB7XG4gICAgICByZXR1cm4gbGFiZWxFbC50ZXh0Q29udGVudDtcbiAgICB9XG4gIH1cblxuICBpZiAoJ3ZhbHVlJyBpbiBlbCAmJiBlbFRhZ05hbWUgIT09ICdvcHRpb24nKSB7XG4gICAgaWYgKGVsLmlkKSB7XG4gICAgICAvLyB0cnkgd2l0aCBsYWJlbFxuICAgICAgY29uc3QgbGFiZWxFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxhYmVsW2Zvcj1cIiR7Q1NTRXNjYXBlKGVsLmlkKX1cIl1gKTtcbiAgICAgIGlmIChsYWJlbEVsKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsRWxOYW1lID0gZGV0ZWN0TmFtZShsYWJlbEVsKTtcbiAgICAgICAgaWYgKGxhYmVsRWxOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsRWxOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1ByaXZhdGVJbnB1dCA9IFsndGV4dCcsICdwYXNzd29yZCddLmluZGV4T2YoZWwuZ2V0QXR0cmlidXRlKCd0eXBlJykpICE9PSAtMTtcblxuICAgIC8vICh2YWx1ZSBpcyBpZ25vcmVkIGZvciB0ZXh0IGlucHV0cyBmb3IgcHJpdmFjeSByZWFzb25zKVxuICAgIGlmIChlbC52YWx1ZSAhPT0gJycgJiYgIWlzUHJpdmF0ZUlucHV0KSB7XG4gICAgICByZXR1cm4gZWwudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJpdmF0ZUlucHV0ICYmIGVsLmlkKSB7XG4gICAgICByZXR1cm4gZWwuaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLnRleHRDb250ZW50ICYmIGVsLnRleHRDb250ZW50Lmxlbmd0aCA8PSBOQU1FX1RFWFRDT05URU5UX01BWF9MRU5HVEgpIHtcbiAgICByZXR1cm4gZWwudGV4dENvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RTdHlsZShlbCkge1xuICBjb25zdCBzdHlsZSA9IHt9O1xuXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZWwuY2xhc3NMaXN0ID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpIDoge307XG4gIGZvciAoY29uc3QgcHJvcCBvZiBTVFlMRV9QUk9QRVJUSUVTKSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZFN0eWxlc1twcm9wXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cblxuXG5mdW5jdGlvbiBkZXRlY3RPcHRpb25zKGVsKSB7XG4gIGlmICghZWwuY2xhc3NMaXN0IHx8ICFlbC5vcHRpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG1hcChlbC5vcHRpb25zLCBvID0+ICh7dmFsdWU6IG8udmFsdWUsIGxhYmVsOiBvLmxhYmVsfSkpO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RWYWx1ZShlbCkge1xuICBpZiAoIWVsLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGVsLnZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RJbmZvKGVsKSB7XG4gIC8vIFRPRE86IHdlIGNvdWxkIG5lZWQgbW9yZSBpbmZvLCBhdCBsZWFzdCBhdHRyaWJ1dGVzXG4gIGxldCBuYW1lID0gZGV0ZWN0TmFtZShlbCk7XG4gIGxldCB0eXBlID0gZGV0ZWN0VHlwZShlbCk7XG4gIGxldCBzdHlsZSA9IGRldGVjdFN0eWxlKGVsKTtcbiAgbGV0IGJvdW5kcyA9IGdldEVsZW1lbnRWaXN1YWxCb3VuZHMoZWwsIHRydWUpO1xuICBsZXQgb3B0aW9ucyA9IGRldGVjdE9wdGlvbnMoZWwpO1xuICBsZXQgdmFsdWUgPSBkZXRlY3RWYWx1ZShlbCk7XG5cblxuICBjb25zdCBpbmZvID0geyB0eXBlLCBib3VuZHMsIG5hbWUsIG9wdGlvbnMsIHZhbHVlLCBzdHlsZSB9O1xuXG4gIHJldHVybiBpbmZvO1xufVxuXG4vLyB0cmF2ZXJzZXMgdGhlIERPTSB0cmVlIGJvdHRvbS11cCBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBlbCBhbmRcbi8vIHJldHVybnMgdGhlIGZpcnN0IGVuY291bnRlcmVkIGhpZ2ggcHJpb3JpdHkgaW5mbyAoaWYgYW55KSxcbi8vIG90aGVyd2lzZSwgcmV0dXJucyB0aGUgaW5mbyBvZiB0aGUgZ2l2ZW4gZWwuXG4vLyBOT1RFOiBzcHJpdGUgaG9sZGVyIGVsZW1lbnRzIGFyZSBleGNsdWRlZCwgdGhleSBhcmUgb25seSB1c2VkIGFzIGxhc3QgcmVzb3J0XG4vLyBpZiB0aGVyZSBhcmVuJ3Qgb3RoZXIgY2FuZGlkYXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWN0aXZlRWxlbWVudCh0YXJnZXQpIHtcbiAgY29uc3QgaXNWYWxpZCA9IChlbCkgPT4gIWlzU3ByaXRlSG9sZGVyKGVsKTtcbiAgY29uc3QgZmlyc3RFbGVtZW50ID0gY2xvc2VzdCh0YXJnZXQsIGlzVmFsaWQpIHx8IHRhcmdldDtcbiAgY29uc3QgZmlyc3RFbGVtZW50Qm91bmRzID0gZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyhmaXJzdEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIG1ha2VDYW5kaWRhdGUoZWwsIGlzRmlyc3QpIHtcbiAgICBjb25zdCBpbmZvID0gZGV0ZWN0SW5mbyhlbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsLFxuICAgICAgaW5mbyxcbiAgICAgIHRhcmdldDogaXNGaXJzdCxcbiAgICAgIGhpZ2hQcmlvcml0eTogSElHSF9QUklPUklUWS5pbmRleE9mKGluZm8udHlwZSkgIT09IC0xLFxuICAgICAgdHlwZUluZm86IGluZm8udHlwZSAhPT0gJ1VOREVGSU5FRCcsXG4gICAgICBuYW1lSW5mbzogISFpbmZvLm5hbWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbbWFrZUNhbmRpZGF0ZShmaXJzdEVsZW1lbnQsIHRydWUpXTtcblxuICBsZXQgY3VycmVudEVsID0gZmlyc3RFbGVtZW50O1xuICBsZXQgY29udGFpbnNTb0ZhciA9IHRydWU7XG4gIHdoaWxlIChjdXJyZW50RWwucGFyZW50Tm9kZSAmJiBjdXJyZW50RWwucGFyZW50Tm9kZS5jbGFzc0xpc3QpIHtcbiAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwucGFyZW50Tm9kZTtcbiAgICBjb25zdCBjdXJyZW50Qm91bmRzID0gZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyhjdXJyZW50RWwsIHRydWUpO1xuICAgIGNvbnRhaW5zU29GYXIgPSBjb250YWluc1NvRmFyICYmIChjdXJyZW50Qm91bmRzLnkgPD0gZmlyc3RFbGVtZW50Qm91bmRzLnkgJiYgY3VycmVudEJvdW5kcy55K2N1cnJlbnRCb3VuZHMuaGVpZ2h0ID49IGZpcnN0RWxlbWVudEJvdW5kcy55K2ZpcnN0RWxlbWVudEJvdW5kcy5oZWlnaHQmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qm91bmRzLnggPD0gZmlyc3RFbGVtZW50Qm91bmRzLnggJiYgY3VycmVudEJvdW5kcy54K2N1cnJlbnRCb3VuZHMud2lkdGggPj0gZmlyc3RFbGVtZW50Qm91bmRzLngrZmlyc3RFbGVtZW50Qm91bmRzLndpZHRoKTtcbiAgICAvLyBPbmx5IGNvbnNpZGVyaW5nIGVsZW1lbnRzIHRoYXQgZnVsbHkgY29udGFpbiB0aGUgdGFyZ2V0XG4gICAgaWYgKCFjb250YWluc1NvRmFyKSBicmVhaztcblxuICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1ha2VDYW5kaWRhdGUoY3VycmVudEVsKTtcbiAgICBpZiAoY2FuZGlkYXRlLnRhcmdldCB8fCBjYW5kaWRhdGUuaGlnaFByaW9yaXR5IHx8IGNhbmRpZGF0ZS50eXBlSW5mbyB8fCBjYW5kaWRhdGUubmFtZUluZm8pIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJlc3RHdWVzcyA9IGZpbmQoY2FuZGlkYXRlcywgeyBoaWdoUHJpb3JpdHk6IHRydWUgfSkgfHxcbiAgICBmaW5kKGNhbmRpZGF0ZXMsIHsgdGFyZ2V0OiB0cnVlIH0pO1xuICAvLyBMaW1pdGluZyBhcmJpdHJhcmlseSB0byA0XG4gIGNvbnN0IGFsdGVybmF0aXZlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGMgPT4gYyAhPT0gYmVzdEd1ZXNzICYmIChjLmhpZ2hQcmlvcml0eSB8fCBjLm5hbWVJbmZvIHx8IGMudGFyZ2V0KSkuc2xpY2UoNCk7XG5cbiAgLy8gUmV0dXJuIGJvdGggdGhlIGJlc3QgZ3Vlc3MgYW5kIHNvbWUgYWx0ZXJuYXRpdmVzICh0aGUgdXNlciBpcyBhbGxvd2VkIHRvXG4gIC8vIHN3aXRjaCB0byBvbmUgbGF0ZXIpXG4gIHJldHVybiB7XG4gICAgZWw6IGJlc3RHdWVzcy5lbCxcbiAgICBpbmZvOiBiZXN0R3Vlc3MuaW5mbyxcbiAgICBhbHRlcm5hdGl2ZXM6IGFsdGVybmF0aXZlcy5tYXAoYyA9PiAoe2VsOiBjLmVsLCBpbmZvOiBjLmluZm99KSlcbiAgfTtcbn1cblxuLy8gR2V0IGluZm9ybWF0aW9uIG9uIHRoZSBlbGVtZW50LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRJbmZvKGVsLCBzY3JlZW5Cb3VuZHM9ZmFsc2UpIHtcbiAgbGV0IHsgaW5mbywgZWw6IGFjdGl2ZUVsLCBhbHRlcm5hdGl2ZXMgfSA9IGZpbmRBY3RpdmVFbGVtZW50KGVsKTtcblxuICBmdW5jdGlvbiBhZGRTY3JlZW5Cb3VuZHMoaW5mbykge1xuICAgIGlmIChzY3JlZW5Cb3VuZHMpIHtcbiAgICAgIGNvbnN0IHBhZ2VCb3VuZHMgPSBpbmZvLmJvdW5kcztcbiAgICAgIGNvbnN0IHNjcmVlbkJvdW5kcyA9IHBhZ2Vib3VuZHMyc2NyZWVuKHBhZ2VCb3VuZHMpO1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgYm91bmRzOiBzY3JlZW5Cb3VuZHMsXG4gICAgICAgIHBhZ2VCb3VuZHMsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGluZm8gPSB7XG4gICAgLi4uYWRkU2NyZWVuQm91bmRzKGluZm8pLFxuICAgIGlzSW5Qb3B1cDogQm9vbGVhbihnZXRQYXJlbnRQb3B1cChlbCkpLFxuICAgIGxvY2F0b3I6IGdldExvY2F0b3IoYWN0aXZlRWwpLFxuICB9O1xuICByZXR1cm4ge1xuICAgIGluZm8sXG4gICAgZWwsXG4gICAgYWN0aXZlRWwsXG4gICAgYWx0ZXJuYXRpdmVzOiBhbHRlcm5hdGl2ZXMubWFwKGEgPT4gKHsuLi5hZGRTY3JlZW5Cb3VuZHMoYS5pbmZvKSwgbG9jYXRvcjogZ2V0TG9jYXRvcihhLmVsKX0pKSxcbiAgfTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L2VsZW1lbnRJbmZvLmpzIiwiaW1wb3J0ICogYXMgZnJhbWVNZXNzYWdlcyBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvZnJhbWVNZXNzYWdlc1wiO1xuaW1wb3J0IGludGVyc2VjdGlvbiBmcm9tIFwibG9kYXNoL2ludGVyc2VjdGlvblwiO1xuaW1wb3J0ICogYXMgaGFuZGxlcnMgZnJvbSBcIi4vaGFuZGxlcnMvaW5kZXhcIjtcbmltcG9ydCBzY3JvbGxFbGVtZW50SW50b1ZpZXcgZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9zY3JvbGxFbGVtZW50SW50b1ZpZXdcIjtcbmltcG9ydCBnZXRCb3VuZHMgZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9nZXRCb3VuZHNcIjtcbmltcG9ydCB7XG4gIHBhZ2Vib3VuZHMyc2NyZWVuLFxuICBzY3JlZW5ib3VuZHMydGFiXG59IGZyb20gXCIuLi8uLi9jb21tb24vdXRpbHMvY29vcmRpbmF0ZXNcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vLi4vY29tbW9uL3NldHRpbmdzXCI7XG5pbXBvcnQgZ2V0UGFyZW50UG9wdXAgZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2dldFBhcmVudFBvcHVwXCI7XG5pbXBvcnQgZWxlbWVudE9uVG9wIGZyb20gXCIuL2VsZW1lbnRPblRvcFwiO1xuaW1wb3J0IHsgY2xvc2VzdCB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2RvbSc7XG5cbmltcG9ydCB7IGdldEZpbGVMb2dnZXIgfSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyXCI7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5pbXBvcnQgbG9jYXRvclNlYXJjaGVyIGZyb20gXCIuL0xvY2F0b3JTZWFyY2hlclwiO1xuXG4vLyBSdW5zIG9uIGV2ZXJ5IGZyYW1lLCBpcyByZXNwb25zaWJsZSBmb3IgZG9pbmcgdGhpbmdzIHRoYXQgY2FuIG9ueSBiZSBkb25lIG9uXG4vLyB0aGUgaW5kaXZpZHVhbCBmcmFtZXMgKGxpa2UgaG9va2luZyBldmVudHMgdG8gZWxlbWVudCkuIERvIG5vdCBkbyBzdHVmZiBoZXJlXG4vLyB0aGF0IGNvdWxkIGJlIGRvbmUgaW4gdGhlIHJvb3QuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50UGxheWVyRnJhbWVOb2RlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuY3VycmVudGx5SG9va2VkID0gbnVsbDtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGZyYW1lTWVzc2FnZXMub25NZXNzYWdlKFxuICAgICAgXCJDb250ZW50UGxheWVyOmhvb2tFbGVtZW50c1wiLFxuICAgICAgbWVzc2FnZSA9PlxuICAgICAgICB0aGlzLmhvb2tFbGVtZW50cyhtZXNzYWdlLnBheWxvYWQuc3RlcCwgbWVzc2FnZS5wYXlsb2FkLmxvY2F0b3JEYXRhKVxuICAgICk7XG4gIH1cblxuICBob29rRWxlbWVudHMoc3RlcCwgbG9jYXRvckRhdGEpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGxvY2F0b3JEYXRhICYmXG4gICAgICBsb2NhdG9yRGF0YS5mcmFtZUlkID09PSBmcmFtZU1lc3NhZ2VzLmZyYW1lSWRcbiAgICAgID8gbG9jYXRvclNlYXJjaGVyLmdldEVscyhsb2NhdG9yRGF0YS5sb2NhdG9ySWQpXG4gICAgICA6IFtdO1xuXG4gICAgY29uc3QgbmV3SG9va2VkID0geyBzdGVwSW5kZXg6IHN0ZXAuaW5kZXgsIGVsZW1lbnRzIH07XG4gICAgY29uc3QgYWxyZWFkeUhvb2tlZCA9IHRoaXMuY3VycmVudGx5SG9va2VkICYmXG4gICAgICB0aGlzLmN1cnJlbnRseUhvb2tlZC5zdGVwSW5kZXggPT09IG5ld0hvb2tlZC5zdGVwSW5kZXggJiZcbiAgICAgIHRoaXMuY3VycmVudGx5SG9va2VkLmVsZW1lbnRzLmxlbmd0aCA9PT0gbmV3SG9va2VkLmVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgaW50ZXJzZWN0aW9uKHRoaXMuY3VycmVudGx5SG9va2VkLmVsZW1lbnRzLCBuZXdIb29rZWQuZWxlbWVudHMpLmxlbmd0aCA9PT1cbiAgICAgICAgbmV3SG9va2VkLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoYWxyZWFkeUhvb2tlZCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiQWxyZWFkeSBob29rZWQgZWxlbWVudHMgKGZvciB0aGlzIHN0ZXApLCBub3RoaW5nIHRvIGRvXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDbGVhciBwcmV2aW91c2x5IGhvb2tlZFxuICAgIHRoaXMuY2xlYXJET01MaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgdGhpcy5fY29tcGxldGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBvbkNvbXBsZXRlZCA9IChlbCkgPT4ge1xuICAgICAgLy8gaWdub3JlIHRoZSB1cmwgY2hhbmdlIGNoZWNrIHdoZW4gY2xpY2tpbmcgb24gYSBsaW5rIHRvd2FyZHMgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgLy8gKHNpbmNlIHRoZXJlIGNvdWxkIGJlIG5vIGFjdHVhbCBVUkwgY2hhbmdlIGluIG1vZGVybiBIVE1MNSBhcHBzLCBzZWUgOTE2I2lzc3VlLTI2NDgwMTk5MylcbiAgICAgIGxldCBza2lwVXJsQ2hlY2sgPSBmYWxzZTtcbiAgICAgIGlmICh3aW5kb3cudG9wID09PSB3aW5kb3cpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gY2xvc2VzdChlbCwgb3RoZXJFbCA9PiBvdGhlckVsLnRhZ05hbWUgPT09ICdBJyk7XG4gICAgICAgIGlmIChhbmNob3IgJiYgYW5jaG9yLmhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgc2tpcFVybENoZWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgZnJhbWVNZXNzYWdlcy5zZW5kKGZyYW1lTWVzc2FnZXMuVE9QLCBcIkNvbnRlbnRQbGF5ZXI6Y29tcGxldGVcIiwge1xuICAgICAgICBjb21wbGV0ZWRBdDogRGF0ZS5ub3coKSwgLy8gTk9URTogbmV3IERhdGUoKSBicmVha3MgRWRnZSB0aHVzIHdlIHVzZSBhIHRpbWVzdGFtcFxuICAgICAgICBza2lwVXJsQ2hlY2ssXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTm90Q29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGxldGVkID0gZmFsc2U7XG4gICAgICBmcmFtZU1lc3NhZ2VzLnNlbmQoZnJhbWVNZXNzYWdlcy5UT1AsIFwiQ29udGVudFBsYXllcjpub3RDb21wbGV0ZWRcIik7XG4gICAgfTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1hcmtlckJvcmRlciA9IDY7XG4gICAgICB0aGlzXG4gICAgICAgIC5zY3JvbGxFbGVtZW50SW50b1ZpZXcoZWxlbWVudHNbMF0sIHN0ZXAsIG1hcmtlckJvcmRlcilcbiAgICAgICAgLnRoZW4oKCkgPT4ge30pO1xuXG4gICAgICB0aGlzLnNldHVwUGFyZW50UG9wdXBMaXN0ZW5lcnMoZWxlbWVudHMpO1xuXG4gICAgICBjb25zdCBoYW5kbGVyVHlwZSA9IHN0ZXAudHlwZTtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1toYW5kbGVyVHlwZV07XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCwgZWxJbmRleCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGVsSW5kZXgsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgb25Db21wbGV0ZWQ6ICgpID0+IG9uQ29tcGxldGVkKGVsKSxcbiAgICAgICAgICAgIG9uTm90Q29tcGxldGVkOiAoKSA9PiBvbk5vdENvbXBsZXRlZChlbCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudGx5SG9va2VkID0gbmV3SG9va2VkO1xuICB9XG5cbiAgLy8gR28gYmFjayB3aGVuIGVsZW1lbnRzIGFyZSBpbnNpZGUgYSBkcm9wZG93biBhbmQgaXQgaXMgY2xvc2VkXG4gIC8vIE5vdGU6IGFzc3VtZXMgdGhlIGRyb3Bkb3duIGlzIHRoZSBzYW1lIGZvciBldmVyeSBlbGVtZW50XG4gIHNldHVwUGFyZW50UG9wdXBMaXN0ZW5lcnMoZWxlbWVudHMpIHtcbiAgICBsZXQgcGFyZW50UG9wdXA7XG4gICAgY29uc3QgZWxJblBvcHVwID0gZWxlbWVudHMuZmlsdGVyKGVsID0+IGVsZW1lbnRPblRvcChlbCkpLmZpbmQoZWwgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFBhcmVudFBvcHVwID0gZ2V0UGFyZW50UG9wdXAoZWwpO1xuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRQb3B1cCkge1xuICAgICAgICBwYXJlbnRQb3B1cCA9IGN1cnJlbnRQYXJlbnRQb3B1cDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKCFlbEluUG9wdXApIHJldHVybjtcblxuICAgIGNvbnN0IHRpbWVyTmFtZSA9IFwic2V0dXBQYXJlbnRQb3B1cExpc3RlbmVyc1wiO1xuICAgIGxldCBtZXNzYWdlU2VudCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcih0aW1lck5hbWUpO1xuICAgICAgdGhpcy5hZGRUaW1lcihcbiAgICAgICAgdGltZXJOYW1lLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0UG9wdXAgPSBnZXRQYXJlbnRQb3B1cChldmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGludGVyYWN0aW9uT3V0c2lkZVBvcHVwID0gIXRhcmdldFBvcHVwIHx8XG4gICAgICAgICAgICB0YXJnZXRQb3B1cCAhPT0gcGFyZW50UG9wdXA7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1lc3NhZ2VTZW50ICYmXG4gICAgICAgICAgICAhdGhpcy5fY29tcGxldGVkICYmXG4gICAgICAgICAgICBpbnRlcmFjdGlvbk91dHNpZGVQb3B1cCAmJlxuICAgICAgICAgICAgIWVsZW1lbnRPblRvcChlbEluUG9wdXApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtZXNzYWdlU2VudCA9IHRydWU7XG4gICAgICAgICAgICBmcmFtZU1lc3NhZ2VzLnNlbmQoZnJhbWVNZXNzYWdlcy5UT1AsIFwiQ29udGVudFBsYXllcjpnb0JhY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAyMDBcbiAgICAgICk7XG4gICAgfTtcbiAgICB0aGlzLmxpc3RlblRvRE9NKHdpbmRvdywgXCJjbGlja1wiLCBoYW5kbGUpO1xuICAgIHRoaXMubGlzdGVuVG9ET00od2luZG93LCBcIm1vdXNlb3ZlclwiLCBoYW5kbGUpO1xuICB9XG5cbiAgbGlzdGVuVG9ET00oZWwsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIHRoaXMuZG9tTGlzdGVuZXJzID0gdGhpcy5kb21MaXN0ZW5lcnMgfHwgW107XG5cbiAgICBoYW5kbGVyID0gaGFuZGxlci5iaW5kKHRoaXMpO1xuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXG4gICAgY29uc3QgZG9tTGlzdGVuZXIgPSBbZWwsIGV2ZW50TmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZV07XG4gICAgY29uc3QgZG9tTGlzdGVuZXJJbmRleCA9IHRoaXMuZG9tTGlzdGVuZXJzLmxlbmd0aDtcbiAgICB0aGlzLmRvbUxpc3RlbmVycy5wdXNoKGRvbUxpc3RlbmVyKTtcbiAgICByZXR1cm4gZG9tTGlzdGVuZXJJbmRleDtcbiAgfVxuXG4gIHN0b3BET01MaXN0ZW5pbmcoZG9tTGlzdGVuZXJJbmRleCkge1xuICAgIHRoaXMuZG9tTGlzdGVuZXJzID0gdGhpcy5kb21MaXN0ZW5lcnMgfHwgW107XG5cbiAgICBjb25zdCBkb21MaXN0ZW5lciA9IHRoaXMuZG9tTGlzdGVuZXJzW2RvbUxpc3RlbmVySW5kZXhdO1xuICAgIGlmICghZG9tTGlzdGVuZXIpIHJldHVybjtcblxuICAgIGNvbnN0IGVsID0gZG9tTGlzdGVuZXJbMF0sXG4gICAgICBldmVudE5hbWUgPSBkb21MaXN0ZW5lclsxXSxcbiAgICAgIGhhbmRsZXIgPSBkb21MaXN0ZW5lclsyXSxcbiAgICAgIHVzZUNhcHR1cmUgPSBkb21MaXN0ZW5lclszXTtcblxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblxuICAgIHRoaXMuZG9tTGlzdGVuZXJzW2RvbUxpc3RlbmVySW5kZXhdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY2xlYXJET01MaXN0ZW5lcnMoZWwpIHtcbiAgICB0aGlzLmRvbUxpc3RlbmVycyA9IHRoaXMuZG9tTGlzdGVuZXJzIHx8IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmRvbUxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGRvbUxpc3RlbmVyID0gdGhpcy5kb21MaXN0ZW5lcnNbaV07XG4gICAgICBpZiAoZG9tTGlzdGVuZXIpIHtcbiAgICAgICAgLy8gYXJyYXkgaXMgc3BhcnNlIVxuICAgICAgICBpZiAoIWVsIHx8IGRvbUxpc3RlbmVyWzBdID09PSBlbCkge1xuICAgICAgICAgIHRoaXMuc3RvcERPTUxpc3RlbmluZyhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZFRpbWVyKG5hbWUsIGNhbGxiYWNrLCB0aW1lKSB7XG4gICAgdGhpcy50aW1lcnMgPSB0aGlzLnRpbWVycyB8fCB7fTtcblxuICAgIHRoaXMudGltZXJzW25hbWVdID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW25hbWVdO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSxcbiAgICAgIHRpbWVcbiAgICApO1xuICB9XG5cbiAgZ2V0VGltZXIobmFtZSkge1xuICAgIGlmICghdGhpcy50aW1lcnMpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnRpbWVyc1tuYW1lXTtcbiAgfVxuXG4gIGNsZWFyVGltZXIobmFtZSkge1xuICAgIGlmICghdGhpcy50aW1lcnMpIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbbmFtZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tuYW1lXTtcbiAgfVxuXG4gIC8vIG5hbWUgZXhhbXBsZXM6ICdmb28uYmFyLionLCAnZm9vLiouc2FtcGxlJywgJyonXG4gIGNsZWFyVGltZXJzKG5hbWUgPSBcIipcIikge1xuICAgIGlmICghdGhpcy50aW1lcnMpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXR0ZXJuID0gXCJeXCIgKyBuYW1lLnNwbGl0KFwiKlwiKS5tYXAoZXNjYXBlUmVnRXhwKS5qb2luKFwiLipcIikgKyBcIiRcIjtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybik7XG5cbiAgICBmb3IgKGNvbnN0IGFOYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMudGltZXJzKSkge1xuICAgICAgaWYgKHJlZ2V4LnRlc3QoYU5hbWUpKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcihhTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsRWxlbWVudEludG9WaWV3KGVsLCBzdGVwLCBtYXJrZXJCb3JkZXIpIHtcbiAgICBpZiAoc3RlcC50eXBlID09PSBcIlJFQURcIikgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHJldHVybiBzY3JvbGxFbGVtZW50SW50b1ZpZXcoXG4gICAgICBlbCxcbiAgICAgIG1hcmtlckJvcmRlclxuICAgICkudGhlbigoKSA9PiB0aGlzLnNjcm9sbFdpbmRvd0ludG9WaWV3KGVsKSk7XG4gIH1cblxuICBzY3JvbGxXaW5kb3dJbnRvVmlldyhlbCkge1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBjb25zdCBzZXJpYWxpemFibGVCb3VuZHMgPSBnZXRCb3VuZHMoZWwpO1xuICAgIGZyYW1lTWVzc2FnZXMuc2VuZChcbiAgICAgIGZyYW1lTWVzc2FnZXMuVE9QLFxuICAgICAgXCJDb250ZW50UGxheWVyOnNjcm9sbFdpbmRvd0ludG9WaWV3XCIsXG4gICAgICBzZXJpYWxpemFibGVCb3VuZHNcbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL0NvbnRlbnRQbGF5ZXJGcmFtZU5vZGUuanMiLCIvLyBUaGUgcGFydCBvZiB0aGUgcGxheWVyIHRoYXQgcnVucyBhcyBhIGNvbnRlbnQgc2NyaXB0LiBUaGUgbWFpbiBwYXJ0XG4vLyBvZiB0aGUgcGxheWVyIGlzIHdpdGhpbiB0aGUgcGFuZWwgc2NyaXB0IGN1cnJlbnRseS5cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiYmFzZS9jb21tb24vQ29tcG9uZW50XCI7XG5pbXBvcnQge1xuICBkcmF3TWFya2VyLFxuICBoaWRlTWFya2VyLFxuICBTRUxFQ1RPUl9JRCBhcyBNQVJLRVJfU0VMRUNUT1JfSURcbn0gZnJvbSBcIi4vZHJhd01hcmtlclwiO1xuaW1wb3J0IGNvbXBhY3QgZnJvbSBcImxvZGFzaC9jb21wYWN0XCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcImxvZGFzaC9kZWJvdW5jZVwiO1xuaW1wb3J0IGV2ZXJ5IGZyb20gXCJsb2Rhc2gvZXZlcnlcIjtcbmltcG9ydCBmaW5kIGZyb20gXCJsb2Rhc2gvZmluZFwiO1xuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoL2dldFwiO1xuaW1wb3J0IGhhcyBmcm9tIFwibG9kYXNoL2hhc1wiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsXCI7XG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gvbWFwXCI7XG5pbXBvcnQgbWF4IGZyb20gXCJsb2Rhc2gvbWF4XCI7XG5pbXBvcnQgc29tZSBmcm9tIFwibG9kYXNoL3NvbWVcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwibG9kYXNoL3Rocm90dGxlXCI7XG5pbXBvcnQgdmFsdWVzIGZyb20gXCJsb2Rhc2gvdmFsdWVzXCI7XG5pbXBvcnQgaW50ZXJzZWN0aW9uIGZyb20gXCJsb2Rhc2gvaW50ZXJzZWN0aW9uXCI7XG5pbXBvcnQgKiBhcyBoYW5kbGVycyBmcm9tIFwiLi9oYW5kbGVycy9pbmRleFwiO1xuaW1wb3J0IHNjcm9sbEVsZW1lbnRJbnRvVmlldyBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWxzL3Njcm9sbEVsZW1lbnRJbnRvVmlld1wiO1xuaW1wb3J0IGdldEJvdW5kcyBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWxzL2dldEJvdW5kc1wiO1xuaW1wb3J0IHtcbiAgcGFnZWJvdW5kczJzY3JlZW4sXG4gIHNjcmVlbmJvdW5kczJ0YWJcbn0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9jb29yZGluYXRlc1wiO1xuaW1wb3J0IGNyZWF0ZUxvY2F0b3JUZXN0IGZyb20gXCIuL2NyZWF0ZUxvY2F0b3JUZXN0XCI7XG5pbXBvcnQgZ2V0RWxlbWVudFZpc3VhbEJvdW5kcyBmcm9tIFwiLi4vZ2V0RWxlbWVudFZpc3VhbEJvdW5kc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbE9mZnNldCBmcm9tIFwiLi4vZ2V0V2luZG93U2Nyb2xsT2Zmc2V0XCI7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2VcIjtcbmltcG9ydCBpc01vYmlsZUJyb3dzZXJzIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9pc01vYmlsZUJyb3dzZXJzXCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uLy4uL2NvbW1vbi9zZXR0aW5nc1wiO1xuaW1wb3J0ICogYXMgZnJhbWVNZXNzYWdlcyBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvZnJhbWVNZXNzYWdlc1wiO1xuaW1wb3J0IHsgYWRkUmVhdHRhY2hNZXNzYWdlTGlzdGVuZXIgfSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvd2luZG93RXZlbnRzXCI7XG5pbXBvcnQgeyBzYWZlU2V0SW50ZXJ2YWwgfSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvdGltZXJzXCI7XG5pbXBvcnQgeyByZWRpcmVjdElmTmVlZGVkIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL3BsYXllclwiO1xuaW1wb3J0IGlzUGFnZUxvZ2dlZEluLCB7XG4gIGdldFBhZ2VMb2dnZWRJblR5cGVcbn0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2lzUGFnZUxvZ2dlZEluXCI7XG5pbXBvcnQgaXNTdGVwTG9nZ2VkSW4sIHtcbiAgZ2V0U3RlcExvZ2dlZEluVHlwZVxufSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvaXNTdGVwTG9nZ2VkSW5cIjtcbmltcG9ydCB7IGZpbmROYXZBY3RpdmVBbmNob3IgfSBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvYWN0aXZlTmF2XCI7XG5pbXBvcnQgZnV6enlNYXRjaFVybCBmcm9tIFwiYmFzZS9jb21tb24vdXRpbHMvZnV6enlNYXRjaFVybFwiO1xuaW1wb3J0IGdldFBhcmVudFBvcHVwIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9nZXRQYXJlbnRQb3B1cFwiO1xuaW1wb3J0IGFkanVzdFBhbmVsUG9zaXRpb24gZnJvbSBcIi4vYWRqdXN0UGFuZWxQb3NpdGlvblwiO1xuaW1wb3J0IHNjcm9sbFdpbmRvd0ludG9WaWV3IGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9TY3JvbGxXaW5kb3dJbnRvVmlld1wiO1xuaW1wb3J0IGxvY2F0b3JTZWFyY2hlciBmcm9tIFwiLi9Mb2NhdG9yU2VhcmNoZXJcIjtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIm5vZGUtZXZlbnQtZW1pdHRlclwiO1xuXG5pbXBvcnQgeyBnZXRGaWxlTG9nZ2VyIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2xvZ2dlclwiO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBzZXR0aW5ncy5nZXQoXCJkZWZhdWx0Q29sb3JzXCIpO1xuXG5mdW5jdGlvbiBpc0lvcmFkRWRpdG9yVXJsKHVybCkge1xuICByZXR1cm4gLyhefFxcLilpb3JhZFxcLihjb218ZGV2KVxcL2VkaXRvcihcXD98XFwvKS8udGVzdCh1cmwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50UGxheWVyVG9wRnJhbWUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmN1cnJlbnRMb2NhdG9yRGF0YSA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmV1bmxvYWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZW50ZXJTdGVwID0gdGhyb3R0bGUodGhpcy5lbnRlclN0ZXAuYmluZCh0aGlzKSwgMTAwMCk7XG5cbiAgICAvLyB0aGUgXCJub3QgZm91bmRcIiBpcyBkZWxheWVkIHRvIGdpdmUgdGhlIGV4dGVuc2lvbiBzb21lIGV4dHJhIHNlY29uZHNcbiAgICAvLyBiZWZvcmUgc3dpdGNoaW5nIHRoZSBwYW5lbCB2aWV3XG4gICAgLy8gdGhlIFwiZm91bmRcIiBpc24ndCBkZWxheWVkIHNpbmNlIHdlIHdhbnQgdG8gcGxheSBhdWRpbyBldGMuIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICB0aGlzLl9ub3RpZnlOb3RGb3VuZCA9IHRocm90dGxlKHRoaXMuX25vdGlmeU5vdEZvdW5kLmJpbmQodGhpcyksIDIwMDAsIHtcbiAgICAgIGxlYWRpbmc6IGZhbHNlLFxuICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX2FkanVzdFBhbmVsUG9zaXRpb24gPSBkZWJvdW5jZShhZGp1c3RQYW5lbFBvc2l0aW9uLCA1MDAsIHtcbiAgICAgIGxlYWRpbmc6IGZhbHNlLFxuICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXJ0KC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdGFydCguLi5hcmdzKTtcblxuICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U3RlcCB9ID0gdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLnN0YXRlO1xuXG4gICAgZnJhbWVNZXNzYWdlcy5vbk1lc3NhZ2UoXCJyZWdpc3RlckNvbnRlbnRQbGF5ZXJcIiwgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLmVudGVyU3RlcCgpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyB0YWIgaXMgYWN0aXZlIGFnYWluXG4gICAgICAgIHRoaXMuZW50ZXJTdGVwKCk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgLy8gRXZlcnkgY291cGxlIG9mIHNlY29uZHMgaWYgd2UgaGF2ZW4ndCB5ZXQgZm91bmRcbiAgICAvLyBhIGdvb2QgY29tcG9uZW50IHRvIGhpZ2hsaWdodCBsZXRzIHRyeSBhZ2FpblxuICAgIHNhZmVTZXRJbnRlcnZhbChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5lbnRlclN0ZXAoKTtcbiAgICAgIH0sXG4gICAgICAyMDAwXG4gICAgKTtcblxuICAgIC8vIEV2ZXJ5IGNvdXBsZSBvZiBzZWNvbmRzIHdlIGNoZWNrIGxvZ2luIHN0YXRlXG4gICAgc2FmZVNldEludGVydmFsKCgpID0+IHRoaXMuY2hlY2tMb2dpbigpLCAyMDAwKTtcblxuICAgIGZyYW1lTWVzc2FnZXMub25NZXNzYWdlKFwiTG9jYXRvclNlYXJjaGVyTm9kZTpmcmFtZUNoYW5nZVwiLCBtZXNzYWdlID0+IHtcbiAgICAgIHRoaXMuZW50ZXJTdGVwKHsgZnJhbWVJZDogbWVzc2FnZS5mcmFtZUlkIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogRGlzYWJsZSB3aGVuIG5vdCBpbiBRQSBtb2RlXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIGFsdC1zaGlmdC10XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50U3RlcCAmJiBldmVudC5rZXlDb2RlID09PSA4NCAmJiBldmVudC5hbHRLZXkgJiYgZXZlbnQuc2hpZnRLZXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY3JlYXRlTG9jYXRvclRlc3QoY3VycmVudFN0ZXAsIHRoaXMuZXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlIG1lc3NhZ2UgbGlzdGVuZXIgaGFkIHRvIHJlYXR0YWNoIHdlIG1heSBoYXZlIGxvc3QgbWVzc2FnZSwgbGV0J3NcbiAgICAvLyByZWdpc3RlciBhZ2FpblxuICAgIGFkZFJlYXR0YWNoTWVzc2FnZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJlLXJlZ2lzdGVyIGFmdGVyIHdpbmRvdyBtZXNzYWdlIGV2ZW50IHJlYXR0YWNoZWRcIik7XG4gICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgfSk7XG5cbiAgICBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZShcbiAgICAgIFwiQ29udGVudFBsYXllcjpjb21wbGV0ZVwiLFxuICAgICAgdGhpcy5fY29tcGxldGVkLmJpbmQodGhpcylcbiAgICApO1xuICAgIGZyYW1lTWVzc2FnZXMub25NZXNzYWdlKFxuICAgICAgXCJDb250ZW50UGxheWVyOm5vdENvbXBsZXRlZFwiLFxuICAgICAgdGhpcy5fbm90Q29tcGxldGVkLmJpbmQodGhpcylcbiAgICApO1xuXG4gICAgZnJhbWVNZXNzYWdlcy5vbk1lc3NhZ2UoXCJDb250ZW50UGxheWVyOmdvQmFja1wiLCB0aGlzLl9nb0JhY2suYmluZCh0aGlzKSk7XG5cbiAgICBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZShcbiAgICAgIFwiQ29udGVudFBsYXllcjpzY3JvbGxXaW5kb3dJbnRvVmlld1wiLFxuICAgICAgdGhpcy5fc2Nyb2xsV2luZG93SW50b1ZpZXcuYmluZCh0aGlzKVxuICAgICk7XG5cbiAgICAvLyBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZShcIkNvbnRlbnRQbGF5ZXI6c2V0TWFya2VyRW5hYmxlZFwiLCBtZXNzYWdlID0+IHtcbiAgICAvLyAgIGlmIChtZXNzYWdlLnBheWxvYWQuZW5hYmxlZCkge1xuICAgIC8vICAgICB0aGlzLmVuYWJsZU1hcmtlcihtZXNzYWdlLnBheWxvYWQuaW5kZXgpO1xuICAgIC8vICAgfSBlbHNlIHtcbiAgICAvLyAgICAgdGhpcy5kaXNhYmxlTWFya2VyKG1lc3NhZ2UucGF5bG9hZC5pbmRleCk7XG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG5cbiAgICBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZShcIkNvbnRlbnRQbGF5ZXI6bW91c2Vkb3duXCIsICgpID0+IHtcbiAgICAgIC8vIFNlZSAjMTAyOFxuICAgICAgdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLmRpc3BhdGNoKCdza2lwV2FpdExvY2F0aW9uSHJlZicpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5iZWZvcmV1bmxvYWQgPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgY2hlY2tMb2dpbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydGVkOiB0dXRvcmlhbFN0YXJ0ZWQsXG4gICAgICBjdXJyZW50U3RlcFxuICAgIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG4gICAgaWYgKHR1dG9yaWFsU3RhcnRlZCAmJiBjdXJyZW50U3RlcCkge1xuICAgICAgaWYgKGlzU3RlcExvZ2dlZEluKGN1cnJlbnRTdGVwKSkge1xuICAgICAgICBjb25zdCBuZWVkc0xvZ2luID0gaXNQYWdlTG9nZ2VkSW4oKSA9PT0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9nZ2xlTmVlZHNMb2dpbihuZWVkc0xvZ2luKTtcblxuICAgICAgICAvLyBpZiAoY3VycmVudFN0ZXAuaW5kZXggPT09IDApIHtcbiAgICAgICAgLy8gICBjb25zdCBzdGVwTG9nZ2VkSW5UeXBlID0gZ2V0U3RlcExvZ2dlZEluVHlwZShjdXJyZW50U3RlcCk7XG4gICAgICAgIC8vICAgaWYgKHN0ZXBMb2dnZWRJblR5cGUgPT09ICdhZG1pbicpIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IG5lZWRzQWRtaW5BY2Nlc3MgPSBnZXRQYWdlTG9nZ2VkSW5UeXBlKCkgIT09ICdhZG1pbic7XG4gICAgICAgIC8vICAgICB0aGlzLnRvZ2dsZU5lZWRzQWRtaW5BY2Nlc3MobmVlZHNBZG1pbkFjY2Vzcyk7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlTmVlZHNMb2dpbih2YWx1ZSkge1xuICAgIHRoaXMubmVlZHNMb2dpbiA9IHZhbHVlO1xuICAgIHRoaXMuZmx1eC5wYW5lbENvbnRleHQoKS5kaXNwYXRjaChcInN0ZXBOZWVkc0xvZ2luXCIsIHRoaXMubmVlZHNMb2dpbik7XG4gIH1cblxuICB0b2dnbGVOZWVkc0FkbWluQWNjZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5uZWVkc0FkbWluQWNjZXNzID0gdmFsdWU7XG4gICAgdGhpcy5mbHV4XG4gICAgICAucGFuZWxDb250ZXh0KClcbiAgICAgIC5kaXNwYXRjaChcInN0ZXBOZWVkc0FkbWluQWNjZXNzXCIsIHRoaXMubmVlZHNBZG1pbkFjY2Vzcyk7XG4gIH1cblxuICAvLyBJZiBjdXJyZW50U3RlcCBpcyBudWxsIGl0J2xsIGp1c3QgcmVtb3ZlIGFueSBjdXJyZW50IG1hcmtlclxuICB1cGRhdGVGb3JQYW5lbChvbGRTdGF0ZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmV2aW91c1N0ZXAgPSBvbGRTdGF0ZS5jdXJyZW50U3RlcDtcbiAgICBjb25zdCBjdXJyZW50U3RlcCA9IHN0YXRlLmN1cnJlbnRTdGVwO1xuICAgIGlmIChcbiAgICAgIHByZXZpb3VzU3RlcCAmJlxuICAgICAgY3VycmVudFN0ZXAgJiZcbiAgICAgIGhhcyhwcmV2aW91c1N0ZXAsIFwid2luZG93LmlkXCIpICYmXG4gICAgICBoYXMoY3VycmVudFN0ZXAsIFwid2luZG93LmlkXCIpICYmXG4gICAgICBnZXQocHJldmlvdXNTdGVwLCBcIndpbmRvdy5pZFwiKSAhPT0gZ2V0KGN1cnJlbnRTdGVwLCBcIndpbmRvdy5pZFwiKVxuICAgICkge1xuICAgICAgLy8gYXV0byByZWRpcmVjdCBvbiB0YWIgc3dpdGNoXG4gICAgICAvLyBOb3RlOiB0aGlzIHNob3VsZG4ndCBiZSBleGVjdXRlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAgcmVkaXJlY3RJZk5lZWRlZChjdXJyZW50U3RlcC53aW5kb3cudXJsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgY3VycmVudFN0ZXAgJiYgcHJldmlvdXNTdGVwICYmIGN1cnJlbnRTdGVwLm51bWJlciAhPT0gcHJldmlvdXNTdGVwLm51bWJlclxuICAgICkge1xuICAgICAgdGhpcy5fbm90aWZ5Tm90Rm91bmQuY2FuY2VsKCk7XG4gICAgICB0aGlzLndhaXRpbmdOZXh0U3RlcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZmx1eC51cGRhdGVyKG9sZFN0YXRlLCBzdGF0ZSwgW1xuICAgICAgW1wic3RhcnRlZFwiLCB0aGlzLnN3aXRjaFR1dG9yaWFsU3RhcnRlZC5iaW5kKHRoaXMpXVxuICAgIF0pO1xuXG4gICAgdGhpcy5lbnRlclN0ZXAoKTtcbiAgfVxuXG4gIHN3aXRjaFR1dG9yaWFsU3RhcnRlZCh0dXRvcmlhbFN0YXJ0ZWQpIHtcbiAgICBpZiAoIXR1dG9yaWFsU3RhcnRlZCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrTG9naW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2hpZGVNYXJrZXJzKCk7XG4gICAgdGhpcy50b2dnbGVOZWVkc0xvZ2luKGZhbHNlKTtcbiAgICB0aGlzLnRvZ2dsZU5lZWRzQWRtaW5BY2Nlc3MoZmFsc2UpO1xuICAgIHRoaXMuY3VycmVudExvY2F0b3JEYXRhID0gbnVsbDtcbiAgICB0aGlzLndhaXRpbmdOZXh0U3RlcCA9IGZhbHNlO1xuICB9XG5cbiAgZW50ZXJTdGVwKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0ZWQ6IHR1dG9yaWFsU3RhcnRlZCxcbiAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgd2FpdGluZ0xvY2F0aW9uSHJlZkNoYW5nZVxuICAgIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG5cbiAgICAvLyBOT1RFOiBoZXJlIGRvIG9ubHkgdGhlIGNoZWNrcyB0aGF0IGFwcGx5IHRvIEFMTCB0aGUgZnJhbWVzLFxuICAgIC8vIHNwZWNpZmljIHBlci1mcmFtZSBjaGVja3Mgc2hvdWxkIGJlIGRvbmUgb24gTG9jYXRvclNlYXJjaGVyLmpzXG4gICAgaWYgKCF0dXRvcmlhbFN0YXJ0ZWQpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcImVudGVyU3RlcDogdHV0b3JpYWwgbm90IHN0YXJ0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudFN0ZXApIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcImVudGVyU3RlcDogbm8gY3VycmVudCBzdGVwXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFN0ZXAudHlwZSA9PT0gJ1JFQUQnKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ2VudGVyU3RlcDogbm8gbmVlZCB0byBsb2NhdGUgUkVBRCBzdGVwcycpO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJlbnRlclN0ZXA6IHRhYiBpcyBpbmFjdGl2ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVlZHNMb2dpbikge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiZW50ZXJTdGVwOiBuZWVkcyBsb2dpblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVlZHNBZG1pbkFjY2Vzcykge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiZW50ZXJTdGVwOiBuZWVkcyBhZG1pbiBhY2Nlc3NcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGF5RW50ZXJTdGVwVGltZXIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcImVudGVyU3RlcDogZGVsYXllZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJlbnRlclN0ZXA6IHBhZ2UgaXMgbG9hZGluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmVmb3JldW5sb2FkKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJlbnRlclN0ZXA6IHBhZ2UgaXMgdW5sb2FkaW5nXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2FpdGluZ0xvY2F0aW9uSHJlZkNoYW5nZSkge1xuICAgICAgY29uc29sZS5sb2coXCJlbnRlclN0ZXA6IHdhaXQgZm9yIGxvY2F0aW9uIGhyZWYgY2hhbmdlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlKHtcbiAgICAgIHN0ZXA6IGN1cnJlbnRTdGVwLFxuICAgICAgb25Db21wbGV0ZWQ6IHRoaXMuX2NvbXBsZXRlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Ob3RDb21wbGV0ZWQ6IHRoaXMuX25vdENvbXBsZXRlZC5iaW5kKHRoaXMpLFxuICAgICAgZm9yY2U6IG9wdGlvbnMuZm9yY2VIYW5kbGUgPT09IHRydWUsXG4gICAgICBmcmFtZUlkOiBvcHRpb25zLmZyYW1lSWQgLy8gb3B0aW9uYWwsIHJlc3RyaWN0cyB0aGUgc2VhcmNoIHRvIG9uZSBmcmFtZSAoYW5kIHRvIGl0cyBzdWIgZnJhbWVzKVxuICAgIH0pO1xuICB9XG5cbiAgZHJhd01hcmtlcnMoc3RlcCwgbG9jYXRvckRhdGEsIGVuYWJsZU1hcmtlckluZGV4ID0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0ZWQ6IHR1dG9yaWFsU3RhcnRlZCxcbiAgICAgIG1hcmtlckNvbG9yc1xuICAgIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG5cbiAgICBjb25zdCBpc01vYmlsZSA9IGlzTW9iaWxlQnJvd3NlcnMoKTtcbiAgICBpZiAobG9jYXRvckRhdGEgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZW1iZWQgPSBwcm9jZXNzLmVudi5CUk9XU0VSID09PSBcImVtYmVkXCI7XG4gICAgICBjb25zdCBtYXJrZXJDb2xvciA9IGVtYmVkXG4gICAgICAgID8gdGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zLmNvbG9ycyAmJlxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zLmNvbG9ycy5oaWdobGlnaHQgfHxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcnMuaGlnaGxpZ2h0XG4gICAgICAgIDogLy8gKG1hcmtlckNvbG9ycyAmJiBtYXJrZXJDb2xvcnNbc3RlcC50eXBlXSkgfHxcbiAgICAgICAgICB0aGlzLmV4dGVuc2lvbi5wYW5lbENvbnRyb2xsZXIgJiZcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uLnBhbmVsQ29udHJvbGxlci5jdXN0b21Db2xvcnMgJiZcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9uLnBhbmVsQ29udHJvbGxlci5jdXN0b21Db2xvcnMuaGlnaGxpZ2h0IHx8XG4gICAgICAgICAgICBkZWZhdWx0Q29sb3JzLmhpZ2hsaWdodDtcblxuICAgICAgY29uc3QgZWxlbWVudEJvdW5kcyA9IGxvY2F0b3JEYXRhLmVsZW1lbnRCb3VuZHNcbiAgICAgICAgLmZpbHRlcihsID0+IHtcbiAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGVsZW1lbnRzIG5vdCB2aXNpYmxlIG9uIHRoZSB2aWV3cG9ydFxuICAgICAgICAgIHJldHVybiBsLnZpc2libGU7XG4gICAgICAgIH0pXG4gICAgICAgIC5zb3J0KChsMSwgbDIpID0+IHtcbiAgICAgICAgICAvLyBTb3J0IGVsZW1lbnRzIGluIHktYXhpcyBhbmQgeC1heGlzIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIHJldHVybiBsMS55IC0gbDIueSB8fCBsMS54IC0gbDIueDtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE8gRW5hYmxlIG1hcmtlciBpcyBubyBsb25nZXIgcHJlc2VudFxuICAgICAgZHJhd01hcmtlcihcbiAgICAgICAgZWxlbWVudEJvdW5kcyxcbiAgICAgICAgc3RlcC50eXBlLFxuICAgICAgICBtYXJrZXJDb2xvcixcbiAgICAgICAgZW5hYmxlTWFya2VySW5kZXgsXG4gICAgICAgIHN0ZXAubnVtYmVyLFxuICAgICAgICBpc01vYmlsZSxcbiAgICAgICAgeyBkYmxDbGljazogc3RlcC5ldmVudC5kYmxjbGljayB9XG4gICAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBwcmV2ZW50IGp1bXBpbmcgZWZmZWN0IGJ5IG9ubHkgbW92aW5nIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBtYXJrZXJzXG4gICAgICAgIGlmIChlbGVtZW50Qm91bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLl9hZGp1c3RQYW5lbFBvc2l0aW9uKHRoaXMuZXh0ZW5zaW9uLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3QgaGlkZSB0aGUgbWFya2VycyAoZS5nLiBuZWVkZWQgaWYgdHV0b3JpYWwgZW5kZWQpXG4gICAgICBkcmF3TWFya2VyKG51bGwpLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIHBhbmVsIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIGlmIHRoZSB0dXRvcmlhbCBlbmRlZCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlJ2xsIGhhdmUgdWdseSBqdW1waW5nIGVmZmVjdHMgKCM3NTApXG4gICAgICAgIGlmICghdHV0b3JpYWxTdGFydGVkKSB7XG4gICAgICAgICAgdGhpcy5fYWRqdXN0UGFuZWxQb3NpdGlvbih0aGlzLmV4dGVuc2lvbiwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRBbmRIaWdobGlnaHQoc3RlcCwgZnJhbWVJZCkge1xuICAgIGNvbnN0IHsgc3RhcnRlZDogdHV0b3JpYWxTdGFydGVkIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG5cbiAgICBpZiAoc3RlcC5jb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IG11bHRpcGxlTWF0Y2hlcyA9IEJvb2xlYW4oXG4gICAgICAgIHN0ZXAgJiYgc3RlcC5ldmVudCAmJiBzdGVwLmV2ZW50LmxpdmVfbXVsdGlwbGVNYXRjaGVzXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwcm9taXNlID0gc3RlcC50eXBlID09PSBcIkRST1BcIiAmJiBtdWx0aXBsZU1hdGNoZXNcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodGhpcy5jdXJyZW50TG9jYXRvckRhdGEpXG4gICAgICAgIDogbG9jYXRvclNlYXJjaGVyLnNlYXJjaChzdGVwLmNvbXBvbmVudC5sb2NhdG9yLCB7XG4gICAgICAgICAgICBtdWx0aXBsZU1hdGNoZXMsXG4gICAgICAgICAgICBmcmFtZUlkXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihsb2NhdG9yRGF0YSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLnN0YXRlLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAvLyB0b28gbGF0ZSAocHJldmVudCBzaG93aW5nIG9mIG1hcmtlcnMsICM4MzkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGUuY3VycmVudFN0ZXAgJiZcbiAgICAgICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGUuY3VycmVudFN0ZXAubnVtYmVyICE9PSBzdGVwLm51bWJlclxuICAgICAgICApIHtcbiAgICAgICAgICAvLyB0b28gbGF0ZSAocHJldmVudCBzaG93aW5nIG9mIG1hcmtlcnMsICM5MzcpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndhaXRpbmdOZXh0U3RlcCkge1xuICAgICAgICAgIC8vIHRvbyBsYXRlIChwcmV2ZW50IHNob3dpbmcgb2YgbWFya2VycywgIzEwNjApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5kTGF0ZXJTdGVwSWZOZWVkZWQobG9jYXRvckRhdGEsIHN0ZXApO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdGhlIHN0ZXAgaW5kZXggdG8gZG8gcHJvcGVyIGVxdWFsaXR5IGNoZWNrc1xuICAgICAgICBpZiAobG9jYXRvckRhdGEpIHtcbiAgICAgICAgICBsb2NhdG9yRGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmxvY2F0b3JEYXRhLFxuICAgICAgICAgICAgc3RlcEluZGV4OiBzdGVwLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFcXVhbChsb2NhdG9yRGF0YSwgdGhpcy5jdXJyZW50TG9jYXRvckRhdGEpKSB7XG4gICAgICAgICAgaWYgKCFsb2NhdG9yRGF0YSAmJiAhdGhpcy5jdXJyZW50TG9jYXRvckRhdGEgJiYgdHV0b3JpYWxTdGFydGVkKSB7XG4gICAgICAgICAgICAvLyBuZWVkZWQgaW4gY2FzZSB0aGUgZmlyc3Qgc3RlcCBpc24ndCBmb3VuZCAoIzY5NClcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeUZvdW5kU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugc2VuZCB0byBhbGwgKGFuZCBub3QganVzdCB0aGUgZnJhbWUgY29udGFpbmluZyB0aGUgZWxlbWVudClcbiAgICAgICAgLy8gYmVjYXVzZSBmcmFtZXMgd2l0aG91dCB0aGUgZWxlbWVudCBtYXkgbmVlZCB0byBoaWRlIHN0dWZmLlxuICAgICAgICBmcmFtZU1lc3NhZ2VzLnNlbmQoZnJhbWVNZXNzYWdlcy5BTEwsIFwiQ29udGVudFBsYXllcjpob29rRWxlbWVudHNcIiwge1xuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgbG9jYXRvckRhdGFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRvckRhdGEgPSBsb2NhdG9yRGF0YTtcbiAgICAgICAgdGhpcy5kcmF3TWFya2VycyhzdGVwLCBsb2NhdG9yRGF0YSk7XG5cbiAgICAgICAgaWYgKHR1dG9yaWFsU3RhcnRlZCkge1xuICAgICAgICAgIHRoaXMuX25vdGlmeUZvdW5kU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd01hcmtlcnMoc3RlcCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gbG9jYXRvciBkYXRhIGhhc24ndCBiZWVuIGZvdW5kIGZvciB0aGUgMXN0IHN0ZXAuIExvb2tzIHRocm91Z2hcbiAgLy8gbGF0ZXIgc3RlcHMgYW5kIGlmIHdlIGZpbmQgYSB1cmwgKGZ1enp5KSBtYXRjaCBhbmQgY2FuIGZpbmQgdGhlIGxvY2F0b3JcbiAgLy8gdGhlbiB3ZSBvZmZlciB0aGUgdXNlciBhbiBvcHRpb24gdG8gc2tpcCBhaGVhZFxuICBmaW5kTGF0ZXJTdGVwKG1hdGNoRm4sIGxvb2thaGVhZCA9IDMpIHtcbiAgICBjb25zdCB7IG90aGVyU3RlcHMsIGlnbm9yZUxhdGVyU3RlcCB9ID0gdGhpcy5mbHV4LnBhbmVsQ29udGV4dCgpLnN0YXRlO1xuICAgIGlmICghb3RoZXJTdGVwcyB8fCBpZ25vcmVMYXRlclN0ZXAgfHwgdGhpcy5fZmluZGluZ0xhdGVyU3RlcClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIHRoaXMuX2ZpbmRpbmdMYXRlclN0ZXAgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBMb29rIGF0IHRoZSBuZXh0IHN0ZXBzIGdpdmVuIHRoYXQgdGhlIGZpcnN0IHN0ZXAgZGlkbid0IG1hdGNoXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlTWF0Y2hlcyA9IG90aGVyU3RlcHNcbiAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAuZmlsdGVyKG1hdGNoRm4pXG4gICAgICAgICAgLnNsaWNlKDAsIGxvb2thaGVhZCArIDEpO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChwb3NzaWJsZU1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5kaW5nTGF0ZXJTdGVwID0gZmFsc2U7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyB1cmwsIGxvY2F0b3IsIGluZGV4IH0gPSBwb3NzaWJsZU1hdGNoZXMuc2hpZnQoKTtcbiAgICAgICAgICBsb2NhdG9yU2VhcmNoZXIuc2VhcmNoKGxvY2F0b3IpLnRoZW4obG9jYXRvckRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGxvY2F0b3JEYXRhKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbmRpbmdMYXRlclN0ZXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnRk9VTkQgTUFUQ0hJTkcgU1RFUCcsIHVybCwgbG9jYXRvckRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgICAgdGhpcy5fZm91bmRMYXRlclN0ZXAoaW5kZXgpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTGV0cyBsb29rIGF0IHRoZSBuZXh0IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMuX2ZpbmRpbmdMYXRlclN0ZXAgPSBmYWxzZTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmaW5kTGF0ZXJTdGVwSWZOZWVkZWQobG9jYXRvckRhdGEsIHN0ZXApIHtcbiAgICBpZiAoc3RlcC5pbmRleCAhPT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gSWYgd2UgYXJlIGluc2lkZSB0aGUgaW9yYWQgZWRpdG9yLFxuICAgIC8vIFRIRU4gc2VlIGlmIHdlIGNhbiBqdW1wIHJpZ2h0IHRvIHRoZSBmaXJzdCBlZGl0b3Igc3RlcCB0aGF0IG1hdGNoZXMgKGlmIGFueSlcbiAgICBpZiAoaXNJb3JhZEVkaXRvclVybCh3aW5kb3cubG9jYXRpb24uaHJlZikpIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kTGF0ZXJTdGVwKCh7IHVybCB9KSA9PlxuICAgICAgICBpc0lvcmFkRWRpdG9yVXJsKHVybCkpO1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHR1dG9yaWFsIHdhcyBjYXB0dXJlZCB3aGlsZSBsb2dnZWQgb3V0LCBidXQgd2UgYXJlIGFscmVhZHkgbG9nZ2VkIGluLFxuICAgIC8vIHRoZW4gc2VlIGlmIHdlIGNhbiBqdW1wIGFmdGVyIHRoZSBsb2dpbiB0b29rIHBsYWNlIChpZiBpdCBldmVyIGRpZClcbiAgICAvLyAoc3RyaWN0ID09PSBmYWxzZSBjaGVjayBzaW5jZSBvbGQgdHV0b3JpYWxzIG1pZ2h0IG5vdCBoYXZlIHRoaXMgcHJvcGVydHkpXG4gICAgY29uc3Qgc3RlcExvZ2dlZE91dCA9IGlzU3RlcExvZ2dlZEluKHN0ZXApID09PSBmYWxzZTtcbiAgICBjb25zdCBsb2dnZWRJbiA9IGlzUGFnZUxvZ2dlZEluKCk7XG4gICAgaWYgKHN0ZXBMb2dnZWRPdXQgJiYgbG9nZ2VkSW4pIHtcbiAgICAgIC8vIHNraXAgdG8gdGhlIGZpcnN0IGxvZ2dlZCBpbiBzdGVwIChpZiBhbnkpXG4gICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZExhdGVyU3RlcCgoeyBsb2dnZWRJbiB9KSA9PiBsb2dnZWRJbik7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc3RlcCBpcyBhYm91dCBjbGlja2luZyBvbiB0aGUgY3VycmVudCBuYXYgaXRlbVxuICAgIC8vIChyZXN0cmljdGVkIHRvIHRoZSBjdXJyZW50IGZyYW1lIGZvciB0ZWNoaW5pY2FsIGxpbWl0YXRpb25zKSxcbiAgICAvLyB0aGVuIGF1dG8gYWR2YW5jZSB0byB0aGUgbmV4dCBzdGVwXG4gICAgaWYgKHN0ZXAudHlwZSA9PT0gXCJMRUZUX0NMSUNLXCIpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gbG9jYXRvckRhdGEgJiZcbiAgICAgICAgbG9jYXRvckRhdGEuZnJhbWVJZCA9PT0gZnJhbWVNZXNzYWdlcy5mcmFtZUlkXG4gICAgICAgID8gbG9jYXRvclNlYXJjaGVyLl9ub2RlLmxvY2F0ZWRFbHNcbiAgICAgICAgOiAvLyBIQUNLOiB3ZSBuZWVkIHRoZSBhY3R1YWwgZWxzIHJlZmVyZW5jZXMsIHRoZSBxdWVyeSBpcyBub3QgZW5vdWdoIHRvIHJlY29uc3RydWN0IHRoZW0gKGJlY2F1c2Ugb2Ygc2ltaWxhciBlbGVtZW50cywgZmlsdGVyaW5nIGJ5IHRleHQsIGV0Yy4pXG4gICAgICAgICAgW107XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZWxlbWVudHNbMF07XG4gICAgICAgIGNvbnN0IG5hdkFjdGl2ZUFuY2hvciA9IGZpbmROYXZBY3RpdmVBbmNob3IoKTtcbiAgICAgICAgaWYgKGVsID09PSBuYXZBY3RpdmVBbmNob3IpIHtcbiAgICAgICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZExhdGVyU3RlcChcbiAgICAgICAgICAgICh7IGluZGV4IH0pID0+IGluZGV4ID09PSBzdGVwLmluZGV4ICsgMVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJsIGRvZXNuJ3QgbWF0Y2ggd2hhdCB3ZSdyZSBleHBlY3RpbmcgQU5EXG4gICAgLy8gd2UgZGlkbid0IGZpbmQgdGhlIGVsZW1lbnQgd2UgZXhwZWN0ZWQgVEhFTiBzZWUgaWYgd2VcbiAgICAvLyBjYW4gZmluZCBhbm90aGVyIHN0ZXAgdGhhdCBtYXRjaGVzLlxuICAgIGlmICghbG9jYXRvckRhdGEgJiYgIWZ1enp5TWF0Y2hVcmwoc3RlcC53aW5kb3cudXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZikpIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kTGF0ZXJTdGVwKCh7IHVybCB9KSA9PlxuICAgICAgICBmdXp6eU1hdGNoVXJsKHVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpKTtcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZSh7IHN0ZXAsIHBhcmVudFN0ZXAsIG9uQ29tcGxldGVkLCBvbk5vdENvbXBsZXRlZCwgZm9yY2UsIGZyYW1lSWQgfSkge1xuICAgIHRoaXMuZmluZEFuZEhpZ2hsaWdodChzdGVwLCBmcmFtZUlkKTtcblxuICAgIC8vIFRPT0Q6IFdvdWxkIHRoaXMgYmUgYmV0dGVyIGhhbmRsZWQgYnkganVzdCBmbGF0dGVuaW5nIG91dCBpbnRvIHNlcGVyYXRlXG4gICAgLy8gVFlQSU5HIGFuZCBDTElDSyBhY3Rpb25zP1xuICAgIGNvbnN0IGlzQ29tcG9zaXRlU3RlcCA9IHN0ZXAuc3RlcHMgJiZcbiAgICAgIHN0ZXAuc3RlcHMubGVuZ3RoICE9PSAwICYmXG4gICAgICBzdGVwLnN1bW1hcnkgIT09IHRydWU7XG5cbiAgICBjb25zdCBpc1R5cGluZ0FuZENsaWNrID0gc3RlcC50eXBlID09PSBcIlRZUElOR1wiICYmXG4gICAgICBpc0NvbXBvc2l0ZVN0ZXAgJiZcbiAgICAgIHN0ZXAuc3RlcHMubGVuZ3RoID09PSAyICYmXG4gICAgICBzdGVwLnN0ZXBzWzBdLnR5cGUgPT09IFwiVFlQSU5HXCIgJiZcbiAgICAgIHN0ZXAuc3RlcHNbMV0udHlwZSA9PT0gXCJMRUZUX0NMSUNLXCI7XG5cbiAgICBpZiAoaXNUeXBpbmdBbmRDbGljaykge1xuICAgICAgdGhpcy5oYW5kbGVUeXBpbmdBbmRDbGljayhcbiAgICAgICAgc3RlcCxcbiAgICAgICAgb25Db21wbGV0ZWQsXG4gICAgICAgIG9uTm90Q29tcGxldGVkLFxuICAgICAgICBmb3JjZSxcbiAgICAgICAgZnJhbWVJZFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVUeXBpbmdBbmRDbGljayhzdGVwLCBvbkNvbXBsZXRlZCwgb25Ob3RDb21wbGV0ZWQsIGZvcmNlLCBmcmFtZUlkKSB7XG4gICAgLy8gV2FzIFRZUElOR19BTkRfQ0xJQ0sgaGFuZGxlciwgYnV0IHdhcyBvbmx5IG9uZSBpbiB1c2UgdGhhdCB1c2VkIHJlLWVudHJhbnQgaGFuZGxlIGNhbGxcbiAgICBjb25zdCB0eXBpbmdTdGVwID0gc3RlcC5zdGVwc1swXTtcbiAgICBjb25zdCBjbGlja1N0ZXAgPSBzdGVwLnN0ZXBzWzFdO1xuXG4gICAgY29uc3Qgb25UeXBpbmdDb21wbGV0ZWQgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5hZHZhbmNlKSBvbkNvbXBsZXRlZCgpO1xuICAgICAgZWxzZSBoYW5kbGVDbGljaygpO1xuICAgIH07XG5cbiAgICBjb25zdCBvblR5cGluZ05vdENvbXBsZXRlZCA9ICgpID0+IHtcbiAgICAgIC8vIG5vLW9wOlxuICAgICAgLy8gaWdub3JlIG5vdCBjb21wbGV0ZWQgZmVlZGJhY2sgZm9yIHR5cGluZyBtYXJrZXJcbiAgICAgIC8vIChzaW5jZSBpcyBub3QgY29tcGxldGVkIGFmdGVyIGVhY2gga2V5cHJlc3MgdW50aWwgdGhlIGZ1bGwgdGV4dCBoYXMgYmVlbiB0eXBlZClcbiAgICB9O1xuXG4gICAgY29uc3Qgb25DbGlja0NvbXBsZXRlZCA9ICgpID0+IHtcbiAgICAgIG9uQ29tcGxldGVkKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uQ2xpY2tOb3RDb21wbGV0ZWQgPSAoKSA9PiB7XG4gICAgICBvbk5vdENvbXBsZXRlZCgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVUeXBpbmcgPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZSh7XG4gICAgICAgIHN0ZXA6IHR5cGluZ1N0ZXAsXG4gICAgICAgIHBhcmVudFN0ZXA6IHN0ZXAsXG4gICAgICAgIG9uQ29tcGxldGVkOiBvblR5cGluZ0NvbXBsZXRlZC5iaW5kKHRoaXMpLFxuICAgICAgICBvbk5vdENvbXBsZXRlZDogb25UeXBpbmdOb3RDb21wbGV0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgZm9yY2UsXG4gICAgICAgIGZyYW1lSWRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlKHtcbiAgICAgICAgc3RlcDogY2xpY2tTdGVwLFxuICAgICAgICBwYXJlbnRTdGVwOiBzdGVwLFxuICAgICAgICBvbkNvbXBsZXRlZDogb25DbGlja0NvbXBsZXRlZC5iaW5kKHRoaXMpLFxuICAgICAgICBvbk5vdENvbXBsZXRlZDogb25DbGlja05vdENvbXBsZXRlZC5iaW5kKHRoaXMpLFxuICAgICAgICBmb3JjZSxcbiAgICAgICAgZnJhbWVJZFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGhhbmRsZVR5cGluZygpO1xuICB9XG5cbiAgcmVnaXN0ZXIoKSB7XG4gICAgZnJhbWVNZXNzYWdlcy5zZW5kKGZyYW1lTWVzc2FnZXMuVE9QLCBcInJlZ2lzdGVyQ29udGVudFBsYXllclwiKTtcbiAgfVxuXG4gIC8vIGNvbnN0IHsgY3VycmVudFN0ZXAgfSA9IHRoaXMuZmx1eC5wYW5lbENvbnRleHQoKS5zdGF0ZTtcbiAgLy8gZW5hYmxlTWFya2VyKGluZGV4KSB7XG4gIC8vICAgaWYgKGN1cnJlbnRTdGVwICYmIHRoaXMuY3VycmVudExvY2F0b3JEYXRhKSB7XG4gIC8vICAgICB0aGlzLmRyYXdNYXJrZXJzKGN1cnJlbnRTdGVwLCB0aGlzLmN1cnJlbnRMb2NhdG9yRGF0YSwgaW5kZXgpO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8vIGRpc2FibGVNYXJrZXIoaW5kZXgpIHtcbiAgLy8gICBpZiAoY3VycmVudFN0ZXAgJiYgdGhpcy5jdXJyZW50TG9jYXRvckRhdGEpIHtcbiAgLy8gICAgIHRoaXMuZHJhd01hcmtlcnMoY3VycmVudFN0ZXAsIHRoaXMuY3VycmVudExvY2F0b3JEYXRhLCBudWxsKTtcbiAgLy8gICB9XG4gIC8vIH1cblxuICBfaGlkZU1hcmtlcnMoKSB7XG4gICAgdGhpcy5kcmF3TWFya2VycyhudWxsLCBudWxsKTtcbiAgfVxuXG4gIF9ub3RpZnlGb3VuZFN0YXRlKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdG9yRGF0YSkge1xuICAgICAgdGhpcy5fbm90aWZ5Tm90Rm91bmQuY2FuY2VsKCk7XG4gICAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goXCJzdGVwRm91bmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vdGlmeU5vdEZvdW5kKCk7XG4gICAgfVxuICB9XG5cbiAgX25vdGlmeU5vdEZvdW5kKCkge1xuICAgIHRoaXMuZmx1eC5wYW5lbENvbnRleHQoKS5kaXNwYXRjaChcInN0ZXBOb3RGb3VuZFwiKTtcbiAgfVxuXG4gIF9jb21wbGV0ZWQoeyBwYXlsb2FkOiBvcHRpb25zIH0gPSB7fSkge1xuICAgIHRoaXMuX2hpZGVNYXJrZXJzKCk7XG5cbiAgICBjb25zdCB7IGN1cnJlbnRTdGVwLCBvdGhlclN0ZXBzIH0gPSB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuc3RhdGU7XG4gICAgY29uc3QgbmV4dE90aGVyU3RlcCA9IGN1cnJlbnRTdGVwICYmXG4gICAgICBvdGhlclN0ZXBzICYmXG4gICAgICBvdGhlclN0ZXBzW2N1cnJlbnRTdGVwLmluZGV4ICsgMV07XG4gICAgaWYgKCFuZXh0T3RoZXJTdGVwKSB7XG4gICAgICB0aGlzLmRlbGF5RW50ZXJTdGVwKCk7XG4gICAgfVxuICAgIHRoaXMud2FpdGluZ05leHRTdGVwID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goXCJzdGVwQ29tcGxldGVkXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgX25vdENvbXBsZXRlZCgpIHtcbiAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goXCJzdGVwTm90Q29tcGxldGVkXCIpO1xuICB9XG5cbiAgX2dvQmFjaygpIHtcbiAgICB0aGlzLmZsdXgucGFuZWxDb250ZXh0KCkuZGlzcGF0Y2goXCJzdGVwR29CYWNrXCIpO1xuICB9XG5cbiAgX3Njcm9sbFdpbmRvd0ludG9WaWV3KG1lc3NhZ2UpIHtcbiAgICBzY3JvbGxXaW5kb3dJbnRvVmlldyhtZXNzYWdlLnBheWxvYWQpO1xuICB9XG5cbiAgX2ZvdW5kTGF0ZXJTdGVwKHN0ZXBJbmRleCkge1xuICAgIHRoaXMuZmx1eC5wYW5lbENvbnRleHQoKS5kaXNwYXRjaChcImZvdW5kTGF0ZXJTdGVwXCIsIHN0ZXBJbmRleCwgdHJ1ZSk7XG4gIH1cblxuICBkZWxheUVudGVyU3RlcCgpIHtcbiAgICBpZiAodGhpcy5kZWxheUVudGVyU3RlcFRpbWVyKSByZXR1cm47XG4gICAgdGhpcy5kZWxheUVudGVyU3RlcFRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWxheUVudGVyU3RlcFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVudGVyU3RlcCgpO1xuICAgICAgfSxcbiAgICAgIDEwMDBcbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL0NvbnRlbnRQbGF5ZXJUb3BGcmFtZS5qcyIsIi8vIEFkanVzdCB0aGUgcGFuZWwgc28gaXQgZG9lc24ndCBjb3ZlciB0aGUgbWFya2VyLiBJIGhhdmUgZXh0cmFjdGVkIHRoaXMgZnJvbVxuLy8gQ29udGVudFBsYXllciBidXQgc3VyZWx5IGl0IHJlYWxseSBiZWxvbmdzIHdpdGggdGhlIHBhbmVsIGNvbnRyb2xsZXIuXG5cbmltcG9ydCB7IFNFTEVDVE9SX0lEIGFzIE1BUktFUl9TRUxFQ1RPUl9JRCB9IGZyb20gXCIuL2RyYXdNYXJrZXJcIjtcbmltcG9ydCBnZXRCb3VuZHMgZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9nZXRCb3VuZHNcIjtcbmltcG9ydCBnZXRFbGVtZW50VmlzdWFsQm91bmRzIGZyb20gXCIuLi9nZXRFbGVtZW50VmlzdWFsQm91bmRzXCI7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2VcIjtcbmltcG9ydCBpc01vYmlsZUJyb3dzZXJzIGZyb20gXCJiYXNlL2NvbW1vbi91dGlscy9pc01vYmlsZUJyb3dzZXJzXCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uLy4uL2NvbW1vbi9zZXR0aW5nc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJ2xvZGFzaC9pZGVudGl0eSc7XG5pbXBvcnQgeyBnZXRGaWxlTG9nZ2VyIH0gZnJvbSBcImJhc2UvY29tbW9uL3V0aWxzL2xvZ2dlclwiO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZnVuY3Rpb24gaXNaZW5kZXNrUGFnZSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZXNwYWNlKCd6ZW5kZXNrLXZpc2libGUnKSk7XG59XG5cbmxldCBwcmV2aW91c0luZm8gPSBudWxsOyAvLyB7IHN0ZXAsIG1hcmtlcnNCb3VuZHMgfVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGp1c3RQYW5lbFBvc2l0aW9uKGV4dGVuc2lvbiwgc3RlcCkge1xuICBjb25zdCBlbWJlZCA9IHByb2Nlc3MuZW52LkJST1dTRVIgPT09IFwiZW1iZWRcIjtcbiAgY29uc3QgcGFuZWxFbCA9IGV4dGVuc2lvbi5wYW5lbENvbnRyb2xsZXIucGFuZWxFbDtcbiAgY29uc3Qgd2lkZ2V0RWwgPSBleHRlbnNpb24ucGFuZWxDb250cm9sbGVyLmNsb3NlRWw7XG4gIGlmICghcGFuZWxFbCB8fCAhd2lkZ2V0RWwpIHJldHVybjtcblxuICBjb25zdCBpc01vYmlsZSA9IGVtYmVkICYmIGlzTW9iaWxlQnJvd3NlcnMoKTtcbiAgY29uc3QgaXNaZW5kZXNrID0gaXNaZW5kZXNrUGFnZSgpO1xuICBjb25zdCBwYW5lbE9ubHkgPSBpc01vYmlsZSB8fCBpc1plbmRlc2s7XG4gIGNvbnN0IHBhbmVsQ1NTUG9zaXRpb24gPSBjYWxjdWxhdGVQYW5lbENTU1Bvc2l0aW9uKGV4dGVuc2lvbiwgc3RlcCk7XG5cbiAgaWYgKCFwYW5lbENTU1Bvc2l0aW9uLm92ZXJsYXBzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFuZWxSZWFsQm91bmRzID0gZXh0ZW5zaW9uLnBhbmVsQ29udHJvbGxlci5wYW5lbFJlYWxCb3VuZHM7XG4gIGNvbnN0IHBhbmVsRnVsbEJvdW5kcyA9IGdldEJvdW5kcyhwYW5lbEVsKTtcbiAgY29uc3QgcGFuZWxSZWFsSGVpZ2h0ID0gcGFuZWxSZWFsQm91bmRzID8gcGFuZWxSZWFsQm91bmRzLmhlaWdodCA6IHBhbmVsRnVsbEJvdW5kcy5oZWlnaHQ7XG4gIGNvbnN0IGNhcHR1cmluZ0FjdGl2ZSA9IHBhbmVsRWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWVzcGFjZSgnY2FwdHVyaW5nJykpO1xuICBjb25zdCBwYW5lbFRvcElubmVyTWFyZ2luID0gY2FwdHVyaW5nQWN0aXZlID8gMCA6IChwYW5lbEZ1bGxCb3VuZHMuaGVpZ2h0IC0gcGFuZWxSZWFsSGVpZ2h0KTtcblxuICBpZiAoaXNaZW5kZXNrKSB7XG4gICAgcGFuZWxFbC5zdHlsZS50b3AgPSAod2luZG93LmlubmVySGVpZ2h0IC0gcGFuZWxDU1NQb3NpdGlvbi5wYW5lbC5ib3R0b20gLSBwYW5lbFRvcElubmVyTWFyZ2luKSArIFwicHhcIjtcbiAgfSBlbHNlIHtcbiAgICBwYW5lbEVsLnN0eWxlLmJvdHRvbSA9IHBhbmVsQ1NTUG9zaXRpb24ucGFuZWwuYm90dG9tICsgXCJweFwiO1xuICB9XG4gIHBhbmVsRWwuc3R5bGUucmlnaHQgPSBwYW5lbENTU1Bvc2l0aW9uLnBhbmVsLnJpZ2h0ICsgXCJweFwiO1xuICBpZiAoIXBhbmVsT25seSkge1xuICAgIHdpZGdldEVsLnN0eWxlLmJvdHRvbSA9IHBhbmVsQ1NTUG9zaXRpb24ud2lkZ2V0LmJvdHRvbSArIFwicHhcIjtcbiAgICB3aWRnZXRFbC5zdHlsZS5yaWdodCA9IHBhbmVsQ1NTUG9zaXRpb24ud2lkZ2V0LnJpZ2h0ICsgXCJweFwiO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHRvIHVwZGF0ZSB0aGUgcmVhbCBib3VuZHMgd2hlbmV2ZXIgdGhleSBjaGFuZ2VcbiAgLy9leHRlbnNpb24ucGFuZWxDb250cm9sbGVyLmNhbGN1bGF0ZVBhbmVsUmVhbEJvdW5kcygpO1xufVxuXG4vLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgbWFya2Vyc1xuZnVuY3Rpb24gY2FsY3VsYXRlUGFuZWxDU1NQb3NpdGlvbihleHRlbnNpb24sIHN0ZXApIHtcbiAgY29uc3QgZW1iZWQgPSBwcm9jZXNzLmVudi5CUk9XU0VSID09PSBcImVtYmVkXCI7XG4gIGNvbnN0IGlzTW9iaWxlID0gZW1iZWQgJiYgaXNNb2JpbGVCcm93c2VycygpO1xuICBjb25zdCBpc1plbmRlc2sgPSBpc1plbmRlc2tQYWdlKCk7XG4gIGNvbnN0IHBhbmVsT25seSA9IGlzTW9iaWxlIHx8IGlzWmVuZGVzaztcbiAgY29uc3QgZGVmYXVsdEJvdHRvbSA9IGlzTW9iaWxlID8gMCA6IGlzWmVuZGVzayA/ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSAyNSkgOiAyMDtcbiAgY29uc3QgZGVmYXVsdFJpZ2h0ID0gaXNNb2JpbGUgPyAwIDogaXNaZW5kZXNrID8gLTUgOiAyMDtcbiAgY29uc3Qgd2lkZ2V0Qm90dG9tRGlmZiA9IDM1O1xuICBjb25zdCB3aWRnZXRSaWdodERpZmYgPSAtNDA7XG4gIGNvbnN0IGRlZmF1bHRXaWRnZXQgPSB7IGJvdHRvbTogZGVmYXVsdEJvdHRvbSwgcmlnaHQ6IGRlZmF1bHRSaWdodCB9O1xuICBjb25zdCBkZWZhdWx0UmV0dXJuID0ge1xuICAgIHdpZGdldDogZGVmYXVsdFdpZGdldCxcbiAgICBwYW5lbDogcGFuZWxPbmx5XG4gICAgICA/IGRlZmF1bHRXaWRnZXRcbiAgICAgIDogeyBib3R0b206IGRlZmF1bHRCb3R0b20gKyAzNSwgcmlnaHQ6IGRlZmF1bHRSaWdodCAtIDQwIH1cbiAgfTtcbiAgY29uc3QgcGFuZWxFbCA9IGV4dGVuc2lvbi5wYW5lbENvbnRyb2xsZXIucGFuZWxFbDtcbiAgY29uc3Qgd2lkZ2V0RWwgPSBleHRlbnNpb24ucGFuZWxDb250cm9sbGVyLmNsb3NlRWw7XG4gIGNvbnN0IG1hcmtlckJvdW5kcyA9IGdldE1lcmdlZE1hcmtlckJvdW5kcyhzdGVwKTtcbiAgaWYgKCFwYW5lbEVsIHx8ICF3aWRnZXRFbCB8fCAhbWFya2VyQm91bmRzKSByZXR1cm4gZGVmYXVsdFJldHVybjtcbiAgaWYgKG1hcmtlckJvdW5kcy52aXNpYmxlSGVpZ2h0IDw9IDAgfHwgbWFya2VyQm91bmRzLnZpc2libGVXaWR0aCA8PSAwKSB7XG4gICAgLy8gbWFya2VyIGlzIG91dHNpZGUgdGhlIHZpZXdwb3J0XG4gICAgbG9nZ2VyLmRlYnVnKFwibWFya2VyIGlzIG91dHNpZGUgdmlld3BvcnQhXCIpO1xuICAgIHJldHVybiBkZWZhdWx0UmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFuZWxCb3VuZHMgPSBleHRlbnNpb24ucGFuZWxDb250cm9sbGVyLnBhbmVsUmVhbEJvdW5kcyB8fCBnZXRCb3VuZHMocGFuZWxFbCk7XG4gIGNvbnN0IHdpZGdldEJvdW5kcyA9IGdldEJvdW5kcyh3aWRnZXRFbCk7XG5cbiAgaWYgKHBhbmVsQm91bmRzLmhlaWdodCA9PT0gMCB8fCB3aWRnZXRCb3VuZHMuaGVpZ2h0ID09PSAwKVxuICAgIHJldHVybiBkZWZhdWx0UmV0dXJuO1xuXG4gIGNvbnN0IHBhbmVsQWN0aXZlQm90dG9tID0gaXNaZW5kZXNrID8gcGFuZWxCb3VuZHMuYm90dG9tIDogTWF0aC5tYXgocGFuZWxCb3VuZHMuYm90dG9tLCB3aWRnZXRCb3VuZHMuYm90dG9tKTtcbiAgY29uc3QgcGFuZWxBY3RpdmVSaWdodCA9IGlzWmVuZGVzayA/IHBhbmVsQm91bmRzLnJpZ2h0IDogTWF0aC5tYXgocGFuZWxCb3VuZHMucmlnaHQsIHdpZGdldEJvdW5kcy5yaWdodCk7XG4gIGNvbnN0IHBhbmVsVmlzaWJsZUhlaWdodCA9IHBhbmVsT25seVxuICAgID8gcGFuZWxCb3VuZHMuaGVpZ2h0XG4gICAgOiBwYW5lbEFjdGl2ZUJvdHRvbSAtIHBhbmVsQm91bmRzLnRvcDtcbiAgY29uc3QgcGFuZWxWaXNpYmxlV2lkdGggPSBwYW5lbE9ubHlcbiAgICA/IHBhbmVsQm91bmRzLndpZHRoXG4gICAgOiBwYW5lbEFjdGl2ZVJpZ2h0IC0gcGFuZWxCb3VuZHMubGVmdDtcblxuICBsZXQgcGFuZWxDU1NCb3R0b20gPSBkZWZhdWx0Qm90dG9tO1xuICBsZXQgcGFuZWxDU1NSaWdodCA9IGRlZmF1bHRSaWdodDtcbiAgY29uc3QgcGFuZWxTY3JlZW5Ub3AgPSBOdW1iZXIocGFuZWxFbC5zdHlsZS50b3AucmVwbGFjZSgncHgnLCAnJykpIHx8XG4gICAgd2luZG93LmlubmVySGVpZ2h0IC0gcGFuZWxWaXNpYmxlSGVpZ2h0IC0gZGVmYXVsdEJvdHRvbTtcbiAgY29uc3QgcGFuZWxTY3JlZW5MZWZ0ID0gTnVtYmVyKHBhbmVsRWwuc3R5bGUubGVmdC5yZXBsYWNlKCdweCcsICcnKSkgfHxcbiAgICB3aW5kb3cuaW5uZXJXaWR0aCAtIHBhbmVsVmlzaWJsZVdpZHRoIC0gZGVmYXVsdFJpZ2h0O1xuICBjb25zdCBvdmVybGFwcyA9ICEocGFuZWxBY3RpdmVSaWdodCA8PSBtYXJrZXJCb3VuZHMubGVmdCB8fFxuICAgICAgICAgICAgICAgICAgcGFuZWxCb3VuZHMubGVmdCA+PSBtYXJrZXJCb3VuZHMucmlnaHQgfHxcbiAgICAgICAgICAgICAgICAgIHBhbmVsQWN0aXZlQm90dG9tIDw9IG1hcmtlckJvdW5kcy50b3AgIHx8XG4gICAgICAgICAgICAgICAgICBwYW5lbEJvdW5kcy50b3AgPj0gbWFya2VyQm91bmRzLmJvdHRvbSk7XG5cbiAgaWYgKG92ZXJsYXBzKSB7XG4gICAgaWYgKGV4dGVuc2lvbi5wYW5lbENvbnRyb2xsZXIucGFuZWxEcmFnZ2VkKSB7XG4gICAgICBleHRlbnNpb24ucGFuZWxDb250cm9sbGVyLnJlc2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwSGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICBtYXJrZXJCb3VuZHMuYm90dG9tIC0gcGFuZWxTY3JlZW5Ub3AsXG4gICAgICBtYXJrZXJCb3VuZHMudmlzaWJsZUhlaWdodCxcbiAgICAgIHBhbmVsVmlzaWJsZUhlaWdodFxuICAgICk7XG4gICAgY29uc3Qgb3ZlcmxhcFdpZHRoID0gTWF0aC5taW4oXG4gICAgICBtYXJrZXJCb3VuZHMucmlnaHQgLSBwYW5lbFNjcmVlbkxlZnQsXG4gICAgICBtYXJrZXJCb3VuZHMudmlzaWJsZVdpZHRoLFxuICAgICAgcGFuZWxWaXNpYmxlV2lkdGhcbiAgICApO1xuICAgIGNvbnN0IG92ZXJsYXBGYWN0b3IgPSBvdmVybGFwSGVpZ2h0ICpcbiAgICAgIG92ZXJsYXBXaWR0aCAvXG4gICAgICAobWFya2VyQm91bmRzLnZpc2libGVIZWlnaHQgKiBtYXJrZXJCb3VuZHMudmlzaWJsZVdpZHRoKTtcblxuICAgIC8vbG9nZ2VyLmRlYnVnKG92ZXJsYXBGYWN0b3IsIG92ZXJsYXBIZWlnaHQsIG92ZXJsYXBXaWR0aCwgbWFya2VyQm91bmRzLnZpc2libGVIZWlnaHQsIG1hcmtlckJvdW5kcy52aXNpYmxlV2lkdGgpO1xuXG4gICAgaWYgKG92ZXJsYXBGYWN0b3IgPj0gMC4xMCkge1xuICAgICAgY29uc3QgZ2FwID0gMTA7XG5cbiAgICAgIGxldCBlbm91Z2hWZXJ0aWNhbFNwYWNlO1xuICAgICAgaWYgKGlzWmVuZGVzaykge1xuICAgICAgICAvLyBtb3ZlIGRvd25cbiAgICAgICAgcGFuZWxDU1NCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBtYXJrZXJCb3VuZHMuYm90dG9tIC0gZ2FwO1xuICAgICAgICBlbm91Z2hWZXJ0aWNhbFNwYWNlID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIG1hcmtlckJvdW5kcy5ib3R0b20pID49IHBhbmVsVmlzaWJsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdXBcbiAgICAgICAgcGFuZWxDU1NCb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBtYXJrZXJCb3VuZHMudG9wICsgZ2FwO1xuICAgICAgICBlbm91Z2hWZXJ0aWNhbFNwYWNlID0gbWFya2VyQm91bmRzLnRvcCA+PSBwYW5lbFZpc2libGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghZW5vdWdoVmVydGljYWxTcGFjZSkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBzcGFjZSBpcyBub3QgZW5vdWdoISBNb3ZlIGxlZnRcbiAgICAgICAgcGFuZWxDU1NCb3R0b20gPSBkZWZhdWx0Qm90dG9tO1xuICAgICAgICBwYW5lbENTU1JpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSBtYXJrZXJCb3VuZHMubGVmdCArIGdhcDtcbiAgICAgICAgaWYgKG1hcmtlckJvdW5kcy5sZWZ0IDwgcGFuZWxWaXNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAvLyBsZWZ0IHNwYWNlIG5vdCBlbm91Z2ghXG4gICAgICAgICAgcGFuZWxDU1NSaWdodCA9IGRlZmF1bHRSaWdodDtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIFwiTm90IGVub3VnaCBzcGFjZSBmb3Igc2hvd2luZyBwYW5lbCB3aXRob3V0IG92ZXJsYXBwaW5nIHdpdGggbWFya2VycyFcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB3aWRnZXRSZXR1cm4gPSB7IGJvdHRvbTogcGFuZWxDU1NCb3R0b20sIHJpZ2h0OiBwYW5lbENTU1JpZ2h0IH07XG4gIHJldHVybiB7XG4gICAgb3ZlcmxhcHMsXG4gICAgd2lkZ2V0OiB3aWRnZXRSZXR1cm4sXG4gICAgcGFuZWw6IHBhbmVsT25seVxuICAgICAgPyB3aWRnZXRSZXR1cm5cbiAgICAgIDoge1xuICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgoXG4gICAgICAgICAgICBwYW5lbENTU0JvdHRvbSArIHdpZGdldEJvdHRvbURpZmYsXG4gICAgICAgICAgICBkZWZhdWx0UmV0dXJuLnBhbmVsLmJvdHRvbVxuICAgICAgICAgICksXG4gICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KFxuICAgICAgICAgICAgcGFuZWxDU1NSaWdodCArIHdpZGdldFJpZ2h0RGlmZixcbiAgICAgICAgICAgIGRlZmF1bHRSZXR1cm4ucGFuZWwucmlnaHRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgfTtcbn1cblxuLy8gUmV0dXJucyBhIHNpbmdsZSBib3VuZHMgb2JqZWN0IGJ5IG1lcmdpbmcgdGhlIGJvdW5kc1xuLy8gb2YgYWxsIHRoZSBtYXJrZXJzIG9uIHNjcmVlblxuZnVuY3Rpb24gZ2V0TWVyZ2VkTWFya2VyQm91bmRzKHN0ZXApIHtcbiAgY29uc3QgbWFya2Vyc0JvdW5kcyA9IGdldE1hcmtlckVscygpXG4gICAgLm1hcChlbCA9PiBnZXRNYXJrZXJCb3VuZHMoZWwpKVxuICAgIC5maWx0ZXIoaWRlbnRpdHkpO1xuXG4gIGlmIChcbiAgICBzdGVwICYmXG4gICAgcHJldmlvdXNJbmZvICYmXG4gICAgcHJldmlvdXNJbmZvLnN0ZXAgJiZcbiAgICBwcmV2aW91c0luZm8uc3RlcC5pbmRleCA9PT0gc3RlcC5pbmRleCAtIDEgJiZcbiAgICBwcmV2aW91c0luZm8uc3RlcC50eXBlID09PSAnSE9WRVInXG4gICkge1xuICAgIC8vIGluY2x1ZGUgcHJldmlvdXMgbWFya2VycyB0b29cbiAgICBtYXJrZXJzQm91bmRzLnB1c2goLi4ucHJldmlvdXNJbmZvLm1hcmtlcnNCb3VuZHMpO1xuICB9IGVsc2Uge1xuICAgIHByZXZpb3VzSW5mbyA9IHsgc3RlcCwgbWFya2Vyc0JvdW5kcyB9O1xuICB9XG5cbiAgaWYgKG1hcmtlcnNCb3VuZHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgaWYgKG1hcmtlcnNCb3VuZHMubGVuZ3RoID09PSAxKSByZXR1cm4gbWFya2Vyc0JvdW5kc1swXTsgLy8gb3B0aW1pemF0aW9uXG5cbiAgY29uc3QgbWVyZ2VkTWFya2VyQm91bmRzID0ge1xuICAgIHRvcDogTWF0aC5taW4oLi4ubWFya2Vyc0JvdW5kcy5tYXAoYiA9PiBiLnRvcCkpLFxuICAgIGJvdHRvbTogTWF0aC5tYXgoLi4ubWFya2Vyc0JvdW5kcy5tYXAoYiA9PiBiLmJvdHRvbSkpLFxuICAgIGxlZnQ6IE1hdGgubWluKC4uLm1hcmtlcnNCb3VuZHMubWFwKGIgPT4gYi5sZWZ0KSksXG4gICAgcmlnaHQ6IE1hdGgubWF4KC4uLm1hcmtlcnNCb3VuZHMubWFwKGIgPT4gYi5yaWdodCkpLFxuICB9O1xuXG4gIG1lcmdlZE1hcmtlckJvdW5kcy5oZWlnaHQgPSBtZXJnZWRNYXJrZXJCb3VuZHMuYm90dG9tIC0gbWVyZ2VkTWFya2VyQm91bmRzLnRvcDtcbiAgbWVyZ2VkTWFya2VyQm91bmRzLndpZHRoID0gbWVyZ2VkTWFya2VyQm91bmRzLnJpZ2h0IC0gbWVyZ2VkTWFya2VyQm91bmRzLmxlZnQ7XG5cbiAgbWVyZ2VkTWFya2VyQm91bmRzLnZpc2libGVIZWlnaHQgPSBNYXRoLm1pbihcbiAgICBtZXJnZWRNYXJrZXJCb3VuZHMuaGVpZ2h0LFxuICAgIHdpbmRvdy5pbm5lckhlaWdodCAtIG1lcmdlZE1hcmtlckJvdW5kcy50b3BcbiAgKTtcbiAgbWVyZ2VkTWFya2VyQm91bmRzLnZpc2libGVXaWR0aCA9IE1hdGgubWluKFxuICAgIG1lcmdlZE1hcmtlckJvdW5kcy53aWR0aCxcbiAgICB3aW5kb3cuaW5uZXJXaWR0aCAtIG1lcmdlZE1hcmtlckJvdW5kcy5sZWZ0XG4gICk7XG5cbiAgcmV0dXJuIG1lcmdlZE1hcmtlckJvdW5kcztcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VyRWxzKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiICsgTUFSS0VSX1NFTEVDVE9SX0lEKVxuICApLmZpbHRlcihcbiAgICBlbCA9PiBlbC5zdHlsZS5kaXNwbGF5ICE9PSBcIm5vbmVcIiAmJiBlbC5zdHlsZS52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlckJvdW5kcyhtYXJrZXJFbCkge1xuICBpZiAoIW1hcmtlckVsKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBtYXJrZXJJbmZvRWwgPSBtYXJrZXJFbC5xdWVyeVNlbGVjdG9yKFxuICAgIFwiLlwiICsgTUFSS0VSX1NFTEVDVE9SX0lEICsgXCJtYXJrZXItaW5mb1wiXG4gICk7XG4gIGNvbnN0IGlzVmFsaWRNYXJrZXJJbmZvRWwgPSBtYXJrZXJJbmZvRWwgJiZcbiAgICBtYXJrZXJJbmZvRWwuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiZcbiAgICBtYXJrZXJJbmZvRWwuc3R5bGUudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIjtcblxuICBjb25zdCBtYXJrZXJDb29yZHMgPSBnZXRFbGVtZW50VmlzdWFsQm91bmRzKG1hcmtlckVsLCB0cnVlKTtcbiAgaWYgKCFtYXJrZXJDb29yZHMpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IG1hcmtlckluZm9Db29yZHMgPSBpc1ZhbGlkTWFya2VySW5mb0VsXG4gICAgPyBnZXRFbGVtZW50VmlzdWFsQm91bmRzKG1hcmtlckluZm9FbCwgdHJ1ZSlcbiAgICA6IG1hcmtlckNvb3JkcztcblxuICBjb25zdCBtYXJrZXJCb3VuZHMgPSB7XG4gICAgdG9wOiBNYXRoLm1pbihtYXJrZXJDb29yZHMueSwgbWFya2VySW5mb0Nvb3Jkcy55KSxcbiAgICBib3R0b206IE1hdGgubWF4KFxuICAgICAgbWFya2VyQ29vcmRzLnkgKyBtYXJrZXJDb29yZHMuaGVpZ2h0LFxuICAgICAgbWFya2VySW5mb0Nvb3Jkcy55ICsgbWFya2VySW5mb0Nvb3Jkcy5oZWlnaHRcbiAgICApLFxuICAgIGxlZnQ6IE1hdGgubWluKG1hcmtlckNvb3Jkcy54LCBtYXJrZXJJbmZvQ29vcmRzLngpLFxuICAgIHJpZ2h0OiBNYXRoLm1heChcbiAgICAgIG1hcmtlckNvb3Jkcy54ICsgbWFya2VyQ29vcmRzLndpZHRoLFxuICAgICAgbWFya2VySW5mb0Nvb3Jkcy54ICsgbWFya2VySW5mb0Nvb3Jkcy53aWR0aFxuICAgIClcbiAgfTtcbiAgbWFya2VyQm91bmRzLmhlaWdodCA9IG1hcmtlckJvdW5kcy5ib3R0b20gLSBtYXJrZXJCb3VuZHMudG9wO1xuICBtYXJrZXJCb3VuZHMud2lkdGggPSBtYXJrZXJCb3VuZHMucmlnaHQgLSBtYXJrZXJCb3VuZHMubGVmdDtcblxuICBjb25zdCBtYXJrZXJWaXNpYmxlSGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgbWFya2VyQm91bmRzLmhlaWdodCxcbiAgICB3aW5kb3cuaW5uZXJIZWlnaHQgLSBtYXJrZXJCb3VuZHMudG9wXG4gICk7XG4gIGNvbnN0IG1hcmtlclZpc2libGVXaWR0aCA9IE1hdGgubWluKFxuICAgIG1hcmtlckJvdW5kcy53aWR0aCxcbiAgICB3aW5kb3cuaW5uZXJXaWR0aCAtIG1hcmtlckJvdW5kcy5sZWZ0XG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5tYXJrZXJCb3VuZHMsXG4gICAgdmlzaWJsZUhlaWdodDogbWFya2VyVmlzaWJsZUhlaWdodCxcbiAgICB2aXNpYmxlV2lkdGg6IG1hcmtlclZpc2libGVXaWR0aCxcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvYWRqdXN0UGFuZWxQb3NpdGlvbi5qcyIsImV4cG9ydCBmdW5jdGlvbiBEUkFHKHsgZWwsIG9uQ29tcGxldGVkLCBvbk5vdENvbXBsZXRlZCB9KSB7XG4gIHRoaXMubGlzdGVuVG9ET00oZWwsICdkcmFnc3RhcnQnLCBvbkNvbXBsZXRlZCwgdHJ1ZSk7XG4gIHRoaXMubGlzdGVuVG9ET00oZWwsICdtb3VzZWRvd24nLCBvbkNvbXBsZXRlZCwgdHJ1ZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL0RSQUcuanMiLCJleHBvcnQgZnVuY3Rpb24gRFJPUCh7IGVsLCBzdGVwLCBvbkNvbXBsZXRlZCwgb25Ob3RDb21wbGV0ZWQgfSkge1xuICBsZXQgZHJvcHBlZCA9IGZhbHNlO1xuXG4gIHRoaXMubGlzdGVuVG9ET00oZWwsICdkcm9wJywgKCkgPT4ge1xuICAgIGRyb3BwZWQgPSB0cnVlO1xuICAgIG9uQ29tcGxldGVkKCk7XG4gIH0sIHRydWUpO1xuXG4gIC8vIHNvbWUgYXBwcyBkb24ndCB0cmlnZ2VyIGRyb3AgKGUuZy4gZ29vZ2xlIGRyaXZlKVxuICB0aGlzLmxpc3RlblRvRE9NKGVsLCAnbW91c2V1cCcsICgpID0+IHtcbiAgICBkcm9wcGVkID0gdHJ1ZTtcbiAgICBvbkNvbXBsZXRlZCgpO1xuICB9LCB0cnVlKTtcblxuICB0aGlzLmxpc3RlblRvRE9NKHdpbmRvdywgJ2RyYWdlbmQnLCAoKSA9PiB7XG4gICAgaWYgKCFkcm9wcGVkKSBvbk5vdENvbXBsZXRlZCgpO1xuICB9LCB0cnVlKTtcblxuICAvLyBzb21lIGFwcHMgZG9uJ3QgdHJpZ2dlciBkcm9wIChlLmcuIGdvb2dsZSBkcml2ZSlcbiAgdGhpcy5saXN0ZW5Ub0RPTSh3aW5kb3csICdtb3VzZXVwJywgKCkgPT4ge1xuICAgIGlmICghZHJvcHBlZCkgb25Ob3RDb21wbGV0ZWQoKTtcbiAgfSwgZmFsc2UpOyAvLyBmYWxzZSB0byB0cmlnZ2VyIGNhbGxiYWNrIGFmdGVyIHRoZSBlbCBoYW5kbGVyXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL0RST1AuanMiLCJleHBvcnQgZnVuY3Rpb24gSE9WRVIoeyBlbCwgb25Db21wbGV0ZWQsIG9uTm90Q29tcGxldGVkIH0pIHtcbiAgdGhpcy5saXN0ZW5Ub0RPTShlbCwgJ21vdXNlb3ZlcicsIG9uQ29tcGxldGVkLCB0cnVlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvSE9WRVIuanMiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gTEVGVF9DTElDSyh7IGVsLCBzdGVwLCBvbkNvbXBsZXRlZCwgb25Ob3RDb21wbGV0ZWQgfSkge1xuICBjb25zdCBpc0RvdWJsZUNsaWNrID0gZ2V0KHN0ZXAsICdldmVudC5kYmxjbGljaycpID09PSB0cnVlO1xuICBjb25zdCBpc0Ryb3Bkb3duQ2hhbmdlID0gZ2V0KHN0ZXAsICdldmVudC5jaGFuZ2UnKSA9PT0gdHJ1ZTtcblxuICBpZiAoZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAvLyBGb3JjZSAnY2hhbmdlJyBldmVudCBldmVuIGlmIHRoZSBzZWxlY3QgaGFzIG9uZSBzaW5nbGUgb3B0aW9uLCBvciBpZiB0aGUgdXNlclxuICAgIC8vIHNlbGVjdHMgdGhlIGFscmVhZHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgIC8vIFdlIGRvIHRoaXMgYnkgY3JlYXRpbmcgYW4gaGlkZGVuIG9wdGlvbiBvbiB0aGUgZmx5IGFuZCBieSBzZXR0aW5nIGl0IGFzIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgY29uc3Qgb3B0aW9uID0gZWwucXVlcnlTZWxlY3Rvcihgb3B0aW9uLiR7bmFtZXNwYWNlKCl9YCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLmNsYXNzTmFtZSA9IG5hbWVzcGFjZSgpO1xuICAgIG9wdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIG9wdGlvbi5pbm5lckhUTUwgPSBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdID8gZWwub3B0aW9uc1tlbC5zZWxlY3RlZEluZGV4XS5pbm5lckhUTUwgOiAnJztcbiAgICBlbC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSBlbC5vcHRpb25zLmxlbmd0aCAtIDE7XG4gIH1cblxuICAvLyBtb3VzZWRvd24gaXMgdXNlZCBpbnN0ZWFkIG9mIG1vdXNldXAgb3IgY2xpY2sgYmVjYXVzZSBpcyBtb3JlIHJlbGlhYmxlICgjMTIxKVxuICB0aGlzLmxpc3RlblRvRE9NKGVsLCAnbW91c2Vkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICAvLyByaWdodCBjbGlja1xuICAgICAgb25Ob3RDb21wbGV0ZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNEb3VibGVDbGljaykge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgY2xpY2sgb2YgYW4gZXZlbnR1YWwgZG91YmxlIGNsaWNrLFxuICAgICAgLy8gd2UgY2FuJ3QgYmUgc3VyZSBpZiBhY3Rpb24gd2lsbCBiZSBhIGZhaWx1cmUgb3Igbm90LFxuICAgICAgLy8gPT4gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNEcm9wZG93bkNoYW5nZSkge1xuICAgICAgLy8gaGFuZGxlZCB2aWEgdGhlIGNoYW5nZSBldmVudFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uQ29tcGxldGVkKCk7XG4gIH0sIHRydWUpO1xuXG4gIHRoaXMubGlzdGVuVG9ET00oZWwsICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgaWYgKGlzRHJvcGRvd25DaGFuZ2UpIHtcbiAgICAgIG9uQ29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICB0aGlzLmxpc3RlblRvRE9NKGVsLCAnZGJsY2xpY2snLCAoKSA9PiB7XG4gICAgaWYgKGdldChzdGVwLCAnZXZlbnQuZGJsY2xpY2snKSA9PT0gdHJ1ZSkgb25Db21wbGV0ZWQoKTtcbiAgICBlbHNlIG9uTm90Q29tcGxldGVkKCk7XG4gIH0sIHRydWUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L3BsYXllci9oYW5kbGVycy9MRUZUX0NMSUNLLmpzIiwiZXhwb3J0IGZ1bmN0aW9uIFJFQUQoKSB7XG4gIC8vIG5vdGhpbmcgdG8gZG9cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvUkVBRC5qcyIsImV4cG9ydCBmdW5jdGlvbiBSSUdIVF9DTElDSyh7IGVsLCBvbkNvbXBsZXRlZCwgb25Ob3RDb21wbGV0ZWQgfSkge1xuICBsZXQgY29tcGxldGVkID0gZmFsc2U7XG5cbiAgdGhpcy5saXN0ZW5Ub0RPTShlbCwgJ21vdXNlZG93bicsIChldmVudCkgPT4ge1xuICAgIC8vIChpbXBsaWNpdGx5IGFsc28gaGFuZGxlIGZhaWx1cmUgZm9yIGxlZnQgY2xpY2sgLyBkb3VibGUgY2xpY2spXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgb25Db21wbGV0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25Ob3RDb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gIHRoaXMubGlzdGVuVG9ET00oZWwsICdjb250ZXh0bWVudScsICgpID0+IHtcbiAgICBpZiAoIWNvbXBsZXRlZCkgeyAvLyAoc29tZXRpbWVzIGNvbnRleHRtZW51IGlzIHRyaWdnZXJlZCBhZnRlciBtb3VzZWRvd24pXG4gICAgICBvbkNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvcGxheWVyL2hhbmRsZXJzL1JJR0hUX0NMSUNLLmpzIiwiZXhwb3J0IGZ1bmN0aW9uIFNDUk9MTCgpIHtcbiAgLy8gVE9ET1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L3BsYXllci9oYW5kbGVycy9TQ1JPTEwuanMiLCJpbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuXG5jb25zdCB0eXBpbmdUaW1lb3V0ID0gMzAwMDtcblxuZnVuY3Rpb24gZmluZEZvcm1TdWJtaXRFbChlbCkge1xuICBsZXQgY3VycmVudEVsID0gZWw7XG4gIGxldCBmb3JtRWw7XG4gIHdoaWxlIChjdXJyZW50RWwpIHtcbiAgICBpZiAoY3VycmVudEVsLnRhZ05hbWUgPT09ICdGT1JNJykge1xuICAgICAgZm9ybUVsID0gY3VycmVudEVsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIGlmIChmb3JtRWwpIHtcbiAgICByZXR1cm4gZm9ybUVsLnF1ZXJ5U2VsZWN0b3IoJ1t0eXBlPVwic3VibWl0XCJdJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUWVBJTkcoeyBlbCwgZWxJbmRleCwgc3RlcCwgb25Db21wbGV0ZWQsIG9uTm90Q29tcGxldGVkIH0pIHtcbiAgY29uc3QgdGltZXJOYW1lID0gYGhhbmRsZXJzLnR5cGluZ1ske2VsSW5kZXh9XS5jb21wbGV0ZWRgO1xuXG4gIGNvbnN0IHRleHQgPSBnZXQoc3RlcCwgJ2V2ZW50LnRleHQnKTtcbiAgY29uc3QgaXNQYXNzd29yZCA9IGdldChzdGVwLCAnZXZlbnQucGFzc3dvcmQnKTtcblxuICB0aGlzLmxpc3RlblRvRE9NKGVsLCAna2V5dXAnLCAoKSA9PiB7XG4gICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyTmFtZSk7XG5cbiAgICBjb25zdCBlbnRlcmVkVGV4dCA9ICh0eXBlb2YgZWwudmFsdWUgIT09ICd1bmRlZmluZWQnKSA/IGVsLnZhbHVlIDogZWwudGV4dENvbnRlbnQ7XG4gICAgaWYgKGlzUGFzc3dvcmQpIHtcbiAgICAgIC8vIGNoZWNrIGxlbmd0aCBvbmx5LCBubyBjaGFyYWN0ZXJzIG1hdGNoZWRcbiAgICAgIGlmIChlbnRlcmVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb25Ob3RDb21wbGV0ZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgY29tcGxldGVkIGlmIHRoZSB1c2VyIGhhcyB0eXBlZCB0aGUgd3JvbmcgdGV4dFxuICAgICAgaWYgKHRleHQgIT09IHVuZGVmaW5lZCAmJiB0ZXh0ICE9PSAnJyAmJiBlbnRlcmVkVGV4dCAhPT0gdGV4dCkge1xuICAgICAgICBvbk5vdENvbXBsZXRlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVmZXJyZWQgY29tcGxldGl0aW9uXG4gICAgdGhpcy5hZGRUaW1lcih0aW1lck5hbWUsIG9uQ29tcGxldGVkLCB0eXBpbmdUaW1lb3V0KTtcbiAgICBvbk5vdENvbXBsZXRlZCgpO1xuICB9LCB0cnVlKTtcblxuICB0aGlzLmxpc3RlblRvRE9NKGVsLCAna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMTMgfHwgZXZlbnQud2hpY2ggPT09IDkpIHsgLy8gZW50ZXIgb3IgdGFiXG4gICAgICAvLyBoYW5kbGUgZW50ZXIvdGFiIGludGVyYWN0aW9uIHdpc2VcbiAgICAgIGlmICh0aGlzLmdldFRpbWVyKHRpbWVyTmFtZSkgfHwgdGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gdGhlIHVzZXIgdHlwZWQgc29tZXRoaW5nIGFuZCBpcyB3YWl0aW5nIHRoZSB0aW1lb3V0LFxuICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUgcHJlc3NlZCBlbnRlci90YWJcbiAgICAgICAgLy8gPT4gc2hvcnRjdXQ6IGFkdmFuY2UgZGlyZWN0bHkgdG8gdGhlIG5leHQgc2xpZGVcbiAgICAgICAgb25Db21wbGV0ZWQoeyBhZHZhbmNlOiB0cnVlIH0pOyAvLyBjb21wbGV0ZWQgd2l0aCBvcHRpb25zXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBhdXRvIGFkdmFuY2Ugb24gZm9ybSBzdWJtaXRcbiAgLy8gKG5lZWRlZCBpZiB1c2VyIG1hbnVhbGx5IGNsaWNrcyBvbiBzdWJtaXQgYnV0dG9uLCBzZWUgIzY3MilcbiAgY29uc3QgZm9ybVN1Ym1pdEVsID0gZmluZEZvcm1TdWJtaXRFbChlbCk7XG4gIGlmIChmb3JtU3VibWl0RWwpIHtcbiAgICB0aGlzLmxpc3RlblRvRE9NKGZvcm1TdWJtaXRFbCwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZ2V0VGltZXIodGltZXJOYW1lKSB8fCB0aGlzLmNvbXBsZXRlZCkge1xuICAgICAgICBvbkNvbXBsZXRlZCh7IGFkdmFuY2U6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jhc2UvY29udGVudC9wbGF5ZXIvaGFuZGxlcnMvVFlQSU5HLmpzIiwiaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlLWV2ZW50LWVtaXR0ZXInO1xuXG5jb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG53aW5kb3dbbmFtZXNwYWNlKCdsb2FkZWQnKV0gPSAoY2xhc3NOYW1lLCBDbGFzcykgPT4ge1xuICBlbWl0dGVyLmVtaXQoJ2xvYWRlZDonICsgY2xhc3NOYW1lLCBDbGFzcyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoY2xhc3NOYW1lLCBvbkxvYWRlZCkgPT4ge1xuICBjb25zdCBnbG9iYWxWYXIgPSB3aW5kb3dbbmFtZXNwYWNlKCdjb21wb25lbnQtJyArIGNsYXNzTmFtZSldO1xuICBpZiAoZ2xvYmFsVmFyKSB7XG4gICAgb25Mb2FkZWQoZ2xvYmFsVmFyKTtcbiAgfSBlbHNlIHtcbiAgICBlbWl0dGVyLm9uY2UoJ2xvYWRlZDonICsgY2xhc3NOYW1lLCAoQ2xhc3MpID0+IG9uTG9hZGVkKENsYXNzKSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvd2FpdEZvckNvbXBvbmVudC5qcyIsImltcG9ydCAqIGFzIGZyYW1lTWVzc2FnZXMgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvZnJhbWVNZXNzYWdlcyc7XG5pbXBvcnQgd2FpdEZvckluaXQgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvd2FpdEZvckluaXQnO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5sZXQgem9vbSA9IDE7IC8vIGVkdWNhdGVkIGd1ZXNzXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRab29tKCkge1xuICByZXR1cm4gem9vbTtcbn1cblxud2FpdEZvckluaXQoKCkgPT4ge1xuICBmcmFtZU1lc3NhZ2VzLm9uTWVzc2FnZSgnY29vcmRpbmF0ZXMtem9vbScsICh7IHBheWxvYWQgfSkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdnb3Qgem9vbScpO1xuICAgIHpvb20gPSBwYXlsb2FkO1xuICB9KTtcbiAgZnJhbWVNZXNzYWdlcy5zZW5kKGZyYW1lTWVzc2FnZXMuVE9QLCAnY29vcmRpbmF0ZXMtZ2V0Wm9vbScpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9iYXNlL2NvbnRlbnQvem9vbS96b29tRnJhbWVOb2RlLmpzIiwiaW1wb3J0ICogYXMgZnJhbWVNZXNzYWdlcyBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9mcmFtZU1lc3NhZ2VzJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KGV4dGVuc2lvbikge1xuICBsZXQgem9vbSA9IDE7IC8vIGVkdWNhdGVkIGd1ZXNzXG5cbiAgZnVuY3Rpb24gc2VuZFpvb20oKSB7XG4gICAgZnJhbWVNZXNzYWdlcy5zZW5kKGZyYW1lTWVzc2FnZXMuQUxMLCAnY29vcmRpbmF0ZXMtem9vbScsIHpvb20pO1xuICB9XG5cbiAgZnJhbWVNZXNzYWdlcy5vbk1lc3NhZ2UoJ2Nvb3JkaW5hdGVzLWdldFpvb20nLCAoKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ2dldFpvb20nKTtcbiAgICBzZW5kWm9vbSgpO1xuICB9KTtcblxuICBmdW5jdGlvbiByZXRyaWV2ZVpvb20oKSB7XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkJST1dTRVIgPT09ICdlZGdlJykge1xuICAgICAgICAvLyBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2llL2VuLVVTLzllNWI4ZmI2LWY1OTItNDVlNy1hNGI4LWZkODZlM2MyMjM5My9ob3ctY2FuLWktZGV0ZWN0LW15LXpvb20tYnJvd3Nlci1sZXZlbC1vbi1hLXBhZ2Vsb2FkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgICAgcmVzb2x2ZShzY3JlZW4uZGV2aWNlWERQSSAvIDk2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuc2lvbi5wb3J0TWFuYWdlci5iYWNrZ3JvdW5kUG9ydC5zZW5kKHsgdG9waWM6ICdnZXRab29tJyB9LCByZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKHogPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZygnY29udGVudCBnZXRab29tJywgeik7XG4gICAgICBpZiAoeiAhPT0gem9vbSkge1xuICAgICAgICAvLyBub3RpZnkgY2hpbGQgZnJhbWVzIG9mIG5ldyB6b29tXG4gICAgICAgIHpvb20gPSB6O1xuICAgICAgICBzZW5kWm9vbSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJldHJpZXZlWm9vbSk7XG4gIHJldHJpZXZlWm9vbSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYmFzZS9jb250ZW50L3pvb20vem9vbVRvcEZyYW1lLmpzIiwiLy8gTWFpbnRhaW4gc3RhdGUgZm9yIHRoZSBicm93c2VyIGFjdGlvbiBidXR0b24gcG9wdXBcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnbm9kZS1ldmVudC1lbWl0dGVyJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlckFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvLyBkdW1teSBpbXBsZW1lbnRhdGlvblxuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9Ccm93c2VyQWN0aW9uTWFuYWdlci5qcyIsIi8vaW1wb3J0IEJyaWRnZSBmcm9tICdiYXNlL2JhY2tncm91bmQvQnJpZGdlJztcblxuLy8gT1BUSU1JWkFUSU9OOiBkb24ndCBleHRlbmQgcGFyZW50IEJyaWRnZSwgc2luY2Ugd2Ugb25seSBuZWVkIGEgZHVtbXkgY29tcG9uZW50LlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1iZWRCcmlkZ2Uge1xuICBzdGF0aWMgbGlzdGVuKGV4dGVuc2lvbikge1xuICAgIC8vIGR1bW15IGltcGxlbWVudGF0aW9uXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2JhY2tncm91bmQvRW1iZWRCcmlkZ2UuanMiLCIvLyBOb3RlOiBhc3N1bWVzIHRoYXQgdGhlcmUgYXJlbid0IHR3byBvciBtb3JlIG1lc3NhZ2VzIHNlbnQgYXQgdGhlIHNhbWUgZXhhY3QgdGltZSAobWlsbGlzZWNvbmQpLlxuXG5pbXBvcnQgUG9ydCBmcm9tICdiYXNlL2NvbW1vbi9Qb3J0JztcbmltcG9ydCBhZnRlciBmcm9tICdsb2Rhc2gvYWZ0ZXInO1xuaW1wb3J0IGZpbmQgZnJvbSAnbG9kYXNoL2ZpbmQnO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBoYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJ2xvZGFzaC92YWx1ZXMnO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnbG9kYXNoL2ZsYXR0ZW4nO1xuaW1wb3J0IHNvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuY29uc3QgaW5NZXNzYWdlc0tleSA9ICdtZXNzYWdlc190b19iYWNrZ3JvdW5kJztcbmNvbnN0IG91dE1lc3NhZ2VzS2V5ID0gJ21lc3NhZ2VzX3RvX2RvY3VtZW50cyc7XG5jb25zdCBhY2tzTWVzc2FnZXNLZXkgPSAnbWVzc2FnZXNfYWNrcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtYmVkRG9jdW1lbnRzUG9ydCBleHRlbmRzIFBvcnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5fb3V0TWVzc2FnZXNDb3VudGVyID0gMDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9oYW5kbGVJbk1lc3NhZ2VzUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IG51bGw7XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9wb3J0KSByZXR1cm47XG4gICAgdGhpcy5fcG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeTtcbiAgICB0aGlzLl9oYW5kbGVJbk1lc3NhZ2VzUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMgPSB7fTsgLy8gPG91dCBtZXNzYWdlIGlkLCBoYW5kbGVyPlxuXG4gICAgLy8gbWFrZSBzdXJlIHRvIGhhbmRsZSBhbnkgbWVzc2FnZSB0aGF0IHdhcyBzZW50IGp1c3QgYmVmb3JlIHBhZ2UgcmVsb2FkXG4gICAgdGhpcy5jaGVja0luY29taW5nTWVzc2FnZXModHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBzdXBlci5jb25uZWN0KCk7XG4gICAgICB0aGlzLl9vbkNvbm5lY3RlZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2JpbmRIYW5kbGVycygpIHtcbiAgICBpZiAoIXRoaXMuX3BvcnQpIHJldHVybjtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gWydjaGFuZ2UnLCAoKSA9PiB0aGlzLmNoZWNrSW5jb21pbmdNZXNzYWdlcygpXTtcbiAgICB0aGlzLl9wb3J0LnRhYnMub24oLi4ubGlzdGVuZXIpO1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHN1cGVyLl9iaW5kSGFuZGxlcnMoKTtcbiAgfVxuXG4gIGNoZWNrSW5jb21pbmdNZXNzYWdlcyhpbmNsdWRlSW52YWxpZFRhYnMgPSBmYWxzZSkge1xuICAgIC8vIG1ha2Ugc3VyZSB0byBoYW5kbGUgdGhlIHByZXZpb3VzIG1lc3NhZ2VzIGJlZm9yZVxuICAgIC8vIHN0YXJ0aW5nIHdpdGggdGhlIG5ldyBvbmVzICh0byBwcmV2ZW50IGRvdWJsZSBoYW5kbGluZylcbiAgICB0aGlzLl9oYW5kbGVJbk1lc3NhZ2VzUHJvbWlzZSA9IHRoaXMuX2hhbmRsZUluTWVzc2FnZXNQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgaW5jbHVkZUludmFsaWRUYWJzID8gdGhpcy5fcG9ydC50YWJzLmdldEFsbEluY2x1ZGluZ0ludmFsaWQoKSA6IHRoaXMuX3BvcnQudGFicy5nZXRBbGwoKSxcbiAgICAgICAgdGhpcy5fcG9ydC5iYWNrZ3JvdW5kLmdldCgpLFxuICAgICAgXSlcbiAgICAgIC50aGVuKGFzeW5jIChbdGFicyA9IHt9LCBiYWNrZ3JvdW5kID0ge31dKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NsZWFuT3V0Z29pbmdNZXNzYWdlcyhiYWNrZ3JvdW5kLCB0YWJzKTtcblxuICAgICAgICBjb25zdCBpbmNvbWluZ01lc3NhZ2VzID0gdGhpcy5fY2FsY3VsYXRlSW5jb21pbmdNZXNzYWdlcyh0YWJzKTtcbiAgICAgICAgY29uc3QgYWNrc01lc3NhZ2VzID0gYXdhaXQgdGhpcy5fY2xlYW5BY2tzTWVzc2FnZXMoYmFja2dyb3VuZCwgaW5jb21pbmdNZXNzYWdlcyk7XG4gICAgICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gdGhpcy5fY2FsY3VsYXRlTmV3SW5jb21pbmdNZXNzYWdlcyhpbmNvbWluZ01lc3NhZ2VzLCBhY2tzTWVzc2FnZXMpO1xuXG4gICAgICAgIGNvbnN0IHNldEl0ZW1zID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmV3TWVzc2FnZSBvZiBuZXdNZXNzYWdlcykge1xuICAgICAgICAgIGNvbnN0IGlkID0gbmV3TWVzc2FnZS5wcml2YXRlLmlkO1xuXG4gICAgICAgICAgaWYgKG5ld01lc3NhZ2UucHVibGljLl9lY2hvKSB7XG4gICAgICAgICAgICAvLyByZXNwb25zZVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdFbWJlZERvY3VtZW50c1BvcnQgcmVzcG9uc2UgbWVzc2FnZScsIG5ld01lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tuZXdNZXNzYWdlLnB1YmxpYy5fZWNob107XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW25ld01lc3NhZ2UucHVibGljLl9lY2hvXTtcbiAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyKG5ld01lc3NhZ2UucHVibGljLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhY3R1YWwgbmV3IG1lc3NhZ2VcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRW1iZWREb2N1bWVudHNQb3J0IG5ldyBtZXNzYWdlJywgbmV3TWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLl9vbk1lc3NhZ2VSZWNlaXZlZCh7XG4gICAgICAgICAgICAgIC4uLm5ld01lc3NhZ2UucHVibGljLFxuICAgICAgICAgICAgICB0YWI6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdNZXNzYWdlLnByaXZhdGUudGFiLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVJbnZhbGlkVGFicyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5fbWFrZVJlc3BvbmQobmV3TWVzc2FnZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNldCB0aGUgYWNrXG4gICAgICAgICAgc2V0SXRlbXNbYCR7YWNrc01lc3NhZ2VzS2V5fS4ke2lkfWBdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9wb3J0LmJhY2tncm91bmQuc2V0QnlQYXRoKHNldEl0ZW1zKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbk1lc3NhZ2VzUHJvbWlzZTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZSB0aGUgb3V0Z29pbmcgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSByZWxhdGl2ZSB0YWIsXG4gIC8vIHJldHVybiB0aGUgdXBkYXRlZCBvYmplY3RcbiAgYXN5bmMgX2NsZWFuT3V0Z29pbmdNZXNzYWdlcyhiYWNrZ3JvdW5kLCB0YWJzKSB7XG4gICAgY29uc3Qgb3V0Z29pbmdNZXNzYWdlcyA9IGdldChiYWNrZ3JvdW5kLCBvdXRNZXNzYWdlc0tleSkgfHwge307IC8vIG9iamVjdCA8aWQsIG1zZz5cblxuICAgIGNvbnN0IHBhdGhzVG9SZW1vdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKG91dGdvaW5nTWVzc2FnZXMpKSB7XG4gICAgICBjb25zdCBvdXRnb2luZ01lc3NhZ2UgPSBvdXRnb2luZ01lc3NhZ2VzW2lkXTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIGFzc29jaWF0ZWQgdGFiIGhhbmRsZWQgdGhlIG1lc3NhZ2VcbiAgICAgIGNvbnN0IHRhYklkID0gb3V0Z29pbmdNZXNzYWdlLnByaXZhdGUudGFiSWQ7XG4gICAgICBjb25zdCB0YWIgPSB0YWJzW3RhYklkXTtcbiAgICAgIGlmICghdGFiIHx8IGhhcyh0YWIsIGAke2Fja3NNZXNzYWdlc0tleX0uJHtpZH1gKSkge1xuICAgICAgICBwYXRoc1RvUmVtb3ZlLnB1c2goYCR7b3V0TWVzc2FnZXNLZXl9LiR7aWR9YCk7XG4gICAgICAgIGRlbGV0ZSBvdXRnb2luZ01lc3NhZ2VzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fcG9ydC5iYWNrZ3JvdW5kLnJlbW92ZUJ5UGF0aChwYXRoc1RvUmVtb3ZlKTtcblxuICAgIHJldHVybiBvdXRnb2luZ01lc3NhZ2VzO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBpbmNvbWluZyBtZXNzYWdlcyBhcyBhbiBhcnJheSBzb3J0ZWQgaW4gc2VudCBvcmRlclxuICBfY2FsY3VsYXRlSW5jb21pbmdNZXNzYWdlcyh0YWJzKSB7XG4gICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4odmFsdWVzKHRhYnMpLm1hcCh0YWIgPT4gdmFsdWVzKHRhYltpbk1lc3NhZ2VzS2V5XSB8fCB7fSkpKVxuICAgIHJldHVybiBzb3J0QnkoZmxhdCwgbXNnID0+IGdldChtc2csICdwcml2YXRlLnRpbWUnKSk7XG4gIH1cblxuICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmUgdGhlIGFja3MgYXNzb2NpYXRlZCB0byBubyBpbmNvbWluZyBtZXNzYWdlLFxuICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgb2JqZWN0XG4gIC8vIE5vdGU6IGluY29taW5nTWVzc2FnZXMgaXMgYW4gYXJyYXksIG5vdCBhbiBvYmplY3QhXG4gIGFzeW5jIF9jbGVhbkFja3NNZXNzYWdlcyhiYWNrZ3JvdW5kLCBpbmNvbWluZ01lc3NhZ2VzKSB7XG4gICAgY29uc3QgYWNrc01lc3NhZ2VzID0gZ2V0KGJhY2tncm91bmQsIGFja3NNZXNzYWdlc0tleSkgfHwge307XG5cbiAgICBjb25zdCBwYXRoc1RvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhhY2tzTWVzc2FnZXMpKSB7XG4gICAgICAvLyBpZCByZWZlciB0byB0aGUgaW5jb21pbmcgbWVzc2FnZVxuICAgICAgY29uc3QgaW5jb21pbmdNZXNzYWdlID0gZmluZChpbmNvbWluZ01lc3NhZ2VzLCBtc2cgPT4gbXNnLnByaXZhdGUuaWQgPT09IGlkKTtcbiAgICAgIGlmICghaW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHBhdGhzVG9SZW1vdmUucHVzaChgJHthY2tzTWVzc2FnZXNLZXl9LiR7aWR9YCk7XG4gICAgICAgIGRlbGV0ZSBhY2tzTWVzc2FnZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9wb3J0LmJhY2tncm91bmQucmVtb3ZlQnlQYXRoKHBhdGhzVG9SZW1vdmUpO1xuXG4gICAgcmV0dXJuIGFja3NNZXNzYWdlcztcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgTkVXIGluY29taW5nIG1lc3NhZ2VzIGJ5IHNraXBwaW5nIHRoZSBhbHJlYWR5IGhhbmRsZWQgb25lc1xuICBfY2FsY3VsYXRlTmV3SW5jb21pbmdNZXNzYWdlcyhpbmNvbWluZ01lc3NhZ2VzLCBhY2tzTWVzc2FnZXMpIHtcbiAgICByZXR1cm4gaW5jb21pbmdNZXNzYWdlcy5maWx0ZXIobXNnID0+IGhhcyhhY2tzTWVzc2FnZXMsIG1zZy5wcml2YXRlLmlkKSA9PT0gZmFsc2UpO1xuICB9XG5cbiAgX21ha2VSZXNwb25kKG5ld01lc3NhZ2UpIHtcbiAgICByZXR1cm4gKHJlc3BvbnNlKSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0VtYmVkRG9jdW1lbnRzUG9ydDogc2VuZGluZyByZXNwb25zZScsIHJlc3BvbnNlLCBuZXdNZXNzYWdlKTtcbiAgICAgIHRoaXMuc2VuZFRvT25lKG5ld01lc3NhZ2UucHJpdmF0ZS50YWIuaWQsIHtcbiAgICAgICAgX2VjaG86IG5ld01lc3NhZ2UucHJpdmF0ZS5pZCxcbiAgICAgICAgZGF0YTogcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcnQpIHJldHVybjtcbiAgICB0aGlzLl91bmJpbmRIYW5kbGVycygpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX29uRGlzY29ubmVjdGVkKCk7XG4gICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgX3VuYmluZEhhbmRsZXJzKCkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9wb3J0LnRhYnMucmVtb3ZlTGlzdGVuZXIoLi4ubGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIC8vIHNlbmQgdG8gYWxsIHRhYnNcbiAgLy8gTm90ZTogcmVzcG9uc2VIYW5kbGVyIGlzIGNhbGxlZCBvbmNlIHdpdGggYW4gb2JqZWN0IDx0YWIgaWQsIHRhYiByZXNwb25zZT5cbiAgc2VuZChtZXNzYWdlLCByZXNwb25zZUhhbmRsZXIgPSAoKSA9PiB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdFbWJlZERvY3VtZW50c1BvcnQ6IHNlbmQnLCBtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB0aGlzLmV4dGVuc2lvbi50YWJzQ29udHJvbGxlci5nZXRBbGxUYWJzKCkudGhlbih0YWJzID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmFjdGl2ZSkgdGFicyA9IHRhYnMuZmlsdGVyKHRhYiA9PiB0YWIuYWN0aXZlKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0ge307XG4gICAgICBjb25zdCBjb21wbGV0ZSA9IGFmdGVyKHRhYnMubGVuZ3RoLCByZXNwb25zZUhhbmRsZXIuYmluZChudWxsLCByZXNwb25zZXMpKTtcbiAgICAgIHRhYnMuZm9yRWFjaCh0YWIgPT4ge1xuICAgICAgICB0aGlzLnNlbmRUb09uZSh0YWIuaWQsIG1lc3NhZ2UsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIHJlc3BvbnNlc1t0YWIuaWRdID0gcmVzcG9uc2U7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuXG4gICAgc3VwZXIuc2VuZChtZXNzYWdlLCByZXNwb25zZUhhbmRsZXIpO1xuICB9XG5cbiAgc2VuZFRvT25lKHRhYklkLCBtZXNzYWdlLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICBsb2dnZXIuZGVidWcoJ0VtYmVkRG9jdW1lbnRzUG9ydDogc2VuZFRvT25lJywgbWVzc2FnZSk7XG5cbiAgICBtZXNzYWdlID0geyAuLi5tZXNzYWdlLCB0YWI6IHsgaWQ6IHRhYklkIH0gfTtcblxuICAgIC8vIEhBQ0s6IG1lc3NhZ2luZyBzZWVtcyB0byBicmVhayB3aGVuIHNlbmRUb09uZVxuICAgIC8vIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBzeW5jaHJvbm91c2x5LCBub3Qgc3VyZSB3aHkuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBuZXdPdXRNZXNzYWdlID0ge1xuICAgICAgICBwcml2YXRlOiB7XG4gICAgICAgICAgaWQ6IHRoaXMuZXh0ZW5zaW9uLmJhY2tncm91bmRJZCArICdfJyArIHRoaXMuX291dE1lc3NhZ2VzQ291bnRlcixcbiAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHRhYklkLFxuICAgICAgICB9LFxuICAgICAgICBwdWJsaWM6IG1lc3NhZ2UsXG4gICAgICB9O1xuICAgICAgdGhpcy5fb3V0TWVzc2FnZXNDb3VudGVyKys7XG5cbiAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tuZXdPdXRNZXNzYWdlLnByaXZhdGUuaWRdID0gcmVzcG9uc2VIYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3J0LmJhY2tncm91bmQuc2V0QnlQYXRoKHsgW2Ake291dE1lc3NhZ2VzS2V5fS4ke25ld091dE1lc3NhZ2UucHJpdmF0ZS5pZH1gXTogbmV3T3V0TWVzc2FnZSB9KTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZERvY3VtZW50c1BvcnQuanMiLCJpbXBvcnQgRXh0ZW5zaW9uIGZyb20gJ2Jhc2UvYmFja2dyb3VuZC9FeHRlbnNpb24nO1xuaW1wb3J0IFNoYXJlZE1lbW9yeSBmcm9tICcuL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnknO1xuaW1wb3J0IEVtYmVkU3RvcmFnZSBmcm9tICcuL0VtYmVkU3RvcmFnZSc7XG5pbXBvcnQgRW1iZWRQb3J0TWFuYWdlciBmcm9tICcuL0VtYmVkUG9ydE1hbmFnZXInO1xuaW1wb3J0IEVtYmVkRmx1eCBmcm9tICcuL0VtYmVkRmx1eCc7XG5pbXBvcnQgRW1iZWRCcm93c2VyQ2FwdHVyZSBmcm9tICcuL2NhcHR1cmUvRW1iZWRCcm93c2VyQ2FwdHVyZSc7XG5pbXBvcnQgQnJvd3NlckFjdGlvbk1hbmFnZXIgZnJvbSAnLi9Ccm93c2VyQWN0aW9uTWFuYWdlcic7XG5pbXBvcnQgRW1iZWRCcmlkZ2UgZnJvbSAnLi9FbWJlZEJyaWRnZSc7XG5pbXBvcnQgRW1iZWRUYWJzQ29udHJvbGxlciBmcm9tICcuL0VtYmVkVGFic0NvbnRyb2xsZXInO1xuaW1wb3J0IEVtYmVkUGFuZWxDb250cm9sbGVyIGZyb20gJy4vRW1iZWRQYW5lbENvbnRyb2xsZXInO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJ2Jhc2UvY29tbW9uL3NldHRpbmdzJztcbmltcG9ydCBTdHViQ29tcG9uZW50IGZyb20gJy4uL2NvbW1vbi9TdHViQ29tcG9uZW50JztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1iZWRFeHRlbnNpb24gZXh0ZW5kcyBFeHRlbnNpb24ge1xuICBnZXRVUkwocGF0aCkge1xuICAgIHJldHVybiBzZXR0aW5ncy5nZXQoJ2V4dGVuc2lvbi5lbWJlZC5iYXNlUGF0aCcpICsgJy8nICsgcGF0aDtcbiAgfVxuXG4gIGdldFBvcnRNYW5hZ2VyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkUG9ydE1hbmFnZXI7XG4gIH1cblxuICBnZXRGbHV4Q2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkRmx1eDtcbiAgfVxuXG4gIGdldFNoYXJlZE1lbW9yeUNsYXNzKCkge1xuICAgIHJldHVybiBTaGFyZWRNZW1vcnk7XG4gIH1cblxuICBnZXRTdG9yYWdlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkU3RvcmFnZTtcbiAgfVxuXG4gIGdldFRhYnNDb250cm9sbGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkVGFic0NvbnRyb2xsZXI7XG4gIH1cblxuICBnZXRQYW5lbENvbnRyb2xsZXJDbGFzcygpIHtcbiAgICByZXR1cm4gRW1iZWRQYW5lbENvbnRyb2xsZXI7XG4gIH1cblxuICBnZXRCcm93c2VyQ2FwdHVyZUNsYXNzKCkge1xuICAgIHJldHVybiBFbWJlZEJyb3dzZXJDYXB0dXJlO1xuICB9XG5cbiAgZ2V0QnJvd3NlckFjdGlvbk1hbmFnZXJDbGFzcygpIHtcbiAgICByZXR1cm4gQnJvd3NlckFjdGlvbk1hbmFnZXI7XG4gIH1cblxuICBnZXRCcmlkZ2VDbGFzcygpIHtcbiAgICByZXR1cm4gRW1iZWRCcmlkZ2U7XG4gIH1cblxuICBnZXRBdXRoQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFN0dWJDb21wb25lbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBOb3RlOiB1c2Ugc2FtZSB2ZXJzaW9uIG9mIGNocm9tZSBleHRlbnNpb24gKFZFUlNJT04gaXMgaW5zZXJ0ZWQgYnkgd2VicGFjaylcbiAgICBzdXBlcignZW1iZWQnLCBWRVJTSU9OLCAnZW1iZWQnKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZEV4dGVuc2lvbi5qcyIsImltcG9ydCBGbHV4IGZyb20gJ2Jhc2UvYmFja2dyb3VuZC9GbHV4JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1iZWRGbHV4IGV4dGVuZHMgRmx1eCB7XG4gIGZldGNoKCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLmV4dGVuc2lvbi5zaGFyZWRNZW1vcnkuYmFja2dyb3VuZC5nZXQoJ2JhY2tncm91bmRTdGF0ZScpLnRoZW4oKHN0YXRlID0ge30pID0+IHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlTWFuYWdlci5zdGF0ZSA9IHN0YXRlOyAvLyBIQUNLOiB3ZSB3YW50IHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIGltbWVkaWF0ZWx5XG4gICAgICB9KS50aGVuKCgpID0+IHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS5iYWNrZ3JvdW5kLnJlbW92ZUJ5UGF0aCgnYmFja2dyb3VuZFN0YXRlJykpLFxuXG4gICAgICB0aGlzLmV4dGVuc2lvbi5zaGFyZWRNZW1vcnkuYmFja2dyb3VuZC5nZXQoJ2NvbnRlbnRTdGF0ZXMnKS50aGVuKChzdGF0ZSA9IHt9KSA9PiB7XG4gICAgICAgIHRoaXMuY29udGVudFN0YXRlcyA9IHN0YXRlO1xuICAgICAgfSkudGhlbigoKSA9PiB0aGlzLmV4dGVuc2lvbi5zaGFyZWRNZW1vcnkuYmFja2dyb3VuZC5yZW1vdmVCeVBhdGgoJ2NvbnRlbnRTdGF0ZXMnKSksXG5cbiAgICAgIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS5iYWNrZ3JvdW5kLmdldCgncGFuZWxTdGF0ZXMnKS50aGVuKChzdGF0ZSA9IHt9KSA9PiB7XG4gICAgICAgIHRoaXMucGFuZWxTdGF0ZXMgPSBzdGF0ZTtcbiAgICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5leHRlbnNpb24uc2hhcmVkTWVtb3J5LmJhY2tncm91bmQucmVtb3ZlQnlQYXRoKCdwYW5lbFN0YXRlcycpKSxcbiAgICBdKTtcbiAgfVxuXG4gIGhhbmRsZUJhY2tncm91bmRTdGF0ZSguLi5hcmdzKSB7XG4gICAgc3VwZXIuaGFuZGxlQmFja2dyb3VuZFN0YXRlKC4uLmFyZ3MpO1xuICAgIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS5iYWNrZ3JvdW5kLmV4dGVuZEJ5UGF0aCgnYmFja2dyb3VuZFN0YXRlJywgdGhpcy5iYWNrZ3JvdW5kU3RhdGUpO1xuICB9XG5cbiAgaGFuZGxlQ29udGVudFN0YXRlKHN0YXRlLCB0YWJJZCkge1xuICAgIHN1cGVyLmhhbmRsZUNvbnRlbnRTdGF0ZShzdGF0ZSwgdGFiSWQpO1xuICAgIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS5iYWNrZ3JvdW5kLmV4dGVuZEJ5UGF0aChgY29udGVudFN0YXRlcy4ke3RhYklkfWAsIHN0YXRlKTtcbiAgfVxuXG4gIGhhbmRsZVBhbmVsU3RhdGUoc3RhdGUsIHRhYklkKSB7XG4gICAgc3VwZXIuaGFuZGxlUGFuZWxTdGF0ZShzdGF0ZSwgdGFiSWQpO1xuICAgIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS5iYWNrZ3JvdW5kLmV4dGVuZEJ5UGF0aChgcGFuZWxTdGF0ZXMuJHt0YWJJZH1gLCBzdGF0ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2JhY2tncm91bmQvRW1iZWRGbHV4LmpzIiwiaW1wb3J0IFBhbmVsQ29udHJvbGxlciBmcm9tICdiYXNlL2JhY2tncm91bmQvUGFuZWxDb250cm9sbGVyJztcblxuaW1wb3J0IHtnZXRGaWxlTG9nZ2VyfSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9sb2dnZXInO1xuY29uc3QgbG9nZ2VyID0gZ2V0RmlsZUxvZ2dlcihfX2ZpbGVuYW1lKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1iZWRQYW5lbENvbnRyb2xsZXIgZXh0ZW5kcyBQYW5lbENvbnRyb2xsZXIge1xuICBpc1BhbmVsT3Blbih0YWJJZCkge1xuICAgIHJldHVybiB0aGlzLm93bkNvbnRleHQoKS5zdGF0ZS5pc1BhbmVsT3BlbjtcbiAgfVxuXG4gIHNob3VsZFBhbmVsT3Blbk9uTmV3VGFiKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFuZWxPcGVuKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VtYmVkL2JhY2tncm91bmQvRW1iZWRQYW5lbENvbnRyb2xsZXIuanMiLCJpbXBvcnQgUG9ydE1hbmFnZXIgZnJvbSAnYmFzZS9iYWNrZ3JvdW5kL1BvcnRNYW5hZ2VyJztcbmltcG9ydCBFbWJlZERvY3VtZW50c1BvcnQgZnJvbSAnLi9FbWJlZERvY3VtZW50c1BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZFBvcnRNYW5hZ2VyIGV4dGVuZHMgUG9ydE1hbmFnZXIge1xuICBnZXREb2N1bWVudHNQb3J0Q2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkRG9jdW1lbnRzUG9ydDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZFBvcnRNYW5hZ2VyLmpzIiwiaW1wb3J0IENvbW1vbkVtYmVkU3RvcmFnZSBmcm9tICdlbWJlZC9jb21tb24vRW1iZWRTdG9yYWdlJztcbmltcG9ydCBPYmplY3RTdG9yZSBmcm9tICdlbWJlZC9jb21tb24vc2hhcmVkTWVtb3J5L09iamVjdFN0b3JlJztcbmltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcblxuY29uc3Qgc3RvcmFnZVJlcXVlc3RXaGl0ZWxpc3QgPSBbJ3NldCcsICdyZW1vdmUnLCAnY2xlYXInXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1iZWRTdG9yYWdlIGV4dGVuZHMgQ29tbW9uRW1iZWRTdG9yYWdlIHtcbiAgc3RhcnQoLi4uYXJncykge1xuICAgIHN1cGVyLnN0YXJ0KC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5fb2JqZWN0U3RvcmUgPSBuZXcgT2JqZWN0U3RvcmUobmFtZXNwYWNlKCdzdG9yYWdlJyksICdyZWFkd3JpdGUnKTtcbiAgICB0aGlzLnNldHVwRG9jdW1lbnRzKCk7XG4gIH1cblxuICBzZXR1cERvY3VtZW50cygpIHtcbiAgICB0aGlzLmRvY3VtZW50c1BvcnQgPSB0aGlzLmV4dGVuc2lvbi5wb3J0TWFuYWdlci5kb2N1bWVudHNQb3J0O1xuICAgIHRoaXMuZG9jdW1lbnRzUG9ydC5vbignbWVzc2FnZScsIHRoaXMuaGFuZGxlRG9jdW1lbnRzTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGhhbmRsZURvY3VtZW50c01lc3NhZ2UobWVzc2FnZSwgcmVzcG9uZCkge1xuICAgIG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YSB8fCB7fTtcblxuICAgIGlmIChtZXNzYWdlLnRvcGljID09PSAnc3RvcmFnZVJlcXVlc3QnKSB7XG4gICAgICB0aGlzLl9leGVjdXRlU3RvcmFnZVJlcXVlc3QobWVzc2FnZS5kYXRhKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAoLi4uYXJncykgPT4gcmVzcG9uZCh7IHN0YXR1czogJ3N1Y2Nlc3MnLCBhcmdzIH0pLFxuICAgICAgICAgICguLi5hcmdzKSA9PiByZXNwb25kKHsgc3RhdHVzOiAnZmFpbHVyZScsIGFyZ3MgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZXhlY3V0ZVN0b3JhZ2VSZXF1ZXN0KHsgdHlwZSwgYXJncyB9KSB7XG4gICAgaWYgKHN0b3JhZ2VSZXF1ZXN0V2hpdGVsaXN0LmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyAnc3RvcmFnZVJlcXVlc3Q6IGludmFsaWQgdHlwZSAnICsgdHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0U3RvcmVbdHlwZV0uYXBwbHkodGhpcy5fb2JqZWN0U3RvcmUsIGFyZ3MpO1xuICB9XG5cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0U3RvcmUuZ2V0KC4uLmFyZ3MpO1xuICB9XG5cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0U3RvcmUuc2V0KC4uLmFyZ3MpO1xuICB9XG5cbiAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0U3RvcmUucmVtb3ZlKC4uLmFyZ3MpO1xuICB9XG5cbiAgY2xlYXIoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RTdG9yZS5jbGVhciguLi5hcmdzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9FbWJlZFN0b3JhZ2UuanMiLCJpbXBvcnQgVGFic0NvbnRyb2xsZXIgZnJvbSAnYmFzZS9iYWNrZ3JvdW5kL1RhYnNDb250cm9sbGVyJztcbmltcG9ydCBmaWx0ZXIgZnJvbSAnbG9kYXNoL2ZpbHRlcic7XG5pbXBvcnQgZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJ2xvZGFzaC92YWx1ZXMnO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZFRhYnNDb250cm9sbGVyIGV4dGVuZHMgVGFic0NvbnRyb2xsZXIge1xuICBsaXN0ZW5UYWJPblVwZGF0ZWQoY2FsbGJhY2spIHtcbiAgICAvLyBuby1vcFxuICB9XG5cbiAgbGlzdGVuVGFiT25BY3RpdmF0ZWQoY2FsbGJhY2spIHtcbiAgICBsZXQgY3VycmVudEFjdGl2ZVRhYiA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb24uc2hhcmVkTWVtb3J5LnRhYnMub24oJ2NoYW5nZScsICh7IG5ld1ZhbHVlIH0pID0+IHtcbiAgICAgIGNvbnN0IG5ld1RhYnMgPSBuZXdWYWx1ZSB8fCB7fTtcblxuICAgICAgY29uc3QgbmV3QWN0aXZlVGFicyA9IGZpbHRlcihuZXdUYWJzLCB0YWIgPT4gdGFiLnB1YmxpYy5hY3RpdmUpO1xuICAgICAgaWYgKG5ld0FjdGl2ZVRhYnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnaW50ZXJtZWRpYXRlIGNoYW5nZScsIG5ld1RhYnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0FjdGl2ZVRhYiA9IG5ld0FjdGl2ZVRhYnNbMF07XG4gICAgICBpZiAobmV3QWN0aXZlVGFiKSB7XG4gICAgICAgIC8vIHdhcyBpdCBhbHJlYWR5IGFjdGl2ZT9cbiAgICAgICAgaWYgKCFjdXJyZW50QWN0aXZlVGFiIHx8IGN1cnJlbnRBY3RpdmVUYWIucHVibGljLmlkICE9PSBuZXdBY3RpdmVUYWIucHVibGljLmlkKSB7XG4gICAgICAgICAgLy8gbm9wZSwgbmV3IGFjdGl2YXRpb24hXG4gICAgICAgICAgY3VycmVudEFjdGl2ZVRhYiA9IG5ld0FjdGl2ZVRhYjtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xpc3RlblRhYk9uQWN0aXZhdGVkJywgbmV3VGFicyk7XG4gICAgICAgICAgY2FsbGJhY2soeyB0YWJJZDogbmV3QWN0aXZlVGFiLnB1YmxpYy5pZCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbGlzdGVuVGFiT25SZW1vdmVkKGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgZ2V0VGFiKHRhYklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS50YWJzLmdldEFsbCgpLnRoZW4oKHRhYnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgdGFiID0gZmluZCh0YWJzLCB0YWIgPT4gdGFiLnB1YmxpYy5pZCA9PT0gdGFiSWQpO1xuXG4gICAgICBpZiAoIXRhYikgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyB0YWIgd2l0aCBpZCAke3RhYklkfWApO1xuICAgICAgZWxzZSByZXR1cm4gdGFiLnB1YmxpYztcbiAgICB9KTtcbiAgfVxuXG4gIGdldEFjdGl2ZVRhYklkKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbi5zaGFyZWRNZW1vcnkudGFicy5nZXRBbGwoKS50aGVuKCh0YWJzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHRhYiA9IGZpbmQodGFicywgdGFiID0+IHRhYi5wdWJsaWMuYWN0aXZlKTtcbiAgICAgIHJldHVybiB0YWIgPyB0YWIucHVibGljLmlkIDogbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEFsbFRhYnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uLnNoYXJlZE1lbW9yeS50YWJzLmdldEFsbCgpLnRoZW4oKHRhYnMgPSB7fSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlcyh0YWJzKS5tYXAodGFiID0+IHRhYi5wdWJsaWMpO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9iYWNrZ3JvdW5kL0VtYmVkVGFic0NvbnRyb2xsZXIuanMiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ25vZGUtZXZlbnQtZW1pdHRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtYmVkQnJvd3NlckNhcHR1cmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvLyBkdW1teSBpbXBsZW1lbnRhdGlvblxuICBzdGFydChleHRlbnNpb24pIHtcbiAgICB0aGlzLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvYmFja2dyb3VuZC9jYXB0dXJlL0VtYmVkQnJvd3NlckNhcHR1cmUuanMiLCJpbXBvcnQgQ29tbW9uU2hhcmVkTWVtb3J5IGZyb20gJ2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5JztcbmltcG9ydCBPYmplY3RTdG9yZSBmcm9tICdlbWJlZC9jb21tb24vc2hhcmVkTWVtb3J5L09iamVjdFN0b3JlJztcbmltcG9ydCBUYWJzU3RvcmUgZnJvbSAnZW1iZWQvY29tbW9uL3NoYXJlZE1lbW9yeS9UYWJzU3RvcmUnO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFyZWRNZW1vcnkgZXh0ZW5kcyBDb21tb25TaGFyZWRNZW1vcnkge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBjb25zdCBiYWNrZ3JvdW5kS2V5ID0gbmFtZXNwYWNlKCdiYWNrZ3JvdW5kJyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgT2JqZWN0U3RvcmUoYmFja2dyb3VuZEtleSwgJ3JlYWR3cml0ZScpO1xuICAgIHRoaXMudGFicyA9IG5ldyBUYWJzU3RvcmUoeyBjbGVhbkludmFsaWRUYWJzOiB0cnVlIH0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9iYWNrZ3JvdW5kL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnkuanMiLCJpbXBvcnQgUG9ydCBmcm9tICdiYXNlL2NvbW1vbi9Qb3J0JztcbmltcG9ydCBuYW1lc3BhY2UgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbmFtZXNwYWNlJztcbmltcG9ydCBmaW5kIGZyb20gJ2xvZGFzaC9maW5kJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgaGFzIGZyb20gJ2xvZGFzaC9oYXMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICdsb2Rhc2gvdmFsdWVzJztcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5cbmltcG9ydCB7Z2V0RmlsZUxvZ2dlcn0gZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvbG9nZ2VyJztcbmNvbnN0IGxvZ2dlciA9IGdldEZpbGVMb2dnZXIoX19maWxlbmFtZSk7XG5cbmNvbnN0IGluTWVzc2FnZXNLZXkgPSAnbWVzc2FnZXNfdG9fZG9jdW1lbnRzJztcbmNvbnN0IG91dE1lc3NhZ2VzS2V5ID0gJ21lc3NhZ2VzX3RvX2JhY2tncm91bmQnO1xuY29uc3QgYWNrc01lc3NhZ2VzS2V5ID0gJ21lc3NhZ2VzX2Fja3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZEJhY2tncm91bmRQb3J0IGV4dGVuZHMgUG9ydCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLl9vdXRNZXNzYWdlc0NvdW50ZXIgPSAwO1xuICAgIHRoaXMuX3RvcEZyYW1lSWQgPSBudWxsO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fd2luZG93TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5faGFuZGxlSW5NZXNzYWdlc1Byb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMgPSBudWxsO1xuICAgIHRoaXMuX2Nvbm5lY3RUaW1lID0gbnVsbDtcbiAgfVxuXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuX3BvcnQpIHJldHVybjtcbiAgICB0aGlzLl9wb3J0ID0gdGhpcy5leHRlbnNpb24uc2hhcmVkTWVtb3J5O1xuICAgIHRoaXMuX2hhbmRsZUluTWVzc2FnZXNQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IHt9OyAvLyA8b3V0IG1lc3NhZ2UgaWQsIGhhbmRsZXI+XG4gICAgdGhpcy5fY29ubmVjdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX3NlbmRXaW5kb3dNZXNzYWdlVG9Ub3BGcmFtZSgnZW1iZWRCYWNrZ3JvdW5kUG9ydF9yZWdpc3RlcicpO1xuICAgIHN1cGVyLmNvbm5lY3QoKTtcbiAgICB0aGlzLl9vbkNvbm5lY3RlZCgpO1xuICB9XG5cbiAgX2JpbmRIYW5kbGVycygpIHtcbiAgICBpZiAoIXRoaXMuX3BvcnQpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmV4dGVuc2lvbi5pc1RvcEZyYW1lKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IFsnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaGFuZGxlIHRoZSBwcmV2aW91cyBtZXNzYWdlcyBiZWZvcmVcbiAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCB0aGUgbmV3IG9uZXMgKHRvIHByZXZlbnQgZG91YmxlIGhhbmRsaW5nKVxuICAgICAgICB0aGlzLl9oYW5kbGVJbk1lc3NhZ2VzUHJvbWlzZSA9IHRoaXMuX2hhbmRsZUluTWVzc2FnZXNQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLl9wb3J0LnRhYi5nZXQoKSxcbiAgICAgICAgICAgIHRoaXMuX3BvcnQuYmFja2dyb3VuZC5nZXQoKSxcbiAgICAgICAgICBdKVxuICAgICAgICAgIC50aGVuKGFzeW5jIChbdGFiID0ge30sIGJhY2tncm91bmQgPSB7fV0pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsZWFuT3V0Z29pbmdNZXNzYWdlcyh0YWIsIGJhY2tncm91bmQpO1xuXG4gICAgICAgICAgICBjb25zdCBpbmNvbWluZ01lc3NhZ2VzID0gdGhpcy5fY2FsY3VsYXRlSW5jb21pbmdNZXNzYWdlcyhiYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGFja3NNZXNzYWdlcyA9IGF3YWl0IHRoaXMuX2NsZWFuQWNrc01lc3NhZ2VzKHRhYiwgaW5jb21pbmdNZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBuZXdNZXNzYWdlcyA9IHRoaXMuX2NhbGN1bGF0ZU5ld0luY29taW5nTWVzc2FnZXMoaW5jb21pbmdNZXNzYWdlcywgYWNrc01lc3NhZ2VzKTtcblxuICAgICAgICAgICAgY29uc3Qgc2V0SXRlbXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmV3TWVzc2FnZSBvZiBuZXdNZXNzYWdlcykge1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IG5ld01lc3NhZ2UucHJpdmF0ZS5pZDtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVJbmNvbWluZ01lc3NhZ2UobmV3TWVzc2FnZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3NlbmRXaW5kb3dNZXNzYWdlVG9DaGlsZEZyYW1lcygnZW1iZWRCYWNrZ3JvdW5kUG9ydF9uZXdJbmNvbWluZ01lc3NhZ2UnLCBuZXdNZXNzYWdlKTtcblxuICAgICAgICAgICAgICAvLyBzZXQgdGhlIGFja1xuICAgICAgICAgICAgICBzZXRJdGVtc1tgJHthY2tzTWVzc2FnZXNLZXl9LiR7aWR9YF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9ydC50YWIuc2V0QnlQYXRoKHNldEl0ZW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XTtcbiAgICAgIHRoaXMuX3BvcnQudGFicy5vbiguLi5saXN0ZW5lcik7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gUmVjZWl2ZSBjaGlsZCBmcmFtZSBtZXNzYWdlc1xuICAgIGNvbnN0IGluV2luZG93TGlzdGVuZXIgPSBbJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgLy9pZiAoZXZlbnQuc291cmNlICE9PSB3aW5kb3cpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcgfHwgbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKG1lc3NhZ2UuZnJvbSAhPT0gbmFtZXNwYWNlKCdjb250ZW50JykgfHwgbWVzc2FnZS50byAhPT0gbmFtZXNwYWNlKCdjb250ZW50JykpIHJldHVybjtcbiAgICAgIC8vbG9nZ2VyLmRlYnVnKCdFbWJlZEJhY2tncm91bmRQb3J0OiByZWNlaXZlZCBjb250ZW50IG1lc3NhZ2UnLCBtZXNzYWdlKTtcblxuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdlbWJlZEJhY2tncm91bmRQb3J0X3JlZ2lzdGVyJyAmJiB0aGlzLmV4dGVuc2lvbi5pc1RvcEZyYW1lKSB7XG4gICAgICAgIHRoaXMuX3RvcEZyYW1lSWQgPSB0aGlzLmV4dGVuc2lvbi5mcmFtZUlkO1xuICAgICAgICB0aGlzLl9zZW5kV2luZG93TWVzc2FnZVRvQ2hpbGRGcmFtZXMoJ2VtYmVkQmFja2dyb3VuZFBvcnRfdG9wRnJhbWVJZCcsIHRoaXMuZXh0ZW5zaW9uLmZyYW1lSWQpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdlbWJlZEJhY2tncm91bmRQb3J0X3RvcEZyYW1lSWQnKSB7XG4gICAgICAgIHRoaXMuX3RvcEZyYW1lSWQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIHRoaXMuX3NlbmRXaW5kb3dNZXNzYWdlVG9DaGlsZEZyYW1lcyhtZXNzYWdlLnRvcGljLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdlbWJlZEJhY2tncm91bmRQb3J0X25ld0luY29taW5nTWVzc2FnZScpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlSW5jb21pbmdNZXNzYWdlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIHRoaXMuX3NlbmRXaW5kb3dNZXNzYWdlVG9DaGlsZEZyYW1lcyhtZXNzYWdlLnRvcGljLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudG9waWMgPT09ICdlbWJlZEJhY2tncm91bmRQb3J0X3NlbmQnKSB0aGlzLl9yZWFsU2VuZChtZXNzYWdlLmRhdGEpO1xuICAgIH0sIGZhbHNlXTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciguLi5pbldpbmRvd0xpc3RlbmVyKTtcbiAgICB0aGlzLl93aW5kb3dMaXN0ZW5lcnMucHVzaChpbldpbmRvd0xpc3RlbmVyKTtcblxuICAgIHN1cGVyLl9iaW5kSGFuZGxlcnMoKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZSB0aGUgb3V0Z29pbmcgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gYWxyZWFkeSBoYW5kbGVkIGJ5IHRoZSByZWxhdGl2ZSB0YWIsXG4gIC8vIHJldHVybiB0aGUgdXBkYXRlZCBvYmplY3RcbiAgYXN5bmMgX2NsZWFuT3V0Z29pbmdNZXNzYWdlcyh0YWIsIGJhY2tncm91bmQpIHtcbiAgICBjb25zdCBvdXRnb2luZ01lc3NhZ2VzID0gZ2V0KHRhYiwgb3V0TWVzc2FnZXNLZXkpIHx8IHt9OyAvLyBvYmplY3QgPGlkLCBtc2c+XG5cbiAgICBjb25zdCBwYXRoc1RvUmVtb3ZlID0gW107XG4gICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhvdXRnb2luZ01lc3NhZ2VzKSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIGJhY2tncm91bmQgaGFuZGxlZCB0aGUgbWVzc2FnZVxuICAgICAgaWYgKGhhcyhiYWNrZ3JvdW5kLCBgJHthY2tzTWVzc2FnZXNLZXl9LiR7aWR9YCkpIHtcbiAgICAgICAgcGF0aHNUb1JlbW92ZS5wdXNoKGAke291dE1lc3NhZ2VzS2V5fS4ke2lkfWApO1xuICAgICAgICBkZWxldGUgb3V0Z29pbmdNZXNzYWdlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3BvcnQudGFiLnJlbW92ZUJ5UGF0aChwYXRoc1RvUmVtb3ZlKTtcblxuICAgIHJldHVybiBvdXRnb2luZ01lc3NhZ2VzO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBpbmNvbWluZyBtZXNzYWdlcyBhcyBhbiBhcnJheSBzb3J0ZWQgaW4gc2VudCBvcmRlclxuICBfY2FsY3VsYXRlSW5jb21pbmdNZXNzYWdlcyhiYWNrZ3JvdW5kKSB7XG4gICAgY29uc3QgdmFscyA9IHZhbHVlcyhiYWNrZ3JvdW5kW2luTWVzc2FnZXNLZXldKS5maWx0ZXIobXNnID0+IG1zZy5wcml2YXRlLnRhYklkID09PSB0aGlzLl90b3BGcmFtZUlkKTtcbiAgICByZXR1cm4gc29ydEJ5KHZhbHMsIG1zZyA9PiBnZXQobXNnLCAncHJpdmF0ZS50aW1lJykpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlIHRoZSBhY2tzIGFzc29jaWF0ZWQgdG8gbm8gaW5jb21pbmcgbWVzc2FnZSxcbiAgLy8gcmV0dXJuIHRoZSB1cGRhdGVkIG9iamVjdFxuICAvLyBOb3RlOiBpbmNvbWluZ01lc3NhZ2VzIGlzIGFuIGFycmF5LCBub3QgYW4gb2JqZWN0IVxuICBhc3luYyBfY2xlYW5BY2tzTWVzc2FnZXModGFiLCBpbmNvbWluZ01lc3NhZ2VzKSB7XG4gICAgY29uc3QgYWNrc01lc3NhZ2VzID0gZ2V0KHRhYiwgYWNrc01lc3NhZ2VzS2V5KSB8fCB7fTtcblxuICAgIGNvbnN0IHBhdGhzVG9SZW1vdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKGFja3NNZXNzYWdlcykpIHtcbiAgICAgIC8vIGlkIHJlZmVyIHRvIHRoZSBpbmNvbWluZyBtZXNzYWdlXG4gICAgICBjb25zdCBpbmNvbWluZ01lc3NhZ2UgPSBmaW5kKGluY29taW5nTWVzc2FnZXMsIG1zZyA9PiBtc2cucHJpdmF0ZS5pZCA9PT0gaWQpO1xuICAgICAgaWYgKCFpbmNvbWluZ01lc3NhZ2UpIHtcbiAgICAgICAgcGF0aHNUb1JlbW92ZS5wdXNoKGAke2Fja3NNZXNzYWdlc0tleX0uJHtpZH1gKTtcbiAgICAgICAgZGVsZXRlIGFja3NNZXNzYWdlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX3BvcnQudGFiLnJlbW92ZUJ5UGF0aChwYXRoc1RvUmVtb3ZlKTtcblxuICAgIHJldHVybiBhY2tzTWVzc2FnZXM7XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIE5FVyBpbmNvbWluZyBtZXNzYWdlcyBieSBza2lwcGluZyB0aGUgYWxyZWFkeSBoYW5kbGVkIG9uZXNcbiAgX2NhbGN1bGF0ZU5ld0luY29taW5nTWVzc2FnZXMoaW5jb21pbmdNZXNzYWdlcywgYWNrc01lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIGluY29taW5nTWVzc2FnZXMuZmlsdGVyKG1zZyA9PiBoYXMoYWNrc01lc3NhZ2VzLCBtc2cucHJpdmF0ZS5pZCkgPT09IGZhbHNlKTtcbiAgfVxuXG4gIC8vIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZXZlcnkgbmV3IGluY29taW5nIG1lc3NhZ2UsIGluIGV2ZXJ5IGZyYW1lIChtYWluIGFuZCBjaGlsZHMpXG4gIF9oYW5kbGVJbmNvbWluZ01lc3NhZ2UobmV3TWVzc2FnZSkge1xuICAgIGlmIChuZXdNZXNzYWdlLnByaXZhdGUudGltZSA8PSB0aGlzLl9jb25uZWN0VGltZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdFbWJlZEJhY2tncm91bmRQb3J0IG9sZCBtZXNzYWdlJywgbmV3TWVzc2FnZSwgbmV3TWVzc2FnZS5wcml2YXRlLnRpbWUgLSB0aGlzLl9jb25uZWN0VGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5ld01lc3NhZ2UucHVibGljLl9lY2hvKSB7XG4gICAgICAvLyByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tuZXdNZXNzYWdlLnB1YmxpYy5fZWNob107XG4gICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnRW1iZWRCYWNrZ3JvdW5kUG9ydCByZXNwb25zZSBtZXNzYWdlJywgbmV3TWVzc2FnZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW25ld01lc3NhZ2UucHVibGljLl9lY2hvXTtcbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyKG5ld01lc3NhZ2UucHVibGljLmRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhY3R1YWwgbmV3IG1lc3NhZ2VcbiAgICAgIGxvZ2dlci5kZWJ1ZygnRW1iZWRCYWNrZ3JvdW5kUG9ydCBuZXcgbWVzc2FnZScsIG5ld01lc3NhZ2UpO1xuICAgICAgdGhpcy5fb25NZXNzYWdlUmVjZWl2ZWQobmV3TWVzc2FnZS5wdWJsaWMsIHRoaXMuX21ha2VSZXNwb25kKG5ld01lc3NhZ2UpKTtcbiAgICB9XG4gIH1cblxuICBfbWFrZVJlc3BvbmQobmV3TWVzc2FnZSkge1xuICAgIHJldHVybiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnRW1iZWRCYWNrZ3JvdW5kUG9ydDogc2VuZGluZyByZXNwb25zZScsIHJlc3BvbnNlLCBuZXdNZXNzYWdlKTtcbiAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgIF9lY2hvOiBuZXdNZXNzYWdlLnByaXZhdGUuaWQsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLl9wb3J0KSByZXR1cm47XG4gICAgdGhpcy5fdW5iaW5kSGFuZGxlcnMoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl9vbkRpc2Nvbm5lY3RlZCgpO1xuICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIF91bmJpbmRIYW5kbGVycygpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdGhpcy5fcG9ydC50YWJzLnJlbW92ZUxpc3RlbmVyKC4uLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHdpbmRvd0xpc3RlbmVyIG9mIHRoaXMuX3dpbmRvd0xpc3RlbmVycykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoLi4ud2luZG93TGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLl93aW5kb3dMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIHNlbmQobWVzc2FnZSwgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdFbWJlZEJhY2tncm91bmRQb3J0OiBzZW5kJywgbWVzc2FnZSk7XG5cbiAgICBjb25zdCBuZXdPdXRNZXNzYWdlID0ge1xuICAgICAgcHJpdmF0ZToge1xuICAgICAgICBpZDogdGhpcy5leHRlbnNpb24uZnJhbWVJZCArICdfJyArIHRoaXMuX291dE1lc3NhZ2VzQ291bnRlcixcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgdGFiOiBudWxsLCAvLyB0aGUgdG9wIGZyYW1lIHdpbGwgc2V0IGl0XG4gICAgICB9LFxuICAgICAgcHVibGljOiBtZXNzYWdlLFxuICAgIH07XG4gICAgdGhpcy5fb3V0TWVzc2FnZXNDb3VudGVyKys7XG5cbiAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW25ld091dE1lc3NhZ2UucHJpdmF0ZS5pZF0gPSByZXNwb25zZUhhbmRsZXI7XG4gICAgfVxuXG4gICAgLy8gc2VuZCB0byB0b3AgZnJhbWUgKG91ciBzYW1lIGZyYW1lIGlmIHdlIGFyZSBpbiB0aGUgdG9wIGZyYW1lKVxuICAgIHRoaXMuX3NlbmRXaW5kb3dNZXNzYWdlVG9Ub3BGcmFtZSgnZW1iZWRCYWNrZ3JvdW5kUG9ydF9zZW5kJywgbmV3T3V0TWVzc2FnZSk7XG4gIH1cblxuICAvLyBOb3RlOiB0aGlzIHNob3VsZCBiZSB1c2VkIG9ubHkgYnkgdGhlIHRvcCBmcmFtZS5cbiAgX3JlYWxTZW5kKG5ld091dE1lc3NhZ2UpIHtcbiAgICAvLyB0b3AgZnJhbWUgaW5mbyAoaS5lLiB0aGUgdGFiIGluZm8pXG4gICAgbmV3T3V0TWVzc2FnZS5wcml2YXRlLnRhYiA9IHtcbiAgICAgIGlkOiB0aGlzLmV4dGVuc2lvbi5mcmFtZUlkLFxuICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICB9O1xuXG4gICAgdGhpcy5fcG9ydC50YWIuc2V0QnlQYXRoKHsgW2Ake291dE1lc3NhZ2VzS2V5fS4ke25ld091dE1lc3NhZ2UucHJpdmF0ZS5pZH1gXTogbmV3T3V0TWVzc2FnZSB9KTtcbiAgfVxuXG4gIF9zZW5kV2luZG93TWVzc2FnZVRvVG9wRnJhbWUodG9waWMsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fbWFrZVdpbmRvd01lc3NhZ2UodG9waWMsIGRhdGEpO1xuICAgIHdpbmRvdy50b3AucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbiAgfVxuXG4gIF9zZW5kV2luZG93TWVzc2FnZVRvQ2hpbGRGcmFtZXModG9waWMsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fbWFrZVdpbmRvd01lc3NhZ2UodG9waWMsIGRhdGEpO1xuXG4gICAgY29uc3QgY2hpbGRGcmFtZVdpbmRvd3MgPSBBcnJheS5mcm9tKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpZnJhbWUnKSkubWFwKGlmcmFtZSA9PiBpZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZEZyYW1lV2luZG93cy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRGcmFtZVdpbmRvd3NbaV0ucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcbiAgICB9XG4gIH1cblxuICBfbWFrZVdpbmRvd01lc3NhZ2UodG9waWMsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9waWMsXG4gICAgICBkYXRhLFxuICAgICAgZnJvbTogbmFtZXNwYWNlKCdjb250ZW50JyksXG4gICAgICB0bzogbmFtZXNwYWNlKCdjb250ZW50JyksXG4gICAgfTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvY29udGVudC9FbWJlZEJhY2tncm91bmRQb3J0LmpzIiwiaW1wb3J0IEV4dGVuc2lvbiBmcm9tICdiYXNlL2NvbnRlbnQvRXh0ZW5zaW9uJztcbmltcG9ydCBTaGFyZWRNZW1vcnkgZnJvbSAnLi9zaGFyZWRNZW1vcnkvU2hhcmVkTWVtb3J5JztcbmltcG9ydCBFbWJlZFN0b3JhZ2UgZnJvbSAnLi9FbWJlZFN0b3JhZ2UnO1xuaW1wb3J0IEVtYmVkUG9ydE1hbmFnZXIgZnJvbSAnLi9FbWJlZFBvcnRNYW5hZ2VyJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICdiYXNlL2NvbW1vbi9zZXR0aW5ncyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnbG9kYXNoL2RlZmF1bHRzJztcbmltcG9ydCBTdHViQ29tcG9uZW50IGZyb20gJy4uL2NvbW1vbi9TdHViQ29tcG9uZW50JztcbmltcG9ydCBFbWJlZFBhbmVsQ29udHJvbGxlciBmcm9tICcuL0VtYmVkUGFuZWxDb250cm9sbGVyJztcblxuZnVuY3Rpb24gZ2V0RW1iZWRPcHRpb25zKCkge1xuICBpZiAod2luZG93LmlvcmFkV2lkZ2V0T3B0aW9ucykgcmV0dXJuIHdpbmRvdy5pb3JhZFdpZGdldE9wdGlvbnM7XG5cbiAgLy8gbGVnYWN5XG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtkYXRhLWlvcmFkLXVzZXItaWRdJyk7XG4gIGNvbnN0IGNvbG9ycyA9IHtcbiAgICBtYWluOiBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLWlvcmFkLXdpZGdldC1jb2xvcicpLFxuICAgIG5hdmFCYXI6IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW9yYWQtd2lkZ2V0LW5hdkJhckNvbG9yJyksXG4gICAgYWN0aW9uQnV0dG9uOiBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLWlvcmFkLXdpZGdldC1hY3Rpb25CdXR0b25Db2xvcicpLFxuICAgIGhpZ2hsaWdodDogc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1pb3JhZC13aWRnZXQtaGlnaGxpZ2h0Q29sb3InKSxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB1c2VySWQ6IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW9yYWQtdXNlci1pZCcpLFxuICAgIHByZW1pdW06IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW9yYWQtcHJlbWl1bScpLFxuICAgIGNvbG9yczogZGVmYXVsdHMoY29sb3JzLCBzZXR0aW5ncy5nZXQoJ2RlZmF1bHRDb2xvcnMnKSksXG4gICAgaWNvbjogc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1pb3JhZC13aWRnZXQtaWNvbicpLFxuICAgIGNvbWJpbmVJbnRlcmNvbTogc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1pb3JhZC1jb21iaW5lLWludGVyY29tJyksXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtYmVkRXh0ZW5zaW9uIGV4dGVuZHMgRXh0ZW5zaW9uIHtcbiAgZ2V0VVJMKHBhdGgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gJy8nICsgcGF0aDtcbiAgICBjb25zdCBzY3JpcHRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtkYXRhLWlvcmFkLXVzZXItaWRdJyk7XG4gICAgY29uc3Qgc2NyaXB0VVJMID0gc2NyaXB0RWwuc3JjO1xuICAgIGlmIChzY3JpcHRVUkwpIHtcbiAgICAgIHJldHVybiBzY3JpcHRVUkwuc2xpY2UoMCwgc2NyaXB0VVJMLmxhc3RJbmRleE9mKCcvJykpICsgcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzLmdldCgnZXh0ZW5zaW9uLmVtYmVkLmJhc2VQYXRoJykgKyBwYXRoO1xuICB9XG5cbiAgZ2V0UG9ydE1hbmFnZXJDbGFzcygpIHtcbiAgICByZXR1cm4gRW1iZWRQb3J0TWFuYWdlcjtcbiAgfVxuXG4gIGdldFNoYXJlZE1lbW9yeUNsYXNzKCkge1xuICAgIHJldHVybiBTaGFyZWRNZW1vcnk7XG4gIH1cblxuICBnZXRTdG9yYWdlQ2xhc3MoKSB7XG4gICAgcmV0dXJuIEVtYmVkU3RvcmFnZTtcbiAgfVxuXG4gIGdldE92ZXJsYXlDb250cm9sbGVyQ2xhc3MoKSB7XG4gICAgLy8gT1BUSU1JWkFUSU9OXG4gICAgcmV0dXJuIFN0dWJDb21wb25lbnQ7XG4gIH1cblxuICBnZXRQYW5lbENvbnRyb2xsZXJDbGFzcygpIHtcbiAgICByZXR1cm4gRW1iZWRQYW5lbENvbnRyb2xsZXI7XG4gIH1cblxuICBnZXREb2N1bWVudENhcHR1cmVDbGFzcygpIHtcbiAgICByZXR1cm4gU3R1YkNvbXBvbmVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIE5vdGU6IHVzZSBzYW1lIHZlcnNpb24gb2YgY2hyb21lIGV4dGVuc2lvblxuICAgIHN1cGVyKCdlbWJlZCcsIFZFUlNJT04sICdlbWJlZCcpO1xuXG4gICAgdGhpcy5lbWJlZE9wdGlvbnMgPSBnZXRFbWJlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW1iZWQvY29udGVudC9FbWJlZEV4dGVuc2lvbi5qcyIsImltcG9ydCBQYW5lbENvbnRyb2xsZXIgZnJvbSAnYmFzZS9jb250ZW50L1BhbmVsQ29udHJvbGxlcic7XG5pbXBvcnQgYXBwZW5kT25Cb2R5TGF0ZXIgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvYXBwZW5kT25Cb2R5TGF0ZXInO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuaW1wb3J0IGlzTW9iaWxlQnJvd3NlcnMgZnJvbSAnYmFzZS9jb21tb24vdXRpbHMvaXNNb2JpbGVCcm93c2Vycyc7XG5pbXBvcnQgeyBnZXRJbnRlcmNvbVBlbmRpbmdNZXNzYWdlcyB9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2ludGVyY29tJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICdsb2Rhc2gvZGVmYXVsdHMnO1xuaW1wb3J0IHNwaW5uZXJXaGl0ZSBmcm9tICdiYXNlL2NvbW1vbi9zdmdJbmxpbmUvc3Bpbm5lci13aGl0ZSc7XG5pbXBvcnQgd2lkZ2V0SWNvbiBmcm9tICdiYXNlL2NvbW1vbi9zdmdJbmxpbmUvd2lkZ2V0LWljb24nO1xuXG5pbXBvcnQge2dldEZpbGVMb2dnZXJ9IGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL2xvZ2dlcic7XG5jb25zdCBsb2dnZXIgPSBnZXRGaWxlTG9nZ2VyKF9fZmlsZW5hbWUpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZFBhbmVsQ29udHJvbGxlciBleHRlbmRzIFBhbmVsQ29udHJvbGxlciB7XG4gIGdldFBhbmVsT3B0aW9ucyguLi5hcmdzKSB7XG4gICAgY29uc3QgbGl2ZUVtYmVkRm9yVXNlciA9IHRoaXMuZXh0ZW5zaW9uLmVtYmVkT3B0aW9ucy51c2VySWQ7XG4gICAgY29uc3QgcHJlbWl1bSA9IHRoaXMuZXh0ZW5zaW9uLmVtYmVkT3B0aW9ucy5wcmVtaXVtO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXRQYW5lbE9wdGlvbnMoLi4uYXJncyksXG4gICAgICBlbWJlZDogdHJ1ZSxcbiAgICAgIHVzZXJJZDogbGl2ZUVtYmVkRm9yVXNlcixcbiAgICAgIHByZW1pdW0sXG4gICAgICBtb2JpbGVWaWV3OiBpc01vYmlsZUJyb3dzZXJzKCksXG4gICAgfTtcbiAgfVxuXG4gIHRvZ2dsZVdpZGdldChtb2RlKSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZXNwYWNlKCd3aWRnZXQtdmlzaWJsZScpKTtcblxuICAgIGlmIChtb2RlID09PSAnaGlkZScpIHtcbiAgICAgIHN1cGVyLmhpZGVXaWRnZXQoKTtcbiAgICAgIHRoaXMuc2hvd0Nsb3NlV2lkZ2V0KCk7XG4gICAgICB0aGlzLnNob3dDaGF0QnV0dG9uV2lkZ2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnNob3dXaWRnZXQoKTtcbiAgICAgIHRoaXMuaGlkZUNsb3NlV2lkZ2V0KCk7XG4gICAgICB0aGlzLmhpZGVDaGF0QnV0dG9uV2lkZ2V0KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0T3JNYWtlV2lkZ2V0KHRhYklkKSB7XG4gICAgcmV0dXJuICF0aGlzLndpZGdldEVsID9cbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgd2lkZ2V0LCBjbG9zZSwgY2hhdCB9ID0gdGhpcy5jcmVhdGVXaWRnZXQodGFiSWQpO1xuICAgICAgICB0aGlzLndpZGdldEVsID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmNsb3NlRWwgPSBjbG9zZTtcbiAgICAgICAgdGhpcy5jaGF0QnV0dG9uRWwgPSBjaGF0O1xuXG4gICAgICAgIGFwcGVuZE9uQm9keUxhdGVyKFxuICAgICAgICAgIHdpZGdldCxcbiAgICAgICAgICAoKSA9PiBhcHBlbmRPbkJvZHlMYXRlcihcbiAgICAgICAgICAgIGNoYXQsXG4gICAgICAgICAgICAoKSA9PiBhcHBlbmRPbkJvZHlMYXRlcihcbiAgICAgICAgICAgICAgY2xvc2UsXG4gICAgICAgICAgICAgICgpID0+IHJlc29sdmUoY2xvc2UpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMud2lkZ2V0RWwpO1xuICB9XG5cbiAgY3JlYXRlV2lkZ2V0KHRhYklkKSB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W2RhdGEtaW9yYWQtdXNlci1pZF0nKTtcbiAgICBjb25zdCBpY29uRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBjbG9zZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgY2hhdEJ1dHRvbkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgaGlkZUljb24gPSB0aGlzLmhpZGVJY29uKCk7XG4gICAgaWNvbkVsLmNsYXNzTmFtZSA9XG4gICAgICBuYW1lc3BhY2UoJ3dpZGdldCcsICdoaWRlICcpICtcbiAgICAgIChoaWRlSWNvbiA/IG5hbWVzcGFjZSgnaGlkZS1tb2RlJykgOiAnJyk7XG4gICAgY2xvc2VFbC5jbGFzc05hbWUgPSBuYW1lc3BhY2UoJ3dpZGdldCcsICdoaWRlJykgKyAnIGNsb3NlLXdpZGdldCc7XG4gICAgY2hhdEJ1dHRvbkVsLmNsYXNzTmFtZSA9IG5hbWVzcGFjZSgnaGlkZScpICsgJyBjaGF0YnV0dG9uLXdpZGdldCBjaGF0LXdpdGgtdXMnO1xuICAgIGNoYXRCdXR0b25FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHNldFRpbWVvdXQoKCkgPT4geyBjaGF0QnV0dG9uRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaycgfSwgNTAwKTtcbiAgICBjaGF0QnV0dG9uRWwudGV4dENvbnRlbnQgPSAnQ2hhdCB3aXRoIHVzJztcbiAgICBpY29uRWwuaW5uZXJIVE1MID0gd2lkZ2V0SWNvbigpO1xuICAgIGNsb3NlRWwuaW5uZXJIVE1MID0gc3Bpbm5lcldoaXRlKCk7XG5cbiAgICBjb25zdCB7IGxvZ28sIGNvbG9ycyB9ID0gdGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zO1xuXG4gICAgaWYgKGxvZ28pIHtcbiAgICAgIGljb25FbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2xvZ299JylgO1xuICAgIH1cblxuICAgIGlmIChjb2xvcnMubWFpbikge1xuICAgICAgaWNvbkVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9ycy5tYWluO1xuICAgICAgY2xvc2VFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcnMubWFpbjtcbiAgICAgIGNoYXRCdXR0b25FbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcnMubWFpbjtcbiAgICB9XG5cbiAgICB0aGlzLmN1c3RvbUNvbG9ycyA9IGRlZmF1bHRzKHRoaXMuY3VzdG9tQ29sb3JzIHx8IHt9LCBjb2xvcnMpO1xuXG4gICAgaWNvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5vbldpZGdldENsaWNrKHRhYklkKSk7XG4gICAgY2xvc2VFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMub25DbG9zZVdpZGdldENsaWNrKHRhYklkKSk7XG4gICAgY2hhdEJ1dHRvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5vbkNoYXRCdXR0b25XaWRnZXRDbGljayh0YWJJZCkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZGdldDogaWNvbkVsLFxuICAgICAgY2xvc2U6IGNsb3NlRWwsXG4gICAgICBjaGF0OiBjaGF0QnV0dG9uRWwsXG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVdpZGdldCh7IGxvYWRpbmdTdGVwUGFnZSA9IGZhbHNlLCBjdXJyZW50U3RlcCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMud2lkZ2V0RWwpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmN1c3RvbUNvbG9ycyAmJiB0aGlzLmN1c3RvbUNvbG9ycy5tYWluKSB7XG4gICAgICB0aGlzLndpZGdldEVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY3VzdG9tQ29sb3JzLm1haW47XG4gICAgICB0aGlzLmNsb3NlRWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jdXN0b21Db2xvcnMubWFpbjtcbiAgICAgIHRoaXMuY2hhdEJ1dHRvbkVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY3VzdG9tQ29sb3JzLm1haW47XG4gICAgfVxuXG4gICAgY29uc3QgYyA9IHRoaXMuY2xvc2VFbC5jbGFzc0xpc3Q7XG4gICAgbG9hZGluZ1N0ZXBQYWdlID8gYy5hZGQoJ2xvYWRpbmctd2lkZ2V0JykgOiBjLnJlbW92ZSgnbG9hZGluZy13aWRnZXQnKTtcblxuICAgIGNvbnN0IGFjdGlvbiA9IGN1cnJlbnRTdGVwID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICB0aGlzLmNsb3NlRWwuY2xhc3NMaXN0W2FjdGlvbl0obmFtZXNwYWNlKCdsaXZlLWFjdGl2ZScpKTtcbiAgICB0aGlzLndpZGdldEVsLmNsYXNzTGlzdFthY3Rpb25dKG5hbWVzcGFjZSgnbGl2ZS1hY3RpdmUnKSk7XG4gICAgdGhpcy5jaGF0QnV0dG9uRWwuY2xhc3NMaXN0W2FjdGlvbl0obmFtZXNwYWNlKCdsaXZlLWFjdGl2ZScpKTtcbiAgfVxuXG4gIGhpZGVDaGF0QnV0dG9uV2lkZ2V0KCkge1xuICAgIGlmICghdGhpcy5jaGF0QnV0dG9uRWwpIHJldHVybjtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZXNwYWNlKCdpbnRlcmNvbS12aXNpYmxlJykpKSB7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC5jbGFzc0xpc3QuYWRkKG5hbWVzcGFjZSgnaGlkZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hhdEJ1dHRvbkVsO1xuICB9XG5cbiAgc2hvd0NoYXRCdXR0b25XaWRnZXQoKSB7XG4gICAgaWYgKCF0aGlzLmNoYXRCdXR0b25FbCkgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5vd25Db250ZXh0KCkuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmludGVyY29tSW5zdGFsbGVkICYmICF0aGlzLndpZGdldERpc2FibGVkICYmIHRoaXMuY2hhdEJ1dHRvbkVsKSB7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWVzcGFjZSgnaGlkZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hhdEJ1dHRvbkVsO1xuICB9XG5cbiAgdG9nZ2xlQ2hhdEJ1dHRvbldpZGdldExhYmVsKHRvZ2dsZSkge1xuICAgIGlmICghdGhpcy5jaGF0QnV0dG9uRWwpIHJldHVybjtcbiAgICBpZiAodG9nZ2xlKSB7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC50ZXh0Q29udGVudCA9ICdUdXRvcmlhbHMnO1xuICAgICAgdGhpcy5jaGF0QnV0dG9uRWwuY2xhc3NMaXN0LnJlbW92ZSgnY2hhdC13aXRoLXVzJyk7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC5jbGFzc0xpc3QuYWRkKCdjaGF0LXdpdGgtdXMtdHV0b3JpYWxzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhdEJ1dHRvbkVsLnRleHRDb250ZW50ID0gJ0NoYXQgd2l0aCB1cyc7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC5jbGFzc0xpc3QucmVtb3ZlKCdjaGF0LXdpdGgtdXMtdHV0b3JpYWxzJyk7XG4gICAgICB0aGlzLmNoYXRCdXR0b25FbC5jbGFzc0xpc3QuYWRkKCdjaGF0LXdpdGgtdXMnKTtcbiAgICB9XG4gIH1cblxuICBvbldpZGdldENsaWNrKHRhYklkKSB7XG4gICAgaWYgKGdldEludGVyY29tUGVuZGluZ01lc3NhZ2VzKCkgPiAwKSB7XG4gICAgICB0aGlzLnRvZ2dsZUludGVyY29tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IHNlbmQgdGFiSWQ6IGluIGVtYmVkIHdlIGFsd2F5cyB3YW50IHRvIG9wZW4gcGFuZWxzIGluIGFsbCB0YWJzXG4gICAgICB0aGlzLmJhY2tncm91bmRQb3J0LnNlbmQoe1xuICAgICAgICB0b3BpYzogJ3Nob3dQYW5lbCcsXG4gICAgICAgIGRhdGE6IHsgZXhwbGljaXQ6IHRydWUsIHRhYklkOiB1bmRlZmluZWQgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2hhdEJ1dHRvbldpZGdldENsaWNrKHRhYklkKSB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhuYW1lc3BhY2UoJ2ludGVyY29tLXZpc2libGUnKSkgPyB0aGlzLm9wZW5UdXRvcmlhbHMoKSA6IHRoaXMudG9nZ2xlSW50ZXJjb20oKTtcbiAgfVxuXG4gIGlzQ29tYmluZUludGVyY29tKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zLmNvbWJpbmVJbnRlcmNvbSkgPT09ICd0cnVlJztcbiAgfVxuXG4gIGlzR29vZ2xlVHJhbnNsYXRlKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zLmdvb2dsZVRyYW5zbGF0ZSkgPT09ICd0cnVlJztcbiAgfVxuXG4gIGhpZGVJY29uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5leHRlbnNpb24uZW1iZWRPcHRpb25zLmhpZGVJY29uKSA9PT0gJ3RydWUnO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9jb250ZW50L0VtYmVkUGFuZWxDb250cm9sbGVyLmpzIiwiaW1wb3J0IFBvcnRNYW5hZ2VyIGZyb20gJ2Jhc2UvY29udGVudC9Qb3J0TWFuYWdlcic7XG5pbXBvcnQgRW1iZWRCYWNrZ3JvdW5kUG9ydCBmcm9tICcuL0VtYmVkQmFja2dyb3VuZFBvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZFBvcnRNYW5hZ2VyIGV4dGVuZHMgUG9ydE1hbmFnZXIge1xuICBnZXRCYWNrZ3JvdW5kUG9ydENsYXNzKCkge1xuICAgIHJldHVybiBFbWJlZEJhY2tncm91bmRQb3J0O1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9jb250ZW50L0VtYmVkUG9ydE1hbmFnZXIuanMiLCJpbXBvcnQgQ29tbW9uRW1iZWRTdG9yYWdlIGZyb20gJ2VtYmVkL2NvbW1vbi9FbWJlZFN0b3JhZ2UnO1xuaW1wb3J0IE9iamVjdFN0b3JlIGZyb20gJ2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvT2JqZWN0U3RvcmUnO1xuaW1wb3J0IG5hbWVzcGFjZSBmcm9tICdiYXNlL2NvbW1vbi91dGlscy9uYW1lc3BhY2UnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWJlZFN0b3JhZ2UgZXh0ZW5kcyBDb21tb25FbWJlZFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9vYmplY3RTdG9yZSA9IG5ldyBPYmplY3RTdG9yZShuYW1lc3BhY2UoJ3N0b3JhZ2UnKSwgJ3JlYWQnKTtcbiAgfVxuXG4gIHN0YXJ0KC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdGFydCguLi5hcmdzKTtcblxuICAgIHRoaXMuc2V0dXBCYWNrZ3JvdW5kKCk7XG4gIH1cblxuICBzZXR1cEJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kUG9ydCA9IHRoaXMuZXh0ZW5zaW9uLnBvcnRNYW5hZ2VyLmJhY2tncm91bmRQb3J0O1xuICB9XG5cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0U3RvcmUuZ2V0KC4uLmFyZ3MpO1xuICB9XG5cbiAgc2V0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN0b3JhZ2VSZXF1ZXN0KCdzZXQnLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdG9yYWdlUmVxdWVzdCgncmVtb3ZlJywgYXJncyk7XG4gIH1cblxuICBjbGVhciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdG9yYWdlUmVxdWVzdCgnY2xlYXInLCBhcmdzKTtcbiAgfVxuXG4gIF9tYWtlU3RvcmFnZVJlcXVlc3QodHlwZSwgZGF0YSkge1xuICAgIC8vIFRPRE86IGNoZWNrIHRoYXQgcmVzb2x2ZSBpcyBjb3JyZWN0bHkgY2FsbGVkIGFmdGVyIG1lc3NhZ2UgaXMgaGFuZGxlZCBieSBiYWNrZ3JvdW5kXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvcnQuc2VuZCh7XG4gICAgICAgIHRvcGljOiAnc3RvcmFnZVJlcXVlc3QnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBhcmdzOiBkYXRhLFxuICAgICAgICB9LFxuICAgICAgfSwgKHJlc3BvbnNlID0ge30pID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSByZXNvbHZlKC4uLnJlc3BvbnNlLmFyZ3MpO1xuICAgICAgICBlbHNlIHJlamVjdCguLi5yZXNwb25zZS5hcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9jb250ZW50L0VtYmVkU3RvcmFnZS5qcyIsImltcG9ydCBDb21tb25TaGFyZWRNZW1vcnkgZnJvbSAnZW1iZWQvY29tbW9uL3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnknO1xuaW1wb3J0IE9iamVjdFN0b3JlIGZyb20gJ2VtYmVkL2NvbW1vbi9zaGFyZWRNZW1vcnkvT2JqZWN0U3RvcmUnO1xuaW1wb3J0IFRhYnNTdG9yZSBmcm9tICdlbWJlZC9jb21tb24vc2hhcmVkTWVtb3J5L1RhYnNTdG9yZSc7XG5pbXBvcnQgbmFtZXNwYWNlIGZyb20gJ2Jhc2UvY29tbW9uL3V0aWxzL25hbWVzcGFjZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXJlZE1lbW9yeSBleHRlbmRzIENvbW1vblNoYXJlZE1lbW9yeSB7XG4gIGNvbnN0cnVjdG9yKGZyYW1lSWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgdGFiS2V5ID0gbmFtZXNwYWNlKGB0YWItJHtmcmFtZUlkfWApO1xuICAgIGNvbnN0IGJhY2tncm91bmRLZXkgPSBuYW1lc3BhY2UoJ2JhY2tncm91bmQnKTtcblxuICAgIHRoaXMudGFiID0gbmV3IE9iamVjdFN0b3JlKHRhYktleSwgKHdpbmRvdy5wYXJlbnQgPT09IHdpbmRvdykgPyAncmVhZHdyaXRlJyA6ICdyZWFkJyk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IE9iamVjdFN0b3JlKGJhY2tncm91bmRLZXksICdyZWFkJyk7XG4gICAgdGhpcy50YWJzID0gbmV3IFRhYnNTdG9yZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbWJlZC9jb250ZW50L3NoYXJlZE1lbW9yeS9TaGFyZWRNZW1vcnkuanMiLCIhZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1iKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxiKTphLkRyYWdnYWJsZT1iKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBhKGEsYil7dmFyIGM9dGhpcyxkPWsuYmluZChjLnN0YXJ0LGMpLGU9ay5iaW5kKGMuZHJhZyxjKSxnPWsuYmluZChjLnN0b3AsYyk7aWYoIWYoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRyYWdnYWJsZSBleHBlY3RzIGFyZ3VtZW50IDAgdG8gYmUgYW4gRWxlbWVudFwiKTtiPWsuYXNzaWduKHt9LGksYiksay5hc3NpZ24oYyx7ZWxlbWVudDphLGhhbmRsZTpiLmhhbmRsZSYmZihiLmhhbmRsZSk/Yi5oYW5kbGU6YSxoYW5kbGVyczp7c3RhcnQ6e21vdXNlZG93bjpkLHRvdWNoc3RhcnQ6ZH0sbW92ZTp7bW91c2Vtb3ZlOmUsbW91c2V1cDpnLHRvdWNobW92ZTplLHRvdWNoZW5kOmd9fSxvcHRpb25zOmJ9KSxjLmluaXRpYWxpemUoKX1mdW5jdGlvbiBiKGEpe3JldHVybiBwYXJzZUludChhLDEwKX1mdW5jdGlvbiBjKGEpe3JldHVyblwiY3VycmVudFN0eWxlXCJpbiBhP2EuY3VycmVudFN0eWxlOmdldENvbXB1dGVkU3R5bGUoYSl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5fWZ1bmN0aW9uIGUoYSl7cmV0dXJuIHZvaWQgMCE9PWEmJm51bGwhPT1hfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBFbGVtZW50fHxcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTERvY3VtZW50JiZhIGluc3RhbmNlb2YgSFRNTERvY3VtZW50fWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBGdW5jdGlvbn1mdW5jdGlvbiBoKCl7fXZhciBpPXtncmlkOjAsZmlsdGVyVGFyZ2V0Om51bGwsbGltaXQ6e3g6bnVsbCx5Om51bGx9LHRocmVzaG9sZDowLHNldEN1cnNvcjohMSxzZXRQb3NpdGlvbjohMCxzbW9vdGhEcmFnOiEwLHVzZUdQVTohMCxvbkRyYWc6aCxvbkRyYWdTdGFydDpoLG9uRHJhZ0VuZDpofSxqPXt0cmFuc2Zvcm06ZnVuY3Rpb24oKXtmb3IodmFyIGE9XCIgLW8tIC1tcy0gLW1vei0gLXdlYmtpdC1cIi5zcGxpdChcIiBcIiksYj1kb2N1bWVudC5ib2R5LnN0eWxlLGM9YS5sZW5ndGg7Yy0tOyl7dmFyIGQ9YVtjXStcInRyYW5zZm9ybVwiO2lmKGQgaW4gYilyZXR1cm4gZH19KCl9LGs9e2Fzc2lnbjpmdW5jdGlvbigpe2Zvcih2YXIgYT1hcmd1bWVudHNbMF0sYj1hcmd1bWVudHMubGVuZ3RoLGM9MTtiPmM7YysrKXt2YXIgZD1hcmd1bWVudHNbY107Zm9yKHZhciBlIGluIGQpYVtlXT1kW2VdfXJldHVybiBhfSxiaW5kOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7YS5hcHBseShiLGFyZ3VtZW50cyl9fSxvbjpmdW5jdGlvbihhLGIsYyl7aWYoYiYmYylrLmFkZEV2ZW50KGEsYixjKTtlbHNlIGlmKGIpZm9yKHZhciBkIGluIGIpay5hZGRFdmVudChhLGQsYltkXSl9LG9mZjpmdW5jdGlvbihhLGIsYyl7aWYoYiYmYylrLnJlbW92ZUV2ZW50KGEsYixjKTtlbHNlIGlmKGIpZm9yKHZhciBkIGluIGIpay5yZW1vdmVFdmVudChhLGQsYltkXSl9LGxpbWl0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGQoYik/KGI9WytiWzBdLCtiWzFdXSxhPGJbMF0/YT1iWzBdOmE+YlsxXSYmKGE9YlsxXSkpOmE9K2IsYX0sYWRkRXZlbnQ6XCJhdHRhY2hFdmVudFwiaW4gRWxlbWVudC5wcm90b3R5cGU/ZnVuY3Rpb24oYSxiLGMpe2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyl9OmZ1bmN0aW9uKGEsYixjKXthLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKX0scmVtb3ZlRXZlbnQ6XCJhdHRhY2hFdmVudFwiaW4gRWxlbWVudC5wcm90b3R5cGU/ZnVuY3Rpb24oYSxiLGMpe2EuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyl9OmZ1bmN0aW9uKGEsYixjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjKX19O3JldHVybiBrLmFzc2lnbihhLnByb3RvdHlwZSx7c2V0T3B0aW9uOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gYy5vcHRpb25zW2FdPWIsYy5pbml0aWFsaXplKCksY30sZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kcmFnRXZlbnQ7cmV0dXJue3g6YS54LHk6YS55fX0sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWMuZHJhZ0V2ZW50O3JldHVybiBkLm9yaWdpbmFsPXt4OmQueCx5OmQueX0sYy5tb3ZlKGEsYiksY30sZHJhZ0V2ZW50OntzdGFydGVkOiExLHg6MCx5OjB9LGluaXRpYWxpemU6ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMsZD1iLmVsZW1lbnQsZT0oYi5oYW5kbGUsZC5zdHlsZSksZj1jKGQpLGc9Yi5vcHRpb25zLGg9ai50cmFuc2Zvcm0saT1iLl9kaW1lbnNpb25zPXtoZWlnaHQ6ZC5vZmZzZXRIZWlnaHQsbGVmdDpkLm9mZnNldExlZnQsdG9wOmQub2Zmc2V0VG9wLHdpZHRoOmQub2Zmc2V0V2lkdGh9O2cudXNlR1BVJiZoJiYoYT1mW2hdLFwibm9uZVwiPT09YSYmKGE9XCJcIiksZVtoXT1hK1wiIHRyYW5zbGF0ZTNkKDAsMCwwKVwiKSxnLnNldFBvc2l0aW9uJiYoZS5kaXNwbGF5PVwiYmxvY2tcIixlLmxlZnQ9aS5sZWZ0K1wicHhcIixlLnRvcD1pLnRvcCtcInB4XCIsZS5ib3R0b209ZS5yaWdodD1cImF1dG9cIixlLm1hcmdpbj0wLGUucG9zaXRpb249XCJhYnNvbHV0ZVwiKSxnLnNldEN1cnNvciYmKGUuY3Vyc29yPVwibW92ZVwiKSxiLnNldExpbWl0KGcubGltaXQpLGsuYXNzaWduKGIuZHJhZ0V2ZW50LHt4OmkubGVmdCx5OmkudG9wfSksay5vbihiLmhhbmRsZSxiLmhhbmRsZXJzLnN0YXJ0KX0sc3RhcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIuZ2V0Q3Vyc29yKGEpLGQ9Yi5lbGVtZW50O2IudXNlVGFyZ2V0KGEudGFyZ2V0fHxhLnNyY0VsZW1lbnQpJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6YS5yZXR1cm5WYWx1ZT0hMSxiLmRyYWdFdmVudC5vbGRaaW5kZXg9ZC5zdHlsZS56SW5kZXgsZC5zdHlsZS56SW5kZXg9MWU0LGIuc2V0Q3Vyc29yKGMpLGIuc2V0UG9zaXRpb24oKSxiLnNldFpvb20oKSxrLm9uKGRvY3VtZW50LGIuaGFuZGxlcnMubW92ZSkpfSxkcmFnOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLmRyYWdFdmVudCxkPWIuZWxlbWVudCxlPWIuX2N1cnNvcixmPWIuX2RpbWVuc2lvbnMsZz1iLm9wdGlvbnMsaD1mLnpvb20saT1iLmdldEN1cnNvcihhKSxqPWcudGhyZXNob2xkLGs9KGkueC1lLngpL2grZi5sZWZ0LGw9KGkueS1lLnkpL2grZi50b3A7IWMuc3RhcnRlZCYmaiYmTWF0aC5hYnMoZS54LWkueCk8aiYmTWF0aC5hYnMoZS55LWkueSk8anx8KGMub3JpZ2luYWx8fChjLm9yaWdpbmFsPXt4OmsseTpsfSksYy5zdGFydGVkfHwoZy5vbkRyYWdTdGFydChkLGssbCxhKSxjLnN0YXJ0ZWQ9ITApLGIubW92ZShrLGwpJiZnLm9uRHJhZyhkLGMueCxjLnksYSkpfSxtb3ZlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWMuZHJhZ0V2ZW50LGU9Yy5vcHRpb25zLGY9ZS5ncmlkLGc9Yy5lbGVtZW50LnN0eWxlLGg9Yy5saW1pdChhLGIsZC5vcmlnaW5hbC54LGQub3JpZ2luYWwueSk7cmV0dXJuIWUuc21vb3RoRHJhZyYmZiYmKGg9Yy5yb3VuZChoLGYpKSxoLnghPT1kLnh8fGgueSE9PWQueT8oZC54PWgueCxkLnk9aC55LGcubGVmdD1oLngrXCJweFwiLGcudG9wPWgueStcInB4XCIsITApOiExfSxzdG9wOmZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcyxkPWMuZHJhZ0V2ZW50LGU9Yy5lbGVtZW50LGY9Yy5vcHRpb25zLGc9Zi5ncmlkO2sub2ZmKGRvY3VtZW50LGMuaGFuZGxlcnMubW92ZSksZS5zdHlsZS56SW5kZXg9ZC5vbGRaaW5kZXgsZi5zbW9vdGhEcmFnJiZnJiYoYj1jLnJvdW5kKHt4OmQueCx5OmQueX0sZyksYy5tb3ZlKGIueCxiLnkpLGsuYXNzaWduKGMuZHJhZ0V2ZW50LGIpKSxjLmRyYWdFdmVudC5zdGFydGVkJiZmLm9uRHJhZ0VuZChlLGQueCxkLnksYSksYy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3RoaXMuZHJhZ0V2ZW50LnN0YXJ0ZWQ9ITF9LHJvdW5kOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5ncmlkO3JldHVybnt4OmIqTWF0aC5yb3VuZChhLngvYikseTpiKk1hdGgucm91bmQoYS55L2IpfX0sZ2V0Q3Vyc29yOmZ1bmN0aW9uKGEpe3JldHVybnt4OihhLnRhcmdldFRvdWNoZXM/YS50YXJnZXRUb3VjaGVzWzBdOmEpLmNsaWVudFgseTooYS50YXJnZXRUb3VjaGVzP2EudGFyZ2V0VG91Y2hlc1swXTphKS5jbGllbnRZfX0sc2V0Q3Vyc29yOmZ1bmN0aW9uKGEpe3RoaXMuX2N1cnNvcj1hfSxzZXRMaW1pdDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm57eDphLHk6Yn19O2lmKGcoYSkpYi5saW1pdD1hO2Vsc2UgaWYoZihhKSl7dmFyIGQ9Yi5fZGltZW5zaW9ucyxoPWEuc2Nyb2xsSGVpZ2h0LWQuaGVpZ2h0LGk9YS5zY3JvbGxXaWR0aC1kLndpZHRoO2IubGltaXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm57eDprLmxpbWl0KGEsWzAsaV0pLHk6ay5saW1pdChiLFswLGhdKX19fWVsc2UgaWYoYSl7dmFyIGo9e3g6ZShhLngpLHk6ZShhLnkpfTtiLmxpbWl0PWoueHx8ai55P2Z1bmN0aW9uKGIsYyl7cmV0dXJue3g6ai54P2subGltaXQoYixhLngpOmIseTpqLnk/ay5saW1pdChjLGEueSk6Y319OmN9ZWxzZSBiLmxpbWl0PWN9LHNldFBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxjPWEuZWxlbWVudCxkPWMuc3R5bGU7ay5hc3NpZ24oYS5fZGltZW5zaW9ucyx7bGVmdDpiKGQubGVmdCl8fGMub2Zmc2V0TGVmdCx0b3A6YihkLnRvcCl8fGMub2Zmc2V0VG9wfSl9LHNldFpvb206ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcyxiPWEuZWxlbWVudCxkPTE7Yj1iLm9mZnNldFBhcmVudDspe3ZhciBlPWMoYikuem9vbTtpZihlJiZcIm5vcm1hbFwiIT09ZSl7ZD1lO2JyZWFrfX1hLl9kaW1lbnNpb25zLnpvb209ZH0sdXNlVGFyZ2V0OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5maWx0ZXJUYXJnZXQ7cmV0dXJuIGIgaW5zdGFuY2VvZiBGdW5jdGlvbj9iKGEpOiEwfSxkZXN0cm95OmZ1bmN0aW9uKCl7ay5vZmYodGhpcy5oYW5kbGUsdGhpcy5oYW5kbGVycy5zdGFydCksay5vZmYoZG9jdW1lbnQsdGhpcy5oYW5kbGVycy5tb3ZlKX19KSxhfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9kcmFnZ2FibGUvZGlzdC9kcmFnZ2FibGUubWluLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2VtYmVkL2NvbnRlbnQvc3R5bGVzL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDcxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFdmVyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19hcnJheUV2ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MjFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYFxuICovXG5mdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFdmVyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlRXZlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDcyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFeHRyZW11bTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlRXh0cmVtdW0uanNcbi8vIG1vZHVsZSBpZCA9IDcyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlRmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MjRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUd0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fYmFzZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gNzI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICB9XG4gICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuICBhcnJheSA9IGFycmF5c1swXTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmICghKHNlZW5cbiAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgKSkge1xuICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW50ZXJzZWN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDcyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlTWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDcyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV0sXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgKHNyY0luZGV4ICYmIGlzRnVuY3Rpb24ob2JqVmFsdWUpKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanNcbi8vIG1vZHVsZSBpZCA9IDcyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZG9tO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VSYW5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDczMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYXJyYXlTYW1wbGUgPSByZXF1aXJlKCcuL19hcnJheVNhbXBsZScpLFxuICAgIHZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNhbXBsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19iYXNlU2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MzFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1BhaXJzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VUb1BhaXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA3MzJcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBsYXN0ID0gcmVxdWlyZSgnLi9sYXN0JyksXG4gICAgcGFyZW50ID0gcmVxdWlyZSgnLi9fcGFyZW50JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuc2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Jhc2VVbnNldC5qc1xuLy8gbW9kdWxlIGlkID0gNzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0QXJyYXlMaWtlT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2Nhc3RBcnJheUxpa2VPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDczNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2NyZWF0ZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gNzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlVG9QYWlycyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1BhaXJzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb1BhaXJzID0gcmVxdWlyZSgnLi9fc2V0VG9QYWlycycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgIH1cbiAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVG9QYWlycztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL19jcmVhdGVUb1BhaXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA3Mzhcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanNcbi8vIG1vZHVsZSBpZCA9IDczOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlLCBrZXkpIHtcbiAgcmV0dXJuIChrZXkgIT09IHVuZGVmaW5lZCAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21PbWl0Q2xvbmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fY3VzdG9tT21pdENsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA3NDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLyoqXG4gKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gIHZhciBkYXRhLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXRlcmF0b3JUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX2l0ZXJhdG9yVG9BcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNzQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvX3BhcmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNzQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvUGFpcnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9fc2V0VG9QYWlycy5qc1xuLy8gbW9kdWxlIGlkID0gNzQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25JbldpdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9hc3NpZ25JbldpdGguanNcbi8vIG1vZHVsZSBpZCA9IDc0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYmFzZURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL19iYXNlRGlmZmVyZW5jZScpLFxuICAgIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAqIC8vID0+IFsxXVxuICovXG52YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgIDogW107XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvZGlmZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gNzQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBmaXJzdFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDFcbiAqXG4gKiBfLmhlYWQoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2hlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDc0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvaW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gNzQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL2lzU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA3NDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VHdCA9IHJlcXVpcmUoJy4vX2Jhc2VHdCcpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDhcbiAqXG4gKiBfLm1heChbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoL21heC5qc1xuLy8gbW9kdWxlIGlkID0gNzUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICpcbiAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICovXG52YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VXaXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvbWVyZ2VXaXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA3NTFcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGFycmF5U2FtcGxlID0gcmVxdWlyZSgnLi9fYXJyYXlTYW1wbGUnKSxcbiAgICBiYXNlU2FtcGxlID0gcmVxdWlyZSgnLi9fYmFzZVNhbXBsZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYW1wbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC9zYW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgaXRlcmF0b3JUb0FycmF5ID0gcmVxdWlyZSgnLi9faXRlcmF0b3JUb0FycmF5JyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogXy50b0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICpcbiAqIF8udG9BcnJheSgxKTtcbiAqIC8vID0+IFtdXG4gKlxuICogXy50b0FycmF5KG51bGwpO1xuICogLy8gPT4gW11cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICB9XG4gIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgcmV0dXJuIGZ1bmModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC90b0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwidmFyIGNyZWF0ZVRvUGFpcnMgPSByZXF1aXJlKCcuL19jcmVhdGVUb1BhaXJzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZW50cmllc1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbnZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b1BhaXJzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvdG9QYWlycy5qc1xuLy8gbW9kdWxlIGlkID0gNzU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGJhc2VVbmlxID0gcmVxdWlyZSgnLi9fYmFzZVVuaXEnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbnZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC91bmlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICogaW4gdGhlIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvdW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gNzU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICpcbiAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAqL1xuZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXFXaXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gvdW5pcVdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDc1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJ2YXIgY29udmVydCA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3N0cikge1xuICAgIHZhciBtLCBjb252LCBwYXJ0cywgYWxwaGE7XG4gICAgaWYgKG0gPSAvXigoPzpyZ2J8aHNbbHZdfGNteWt8eHl6fGxhYilhPylcXHMqXFwoKFteXFwpXSopXFwpLy5leGVjKGNzdHIpKSB7XG4gICAgICAgIHZhciBuYW1lID0gbVsxXTtcbiAgICAgICAgdmFyIGJhc2UgPSBuYW1lLnJlcGxhY2UoL2EkLywgJycpO1xuICAgICAgICB2YXIgc2l6ZSA9IGJhc2UgPT09ICdjbXlrJyA/IDQgOiAzO1xuICAgICAgICBjb252ID0gY29udmVydFtiYXNlXTtcbiAgICAgICAgXG4gICAgICAgIHBhcnRzID0gbVsyXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKixcXHMqLylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoLyUkLy50ZXN0KHgpICYmIGkgPT09IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoeCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC8lJC8udGVzdCh4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgICAgIGlmIChuYW1lID09PSBiYXNlKSBwYXJ0cy5wdXNoKDEpO1xuICAgICAgICBhbHBoYSA9IHBhcnRzW3NpemVdID09PSB1bmRlZmluZWQgPyAxIDogcGFydHNbc2l6ZV07XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCwgc2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBjb252W2Jhc2VdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFydHMgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL14jW0EtRmEtZjAtOV0rJC8udGVzdChjc3RyKSkge1xuICAgICAgICB2YXIgYmFzZSA9IGNzdHIucmVwbGFjZSgvXiMvLCcnKTtcbiAgICAgICAgdmFyIHNpemUgPSBiYXNlLmxlbmd0aDtcbiAgICAgICAgY29udiA9IGNvbnZlcnQucmdiO1xuICAgICAgICBwYXJ0cyA9IGJhc2Uuc3BsaXQoc2l6ZSA9PT0gMyA/IC8oLikvIDogLyguLikvKTtcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCArIHgsIDE2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxNilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICA7XG4gICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgY29udi5yZ2IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJ0cyB9O1xuICAgICAgICBpZiAoIXBhcnRzWzBdKSBwYXJ0c1swXSA9IDA7XG4gICAgICAgIGlmICghcGFydHNbMV0pIHBhcnRzWzFdID0gMDtcbiAgICAgICAgaWYgKCFwYXJ0c1syXSkgcGFydHNbMl0gPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udiA9IGNvbnZlcnQua2V5d29yZDtcbiAgICAgICAgY29udi5rZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3N0ciB9O1xuICAgICAgICBwYXJ0cyA9IGNzdHI7XG4gICAgICAgIGFscGhhID0gMTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgcmdiOiB1bmRlZmluZWQsXG4gICAgICAgIGhzbDogdW5kZWZpbmVkLFxuICAgICAgICBoc3Y6IHVuZGVmaW5lZCxcbiAgICAgICAgY215azogdW5kZWZpbmVkLFxuICAgICAgICBrZXl3b3JkOiB1bmRlZmluZWQsXG4gICAgICAgIGhleDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0cnkgeyByZXMucmdiID0gY29udi5yZ2IocGFydHMpIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHsgcmVzLmhzbCA9IGNvbnYuaHNsKHBhcnRzKSB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7IHJlcy5oc3YgPSBjb252LmhzdihwYXJ0cykgfSBjYXRjaCAoZSkge31cbiAgICB0cnkgeyByZXMuY215ayA9IGNvbnYuY215ayhwYXJ0cykgfSBjYXRjaCAoZSkge31cbiAgICB0cnkgeyByZXMua2V5d29yZCA9IGNvbnYua2V5d29yZChwYXJ0cykgfSBjYXRjaCAoZSkge31cbiAgICBcbiAgICBpZiAocmVzLnJnYikgcmVzLmhleCA9ICcjJyArIHJlcy5yZ2IubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBzID0geC50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSkgcmV0dXJuICcwJyArIHM7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH0pLmpvaW4oJycpO1xuICAgIFxuICAgIGlmIChyZXMucmdiKSByZXMucmdiYSA9IHJlcy5yZ2IuY29uY2F0KGFscGhhKTtcbiAgICBpZiAocmVzLmhzbCkgcmVzLmhzbGEgPSByZXMuaHNsLmNvbmNhdChhbHBoYSk7XG4gICAgaWYgKHJlcy5oc3YpIHJlcy5oc3ZhID0gcmVzLmhzdi5jb25jYXQoYWxwaGEpO1xuICAgIGlmIChyZXMuY215aykgcmVzLmNteWthID0gcmVzLmNteWsuY29uY2F0KGFscGhhKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGFyc2UtY29sb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKiBNSVQgbGljZW5zZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufVxuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3BhcnNlLWNvbG9yL34vY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNzY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoXCIuL2NvbnZlcnNpb25zXCIpO1xuXG52YXIgY29udmVydCA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBDb252ZXJ0ZXIoKTtcbn1cblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcGFyc2UtY29sb3Ivfi9jb2xvci1jb252ZXJ0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NjVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==
